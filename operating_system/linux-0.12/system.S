
tools/system：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <pg_dir>:
       0:	b8 10 00 00 00       	mov    $0x10,%eax
       5:	8e d8                	mov    %eax,%ds
       7:	8e c0                	mov    %eax,%es
       9:	8e e0                	mov    %eax,%fs
       b:	8e e8                	mov    %eax,%gs
       d:	0f b2 25 60 32 03 00 	lss    0x33260,%esp
      14:	e8 58 00 00 00       	call   71 <setup_idt>
      19:	e8 83 00 00 00       	call   a1 <setup_gdt>
      1e:	b8 10 00 00 00       	mov    $0x10,%eax
      23:	8e d8                	mov    %eax,%ds
      25:	8e c0                	mov    %eax,%es
      27:	8e e0                	mov    %eax,%fs
      29:	8e e8                	mov    %eax,%gs
      2b:	0f b2 25 60 32 03 00 	lss    0x33260,%esp
      32:	31 c0                	xor    %eax,%eax
      34:	40                   	inc    %eax
      35:	a3 00 00 00 00       	mov    %eax,0x0
      3a:	39 05 00 00 10 00    	cmp    %eax,0x100000
      40:	74 f2                	je     34 <OLDSS+0x4>
      42:	0f 20 c0             	mov    %cr0,%eax
      45:	25 11 00 00 80       	and    $0x80000011,%eax
      4a:	83 c8 02             	or     $0x2,%eax
      4d:	0f 22 c0             	mov    %eax,%cr0
      50:	e8 05 00 00 00       	call   5a <check_x87>
      55:	e9 a6 53 00 00       	jmp    5400 <after_page_tables>

0000005a <check_x87>:
      5a:	db e3                	fninit 
      5c:	9b df e0             	fstsw  %ax
      5f:	3c 00                	cmp    $0x0,%al
      61:	74 0b                	je     6e <check_x87+0x14>
      63:	0f 20 c0             	mov    %cr0,%eax
      66:	83 f0 06             	xor    $0x6,%eax
      69:	0f 22 c0             	mov    %eax,%cr0
      6c:	c3                   	ret    
      6d:	90                   	nop
      6e:	db e4                	fnsetpm(287 only) 
      70:	c3                   	ret    

00000071 <setup_idt>:
      71:	8d 15 28 54 00 00    	lea    0x5428,%edx
      77:	b8 00 00 08 00       	mov    $0x80000,%eax
      7c:	66 89 d0             	mov    %dx,%ax
      7f:	66 ba 00 8e          	mov    $0x8e00,%dx
      83:	8d 3d b8 54 00 00    	lea    0x54b8,%edi
      89:	b9 00 01 00 00       	mov    $0x100,%ecx

0000008e <rp_sidt>:
      8e:	89 07                	mov    %eax,(%edi)
      90:	89 57 04             	mov    %edx,0x4(%edi)
      93:	83 c7 08             	add    $0x8,%edi
      96:	49                   	dec    %ecx
      97:	75 f5                	jne    8e <rp_sidt>
      99:	0f 01 1d aa 54 00 00 	lidtl  0x54aa
      a0:	c3                   	ret    

000000a1 <setup_gdt>:
      a1:	0f 01 15 b2 54 00 00 	lgdtl  0x54b2
      a8:	c3                   	ret    
	...

00001000 <pg0>:
	...

00002000 <pg1>:
	...

00003000 <pg2>:
	...

00004000 <pg3>:
	...

00005000 <tmp_floppy_area>:
	...

00005400 <after_page_tables>:
    5400:	6a 00                	push   $0x0
    5402:	6a 00                	push   $0x0
    5404:	6a 00                	push   $0x0
    5406:	68 12 54 00 00       	push   $0x5412
    540b:	68 70 68 00 00       	push   $0x6870
    5410:	eb 3c                	jmp    544e <setup_paging>

00005412 <L6>:
    5412:	eb fe                	jmp    5412 <L6>

00005414 <int_msg>:
    5414:	55                   	push   %ebp
    5415:	6e                   	outsb  %ds:(%esi),(%dx)
    5416:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
    541a:	6e                   	outsb  %ds:(%esi),(%dx)
    541b:	20 69 6e             	and    %ch,0x6e(%ecx)
    541e:	74 65                	je     5485 <setup_paging+0x37>
    5420:	72 72                	jb     5494 <setup_paging+0x46>
    5422:	75 70                	jne    5494 <setup_paging+0x46>
    5424:	74 0a                	je     5430 <ignore_int+0x8>
    5426:	0d                   	.byte 0xd
	...

00005428 <ignore_int>:
    5428:	50                   	push   %eax
    5429:	51                   	push   %ecx
    542a:	52                   	push   %edx
    542b:	1e                   	push   %ds
    542c:	06                   	push   %es
    542d:	0f a0                	push   %fs
    542f:	b8 10 00 00 00       	mov    $0x10,%eax
    5434:	8e d8                	mov    %eax,%ds
    5436:	8e c0                	mov    %eax,%es
    5438:	8e e0                	mov    %eax,%fs
    543a:	68 14 54 00 00       	push   $0x5414
    543f:	e8 ee 3e 00 00       	call   9332 <printk>
    5444:	58                   	pop    %eax
    5445:	0f a1                	pop    %fs
    5447:	07                   	pop    %es
    5448:	1f                   	pop    %ds
    5449:	5a                   	pop    %edx
    544a:	59                   	pop    %ecx
    544b:	58                   	pop    %eax
    544c:	cf                   	iret   
    544d:	90                   	nop

0000544e <setup_paging>:
    544e:	b9 00 14 00 00       	mov    $0x1400,%ecx
    5453:	31 c0                	xor    %eax,%eax
    5455:	31 ff                	xor    %edi,%edi
    5457:	fc                   	cld    
    5458:	f3 ab                	rep stos %eax,%es:(%edi)
    545a:	c7 05 00 00 00 00 07 	movl   $0x1007,0x0
    5461:	10 00 00 
    5464:	c7 05 04 00 00 00 07 	movl   $0x2007,0x4
    546b:	20 00 00 
    546e:	c7 05 08 00 00 00 07 	movl   $0x3007,0x8
    5475:	30 00 00 
    5478:	c7 05 0c 00 00 00 07 	movl   $0x4007,0xc
    547f:	40 00 00 
    5482:	bf fc 4f 00 00       	mov    $0x4ffc,%edi
    5487:	b8 07 f0 ff 00       	mov    $0xfff007,%eax
    548c:	fd                   	std    
    548d:	ab                   	stos   %eax,%es:(%edi)
    548e:	2d 00 10 00 00       	sub    $0x1000,%eax
    5493:	7d f8                	jge    548d <setup_paging+0x3f>
    5495:	fc                   	cld    
    5496:	31 c0                	xor    %eax,%eax
    5498:	0f 22 d8             	mov    %eax,%cr3
    549b:	0f 20 c0             	mov    %cr0,%eax
    549e:	0d 00 00 00 80       	or     $0x80000000,%eax
    54a3:	0f 22 c0             	mov    %eax,%cr0
    54a6:	c3                   	ret    
    54a7:	90                   	nop
	...

000054aa <idt_descr>:
    54aa:	ff 07                	incl   (%edi)
    54ac:	b8 54 00 00 00       	mov    $0x54,%eax
	...

000054b2 <gdt_descr>:
    54b2:	ff 07                	incl   (%edi)
    54b4:	b8                   	.byte 0xb8
    54b5:	5c                   	pop    %esp
	...

000054b8 <idt>:
	...

00005cb8 <gdt>:
	...
    5cc0:	ff 0f                	decl   (%edi)
    5cc2:	00 00                	add    %al,(%eax)
    5cc4:	00 9a c0 00 ff 0f    	add    %bl,0xfff00c0(%edx)
    5cca:	00 00                	add    %al,(%eax)
    5ccc:	00 92 c0 00 00 00    	add    %dl,0xc0(%edx)
	...

000064b8 <fork>:
// __attribute__((always_inline))表示将函数强制设置为内联函数
// int fork(void) __attribute__((always_inline));
//  int pause()系统调用：暂停进程的执行，直到收到一个信号。
// int pause(void) __attribute__((always_inline));
// fork()系统调用函数的定义
_syscall0(int, fork)
    64b8:	83 ec 10             	sub    $0x10,%esp
    64bb:	e8 36 08 00 00       	call   6cf6 <__x86.get_pc_thunk.dx>
    64c0:	81 c2 40 bb 02 00    	add    $0x2bb40,%edx
    64c6:	b8 02 00 00 00       	mov    $0x2,%eax
    64cb:	cd 80                	int    $0x80
    64cd:	89 44 24 0c          	mov    %eax,0xc(%esp)
    64d1:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    64d6:	78 06                	js     64de <fork+0x26>
    64d8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    64dc:	eb 15                	jmp    64f3 <fork+0x3b>
    64de:	8b 44 24 0c          	mov    0xc(%esp),%eax
    64e2:	f7 d8                	neg    %eax
    64e4:	89 c1                	mov    %eax,%ecx
    64e6:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
    64ec:	89 08                	mov    %ecx,(%eax)
    64ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    64f3:	83 c4 10             	add    $0x10,%esp
    64f6:	c3                   	ret    

000064f7 <pause>:
// pause()系统调用函数的定义
_syscall0(int, pause)
    64f7:	83 ec 10             	sub    $0x10,%esp
    64fa:	e8 f7 07 00 00       	call   6cf6 <__x86.get_pc_thunk.dx>
    64ff:	81 c2 01 bb 02 00    	add    $0x2bb01,%edx
    6505:	b8 1d 00 00 00       	mov    $0x1d,%eax
    650a:	cd 80                	int    $0x80
    650c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    6510:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    6515:	78 06                	js     651d <pause+0x26>
    6517:	8b 44 24 0c          	mov    0xc(%esp),%eax
    651b:	eb 15                	jmp    6532 <pause+0x3b>
    651d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6521:	f7 d8                	neg    %eax
    6523:	89 c1                	mov    %eax,%ecx
    6525:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
    652b:	89 08                	mov    %ecx,(%eax)
    652d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    6532:	83 c4 10             	add    $0x10,%esp
    6535:	c3                   	ret    

00006536 <setup>:
// int setup(void * BIOS)系统调用,仅用于linux初始化(仅在这个程序中被调用).
_syscall1(int, setup, void *, BIOS)
    6536:	53                   	push   %ebx
    6537:	83 ec 10             	sub    $0x10,%esp
    653a:	e8 b7 07 00 00       	call   6cf6 <__x86.get_pc_thunk.dx>
    653f:	81 c2 c1 ba 02 00    	add    $0x2bac1,%edx
    6545:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    6549:	b8 00 00 00 00       	mov    $0x0,%eax
    654e:	89 cb                	mov    %ecx,%ebx
    6550:	cd 80                	int    $0x80
    6552:	89 44 24 0c          	mov    %eax,0xc(%esp)
    6556:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    655b:	78 06                	js     6563 <setup+0x2d>
    655d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6561:	eb 15                	jmp    6578 <setup+0x42>
    6563:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6567:	f7 d8                	neg    %eax
    6569:	89 c1                	mov    %eax,%ecx
    656b:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
    6571:	89 08                	mov    %ecx,(%eax)
    6573:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    6578:	83 c4 10             	add    $0x10,%esp
    657b:	5b                   	pop    %ebx
    657c:	c3                   	ret    

0000657d <sync>:
// int sync()系统调用：更新文件系统。
_syscall0(int, sync)
    657d:	83 ec 10             	sub    $0x10,%esp
    6580:	e8 71 07 00 00       	call   6cf6 <__x86.get_pc_thunk.dx>
    6585:	81 c2 7b ba 02 00    	add    $0x2ba7b,%edx
    658b:	b8 24 00 00 00       	mov    $0x24,%eax
    6590:	cd 80                	int    $0x80
    6592:	89 44 24 0c          	mov    %eax,0xc(%esp)
    6596:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    659b:	78 06                	js     65a3 <sync+0x26>
    659d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    65a1:	eb 15                	jmp    65b8 <sync+0x3b>
    65a3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    65a7:	f7 d8                	neg    %eax
    65a9:	89 c1                	mov    %eax,%ecx
    65ab:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
    65b1:	89 08                	mov    %ecx,(%eax)
    65b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    65b8:	83 c4 10             	add    $0x10,%esp
    65bb:	c3                   	ret    

000065bc <fork_for_process0>:
extern long rd_init(long mem_start, int length);	// 虚拟盘初始化(blk_drv/ramdisk.c)
extern long kernel_mktime(struct tm * tm);			// 计算系统开机启动时间(秒)

// fork系统调用函数,该函数作为static inline表示内联函数，主要用来在进程0里面创建进程1的时候内联，使进程0在生成进程1的时候
// 不使用自己的用户堆栈
static inline long fork_for_process0() {
    65bc:	83 ec 10             	sub    $0x10,%esp
    65bf:	e8 32 07 00 00       	call   6cf6 <__x86.get_pc_thunk.dx>
    65c4:	81 c2 3c ba 02 00    	add    $0x2ba3c,%edx
	long __res;
	__asm__ volatile (
    65ca:	b8 02 00 00 00       	mov    $0x2,%eax
    65cf:	cd 80                	int    $0x80
    65d1:	89 44 24 0c          	mov    %eax,0xc(%esp)
		"int $0x80\n\t"  														/* 调用系统中断0x80 ，为系统调用中断*/
		: "=a" (__res)  														/* 返回值->eax(__res) */
		: "0" (2));  															/* 输入为系统中断调用号__NR_name */
	if (__res >= 0)  															/* 如果返回值>=0,则直接返回该值 */
    65d5:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    65da:	78 06                	js     65e2 <fork_for_process0+0x26>
		return __res;
    65dc:	8b 44 24 0c          	mov    0xc(%esp),%eax
    65e0:	eb 15                	jmp    65f7 <fork_for_process0+0x3b>
	errno = -__res;  															/* 否则置出错号,并返回-1 */
    65e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    65e6:	f7 d8                	neg    %eax
    65e8:	89 c1                	mov    %eax,%ecx
    65ea:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
    65f0:	89 08                	mov    %ecx,(%eax)
	return -1;
    65f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    65f7:	83 c4 10             	add    $0x10,%esp
    65fa:	c3                   	ret    

000065fb <sprintf>:

// 内核专用sprintf()函数.该函数用于产生格式化信息并输出到指定缓冲区str中.参数'*fmt'指定输出将采用格式.
static int sprintf(char * str, const char *fmt, ...)
{
    65fb:	53                   	push   %ebx
    65fc:	83 ec 18             	sub    $0x18,%esp
    65ff:	e8 ee 06 00 00       	call   6cf2 <__x86.get_pc_thunk.ax>
    6604:	05 fc b9 02 00       	add    $0x2b9fc,%eax
	va_list args;
	int i;

	va_start(args, fmt);
    6609:	8d 54 24 24          	lea    0x24(%esp),%edx
    660d:	83 c2 04             	add    $0x4,%edx
    6610:	89 54 24 0c          	mov    %edx,0xc(%esp)
	i = vsprintf(str, fmt, args);
    6614:	8b 54 24 24          	mov    0x24(%esp),%edx
    6618:	83 ec 04             	sub    $0x4,%esp
    661b:	ff 74 24 10          	pushl  0x10(%esp)
    661f:	52                   	push   %edx
    6620:	ff 74 24 2c          	pushl  0x2c(%esp)
    6624:	89 c3                	mov    %eax,%ebx
    6626:	e8 6a 30 00 00       	call   9695 <vsprintf>
    662b:	83 c4 10             	add    $0x10,%esp
    662e:	89 44 24 08          	mov    %eax,0x8(%esp)
	va_end(args);
	return i;
    6632:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    6636:	83 c4 18             	add    $0x18,%esp
    6639:	5b                   	pop    %ebx
    663a:	c3                   	ret    

0000663b <time_init>:
#define BCD_TO_BIN(val) ((val) = ((val)&15) + ((val) >> 4) * 10)

// 该函数取CMOS实时钟信息作为开机时间,并保存到全局变量startup_time(秒)中.其中调用的函数kernel_mktime()用于计算从
// 1970年1月1日0时起到开机当日经过的秒数,作为开机时间.
static void time_init(void)
{
    663b:	53                   	push   %ebx
    663c:	83 ec 38             	sub    $0x38,%esp
    663f:	e8 b6 06 00 00       	call   6cfa <__x86.get_pc_thunk.bx>
    6644:	81 c3 bc b9 02 00    	add    $0x2b9bc,%ebx
	struct tm time;								// 时间结构tm定义在include/time.h中
	// CMOS的访问速度很慢.为了减小时间误差,在读取了下面循环中所有数值后,若此时CMOS中秒值了变化,那么就重新读取所有值.这样内核
	// 就能把与CMOS时间误差控制在1秒之内.
	do {
		time.tm_sec = CMOS_READ(0);				// 当前时间秒值(均是BCD码值)
    664a:	b8 80 00 00 00       	mov    $0x80,%eax
    664f:	ba 70 00 00 00       	mov    $0x70,%edx
    6654:	ee                   	out    %al,(%dx)
    6655:	eb 00                	jmp    6657 <time_init+0x1c>
    6657:	eb 00                	jmp    6659 <time_init+0x1e>
    6659:	b8 71 00 00 00       	mov    $0x71,%eax
    665e:	89 c2                	mov    %eax,%edx
    6660:	ec                   	in     (%dx),%al
    6661:	eb 00                	jmp    6663 <time_init+0x28>
    6663:	eb 00                	jmp    6665 <time_init+0x2a>
    6665:	88 44 24 2f          	mov    %al,0x2f(%esp)
    6669:	0f b6 44 24 2f       	movzbl 0x2f(%esp),%eax
    666e:	0f b6 c0             	movzbl %al,%eax
    6671:	89 44 24 04          	mov    %eax,0x4(%esp)
		time.tm_min = CMOS_READ(2);				// 当前分钟值.
    6675:	b8 82 00 00 00       	mov    $0x82,%eax
    667a:	ba 70 00 00 00       	mov    $0x70,%edx
    667f:	ee                   	out    %al,(%dx)
    6680:	eb 00                	jmp    6682 <time_init+0x47>
    6682:	eb 00                	jmp    6684 <time_init+0x49>
    6684:	b8 71 00 00 00       	mov    $0x71,%eax
    6689:	89 c2                	mov    %eax,%edx
    668b:	ec                   	in     (%dx),%al
    668c:	eb 00                	jmp    668e <time_init+0x53>
    668e:	eb 00                	jmp    6690 <time_init+0x55>
    6690:	88 44 24 2e          	mov    %al,0x2e(%esp)
    6694:	0f b6 44 24 2e       	movzbl 0x2e(%esp),%eax
    6699:	0f b6 c0             	movzbl %al,%eax
    669c:	89 44 24 08          	mov    %eax,0x8(%esp)
		time.tm_hour = CMOS_READ(4);			// 当前小时值.
    66a0:	b8 84 00 00 00       	mov    $0x84,%eax
    66a5:	ba 70 00 00 00       	mov    $0x70,%edx
    66aa:	ee                   	out    %al,(%dx)
    66ab:	eb 00                	jmp    66ad <time_init+0x72>
    66ad:	eb 00                	jmp    66af <time_init+0x74>
    66af:	b8 71 00 00 00       	mov    $0x71,%eax
    66b4:	89 c2                	mov    %eax,%edx
    66b6:	ec                   	in     (%dx),%al
    66b7:	eb 00                	jmp    66b9 <time_init+0x7e>
    66b9:	eb 00                	jmp    66bb <time_init+0x80>
    66bb:	88 44 24 2d          	mov    %al,0x2d(%esp)
    66bf:	0f b6 44 24 2d       	movzbl 0x2d(%esp),%eax
    66c4:	0f b6 c0             	movzbl %al,%eax
    66c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
		time.tm_mday = CMOS_READ(7);			// 一月中的当天日期.
    66cb:	b8 87 00 00 00       	mov    $0x87,%eax
    66d0:	ba 70 00 00 00       	mov    $0x70,%edx
    66d5:	ee                   	out    %al,(%dx)
    66d6:	eb 00                	jmp    66d8 <time_init+0x9d>
    66d8:	eb 00                	jmp    66da <time_init+0x9f>
    66da:	b8 71 00 00 00       	mov    $0x71,%eax
    66df:	89 c2                	mov    %eax,%edx
    66e1:	ec                   	in     (%dx),%al
    66e2:	eb 00                	jmp    66e4 <time_init+0xa9>
    66e4:	eb 00                	jmp    66e6 <time_init+0xab>
    66e6:	88 44 24 2c          	mov    %al,0x2c(%esp)
    66ea:	0f b6 44 24 2c       	movzbl 0x2c(%esp),%eax
    66ef:	0f b6 c0             	movzbl %al,%eax
    66f2:	89 44 24 10          	mov    %eax,0x10(%esp)
		time.tm_mon = CMOS_READ(8);				// 当前月份(1-12)
    66f6:	b8 88 00 00 00       	mov    $0x88,%eax
    66fb:	ba 70 00 00 00       	mov    $0x70,%edx
    6700:	ee                   	out    %al,(%dx)
    6701:	eb 00                	jmp    6703 <time_init+0xc8>
    6703:	eb 00                	jmp    6705 <time_init+0xca>
    6705:	b8 71 00 00 00       	mov    $0x71,%eax
    670a:	89 c2                	mov    %eax,%edx
    670c:	ec                   	in     (%dx),%al
    670d:	eb 00                	jmp    670f <time_init+0xd4>
    670f:	eb 00                	jmp    6711 <time_init+0xd6>
    6711:	88 44 24 2b          	mov    %al,0x2b(%esp)
    6715:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
    671a:	0f b6 c0             	movzbl %al,%eax
    671d:	89 44 24 14          	mov    %eax,0x14(%esp)
		time.tm_year = CMOS_READ(9);			// 当前年份.
    6721:	b8 89 00 00 00       	mov    $0x89,%eax
    6726:	ba 70 00 00 00       	mov    $0x70,%edx
    672b:	ee                   	out    %al,(%dx)
    672c:	eb 00                	jmp    672e <time_init+0xf3>
    672e:	eb 00                	jmp    6730 <time_init+0xf5>
    6730:	b8 71 00 00 00       	mov    $0x71,%eax
    6735:	89 c2                	mov    %eax,%edx
    6737:	ec                   	in     (%dx),%al
    6738:	eb 00                	jmp    673a <time_init+0xff>
    673a:	eb 00                	jmp    673c <time_init+0x101>
    673c:	88 44 24 2a          	mov    %al,0x2a(%esp)
    6740:	0f b6 44 24 2a       	movzbl 0x2a(%esp),%eax
    6745:	0f b6 c0             	movzbl %al,%eax
    6748:	89 44 24 18          	mov    %eax,0x18(%esp)
	} while (time.tm_sec != CMOS_READ(0));
    674c:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    6750:	b8 80 00 00 00       	mov    $0x80,%eax
    6755:	ba 70 00 00 00       	mov    $0x70,%edx
    675a:	ee                   	out    %al,(%dx)
    675b:	eb 00                	jmp    675d <time_init+0x122>
    675d:	eb 00                	jmp    675f <time_init+0x124>
    675f:	b8 71 00 00 00       	mov    $0x71,%eax
    6764:	89 c2                	mov    %eax,%edx
    6766:	ec                   	in     (%dx),%al
    6767:	eb 00                	jmp    6769 <time_init+0x12e>
    6769:	eb 00                	jmp    676b <time_init+0x130>
    676b:	88 44 24 29          	mov    %al,0x29(%esp)
    676f:	0f b6 44 24 29       	movzbl 0x29(%esp),%eax
    6774:	0f b6 c0             	movzbl %al,%eax
    6777:	39 c1                	cmp    %eax,%ecx
    6779:	0f 85 cb fe ff ff    	jne    664a <time_init+0xf>
	BCD_TO_BIN(time.tm_sec);					// 转换成进进制数值.
    677f:	8b 44 24 04          	mov    0x4(%esp),%eax
    6783:	83 e0 0f             	and    $0xf,%eax
    6786:	89 c1                	mov    %eax,%ecx
    6788:	8b 44 24 04          	mov    0x4(%esp),%eax
    678c:	c1 f8 04             	sar    $0x4,%eax
    678f:	89 c2                	mov    %eax,%edx
    6791:	89 d0                	mov    %edx,%eax
    6793:	c1 e0 02             	shl    $0x2,%eax
    6796:	01 d0                	add    %edx,%eax
    6798:	01 c0                	add    %eax,%eax
    679a:	01 c8                	add    %ecx,%eax
    679c:	89 44 24 04          	mov    %eax,0x4(%esp)
	BCD_TO_BIN(time.tm_min);
    67a0:	8b 44 24 08          	mov    0x8(%esp),%eax
    67a4:	83 e0 0f             	and    $0xf,%eax
    67a7:	89 c1                	mov    %eax,%ecx
    67a9:	8b 44 24 08          	mov    0x8(%esp),%eax
    67ad:	c1 f8 04             	sar    $0x4,%eax
    67b0:	89 c2                	mov    %eax,%edx
    67b2:	89 d0                	mov    %edx,%eax
    67b4:	c1 e0 02             	shl    $0x2,%eax
    67b7:	01 d0                	add    %edx,%eax
    67b9:	01 c0                	add    %eax,%eax
    67bb:	01 c8                	add    %ecx,%eax
    67bd:	89 44 24 08          	mov    %eax,0x8(%esp)
	BCD_TO_BIN(time.tm_hour);
    67c1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    67c5:	83 e0 0f             	and    $0xf,%eax
    67c8:	89 c1                	mov    %eax,%ecx
    67ca:	8b 44 24 0c          	mov    0xc(%esp),%eax
    67ce:	c1 f8 04             	sar    $0x4,%eax
    67d1:	89 c2                	mov    %eax,%edx
    67d3:	89 d0                	mov    %edx,%eax
    67d5:	c1 e0 02             	shl    $0x2,%eax
    67d8:	01 d0                	add    %edx,%eax
    67da:	01 c0                	add    %eax,%eax
    67dc:	01 c8                	add    %ecx,%eax
    67de:	89 44 24 0c          	mov    %eax,0xc(%esp)
	BCD_TO_BIN(time.tm_mday);
    67e2:	8b 44 24 10          	mov    0x10(%esp),%eax
    67e6:	83 e0 0f             	and    $0xf,%eax
    67e9:	89 c1                	mov    %eax,%ecx
    67eb:	8b 44 24 10          	mov    0x10(%esp),%eax
    67ef:	c1 f8 04             	sar    $0x4,%eax
    67f2:	89 c2                	mov    %eax,%edx
    67f4:	89 d0                	mov    %edx,%eax
    67f6:	c1 e0 02             	shl    $0x2,%eax
    67f9:	01 d0                	add    %edx,%eax
    67fb:	01 c0                	add    %eax,%eax
    67fd:	01 c8                	add    %ecx,%eax
    67ff:	89 44 24 10          	mov    %eax,0x10(%esp)
	BCD_TO_BIN(time.tm_mon);
    6803:	8b 44 24 14          	mov    0x14(%esp),%eax
    6807:	83 e0 0f             	and    $0xf,%eax
    680a:	89 c1                	mov    %eax,%ecx
    680c:	8b 44 24 14          	mov    0x14(%esp),%eax
    6810:	c1 f8 04             	sar    $0x4,%eax
    6813:	89 c2                	mov    %eax,%edx
    6815:	89 d0                	mov    %edx,%eax
    6817:	c1 e0 02             	shl    $0x2,%eax
    681a:	01 d0                	add    %edx,%eax
    681c:	01 c0                	add    %eax,%eax
    681e:	01 c8                	add    %ecx,%eax
    6820:	89 44 24 14          	mov    %eax,0x14(%esp)
	BCD_TO_BIN(time.tm_year);
    6824:	8b 44 24 18          	mov    0x18(%esp),%eax
    6828:	83 e0 0f             	and    $0xf,%eax
    682b:	89 c1                	mov    %eax,%ecx
    682d:	8b 44 24 18          	mov    0x18(%esp),%eax
    6831:	c1 f8 04             	sar    $0x4,%eax
    6834:	89 c2                	mov    %eax,%edx
    6836:	89 d0                	mov    %edx,%eax
    6838:	c1 e0 02             	shl    $0x2,%eax
    683b:	01 d0                	add    %edx,%eax
    683d:	01 c0                	add    %eax,%eax
    683f:	01 c8                	add    %ecx,%eax
    6841:	89 44 24 18          	mov    %eax,0x18(%esp)
	time.tm_mon--;								// tm_mon中月份范围是0~11.
    6845:	8b 44 24 14          	mov    0x14(%esp),%eax
    6849:	83 e8 01             	sub    $0x1,%eax
    684c:	89 44 24 14          	mov    %eax,0x14(%esp)
	startup_time = kernel_mktime(&time);		// 计算开机时间.kernel/mktime.c
    6850:	83 ec 0c             	sub    $0xc,%esp
    6853:	8d 44 24 10          	lea    0x10(%esp),%eax
    6857:	50                   	push   %eax
    6858:	e8 fe 60 00 00       	call   c95b <kernel_mktime>
    685d:	83 c4 10             	add    $0x10,%esp
    6860:	89 c2                	mov    %eax,%edx
    6862:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    6868:	89 10                	mov    %edx,(%eax)
}
    686a:	90                   	nop
    686b:	83 c4 38             	add    $0x38,%esp
    686e:	5b                   	pop    %ebx
    686f:	c3                   	ret    

00006870 <main>:
struct drive_info { char dummy[32]; } drive_info;	// 用于存放硬盘参数表信息.

// 内核初始化主程序.初始化结束后将以任务0(idle任务即空闲任务)的身份运行.
// 英文注释含义是"这里确实是void,没错.在startup程序(head.s)中就是这样假设的".参见head.h程序代码.
int main(void)										/* This really IS void, no error here. */
{													/* The startup routine assumes (well, ...) this */
    6870:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    6874:	83 e4 f0             	and    $0xfffffff0,%esp
    6877:	ff 71 fc             	pushl  -0x4(%ecx)
    687a:	55                   	push   %ebp
    687b:	89 e5                	mov    %esp,%ebp
    687d:	53                   	push   %ebx
    687e:	51                   	push   %ecx
    687f:	e8 76 04 00 00       	call   6cfa <__x86.get_pc_thunk.bx>
    6884:	81 c3 7c b7 02 00    	add    $0x2b77c,%ebx
#ifdef EM
	// 开启仿真协处理器
	__asm__("movl %cr0,%eax \n\t" \
    688a:	0f 20 c0             	mov    %cr0,%eax
    688d:	83 f0 06             	xor    $0x6,%eax
    6890:	0f 22 c0             	mov    %eax,%cr0
	// 首先保存根文件系统设备和交换文件设备号,并根据setup.s程序中获取的信息设置控制台终端屏幕行,列数环境变量TERM,并用其设置初始init进程
	// 中执行etc/rc文件和shell程序使用的环境变量,以及复制内存0x90080处的硬盘表.
	// 其中ROOT_DEV已在前面包含进的include/linux/fs.h文件上被声明为extern_int
	// 而SWAP_DEV在include/linux/mm.h文件内也作了相同声明.这里mm.h文件并没有显式地列在本程序前部,因为前面包含进的include/linux/sched.h
	// 文件中已经含有它.
 	ROOT_DEV = ORIG_ROOT_DEV;										// ROOT_DEV定义在fs/super.c
    6893:	b8 fc 01 09 00       	mov    $0x901fc,%eax
    6898:	0f b7 00             	movzwl (%eax),%eax
    689b:	0f b7 d0             	movzwl %ax,%edx
    689e:	c7 c0 4c 61 03 00    	mov    $0x3614c,%eax
    68a4:	89 10                	mov    %edx,(%eax)
 	SWAP_DEV = ORIG_SWAP_DEV;										// SWAP_DEV定义在mm/swap.c
    68a6:	b8 fa 01 09 00       	mov    $0x901fa,%eax
    68ab:	0f b7 00             	movzwl (%eax),%eax
    68ae:	0f b7 d0             	movzwl %ax,%edx
    68b1:	c7 c0 20 52 03 00    	mov    $0x35220,%eax
    68b7:	89 10                	mov    %edx,(%eax)
   	sprintf(term, "TERM=con%dx%d", CON_COLS, CON_ROWS);
    68b9:	b8 0e 00 09 00       	mov    $0x9000e,%eax
    68be:	0f b7 00             	movzwl (%eax),%eax
    68c1:	0f b7 c0             	movzwl %ax,%eax
    68c4:	0f b6 d0             	movzbl %al,%edx
    68c7:	b8 0e 00 09 00       	mov    $0x9000e,%eax
    68cc:	0f b7 00             	movzwl (%eax),%eax
    68cf:	66 c1 e8 08          	shr    $0x8,%ax
    68d3:	0f b7 c0             	movzwl %ax,%eax
    68d6:	52                   	push   %edx
    68d7:	50                   	push   %eax
    68d8:	8d 83 27 40 ff ff    	lea    -0xbfd9(%ebx),%eax
    68de:	50                   	push   %eax
    68df:	8d 83 60 1b 00 00    	lea    0x1b60(%ebx),%eax
    68e5:	50                   	push   %eax
    68e6:	e8 10 fd ff ff       	call   65fb <sprintf>
    68eb:	83 c4 10             	add    $0x10,%esp
	envp[1] = term;
    68ee:	8d 83 60 1b 00 00    	lea    0x1b60(%ebx),%eax
    68f4:	89 83 40 00 00 00    	mov    %eax,0x40(%ebx)
	envp_rc[1] = term;
    68fa:	8d 83 60 1b 00 00    	lea    0x1b60(%ebx),%eax
    6900:	89 83 2c 00 00 00    	mov    %eax,0x2c(%ebx)
    drive_info = DRIVE_INFO;										// 复制内存0x90080处的硬盘参数表.
    6906:	ba 80 00 09 00       	mov    $0x90080,%edx
    690b:	c7 c0 a0 47 04 00    	mov    $0x447a0,%eax
    6911:	8b 0a                	mov    (%edx),%ecx
    6913:	89 08                	mov    %ecx,(%eax)
    6915:	8b 4a 04             	mov    0x4(%edx),%ecx
    6918:	89 48 04             	mov    %ecx,0x4(%eax)
    691b:	8b 4a 08             	mov    0x8(%edx),%ecx
    691e:	89 48 08             	mov    %ecx,0x8(%eax)
    6921:	8b 4a 0c             	mov    0xc(%edx),%ecx
    6924:	89 48 0c             	mov    %ecx,0xc(%eax)
    6927:	8b 4a 10             	mov    0x10(%edx),%ecx
    692a:	89 48 10             	mov    %ecx,0x10(%eax)
    692d:	8b 4a 14             	mov    0x14(%edx),%ecx
    6930:	89 48 14             	mov    %ecx,0x14(%eax)
    6933:	8b 4a 18             	mov    0x18(%edx),%ecx
    6936:	89 48 18             	mov    %ecx,0x18(%eax)
    6939:	8b 52 1c             	mov    0x1c(%edx),%edx
    693c:	89 50 1c             	mov    %edx,0x1c(%eax)

	// 接着根据机器物理内存容量设置高速缓冲区和主内存的位置和范围.
	// 高速缓存末端地址->buffer_memory_end;机器内存容量->memory_end;主内存开始地址->main_memory_start.
	// 设置物理内存大小
	memory_end = (1 << 20) + (EXT_MEM_K << 10);						// 内存大小=1MB + 扩展内存(k)*1024字节.
    693f:	b8 02 00 09 00       	mov    $0x90002,%eax
    6944:	0f b7 00             	movzwl (%eax),%eax
    6947:	0f b7 c0             	movzwl %ax,%eax
    694a:	c1 e0 0a             	shl    $0xa,%eax
    694d:	05 00 00 10 00       	add    $0x100000,%eax
    6952:	89 83 40 1b 00 00    	mov    %eax,0x1b40(%ebx)
	memory_end &= 0xfffff000;										// 忽略不到4KB(1页)的内存数.
    6958:	8b 83 40 1b 00 00    	mov    0x1b40(%ebx),%eax
    695e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    6963:	89 83 40 1b 00 00    	mov    %eax,0x1b40(%ebx)
	if (memory_end > 16 * 1024 * 1024)								// 如果内存量超过16MB,则按16MB计.
    6969:	8b 83 40 1b 00 00    	mov    0x1b40(%ebx),%eax
    696f:	3d 00 00 00 01       	cmp    $0x1000000,%eax
    6974:	7e 0a                	jle    6980 <main+0x110>
		memory_end = 16 * 1024 * 1024;
    6976:	c7 83 40 1b 00 00 00 	movl   $0x1000000,0x1b40(%ebx)
    697d:	00 00 01 
	// 根据物理内存的大小设置高速缓冲去的末端大小
	if (memory_end > 12 * 1024 * 1024) 								// 如果内存>12MB,则设置缓冲区末端=4MB
    6980:	8b 83 40 1b 00 00    	mov    0x1b40(%ebx),%eax
    6986:	3d 00 00 c0 00       	cmp    $0xc00000,%eax
    698b:	7e 0c                	jle    6999 <main+0x129>
		buffer_memory_end = 4 * 1024 * 1024;
    698d:	c7 83 44 1b 00 00 00 	movl   $0x400000,0x1b44(%ebx)
    6994:	00 40 00 
    6997:	eb 23                	jmp    69bc <main+0x14c>
	else if (memory_end > 6 * 1024 * 1024)							// 否则若内存>6MB,则设置缓冲区末端=2MB
    6999:	8b 83 40 1b 00 00    	mov    0x1b40(%ebx),%eax
    699f:	3d 00 00 60 00       	cmp    $0x600000,%eax
    69a4:	7e 0c                	jle    69b2 <main+0x142>
		buffer_memory_end = 2 * 1024 * 1024;
    69a6:	c7 83 44 1b 00 00 00 	movl   $0x200000,0x1b44(%ebx)
    69ad:	00 20 00 
    69b0:	eb 0a                	jmp    69bc <main+0x14c>
	else
		buffer_memory_end = 1 * 1024 * 1024;						// 否则则设置缓冲区末端=1MB
    69b2:	c7 83 44 1b 00 00 00 	movl   $0x100000,0x1b44(%ebx)
    69b9:	00 10 00 
	// 根据高速缓冲区的末端大小设置主内存区的起始地址
	main_memory_start = buffer_memory_end;							// 主内存起始位置 = 缓冲区末端
    69bc:	8b 83 44 1b 00 00    	mov    0x1b44(%ebx),%eax
    69c2:	89 83 48 1b 00 00    	mov    %eax,0x1b48(%ebx)
	// 参见kernel/blk_drv/ramdisk.c.
#ifdef RAMDISK
	main_memory_start += rd_init(main_memory_start, RAMDISK * 1024);
#endif
	// 以下是内核进行所有方面的初始化工作.
	mem_init(main_memory_start, memory_end);						// 主内存区初始化.(mm/memory.c)
    69c8:	8b 93 40 1b 00 00    	mov    0x1b40(%ebx),%edx
    69ce:	8b 83 48 1b 00 00    	mov    0x1b48(%ebx),%eax
    69d4:	83 ec 08             	sub    $0x8,%esp
    69d7:	52                   	push   %edx
    69d8:	50                   	push   %eax
    69d9:	e8 ae 6d 00 00       	call   d78c <mem_init>
    69de:	83 c4 10             	add    $0x10,%esp
	trap_init();                                    				// 陷阱门(硬件中断向量)初始化.(kernel/traps.c)
    69e1:	e8 21 1a 00 00       	call   8407 <trap_init>
	blk_dev_init();													// 块设备初始化.(blk_drv/ll_rw_blk.c)
    69e6:	e8 ee 1a 01 00       	call   184d9 <blk_dev_init>
	chr_dev_init();													// 字符设备初始化.(chr_drv/tty_io.c)
    69eb:	e8 96 52 01 00       	call   1bc86 <chr_dev_init>
 	tty_init();														// tty初始化(chr_drv/tty_io.c)
    69f0:	e8 9d 52 01 00       	call   1bc92 <tty_init>
	time_init();													// 设置开机启动时间.
    69f5:	e8 41 fc ff ff       	call   663b <time_init>
 	sched_init();													// 调度程序初始化(加载任务0的tr,ldtr)(kernel/sched.c)
    69fa:	e8 e6 0f 00 00       	call   79e5 <sched_init>
	buffer_init(buffer_memory_end);									// 缓冲管理初始化,建内存链表等.(fs/buffer.c)
    69ff:	8b 83 44 1b 00 00    	mov    0x1b44(%ebx),%eax
    6a05:	83 ec 0c             	sub    $0xc,%esp
    6a08:	50                   	push   %eax
    6a09:	e8 a8 a2 00 00       	call   10cb6 <buffer_init>
    6a0e:	83 c4 10             	add    $0x10,%esp
	hd_init();														// 硬盘初始化.	(blk_drv/hd.c)
    6a11:	e8 f6 39 01 00       	call   1a40c <hd_init>
	floppy_init();													// 软驱初始化.	(blk_drv/floppy.c)
    6a16:	e8 6d 29 01 00       	call   19388 <floppy_init>
	sti();															// 所有初始化工作都完了,于是开启中断.
    6a1b:	fb                   	sti    
	// 打印内核初始化完毕
	Log(LOG_INFO_TYPE, "<<<<< Linux0.12 Kernel Init Finished, Ready Start Process0 >>>>>\n");
    6a1c:	83 ec 08             	sub    $0x8,%esp
    6a1f:	8d 83 38 40 ff ff    	lea    -0xbfc8(%ebx),%eax
    6a25:	50                   	push   %eax
    6a26:	6a 00                	push   $0x0
    6a28:	e8 72 f1 01 00       	call   25b9f <Log>
    6a2d:	83 c4 10             	add    $0x10,%esp
	// 下面过程通过在堆栈中设置的参数,利用中断返回指令启动任务0执行.
	move_to_user_mode();											// 移到用户模式下执行.(include/asm/system.h)
    6a30:	89 e0                	mov    %esp,%eax
    6a32:	6a 17                	push   $0x17
    6a34:	50                   	push   %eax
    6a35:	9c                   	pushf  
    6a36:	6a 0f                	push   $0xf
    6a38:	68 3e 6a 00 00       	push   $0x6a3e
    6a3d:	cf                   	iret   
    6a3e:	b8 17 00 00 00       	mov    $0x17,%eax
    6a43:	8e d8                	mov    %eax,%ds
    6a45:	8e c0                	mov    %eax,%es
    6a47:	8e e0                	mov    %eax,%fs
    6a49:	8e e8                	mov    %eax,%gs
	if (!fork_for_process0()) {										/* we count on this going ok */
    6a4b:	e8 6c fb ff ff       	call   65bc <fork_for_process0>
    6a50:	85 c0                	test   %eax,%eax
    6a52:	75 05                	jne    6a59 <main+0x1e9>
		init();														// 在新建的子进程(任务1即init进程)中执行.
    6a54:	e8 60 00 00 00       	call   6ab9 <init>
	 * 我们就回到这里,一直循环执行'pause()'.
	 */
	// pause()系统调用(kernel/sched.c)会把任务0转换成可中断等待状态,再执行调度函数.但是调度函数只要发现系统中没有其他任务可以运行时就会切换
	// 到任务0,是不信赖于任务0的状态.
	for(;;)
		__asm__("int $0x80"::"a" (__NR_pause):);					// 即执行系统调用pause().
    6a59:	b8 1d 00 00 00       	mov    $0x1d,%eax
    6a5e:	cd 80                	int    $0x80
    6a60:	eb f7                	jmp    6a59 <main+0x1e9>

00006a62 <printf>:

// 下面函数产生格式化信息并输出到标准输出设备stdout(1),这里是指屏幕上显示.参数'*fmt'指定输出将采用的格式,参见标准C语言书籍.
// 该子程序正好是vsprintf如何使用的一个简单例子.该程序使用vsprintf()将格式化的字符串放入printbuf缓冲区,然后用write()将
// 缓冲区的内容输出到标准设备(1--stdout).vsprintf()函数的实现见kernel/vsprintf.c.
int printf(const char *fmt, ...)
{
    6a62:	53                   	push   %ebx
    6a63:	83 ec 18             	sub    $0x18,%esp
    6a66:	e8 8f 02 00 00       	call   6cfa <__x86.get_pc_thunk.bx>
    6a6b:	81 c3 95 b5 02 00    	add    $0x2b595,%ebx
	va_list args;
	int i;

	va_start(args, fmt);
    6a71:	8d 44 24 24          	lea    0x24(%esp),%eax
    6a75:	89 44 24 0c          	mov    %eax,0xc(%esp)
	write(1, printbuf, i = vsprintf(printbuf, fmt, args));
    6a79:	8b 44 24 20          	mov    0x20(%esp),%eax
    6a7d:	83 ec 04             	sub    $0x4,%esp
    6a80:	ff 74 24 10          	pushl  0x10(%esp)
    6a84:	50                   	push   %eax
    6a85:	8d 83 40 17 00 00    	lea    0x1740(%ebx),%eax
    6a8b:	50                   	push   %eax
    6a8c:	e8 04 2c 00 00       	call   9695 <vsprintf>
    6a91:	83 c4 10             	add    $0x10,%esp
    6a94:	89 44 24 08          	mov    %eax,0x8(%esp)
    6a98:	83 ec 04             	sub    $0x4,%esp
    6a9b:	ff 74 24 0c          	pushl  0xc(%esp)
    6a9f:	8d 83 40 17 00 00    	lea    0x1740(%ebx),%eax
    6aa5:	50                   	push   %eax
    6aa6:	6a 01                	push   $0x1
    6aa8:	e8 64 ef 01 00       	call   25a11 <write>
    6aad:	83 c4 10             	add    $0x10,%esp
	va_end(args);
	return i;
    6ab0:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    6ab4:	83 c4 18             	add    $0x18,%esp
    6ab7:	5b                   	pop    %ebx
    6ab8:	c3                   	ret    

00006ab9 <init>:

// 在main()中已经进行子系统初始化,包括内存管理,各种硬件设备和驱动程序.init()函数在任务0第1次创建的子进程(任务1)中.它首先对第一个将要执行
// 的程序(shell)的环境进行初始化,然后以登录shell方式加载程序并执行之.
void init(void)
{
    6ab9:	53                   	push   %ebx
    6aba:	83 ec 18             	sub    $0x18,%esp
    6abd:	e8 38 02 00 00       	call   6cfa <__x86.get_pc_thunk.bx>
    6ac2:	81 c3 3e b5 02 00    	add    $0x2b53e,%ebx
	int pid, i, fd;
	// setup()是一个系统调用.用于读取硬盘参数和分区表信息并加载虚拟盘(若存在的话)和安装根文件系统设备.该函数用25行上的宏定义,对就函数是sys_setup(),
	// 在块设备子目录kernel/blk_drv/hd.c.
	setup((void *) &drive_info);
    6ac8:	c7 c0 a0 47 04 00    	mov    $0x447a0,%eax
    6ace:	50                   	push   %eax
    6acf:	e8 62 fa ff ff       	call   6536 <setup>
    6ad4:	83 c4 04             	add    $0x4,%esp
	// 下面以读写访问方式打开设备"/dev/tty0",它对应终端控制台.由于这是第一次打开文件操作,因此产生的文件句柄号(文件描述符)肯定是0.该句柄是UNIX类操作
	// 系统默认的控制台标准输入句柄stdin.这里再把它以读和写的方式分别打开是为了复制产生标准输出(写)句柄stdout和标准出错输出句柄stderr.函数前面的"(void)"
	// 前缀用于表示强制函数无需返回值.
	(void) open("/dev/tty1", O_RDWR, 0);
    6ad7:	83 ec 04             	sub    $0x4,%esp
    6ada:	6a 00                	push   $0x0
    6adc:	6a 02                	push   $0x2
    6ade:	8d 83 7a 40 ff ff    	lea    -0xbf86(%ebx),%eax
    6ae4:	50                   	push   %eax
    6ae5:	e8 87 ee 01 00       	call   25971 <open>
    6aea:	83 c4 10             	add    $0x10,%esp
	(void) dup(0);													// 复制句柄,产生句柄1号--stdout标准输出设备.
    6aed:	83 ec 0c             	sub    $0xc,%esp
    6af0:	6a 00                	push   $0x0
    6af2:	e8 69 ef 01 00       	call   25a60 <dup>
    6af7:	83 c4 10             	add    $0x10,%esp
	(void) dup(0);													// 复制句柄,产生句柄2号--stderr标准出错输出设备.
    6afa:	83 ec 0c             	sub    $0xc,%esp
    6afd:	6a 00                	push   $0x0
    6aff:	e8 5c ef 01 00       	call   25a60 <dup>
    6b04:	83 c4 10             	add    $0x10,%esp
	// 进程1执行的用户级代码的开始
	printf("<<<<< Process 1 console fd = %d >>>>>\n", fd);
    6b07:	83 ec 08             	sub    $0x8,%esp
    6b0a:	ff 74 24 14          	pushl  0x14(%esp)
    6b0e:	8d 83 84 40 ff ff    	lea    -0xbf7c(%ebx),%eax
    6b14:	50                   	push   %eax
    6b15:	e8 48 ff ff ff       	call   6a62 <printf>
    6b1a:	83 c4 10             	add    $0x10,%esp
	// 下面打印缓冲区块数和总字节数,每块1024字节,以及主内存区空闲内存字节数.
	printf("<<<<< %d buffers = %d bytes buffer space >>>>>\n\r", NR_BUFFERS,
    6b1d:	c7 c0 40 61 03 00    	mov    $0x36140,%eax
    6b23:	8b 00                	mov    (%eax),%eax
    6b25:	c1 e0 0a             	shl    $0xa,%eax
    6b28:	89 c2                	mov    %eax,%edx
    6b2a:	c7 c0 40 61 03 00    	mov    $0x36140,%eax
    6b30:	8b 00                	mov    (%eax),%eax
    6b32:	83 ec 04             	sub    $0x4,%esp
    6b35:	52                   	push   %edx
    6b36:	50                   	push   %eax
    6b37:	8d 83 ac 40 ff ff    	lea    -0xbf54(%ebx),%eax
    6b3d:	50                   	push   %eax
    6b3e:	e8 1f ff ff ff       	call   6a62 <printf>
    6b43:	83 c4 10             	add    $0x10,%esp
			NR_BUFFERS * BLOCK_SIZE);
	printf("<<<<< Free mem: %d bytes >>>>>\n\r", memory_end - main_memory_start);
    6b46:	8b 93 40 1b 00 00    	mov    0x1b40(%ebx),%edx
    6b4c:	8b 83 48 1b 00 00    	mov    0x1b48(%ebx),%eax
    6b52:	29 c2                	sub    %eax,%edx
    6b54:	89 d0                	mov    %edx,%eax
    6b56:	83 ec 08             	sub    $0x8,%esp
    6b59:	50                   	push   %eax
    6b5a:	8d 83 e0 40 ff ff    	lea    -0xbf20(%ebx),%eax
    6b60:	50                   	push   %eax
    6b61:	e8 fc fe ff ff       	call   6a62 <printf>
    6b66:	83 c4 10             	add    $0x10,%esp
	// 下面fork()用于创建一个子进程(任务2).对于被创建的子进程,fork()将返回0值,对于原进程(父进程)则返回子进程的进程号pid.所以第202--206行是子进程执行的内容.
	// 该子进程关闭了句柄0(stdin),以只读方式打开/etc/rc文件,并使用execve()函数将进程自身替换成/bin/sh程序(即shell程序),然后执行/bin/sh程序.所携带的参数
	// 和环境变量分别由argv_rc和envp_rc数组给出.关闭句柄0并立刻打开/etc/rc文件的作用是把标准输入stdin重定向到/etc/rc/文件.这样shell程序/bin/sh就可以运行
	// rc文件中设置的命令.由于这里sh的运行方式是非交互式的,因此在执行完rc文件中的命令后就会立刻退出,进程2也随之结束.并于execve()函数说明请参见fs/exec.c程序.
	// 函数_exit()退出时的出错码1 - 操作未许可;2 -- 文件或目录不存在.
	if (!(pid = fork())) {
    6b69:	e8 4a f9 ff ff       	call   64b8 <fork>
    6b6e:	89 44 24 08          	mov    %eax,0x8(%esp)
    6b72:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    6b77:	75 61                	jne    6bda <init+0x121>
		close(0);
    6b79:	83 ec 0c             	sub    $0xc,%esp
    6b7c:	6a 00                	push   $0x0
    6b7e:	e8 47 ee 01 00       	call   259ca <close>
    6b83:	83 c4 10             	add    $0x10,%esp
		if (open("/etc/rc", O_RDONLY, 0))
    6b86:	83 ec 04             	sub    $0x4,%esp
    6b89:	6a 00                	push   $0x0
    6b8b:	6a 00                	push   $0x0
    6b8d:	8d 83 01 41 ff ff    	lea    -0xbeff(%ebx),%eax
    6b93:	50                   	push   %eax
    6b94:	e8 d8 ed 01 00       	call   25971 <open>
    6b99:	83 c4 10             	add    $0x10,%esp
    6b9c:	85 c0                	test   %eax,%eax
    6b9e:	74 0d                	je     6bad <init+0xf4>
			_exit(1);												// 若打开文件失败,则退出(lib/_exit.c).
    6ba0:	83 ec 0c             	sub    $0xc,%esp
    6ba3:	6a 01                	push   $0x1
    6ba5:	e8 ac ed 01 00       	call   25956 <_exit>
    6baa:	83 c4 10             	add    $0x10,%esp
		execve("/bin/sh", argv_rc, envp_rc);						// 替换成/bin/sh程序并执行.
    6bad:	83 ec 04             	sub    $0x4,%esp
    6bb0:	8d 83 28 00 00 00    	lea    0x28(%ebx),%eax
    6bb6:	50                   	push   %eax
    6bb7:	8d 83 20 00 00 00    	lea    0x20(%ebx),%eax
    6bbd:	50                   	push   %eax
    6bbe:	8d 83 00 40 ff ff    	lea    -0xc000(%ebx),%eax
    6bc4:	50                   	push   %eax
    6bc5:	e8 1c ef 01 00       	call   25ae6 <execve>
    6bca:	83 c4 10             	add    $0x10,%esp
		_exit(2);													// 若execve()执行失败则退出.
    6bcd:	83 ec 0c             	sub    $0xc,%esp
    6bd0:	6a 02                	push   $0x2
    6bd2:	e8 7f ed 01 00       	call   25956 <_exit>
    6bd7:	83 c4 10             	add    $0x10,%esp
    }
	// 下面还是父进程（1）执行的语句。wait()等待子进程停止或终止，返回值应是子进程的进程号（pid)。这三句的作用是父进程等待子进程
	// 的结束。&i是存放返回状态信息的位置。如果wait()返回值不等于子进程号，则继续等待。
  	if (pid > 0)
    6bda:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    6bdf:	7e 17                	jle    6bf8 <init+0x13f>
		while (pid != wait(&i));
    6be1:	90                   	nop
    6be2:	83 ec 0c             	sub    $0xc,%esp
    6be5:	8d 44 24 10          	lea    0x10(%esp),%eax
    6be9:	50                   	push   %eax
    6bea:	e8 95 ef 01 00       	call   25b84 <wait>
    6bef:	83 c4 10             	add    $0x10,%esp
    6bf2:	39 44 24 08          	cmp    %eax,0x8(%esp)
    6bf6:	75 ea                	jne    6be2 <init+0x129>
	// 失败”信息并继续执行。对于所创建的子进程将关闭所有以前还遗留的句柄（stdin、stdout、stderr），新创建一个会话并设置进程组号，
	// 然后重新打开/dev/tty0作为stdin，并复制成stdout和stderr。再次执行系统解释程序/bin/sh。但这次执行所选用的参数和环境数组另
	// 选了一套。然后父进程再次运行wait()等等。如果子进程又停止了执行，则在标准输出上显示出错信息“子进程pid停止了运行，返回码是i”，
	// 然后继续重试下去...，形成“大”死循环。
	while (1) {
		if ((pid = fork()) < 0) {
    6bf8:	e8 bb f8 ff ff       	call   64b8 <fork>
    6bfd:	89 44 24 08          	mov    %eax,0x8(%esp)
    6c01:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    6c06:	79 19                	jns    6c21 <init+0x168>
			printf("Fork failed in init %c\r\n", ' ');
    6c08:	83 ec 08             	sub    $0x8,%esp
    6c0b:	6a 20                	push   $0x20
    6c0d:	8d 83 09 41 ff ff    	lea    -0xbef7(%ebx),%eax
    6c13:	50                   	push   %eax
    6c14:	e8 49 fe ff ff       	call   6a62 <printf>
    6c19:	83 c4 10             	add    $0x10,%esp
			continue;
    6c1c:	e9 cc 00 00 00       	jmp    6ced <init+0x234>
		}
		if (!pid) {                             					// 新的子进程。
    6c21:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    6c26:	0f 85 88 00 00 00    	jne    6cb4 <init+0x1fb>
			close(0); close(1); close(2);
    6c2c:	83 ec 0c             	sub    $0xc,%esp
    6c2f:	6a 00                	push   $0x0
    6c31:	e8 94 ed 01 00       	call   259ca <close>
    6c36:	83 c4 10             	add    $0x10,%esp
    6c39:	83 ec 0c             	sub    $0xc,%esp
    6c3c:	6a 01                	push   $0x1
    6c3e:	e8 87 ed 01 00       	call   259ca <close>
    6c43:	83 c4 10             	add    $0x10,%esp
    6c46:	83 ec 0c             	sub    $0xc,%esp
    6c49:	6a 02                	push   $0x2
    6c4b:	e8 7a ed 01 00       	call   259ca <close>
    6c50:	83 c4 10             	add    $0x10,%esp
			setsid();                       						// 创建一新的会话期，见后面说明。
    6c53:	e8 4f ee 01 00       	call   25aa7 <setsid>
			(void) open("/dev/tty1", O_RDWR, 0);
    6c58:	83 ec 04             	sub    $0x4,%esp
    6c5b:	6a 00                	push   $0x0
    6c5d:	6a 02                	push   $0x2
    6c5f:	8d 83 7a 40 ff ff    	lea    -0xbf86(%ebx),%eax
    6c65:	50                   	push   %eax
    6c66:	e8 06 ed 01 00       	call   25971 <open>
    6c6b:	83 c4 10             	add    $0x10,%esp
			(void) dup(0);
    6c6e:	83 ec 0c             	sub    $0xc,%esp
    6c71:	6a 00                	push   $0x0
    6c73:	e8 e8 ed 01 00       	call   25a60 <dup>
    6c78:	83 c4 10             	add    $0x10,%esp
			(void) dup(0);
    6c7b:	83 ec 0c             	sub    $0xc,%esp
    6c7e:	6a 00                	push   $0x0
    6c80:	e8 db ed 01 00       	call   25a60 <dup>
    6c85:	83 c4 10             	add    $0x10,%esp
			_exit(execve("/bin/sh", argv, envp));
    6c88:	83 ec 04             	sub    $0x4,%esp
    6c8b:	8d 83 3c 00 00 00    	lea    0x3c(%ebx),%eax
    6c91:	50                   	push   %eax
    6c92:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
    6c98:	50                   	push   %eax
    6c99:	8d 83 00 40 ff ff    	lea    -0xc000(%ebx),%eax
    6c9f:	50                   	push   %eax
    6ca0:	e8 41 ee 01 00       	call   25ae6 <execve>
    6ca5:	83 c4 10             	add    $0x10,%esp
    6ca8:	83 ec 0c             	sub    $0xc,%esp
    6cab:	50                   	push   %eax
    6cac:	e8 a5 ec 01 00       	call   25956 <_exit>
    6cb1:	83 c4 10             	add    $0x10,%esp
		}
		while (1)
			if (pid == wait(&i))
    6cb4:	83 ec 0c             	sub    $0xc,%esp
    6cb7:	8d 44 24 10          	lea    0x10(%esp),%eax
    6cbb:	50                   	push   %eax
    6cbc:	e8 c3 ee 01 00       	call   25b84 <wait>
    6cc1:	83 c4 10             	add    $0x10,%esp
    6cc4:	39 44 24 08          	cmp    %eax,0x8(%esp)
    6cc8:	74 02                	je     6ccc <init+0x213>
    6cca:	eb e8                	jmp    6cb4 <init+0x1fb>
				break;
    6ccc:	90                   	nop
		printf("\n\rchild %d died with code %04x\n\r", pid, i);
    6ccd:	8b 44 24 04          	mov    0x4(%esp),%eax
    6cd1:	83 ec 04             	sub    $0x4,%esp
    6cd4:	50                   	push   %eax
    6cd5:	ff 74 24 10          	pushl  0x10(%esp)
    6cd9:	8d 83 24 41 ff ff    	lea    -0xbedc(%ebx),%eax
    6cdf:	50                   	push   %eax
    6ce0:	e8 7d fd ff ff       	call   6a62 <printf>
    6ce5:	83 c4 10             	add    $0x10,%esp
		sync();
    6ce8:	e8 90 f8 ff ff       	call   657d <sync>
		if ((pid = fork()) < 0) {
    6ced:	e9 06 ff ff ff       	jmp    6bf8 <init+0x13f>

00006cf2 <__x86.get_pc_thunk.ax>:
    6cf2:	8b 04 24             	mov    (%esp),%eax
    6cf5:	c3                   	ret    

00006cf6 <__x86.get_pc_thunk.dx>:
    6cf6:	8b 14 24             	mov    (%esp),%edx
    6cf9:	c3                   	ret    

00006cfa <__x86.get_pc_thunk.bx>:
    6cfa:	8b 1c 24             	mov    (%esp),%ebx
    6cfd:	c3                   	ret    
    6cfe:	66 90                	xchg   %ax,%ax

00006d00 <show_task>:
// 除了SIGKILL和SIGSTOP信号以外其他信号都是可阻塞的.
#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))

// 内核调试函数.显示任务号nr的进程号,进程状态和内核堆栈空闲字节数(大约).
void show_task(int nr, struct task_struct * p)
{
    6d00:	56                   	push   %esi
    6d01:	53                   	push   %ebx
    6d02:	83 ec 14             	sub    $0x14,%esp
    6d05:	e8 f0 ff ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    6d0a:	81 c3 f6 b2 02 00    	add    $0x2b2f6,%ebx
	int i, j = 4096 - sizeof(struct task_struct);
    6d10:	c7 44 24 08 7c 0b 00 	movl   $0xb7c,0x8(%esp)
    6d17:	00 

	printk("%d: pid=%d, state=%d, father=%d, child=%d, ", nr, p->pid,
		p->state, p->p_pptr->pid, p->p_cptr ? p->p_cptr->pid : -1);
    6d18:	8b 44 24 24          	mov    0x24(%esp),%eax
    6d1c:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
	printk("%d: pid=%d, state=%d, father=%d, child=%d, ", nr, p->pid,
    6d22:	85 c0                	test   %eax,%eax
    6d24:	74 12                	je     6d38 <show_task+0x38>
		p->state, p->p_pptr->pid, p->p_cptr ? p->p_cptr->pid : -1);
    6d26:	8b 44 24 24          	mov    0x24(%esp),%eax
    6d2a:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
	printk("%d: pid=%d, state=%d, father=%d, child=%d, ", nr, p->pid,
    6d30:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    6d36:	eb 05                	jmp    6d3d <show_task+0x3d>
    6d38:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		p->state, p->p_pptr->pid, p->p_cptr ? p->p_cptr->pid : -1);
    6d3d:	8b 54 24 24          	mov    0x24(%esp),%edx
    6d41:	8b 92 bc 02 00 00    	mov    0x2bc(%edx),%edx
	printk("%d: pid=%d, state=%d, father=%d, child=%d, ", nr, p->pid,
    6d47:	8b b2 2c 02 00 00    	mov    0x22c(%edx),%esi
    6d4d:	8b 54 24 24          	mov    0x24(%esp),%edx
    6d51:	8b 0a                	mov    (%edx),%ecx
    6d53:	8b 54 24 24          	mov    0x24(%esp),%edx
    6d57:	8b 92 2c 02 00 00    	mov    0x22c(%edx),%edx
    6d5d:	83 ec 08             	sub    $0x8,%esp
    6d60:	50                   	push   %eax
    6d61:	56                   	push   %esi
    6d62:	51                   	push   %ecx
    6d63:	52                   	push   %edx
    6d64:	ff 74 24 38          	pushl  0x38(%esp)
    6d68:	8d 83 48 41 ff ff    	lea    -0xbeb8(%ebx),%eax
    6d6e:	50                   	push   %eax
    6d6f:	e8 be 25 00 00       	call   9332 <printk>
    6d74:	83 c4 20             	add    $0x20,%esp
	i = 0;
    6d77:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    6d7e:	00 
	while (i < j && !((char *)(p + 1))[i])				// 检测指定任务数据结构以后等于0的字节数.
    6d7f:	eb 05                	jmp    6d86 <show_task+0x86>
		i++;
    6d81:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
	while (i < j && !((char *)(p + 1))[i])				// 检测指定任务数据结构以后等于0的字节数.
    6d86:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6d8a:	3b 44 24 08          	cmp    0x8(%esp),%eax
    6d8e:	7d 17                	jge    6da7 <show_task+0xa7>
    6d90:	8b 44 24 24          	mov    0x24(%esp),%eax
    6d94:	8d 90 84 04 00 00    	lea    0x484(%eax),%edx
    6d9a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6d9e:	01 d0                	add    %edx,%eax
    6da0:	0f b6 00             	movzbl (%eax),%eax
    6da3:	84 c0                	test   %al,%al
    6da5:	74 da                	je     6d81 <show_task+0x81>
	printk("%d/%d chars free in kstack\n\r", i, j);
    6da7:	83 ec 04             	sub    $0x4,%esp
    6daa:	ff 74 24 0c          	pushl  0xc(%esp)
    6dae:	ff 74 24 14          	pushl  0x14(%esp)
    6db2:	8d 83 74 41 ff ff    	lea    -0xbe8c(%ebx),%eax
    6db8:	50                   	push   %eax
    6db9:	e8 74 25 00 00       	call   9332 <printk>
    6dbe:	83 c4 10             	add    $0x10,%esp
	printk("   PC=%08X.", *(1019 + (unsigned long *) p));
    6dc1:	8b 44 24 24          	mov    0x24(%esp),%eax
    6dc5:	05 ec 0f 00 00       	add    $0xfec,%eax
    6dca:	8b 00                	mov    (%eax),%eax
    6dcc:	83 ec 08             	sub    $0x8,%esp
    6dcf:	50                   	push   %eax
    6dd0:	8d 83 91 41 ff ff    	lea    -0xbe6f(%ebx),%eax
    6dd6:	50                   	push   %eax
    6dd7:	e8 56 25 00 00       	call   9332 <printk>
    6ddc:	83 c4 10             	add    $0x10,%esp
	if (p->p_ysptr || p->p_osptr)
    6ddf:	8b 44 24 24          	mov    0x24(%esp),%eax
    6de3:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    6de9:	85 c0                	test   %eax,%eax
    6deb:	75 0e                	jne    6dfb <show_task+0xfb>
    6ded:	8b 44 24 24          	mov    0x24(%esp),%eax
    6df1:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    6df7:	85 c0                	test   %eax,%eax
    6df9:	74 60                	je     6e5b <show_task+0x15b>
		printk("   Younger sib=%d, older sib=%d\n\r",
			p->p_ysptr ? p->p_ysptr->pid : -1,
			p->p_osptr ? p->p_osptr->pid : -1);
    6dfb:	8b 44 24 24          	mov    0x24(%esp),%eax
    6dff:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
		printk("   Younger sib=%d, older sib=%d\n\r",
    6e05:	85 c0                	test   %eax,%eax
    6e07:	74 12                	je     6e1b <show_task+0x11b>
			p->p_osptr ? p->p_osptr->pid : -1);
    6e09:	8b 44 24 24          	mov    0x24(%esp),%eax
    6e0d:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
		printk("   Younger sib=%d, older sib=%d\n\r",
    6e13:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    6e19:	eb 05                	jmp    6e20 <show_task+0x120>
    6e1b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			p->p_ysptr ? p->p_ysptr->pid : -1,
    6e20:	8b 44 24 24          	mov    0x24(%esp),%eax
    6e24:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
		printk("   Younger sib=%d, older sib=%d\n\r",
    6e2a:	85 c0                	test   %eax,%eax
    6e2c:	74 12                	je     6e40 <show_task+0x140>
			p->p_ysptr ? p->p_ysptr->pid : -1,
    6e2e:	8b 44 24 24          	mov    0x24(%esp),%eax
    6e32:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
		printk("   Younger sib=%d, older sib=%d\n\r",
    6e38:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    6e3e:	eb 05                	jmp    6e45 <show_task+0x145>
    6e40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    6e45:	83 ec 04             	sub    $0x4,%esp
    6e48:	52                   	push   %edx
    6e49:	50                   	push   %eax
    6e4a:	8d 83 a0 41 ff ff    	lea    -0xbe60(%ebx),%eax
    6e50:	50                   	push   %eax
    6e51:	e8 dc 24 00 00       	call   9332 <printk>
    6e56:	83 c4 10             	add    $0x10,%esp
    6e59:	eb 12                	jmp    6e6d <show_task+0x16d>
	else
		printk("\n\r");
    6e5b:	83 ec 0c             	sub    $0xc,%esp
    6e5e:	8d 83 c2 41 ff ff    	lea    -0xbe3e(%ebx),%eax
    6e64:	50                   	push   %eax
    6e65:	e8 c8 24 00 00       	call   9332 <printk>
    6e6a:	83 c4 10             	add    $0x10,%esp
}
    6e6d:	90                   	nop
    6e6e:	83 c4 14             	add    $0x14,%esp
    6e71:	5b                   	pop    %ebx
    6e72:	5e                   	pop    %esi
    6e73:	c3                   	ret    

00006e74 <show_state>:

// 显示所有任务的任务号,进程号,进程状态和内核堆栈空闲字节数(大约).
// NR_TASKS是系统能容纳的最大进程(任务)数量(64个),定义在include/kernel/sched.h
void show_state(void)
{
    6e74:	53                   	push   %ebx
    6e75:	83 ec 18             	sub    $0x18,%esp
    6e78:	e8 7d fe ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    6e7d:	81 c3 83 b1 02 00    	add    $0x2b183,%ebx
	int i;

	printk("\rTask-info:\n\r");
    6e83:	83 ec 0c             	sub    $0xc,%esp
    6e86:	8d 83 c5 41 ff ff    	lea    -0xbe3b(%ebx),%eax
    6e8c:	50                   	push   %eax
    6e8d:	e8 a0 24 00 00       	call   9332 <printk>
    6e92:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NR_TASKS; i++)
    6e95:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    6e9c:	00 
    6e9d:	eb 2f                	jmp    6ece <show_state+0x5a>
		if (task[i])
    6e9f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6ea3:	8b 84 83 a0 12 00 00 	mov    0x12a0(%ebx,%eax,4),%eax
    6eaa:	85 c0                	test   %eax,%eax
    6eac:	74 1b                	je     6ec9 <show_state+0x55>
			show_task(i, task[i]);
    6eae:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6eb2:	8b 84 83 a0 12 00 00 	mov    0x12a0(%ebx,%eax,4),%eax
    6eb9:	83 ec 08             	sub    $0x8,%esp
    6ebc:	50                   	push   %eax
    6ebd:	ff 74 24 18          	pushl  0x18(%esp)
    6ec1:	e8 3a fe ff ff       	call   6d00 <show_task>
    6ec6:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NR_TASKS; i++)
    6ec9:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    6ece:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    6ed3:	7e ca                	jle    6e9f <show_state+0x2b>
}
    6ed5:	90                   	nop
    6ed6:	83 c4 18             	add    $0x18,%esp
    6ed9:	5b                   	pop    %ebx
    6eda:	c3                   	ret    

00006edb <math_state_restore>:
/*
 * 将当前协处理器内容保存到老协处理器状态数组中,并将当前任务的协处理器内容加载进协处理器.
 */
// 当任务被调度交换过以后,该函数用以保存原任务的协处理器状态(上下文)并恢复新调度进来的当前任务的协处理器执行状态.
void math_state_restore()
{
    6edb:	e8 12 fe ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    6ee0:	05 20 b1 02 00       	add    $0x2b120,%eax
	// 如果任务没变则返回(上一个任务就是当前任务).这里"上一个任务"是指刚被交换出去的任务.
	if (last_task_used_math == current)
    6ee5:	8b 88 8c 1b 00 00    	mov    0x1b8c(%eax),%ecx
    6eeb:	8b 90 80 12 00 00    	mov    0x1280(%eax),%edx
    6ef1:	39 d1                	cmp    %edx,%ecx
    6ef3:	74 54                	je     6f49 <math_state_restore+0x6e>
		return;
	// 在发送协处理器命令之前要先必WAIT指令.如果上个任务使用了协处理器,则保存其状态.
	__asm__("fwait");
    6ef5:	9b                   	fwait
	if (last_task_used_math) {
    6ef6:	8b 90 8c 1b 00 00    	mov    0x1b8c(%eax),%edx
    6efc:	85 d2                	test   %edx,%edx
    6efe:	74 0c                	je     6f0c <math_state_restore+0x31>
		__asm__("fnsave %0"::"m" (last_task_used_math->tss.i387));
    6f00:	8b 90 8c 1b 00 00    	mov    0x1b8c(%eax),%edx
    6f06:	dd b2 18 04 00 00    	fnsave 0x418(%edx)
	}
	// 现在,las_task_used_math指向当前任务,以备当前任务被交换出去时使用.此时如果当前任务用过协处理器,则恢复其状态.否则的话说明是第一次使用,
	// 于是就向协处理器发初始化命令,并设置使用协处理器标志.
	last_task_used_math = current;
    6f0c:	8b 90 80 12 00 00    	mov    0x1280(%eax),%edx
    6f12:	89 90 8c 1b 00 00    	mov    %edx,0x1b8c(%eax)
	if (current->used_math) {
    6f18:	8b 90 80 12 00 00    	mov    0x1280(%eax),%edx
    6f1e:	0f b7 92 28 03 00 00 	movzwl 0x328(%edx),%edx
    6f25:	66 85 d2             	test   %dx,%dx
    6f28:	74 0d                	je     6f37 <math_state_restore+0x5c>
		__asm__("frstor %0"::"m" (current->tss.i387));
    6f2a:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    6f30:	dd a0 18 04 00 00    	frstor 0x418(%eax)
    6f36:	c3                   	ret    
	} else {
		__asm__("fninit"::);					// 向协处理器发初始化命令.
    6f37:	db e3                	fninit 
		current->used_math=1;					// 设置已使用协处理器标志.
    6f39:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    6f3f:	66 c7 80 28 03 00 00 	movw   $0x1,0x328(%eax)
    6f46:	01 00 
    6f48:	c3                   	ret    
		return;
    6f49:	90                   	nop
	}
}
    6f4a:	c3                   	ret    

00006f4b <schedule>:
 *
 * 注意!!任务0是个闲置('idle')任务,只有当没有其他任务可以运行时才调用它.它不能被杀死,也不睡眠.任务0中的状态信息'state'是从
 * 来不用的.
 */
void schedule(void)
{
    6f4b:	53                   	push   %ebx
    6f4c:	83 ec 20             	sub    $0x20,%esp
    6f4f:	e8 9e fd ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    6f54:	05 ac b0 02 00       	add    $0x2b0ac,%eax

	/* check alarm, wake up any interruptible tasks that have got a signal */
	/* 检测alarm(进程的报警定时值),唤醒任何已得到信号的可中断任务 */

	// 从任务数组中最后一个任务开始循环检测alarm.在循环时跳过空指针项.
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6f59:	8d 90 9c 13 00 00    	lea    0x139c(%eax),%edx
    6f5f:	89 54 24 10          	mov    %edx,0x10(%esp)
    6f63:	e9 e9 00 00 00       	jmp    7051 <schedule+0x106>
		if (*p) {
    6f68:	8b 54 24 10          	mov    0x10(%esp),%edx
    6f6c:	8b 12                	mov    (%edx),%edx
    6f6e:	85 d2                	test   %edx,%edx
    6f70:	0f 84 d6 00 00 00    	je     704c <schedule+0x101>
			// 如果设置过任务超时定时timeout,并且已经超时,则复位超时定时值,并且如果任务处于可中断睡眠状态TASK_INTERRUPTIBLE下,将其置为就绪
			// 状态(TASK_RUNNING).
			if ((*p)->timeout && (*p)->timeout < jiffies) {
    6f76:	8b 54 24 10          	mov    0x10(%esp),%edx
    6f7a:	8b 12                	mov    (%edx),%edx
    6f7c:	8b 92 d8 02 00 00    	mov    0x2d8(%edx),%edx
    6f82:	85 d2                	test   %edx,%edx
    6f84:	74 3f                	je     6fc5 <schedule+0x7a>
    6f86:	8b 54 24 10          	mov    0x10(%esp),%edx
    6f8a:	8b 12                	mov    (%edx),%edx
    6f8c:	8b 8a d8 02 00 00    	mov    0x2d8(%edx),%ecx
    6f92:	8b 90 80 1b 00 00    	mov    0x1b80(%eax),%edx
    6f98:	39 d1                	cmp    %edx,%ecx
    6f9a:	73 29                	jae    6fc5 <schedule+0x7a>
				(*p)->timeout = 0;
    6f9c:	8b 54 24 10          	mov    0x10(%esp),%edx
    6fa0:	8b 12                	mov    (%edx),%edx
    6fa2:	c7 82 d8 02 00 00 00 	movl   $0x0,0x2d8(%edx)
    6fa9:	00 00 00 
				if ((*p)->state == TASK_INTERRUPTIBLE)
    6fac:	8b 54 24 10          	mov    0x10(%esp),%edx
    6fb0:	8b 12                	mov    (%edx),%edx
    6fb2:	8b 12                	mov    (%edx),%edx
    6fb4:	83 fa 01             	cmp    $0x1,%edx
    6fb7:	75 0c                	jne    6fc5 <schedule+0x7a>
					(*p)->state = TASK_RUNNING;
    6fb9:	8b 54 24 10          	mov    0x10(%esp),%edx
    6fbd:	8b 12                	mov    (%edx),%edx
    6fbf:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			}
			// 如果设置过任务的定时值alarm,并且已经过期(alarm<jiffies),则在信号位图中置SIGALRM信号,即向任务发送SIGALARM信号.然后清alarm.
			// 该信号的默认操作是终止进程.jiffies是系统从开机开始算起的滴答数(10ms/滴答).定义在sched.h中.
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    6fc5:	8b 54 24 10          	mov    0x10(%esp),%edx
    6fc9:	8b 12                	mov    (%edx),%edx
    6fcb:	8b 92 dc 02 00 00    	mov    0x2dc(%edx),%edx
    6fd1:	85 d2                	test   %edx,%edx
    6fd3:	74 3b                	je     7010 <schedule+0xc5>
    6fd5:	8b 54 24 10          	mov    0x10(%esp),%edx
    6fd9:	8b 12                	mov    (%edx),%edx
    6fdb:	8b 8a dc 02 00 00    	mov    0x2dc(%edx),%ecx
    6fe1:	8b 90 80 1b 00 00    	mov    0x1b80(%eax),%edx
    6fe7:	39 d1                	cmp    %edx,%ecx
    6fe9:	73 25                	jae    7010 <schedule+0xc5>
				(*p)->signal |= (1 << (SIGALRM - 1));
    6feb:	8b 54 24 10          	mov    0x10(%esp),%edx
    6fef:	8b 12                	mov    (%edx),%edx
    6ff1:	8b 4a 0c             	mov    0xc(%edx),%ecx
    6ff4:	8b 54 24 10          	mov    0x10(%esp),%edx
    6ff8:	8b 12                	mov    (%edx),%edx
    6ffa:	80 cd 20             	or     $0x20,%ch
    6ffd:	89 4a 0c             	mov    %ecx,0xc(%edx)
				(*p)->alarm = 0;
    7000:	8b 54 24 10          	mov    0x10(%esp),%edx
    7004:	8b 12                	mov    (%edx),%edx
    7006:	c7 82 dc 02 00 00 00 	movl   $0x0,0x2dc(%edx)
    700d:	00 00 00 
			}
			// 如果信号位图中除被阻塞的信号外还有其他信号,并且任务处于可中断状态,则置任务为就绪状态.
			// 其中'~(_BLOCKABLE & (*p)->blocked)'用于忽略被阻塞的信号,但SIGKILL和SIGSTOP不能被阻塞.
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) && (*p)->state == TASK_INTERRUPTIBLE)
    7010:	8b 54 24 10          	mov    0x10(%esp),%edx
    7014:	8b 12                	mov    (%edx),%edx
    7016:	8b 4a 0c             	mov    0xc(%edx),%ecx
    7019:	8b 54 24 10          	mov    0x10(%esp),%edx
    701d:	8b 12                	mov    (%edx),%edx
    701f:	8b 92 10 02 00 00    	mov    0x210(%edx),%edx
    7025:	81 e2 ff fe fb ff    	and    $0xfffbfeff,%edx
    702b:	f7 d2                	not    %edx
    702d:	21 ca                	and    %ecx,%edx
    702f:	85 d2                	test   %edx,%edx
    7031:	74 19                	je     704c <schedule+0x101>
    7033:	8b 54 24 10          	mov    0x10(%esp),%edx
    7037:	8b 12                	mov    (%edx),%edx
    7039:	8b 12                	mov    (%edx),%edx
    703b:	83 fa 01             	cmp    $0x1,%edx
    703e:	75 0c                	jne    704c <schedule+0x101>
				(*p)->state = TASK_RUNNING;
    7040:	8b 54 24 10          	mov    0x10(%esp),%edx
    7044:	8b 12                	mov    (%edx),%edx
    7046:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    704c:	83 6c 24 10 04       	subl   $0x4,0x10(%esp)
    7051:	8d 90 a0 12 00 00    	lea    0x12a0(%eax),%edx
    7057:	39 54 24 10          	cmp    %edx,0x10(%esp)
    705b:	0f 87 07 ff ff ff    	ja     6f68 <schedule+0x1d>
		}

	/* this is the scheduler proper: */
	/* 这里是调度程序的主要部分 */
	while (1) {
		c = -1;
    7061:	c7 44 24 14 ff ff ff 	movl   $0xffffffff,0x14(%esp)
    7068:	ff 
		next = 0;
    7069:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    7070:	00 
		i = NR_TASKS;
    7071:	c7 44 24 1c 40 00 00 	movl   $0x40,0x1c(%esp)
    7078:	00 
		p = &task[NR_TASKS];
    7079:	8d 90 a0 13 00 00    	lea    0x13a0(%eax),%edx
    707f:	89 54 24 10          	mov    %edx,0x10(%esp)
		// 这段代码是从任务数组的最后一个任务开始循环处理,并跳过不含任务的数组糟.比较每个就绪状态任务的counter(任务运行时间的递减滴答计数)值,
		// 哪一个值大,运行时间还不长,next就指向哪个的任务号.
		while (--i) {
    7083:	eb 41                	jmp    70c6 <schedule+0x17b>
			// 当前索引没有进程指针则跳过当前循环
			if (!*--p)
    7085:	83 6c 24 10 04       	subl   $0x4,0x10(%esp)
    708a:	8b 54 24 10          	mov    0x10(%esp),%edx
    708e:	8b 12                	mov    (%edx),%edx
    7090:	85 d2                	test   %edx,%edx
    7092:	75 02                	jne    7096 <schedule+0x14b>
				continue;
    7094:	eb 30                	jmp    70c6 <schedule+0x17b>
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
    7096:	8b 54 24 10          	mov    0x10(%esp),%edx
    709a:	8b 12                	mov    (%edx),%edx
    709c:	8b 12                	mov    (%edx),%edx
    709e:	85 d2                	test   %edx,%edx
    70a0:	75 24                	jne    70c6 <schedule+0x17b>
    70a2:	8b 54 24 10          	mov    0x10(%esp),%edx
    70a6:	8b 12                	mov    (%edx),%edx
    70a8:	8b 52 04             	mov    0x4(%edx),%edx
    70ab:	39 54 24 14          	cmp    %edx,0x14(%esp)
    70af:	7d 15                	jge    70c6 <schedule+0x17b>
				c = (*p)->counter, next = i;
    70b1:	8b 54 24 10          	mov    0x10(%esp),%edx
    70b5:	8b 12                	mov    (%edx),%edx
    70b7:	8b 52 04             	mov    0x4(%edx),%edx
    70ba:	89 54 24 14          	mov    %edx,0x14(%esp)
    70be:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    70c2:	89 54 24 18          	mov    %edx,0x18(%esp)
		while (--i) {
    70c6:	83 6c 24 1c 01       	subl   $0x1,0x1c(%esp)
    70cb:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    70d0:	75 b3                	jne    7085 <schedule+0x13a>
		}
		// 如果比较得出有counter值不等于0的结果,或者後方中没有一个可运行的任务存在(此时c仍然为-1,next=0),则退出开始的循环,执行161行上的任务切换
		// 操作.否则就根据每个任务的优先权值,更新每一个任务的counter值,然后回到125行重新比较.counter值的计算方式为counter = counter /2 +priority.
		// 注意,这里计算过程不考虑进程的状态.
		if (c) break;
    70d2:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    70d7:	75 4d                	jne    7126 <schedule+0x1db>
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    70d9:	8d 90 9c 13 00 00    	lea    0x139c(%eax),%edx
    70df:	89 54 24 10          	mov    %edx,0x10(%esp)
    70e3:	eb 30                	jmp    7115 <schedule+0x1ca>
			if (*p)
    70e5:	8b 54 24 10          	mov    0x10(%esp),%edx
    70e9:	8b 12                	mov    (%edx),%edx
    70eb:	85 d2                	test   %edx,%edx
    70ed:	74 21                	je     7110 <schedule+0x1c5>
				(*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
    70ef:	8b 54 24 10          	mov    0x10(%esp),%edx
    70f3:	8b 12                	mov    (%edx),%edx
    70f5:	8b 52 04             	mov    0x4(%edx),%edx
    70f8:	89 d3                	mov    %edx,%ebx
    70fa:	d1 fb                	sar    %ebx
    70fc:	8b 54 24 10          	mov    0x10(%esp),%edx
    7100:	8b 12                	mov    (%edx),%edx
    7102:	8b 4a 08             	mov    0x8(%edx),%ecx
    7105:	8b 54 24 10          	mov    0x10(%esp),%edx
    7109:	8b 12                	mov    (%edx),%edx
    710b:	01 d9                	add    %ebx,%ecx
    710d:	89 4a 04             	mov    %ecx,0x4(%edx)
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    7110:	83 6c 24 10 04       	subl   $0x4,0x10(%esp)
    7115:	8d 90 a0 12 00 00    	lea    0x12a0(%eax),%edx
    711b:	39 54 24 10          	cmp    %edx,0x10(%esp)
    711f:	77 c4                	ja     70e5 <schedule+0x19a>
		c = -1;
    7121:	e9 3b ff ff ff       	jmp    7061 <schedule+0x116>
		if (c) break;
    7126:	90                   	nop
	}
	// 用下面的宏(定义在sched.h中)把当前任务指针current指向任务号为next的任务,并切换到该任务中运行.在146行上next被初始化为0.因此若系统中没有任何
	// 其他任务可运行时,则next始终为0.因此调度函数会在系统空闲时去执行任务0.此时任务0权执行pause()
	switch_to(next);					// 切换到任务号为next的任务,并运行之.
    7127:	8b 54 24 18          	mov    0x18(%esp),%edx
    712b:	c1 e2 04             	shl    $0x4,%edx
    712e:	8d 5a 20             	lea    0x20(%edx),%ebx
    7131:	8b 54 24 18          	mov    0x18(%esp),%edx
    7135:	8b 84 90 a0 12 00 00 	mov    0x12a0(%eax,%edx,4),%eax
    713c:	89 da                	mov    %ebx,%edx
    713e:	89 c1                	mov    %eax,%ecx
    7140:	39 0d 80 32 03 00    	cmp    %ecx,0x33280
    7146:	74 19                	je     7161 <schedule+0x216>
    7148:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
    714d:	87 0d 80 32 03 00    	xchg   %ecx,0x33280
    7153:	ff 6c 24 08          	ljmp   *0x8(%esp)
    7157:	39 0d 8c 3b 03 00    	cmp    %ecx,0x33b8c
    715d:	75 02                	jne    7161 <schedule+0x216>
    715f:	0f 06                	clts   
}
    7161:	90                   	nop
    7162:	83 c4 20             	add    $0x20,%esp
    7165:	5b                   	pop    %ebx
    7166:	c3                   	ret    

00007167 <sys_pause>:

// pause()系统调用.转换当前任务的状态为可中断的等待状态,并重新调试.
// 该系统调用将导致进程进入睡眠状态,直到收到一个信号.该信号用于终止进程或者使进程调用一个信号捕获函数.只有当捕获了一个信号,并且信号捕获处理函数返回,
// pause()才会返回.此时pause()返回值应该是-1,并且errno被置为EINTR.这里还没有完全实现(直到0.95版).
int sys_pause(void)
{
    7167:	e8 86 fb ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    716c:	05 94 ae 02 00       	add    $0x2ae94,%eax
	current->state = TASK_INTERRUPTIBLE;
    7171:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    7177:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	schedule();
    717d:	e8 c9 fd ff ff       	call   6f4b <schedule>
	return 0;
    7182:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7187:	c3                   	ret    

00007188 <__sleep_on>:
// 是任务结构)会改变,因此为了能修改调用该函数程序中原来就是指针变量的值,就需要传递指针'*p'的指针,即'**p'.
// 参数state是任务睡眠使用的状态:TASK_INTERRUPTIBLE或TASK_INTERRUPTIBLE.处于不可中断睡眠状态(TASK_UNINTERRUPTIBLE)的任务需要内核程序利用
// wake_up()函数明确唤醒之.处于可中断睡眠状态(TASK_INTERRUPTIBLE)可以通过信号,任务起时等手段唤醒(置为就绪状态TASK_RUNNING).
// *** 注意,由于本内核代码不是很成熟,因此下列与睡眠相关的代码存在一些问题,不宜深究.
static inline void __sleep_on(struct task_struct **p, int state)
{
    7188:	53                   	push   %ebx
    7189:	83 ec 18             	sub    $0x18,%esp
    718c:	e8 69 fb ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    7191:	81 c3 6f ae 02 00    	add    $0x2ae6f,%ebx
	struct task_struct *tmp;

	// 若指针无效,则退出.(指针所指的对象可以是NULL,但指针本身不会为0).
	// 如果当前任务是任务0,则死机(impossible!).
	if (!p)
    7197:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    719c:	0f 84 b9 00 00 00    	je     725b <__sleep_on+0xd3>
		return;
	if (current == &(init_task.task))
    71a2:	8b 93 80 12 00 00    	mov    0x1280(%ebx),%edx
    71a8:	8d 83 60 02 00 00    	lea    0x260(%ebx),%eax
    71ae:	39 c2                	cmp    %eax,%edx
    71b0:	75 12                	jne    71c4 <__sleep_on+0x3c>
		panic("task[0] trying to sleep");
    71b2:	83 ec 0c             	sub    $0xc,%esp
    71b5:	8d 83 d3 41 ff ff    	lea    -0xbe2d(%ebx),%eax
    71bb:	50                   	push   %eax
    71bc:	e8 1d 21 00 00       	call   92de <panic>
    71c1:	83 c4 10             	add    $0x10,%esp
	// 让tmp指向已经在等待队列上的任务(如果有的话),例如inode->i_wait.并且将睡眠队列头的等待指针指向当前任务.这样就把当前任务插入到了*p的等待队列中.然后
	// 将当前任务置为指定的等待状态,并执行重新调度.
	tmp = *p;
    71c4:	8b 44 24 20          	mov    0x20(%esp),%eax
    71c8:	8b 00                	mov    (%eax),%eax
    71ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
	*p = current;
    71ce:	8b 93 80 12 00 00    	mov    0x1280(%ebx),%edx
    71d4:	8b 44 24 20          	mov    0x20(%esp),%eax
    71d8:	89 10                	mov    %edx,(%eax)
	current->state = state;
    71da:	8b 83 80 12 00 00    	mov    0x1280(%ebx),%eax
    71e0:	8b 54 24 24          	mov    0x24(%esp),%edx
    71e4:	89 10                	mov    %edx,(%eax)
	// 将当前进程睡眠后立刻调用调度函数进行调度新的进程执行
repeat:	schedule();
    71e6:	e8 60 fd ff ff       	call   6f4b <schedule>
	// 只有当这个等待任务被唤醒时,程序才会返回到这里,表示进程已被明确地唤醒并执行.如果等待队列中还有等待任务,并且队列头指针*p所指向的任务不是当前任务时,说明
	// 在本任务插入等待队列后还有任务进入等待队列.于是我们应该也要唤醒这个任务,而我们自己应按顺序让这些后面进入队列的任务唤醒,因此这里将等待队列头所指任务先
	// 置为就绪状态,而自己则置为不可中断等待状态,即自己要等待这些后续队列的任务被唤醒而执行时来唤醒本任务.然后重新执行调度程序.
	if (*p && *p != current) {
    71eb:	8b 44 24 20          	mov    0x20(%esp),%eax
    71ef:	8b 00                	mov    (%eax),%eax
    71f1:	85 c0                	test   %eax,%eax
    71f3:	74 2a                	je     721f <__sleep_on+0x97>
    71f5:	8b 44 24 20          	mov    0x20(%esp),%eax
    71f9:	8b 10                	mov    (%eax),%edx
    71fb:	8b 83 80 12 00 00    	mov    0x1280(%ebx),%eax
    7201:	39 c2                	cmp    %eax,%edx
    7203:	74 1a                	je     721f <__sleep_on+0x97>
		(**p).state = 0;
    7205:	8b 44 24 20          	mov    0x20(%esp),%eax
    7209:	8b 00                	mov    (%eax),%eax
    720b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		current->state = TASK_UNINTERRUPTIBLE;
    7211:	8b 83 80 12 00 00    	mov    0x1280(%ebx),%eax
    7217:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
		goto repeat;
    721d:	eb c7                	jmp    71e6 <__sleep_on+0x5e>
	}
	// 执行到这里,说明本任务真正被唤醒执行.此时等待队列头指针应该指向本任务,若它为空,则表明调度有问题,于是显示警告信息.最后我们让头指针指向在我们前面进入队列的
	// 任务(*p = tmp).若确实存在这样一个任务,即队列中还有任务(tmp不为空),就唤醒之.最先进入队列的任务在唤醒后运行时最终会把等待队列头指针置成NULL.
	if (!*p)
    721f:	8b 44 24 20          	mov    0x20(%esp),%eax
    7223:	8b 00                	mov    (%eax),%eax
    7225:	85 c0                	test   %eax,%eax
    7227:	75 12                	jne    723b <__sleep_on+0xb3>
		printk("Warning: *P = NULL\n\r");
    7229:	83 ec 0c             	sub    $0xc,%esp
    722c:	8d 83 eb 41 ff ff    	lea    -0xbe15(%ebx),%eax
    7232:	50                   	push   %eax
    7233:	e8 fa 20 00 00       	call   9332 <printk>
    7238:	83 c4 10             	add    $0x10,%esp
	if (*p = tmp)
    723b:	8b 44 24 20          	mov    0x20(%esp),%eax
    723f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    7243:	89 10                	mov    %edx,(%eax)
    7245:	8b 44 24 20          	mov    0x20(%esp),%eax
    7249:	8b 00                	mov    (%eax),%eax
    724b:	85 c0                	test   %eax,%eax
    724d:	74 0d                	je     725c <__sleep_on+0xd4>
		tmp->state = 0;
    724f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7253:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    7259:	eb 01                	jmp    725c <__sleep_on+0xd4>
		return;
    725b:	90                   	nop
}
    725c:	83 c4 18             	add    $0x18,%esp
    725f:	5b                   	pop    %ebx
    7260:	c3                   	ret    

00007261 <interruptible_sleep_on>:

// 将当前任务置为可中断的等待状态(TASK_INIERRUPTIBLE),并放入头指针*p指定的等待队列中.
void interruptible_sleep_on(struct task_struct **p)
{
    7261:	83 ec 0c             	sub    $0xc,%esp
    7264:	e8 89 fa ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    7269:	05 97 ad 02 00       	add    $0x2ad97,%eax
	__sleep_on(p, TASK_INTERRUPTIBLE);
    726e:	83 ec 08             	sub    $0x8,%esp
    7271:	6a 01                	push   $0x1
    7273:	ff 74 24 1c          	pushl  0x1c(%esp)
    7277:	e8 0c ff ff ff       	call   7188 <__sleep_on>
    727c:	83 c4 10             	add    $0x10,%esp
}
    727f:	90                   	nop
    7280:	83 c4 0c             	add    $0xc,%esp
    7283:	c3                   	ret    

00007284 <sleep_on>:

// 把当前任务置为不可中断的等待状态(TASK_UNINTERRUPTIBLE),并让睡眠队列头指针指向当前任务.只有明确地唤醒时才会返回.该函数提供了进程与中断处理程序之间的
// 同步机制.
void sleep_on(struct task_struct **p)
{
    7284:	83 ec 0c             	sub    $0xc,%esp
    7287:	e8 66 fa ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    728c:	05 74 ad 02 00       	add    $0x2ad74,%eax
	__sleep_on(p, TASK_UNINTERRUPTIBLE);
    7291:	83 ec 08             	sub    $0x8,%esp
    7294:	6a 02                	push   $0x2
    7296:	ff 74 24 1c          	pushl  0x1c(%esp)
    729a:	e8 e9 fe ff ff       	call   7188 <__sleep_on>
    729f:	83 c4 10             	add    $0x10,%esp
}
    72a2:	90                   	nop
    72a3:	83 c4 0c             	add    $0xc,%esp
    72a6:	c3                   	ret    

000072a7 <wake_up>:

// 唤醒*p指向的任务.*p是任务等待队列头指针.由于新等待任务是插入在等待队列头指针处的,因此唤醒的是最后进入等待队列的任务.若该任务已经处于停止或
// 僵死状态,则显示警告信息.
void wake_up(struct task_struct **p)
{
    72a7:	53                   	push   %ebx
    72a8:	83 ec 08             	sub    $0x8,%esp
    72ab:	e8 4a fa ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    72b0:	81 c3 50 ad 02 00    	add    $0x2ad50,%ebx
	if (p && *p) {
    72b6:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    72bb:	74 54                	je     7311 <wake_up+0x6a>
    72bd:	8b 44 24 10          	mov    0x10(%esp),%eax
    72c1:	8b 00                	mov    (%eax),%eax
    72c3:	85 c0                	test   %eax,%eax
    72c5:	74 4a                	je     7311 <wake_up+0x6a>
		if ((**p).state == TASK_STOPPED)						// 处于停止状态.
    72c7:	8b 44 24 10          	mov    0x10(%esp),%eax
    72cb:	8b 00                	mov    (%eax),%eax
    72cd:	8b 00                	mov    (%eax),%eax
    72cf:	83 f8 04             	cmp    $0x4,%eax
    72d2:	75 12                	jne    72e6 <wake_up+0x3f>
			printk("wake_up: TASK_STOPPED");
    72d4:	83 ec 0c             	sub    $0xc,%esp
    72d7:	8d 83 00 42 ff ff    	lea    -0xbe00(%ebx),%eax
    72dd:	50                   	push   %eax
    72de:	e8 4f 20 00 00       	call   9332 <printk>
    72e3:	83 c4 10             	add    $0x10,%esp
		if ((**p).state == TASK_ZOMBIE)							// 处于僵死状态.
    72e6:	8b 44 24 10          	mov    0x10(%esp),%eax
    72ea:	8b 00                	mov    (%eax),%eax
    72ec:	8b 00                	mov    (%eax),%eax
    72ee:	83 f8 03             	cmp    $0x3,%eax
    72f1:	75 12                	jne    7305 <wake_up+0x5e>
			printk("wake_up: TASK_ZOMBIE");
    72f3:	83 ec 0c             	sub    $0xc,%esp
    72f6:	8d 83 16 42 ff ff    	lea    -0xbdea(%ebx),%eax
    72fc:	50                   	push   %eax
    72fd:	e8 30 20 00 00       	call   9332 <printk>
    7302:	83 c4 10             	add    $0x10,%esp
		(**p).state=0;											// 置为就绪状态TASK_RUNNING.
    7305:	8b 44 24 10          	mov    0x10(%esp),%eax
    7309:	8b 00                	mov    (%eax),%eax
    730b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
}
    7311:	90                   	nop
    7312:	83 c4 08             	add    $0x8,%esp
    7315:	5b                   	pop    %ebx
    7316:	c3                   	ret    

00007317 <ticks_to_floppy_on>:

// 指定软驱启动到正常运转状态所需等待时间.
// 参数nr -- 软驱号(0--3),返回值为滴答.
// 局部变量selected是选中软驱标志(blk_drv/floppy.c).mask是所选软驱对应的数字输出寄存器中启动马达位.mask高4位是各软驱启动马达标志.
int ticks_to_floppy_on(unsigned int nr)
{
    7317:	53                   	push   %ebx
    7318:	83 ec 18             	sub    $0x18,%esp
    731b:	e8 da f9 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    7320:	81 c3 e0 ac 02 00    	add    $0x2ace0,%ebx
	extern unsigned char selected;
	unsigned char mask = 0x10 << nr;
    7326:	8b 44 24 20          	mov    0x20(%esp),%eax
    732a:	ba 10 00 00 00       	mov    $0x10,%edx
    732f:	89 c1                	mov    %eax,%ecx
    7331:	d3 e2                	shl    %cl,%edx
    7333:	89 d0                	mov    %edx,%eax
    7335:	88 44 24 0f          	mov    %al,0xf(%esp)

	// 系统最多有4个软驱.首先预先设置好指定软驱nr停转之前需要经过的时间(100秒).然后取当前DOR寄存器值到临时变量mask中,并把指定软驱的马达
	// 启动标志置位.
	if (nr > 3)
    7339:	83 7c 24 20 03       	cmpl   $0x3,0x20(%esp)
    733e:	76 12                	jbe    7352 <ticks_to_floppy_on+0x3b>
		panic("floppy_on: nr>3");
    7340:	83 ec 0c             	sub    $0xc,%esp
    7343:	8d 83 2b 42 ff ff    	lea    -0xbdd5(%ebx),%eax
    7349:	50                   	push   %eax
    734a:	e8 8f 1f 00 00       	call   92de <panic>
    734f:	83 c4 10             	add    $0x10,%esp
	moff_timer[nr] = 10000;							/* 100 s = very big :-) */	// 停转维持时间.
    7352:	8b 44 24 20          	mov    0x20(%esp),%eax
    7356:	c7 84 83 b0 1b 00 00 	movl   $0x2710,0x1bb0(%ebx,%eax,4)
    735d:	10 27 00 00 
	cli();											/* use floppy_off to turn it off */	// 关中断
    7361:	fa                   	cli    
	mask |= current_DOR;
    7362:	0f b6 83 64 00 00 00 	movzbl 0x64(%ebx),%eax
    7369:	08 44 24 0f          	or     %al,0xf(%esp)
	// 如果当前没有选择软驱,则首先复位其他软驱的选择位,然后指定软驱选择位.
	if (!selected) {
    736d:	c7 c0 d8 61 03 00    	mov    $0x361d8,%eax
    7373:	0f b6 00             	movzbl (%eax),%eax
    7376:	84 c0                	test   %al,%al
    7378:	75 0d                	jne    7387 <ticks_to_floppy_on+0x70>
		mask &= 0xFC;
    737a:	80 64 24 0f fc       	andb   $0xfc,0xf(%esp)
		mask |= nr;
    737f:	8b 44 24 20          	mov    0x20(%esp),%eax
    7383:	08 44 24 0f          	or     %al,0xf(%esp)
	}
	// 如果数字输出寄存器的当前值与要求的值不同,则向FDC数字输出端口输出新值(mask),并且如果要求启动的马达还没有启动,则置相应软驱的马达启动
	// 定时器值(HZ/2 = 0.5秒或50个滴答).若已经启动,则再设置启动定时为2个滴答,能满足下面do_floppy_timer()中先递减后判断的要求.执行本次
	// 定时代码的要求即可.此后更新当前数字输出寄存器current_DOR.
	if (mask != current_DOR) {
    7387:	0f b6 83 64 00 00 00 	movzbl 0x64(%ebx),%eax
    738e:	38 44 24 0f          	cmp    %al,0xf(%esp)
    7392:	74 5d                	je     73f1 <ticks_to_floppy_on+0xda>
		outb(mask, FD_DOR);
    7394:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
    7399:	ba f2 03 00 00       	mov    $0x3f2,%edx
    739e:	ee                   	out    %al,(%dx)
		if ((mask ^ current_DOR) & 0xf0)
    739f:	0f b6 83 64 00 00 00 	movzbl 0x64(%ebx),%eax
    73a6:	32 44 24 0f          	xor    0xf(%esp),%al
    73aa:	0f b6 c0             	movzbl %al,%eax
    73ad:	25 f0 00 00 00       	and    $0xf0,%eax
    73b2:	85 c0                	test   %eax,%eax
    73b4:	74 11                	je     73c7 <ticks_to_floppy_on+0xb0>
			mon_timer[nr] = HZ / 2;
    73b6:	8b 44 24 20          	mov    0x20(%esp),%eax
    73ba:	c7 84 83 a0 1b 00 00 	movl   $0x32,0x1ba0(%ebx,%eax,4)
    73c1:	32 00 00 00 
    73c5:	eb 1f                	jmp    73e6 <ticks_to_floppy_on+0xcf>
		else if (mon_timer[nr] < 2)
    73c7:	8b 44 24 20          	mov    0x20(%esp),%eax
    73cb:	8b 84 83 a0 1b 00 00 	mov    0x1ba0(%ebx,%eax,4),%eax
    73d2:	83 f8 01             	cmp    $0x1,%eax
    73d5:	7f 0f                	jg     73e6 <ticks_to_floppy_on+0xcf>
			mon_timer[nr] = 2;
    73d7:	8b 44 24 20          	mov    0x20(%esp),%eax
    73db:	c7 84 83 a0 1b 00 00 	movl   $0x2,0x1ba0(%ebx,%eax,4)
    73e2:	02 00 00 00 
		current_DOR = mask;
    73e6:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
    73eb:	88 83 64 00 00 00    	mov    %al,0x64(%ebx)
	}
	sti();											// 开中断.
    73f1:	fb                   	sti    
	return mon_timer[nr];							// 最后返回启动马达所需的时间值.
    73f2:	8b 44 24 20          	mov    0x20(%esp),%eax
    73f6:	8b 84 83 a0 1b 00 00 	mov    0x1ba0(%ebx,%eax,4),%eax
}
    73fd:	83 c4 18             	add    $0x18,%esp
    7400:	5b                   	pop    %ebx
    7401:	c3                   	ret    

00007402 <floppy_on>:

// 等待指定软驱马达启动所需的一段时间,然后返回.
// 设置指定软驱的马达启动到正常转速所需的延时,然后睡眠等待.在定时中断过程中会一直递减判断这里设定的延时值.当延时到期,就会 这里的等待进程.
void floppy_on(unsigned int nr)
{
    7402:	53                   	push   %ebx
    7403:	83 ec 08             	sub    $0x8,%esp
    7406:	e8 ef f8 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    740b:	81 c3 f5 ab 02 00    	add    $0x2abf5,%ebx
	// 关中断.如果马达启动定时还没到,就一直把当前进程置为不可中断睡眠状态并放入等待马达运行的队列中.然后开中断.
	cli();
    7411:	fa                   	cli    
	while (ticks_to_floppy_on(nr))
    7412:	eb 1f                	jmp    7433 <floppy_on+0x31>
		sleep_on(nr + wait_motor);
    7414:	8b 44 24 10          	mov    0x10(%esp),%eax
    7418:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    741f:	8d 83 90 1b 00 00    	lea    0x1b90(%ebx),%eax
    7425:	01 d0                	add    %edx,%eax
    7427:	83 ec 0c             	sub    $0xc,%esp
    742a:	50                   	push   %eax
    742b:	e8 54 fe ff ff       	call   7284 <sleep_on>
    7430:	83 c4 10             	add    $0x10,%esp
	while (ticks_to_floppy_on(nr))
    7433:	83 ec 0c             	sub    $0xc,%esp
    7436:	ff 74 24 1c          	pushl  0x1c(%esp)
    743a:	e8 d8 fe ff ff       	call   7317 <ticks_to_floppy_on>
    743f:	83 c4 10             	add    $0x10,%esp
    7442:	85 c0                	test   %eax,%eax
    7444:	75 ce                	jne    7414 <floppy_on+0x12>
	sti();
    7446:	fb                   	sti    
}
    7447:	90                   	nop
    7448:	83 c4 08             	add    $0x8,%esp
    744b:	5b                   	pop    %ebx
    744c:	c3                   	ret    

0000744d <floppy_off>:

// 置关闭相应软驱马达停转定时器(3秒).
// 若不使用该函数明确关闭指定的软驱马达,则在马达开启100秒之后也会被关闭.
void floppy_off(unsigned int nr)
{
    744d:	e8 a0 f8 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    7452:	05 ae ab 02 00       	add    $0x2abae,%eax
	moff_timer[nr] = 3 * HZ;
    7457:	8b 54 24 04          	mov    0x4(%esp),%edx
    745b:	c7 84 90 b0 1b 00 00 	movl   $0x12c,0x1bb0(%eax,%edx,4)
    7462:	2c 01 00 00 
}
    7466:	90                   	nop
    7467:	c3                   	ret    

00007468 <do_floppy_timer>:

// 软盘定时处理子程序.更新马达启动定时值和马达关闭停转时值.该子程序会在时钟定时中断过程中被调用,因此系统每经过一个滴答(10ms)就会被
// 调用一次,随时更新马达开启或停转定时器的值.如果某一个马达停转定时到,则将数字输出寄存器马达启动位复位.
void do_floppy_timer(void)
{
    7468:	53                   	push   %ebx
    7469:	83 ec 18             	sub    $0x18,%esp
    746c:	e8 89 f8 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    7471:	81 c3 8f ab 02 00    	add    $0x2ab8f,%ebx
	int i;
	unsigned char mask = 0x10;
    7477:	c6 44 24 0b 10       	movb   $0x10,0xb(%esp)

	for (i = 0 ; i < 4 ; i++, mask <<= 1) {
    747c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    7483:	00 
    7484:	e9 c6 00 00 00       	jmp    754f <do_floppy_timer+0xe7>
		if (!(mask & current_DOR))						// 如果不是DOR指定的马达则跳过.
    7489:	0f b6 83 64 00 00 00 	movzbl 0x64(%ebx),%eax
    7490:	22 44 24 0b          	and    0xb(%esp),%al
    7494:	84 c0                	test   %al,%al
    7496:	0f 84 a9 00 00 00    	je     7545 <do_floppy_timer+0xdd>
			continue;
		if (mon_timer[i]) {								// 如果马达启动定时到则唤醒进程.
    749c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    74a0:	8b 84 83 a0 1b 00 00 	mov    0x1ba0(%ebx,%eax,4),%eax
    74a7:	85 c0                	test   %eax,%eax
    74a9:	74 49                	je     74f4 <do_floppy_timer+0x8c>
			if (!--mon_timer[i])
    74ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
    74af:	8b 84 83 a0 1b 00 00 	mov    0x1ba0(%ebx,%eax,4),%eax
    74b6:	8d 50 ff             	lea    -0x1(%eax),%edx
    74b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    74bd:	89 94 83 a0 1b 00 00 	mov    %edx,0x1ba0(%ebx,%eax,4)
    74c4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    74c8:	8b 84 83 a0 1b 00 00 	mov    0x1ba0(%ebx,%eax,4),%eax
    74cf:	85 c0                	test   %eax,%eax
    74d1:	75 73                	jne    7546 <do_floppy_timer+0xde>
				wake_up(i + wait_motor);
    74d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    74d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74de:	8d 83 90 1b 00 00    	lea    0x1b90(%ebx),%eax
    74e4:	01 d0                	add    %edx,%eax
    74e6:	83 ec 0c             	sub    $0xc,%esp
    74e9:	50                   	push   %eax
    74ea:	e8 b8 fd ff ff       	call   72a7 <wake_up>
    74ef:	83 c4 10             	add    $0x10,%esp
    74f2:	eb 52                	jmp    7546 <do_floppy_timer+0xde>
		} else if (!moff_timer[i]) {					// 如果马达停转定时到则复位相应马达启动位,并且更新数字输出寄存器.
    74f4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    74f8:	8b 84 83 b0 1b 00 00 	mov    0x1bb0(%ebx,%eax,4),%eax
    74ff:	85 c0                	test   %eax,%eax
    7501:	75 27                	jne    752a <do_floppy_timer+0xc2>
			current_DOR &= ~mask;
    7503:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
    7508:	f7 d0                	not    %eax
    750a:	89 c2                	mov    %eax,%edx
    750c:	0f b6 83 64 00 00 00 	movzbl 0x64(%ebx),%eax
    7513:	21 d0                	and    %edx,%eax
    7515:	88 83 64 00 00 00    	mov    %al,0x64(%ebx)
			outb(current_DOR, FD_DOR);
    751b:	0f b6 83 64 00 00 00 	movzbl 0x64(%ebx),%eax
    7522:	ba f2 03 00 00       	mov    $0x3f2,%edx
    7527:	ee                   	out    %al,(%dx)
    7528:	eb 1c                	jmp    7546 <do_floppy_timer+0xde>
		} else
			moff_timer[i]--;							// 否则马达停转计时递减.
    752a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    752e:	8b 84 83 b0 1b 00 00 	mov    0x1bb0(%ebx,%eax,4),%eax
    7535:	8d 50 ff             	lea    -0x1(%eax),%edx
    7538:	8b 44 24 0c          	mov    0xc(%esp),%eax
    753c:	89 94 83 b0 1b 00 00 	mov    %edx,0x1bb0(%ebx,%eax,4)
    7543:	eb 01                	jmp    7546 <do_floppy_timer+0xde>
			continue;
    7545:	90                   	nop
	for (i = 0 ; i < 4 ; i++, mask <<= 1) {
    7546:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    754b:	d0 64 24 0b          	shlb   0xb(%esp)
    754f:	83 7c 24 0c 03       	cmpl   $0x3,0xc(%esp)
    7554:	0f 8e 2f ff ff ff    	jle    7489 <do_floppy_timer+0x21>
	}
}
    755a:	90                   	nop
    755b:	83 c4 18             	add    $0x18,%esp
    755e:	5b                   	pop    %ebx
    755f:	c3                   	ret    

00007560 <add_timer>:

// 添加定时器.输入参数为指定的定时值(滴答数)和相应的处理程序指针.
// 软盘驱动程序(floppy.c)利用该函数执行启动或关闭马达的延时操作.
// 参数jiffies- 以10毫秒计的滴答数; *fn() - 定时时间到时执行的函数.
void add_timer(long jiffies, void (*fn)(void))
{
    7560:	53                   	push   %ebx
    7561:	83 ec 18             	sub    $0x18,%esp
    7564:	e8 91 f7 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    7569:	81 c3 97 aa 02 00    	add    $0x2aa97,%ebx
	struct timer_list * p;

	// 如果定时处理程序指针为空,则退出.否则关中断.
	if (!fn)
    756f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    7574:	0f 84 5b 01 00 00    	je     76d5 <add_timer+0x175>
		return;
	cli();
    757a:	fa                   	cli    
	// 如果定时值<=0,则立刻调用其处理程序.并且该定时器不加入链表中.
	if (jiffies <= 0)
    757b:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    7580:	7f 0b                	jg     758d <add_timer+0x2d>
		(fn)();
    7582:	8b 44 24 24          	mov    0x24(%esp),%eax
    7586:	ff d0                	call   *%eax
    7588:	e9 45 01 00 00       	jmp    76d2 <add_timer+0x172>
	else {
		// 否则从定时器数组中,找一个空闲项.
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    758d:	8d 83 c0 1b 00 00    	lea    0x1bc0(%ebx),%eax
    7593:	89 44 24 0c          	mov    %eax,0xc(%esp)
    7597:	eb 10                	jmp    75a9 <add_timer+0x49>
			if (!p->fn)
    7599:	8b 44 24 0c          	mov    0xc(%esp),%eax
    759d:	8b 40 04             	mov    0x4(%eax),%eax
    75a0:	85 c0                	test   %eax,%eax
    75a2:	74 13                	je     75b7 <add_timer+0x57>
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    75a4:	83 44 24 0c 0c       	addl   $0xc,0xc(%esp)
    75a9:	8d 83 c0 1e 00 00    	lea    0x1ec0(%ebx),%eax
    75af:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    75b3:	72 e4                	jb     7599 <add_timer+0x39>
    75b5:	eb 01                	jmp    75b8 <add_timer+0x58>
				break;
    75b7:	90                   	nop
		// 如果已经用完了定时器数组,则系统崩溃.否则向定时器数据结构填入就信息,并链入链表头.
		if (p >= timer_list + TIME_REQUESTS)
    75b8:	8d 83 c0 1e 00 00    	lea    0x1ec0(%ebx),%eax
    75be:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    75c2:	72 12                	jb     75d6 <add_timer+0x76>
			panic("No more time requests free");
    75c4:	83 ec 0c             	sub    $0xc,%esp
    75c7:	8d 83 3b 42 ff ff    	lea    -0xbdc5(%ebx),%eax
    75cd:	50                   	push   %eax
    75ce:	e8 0b 1d 00 00       	call   92de <panic>
    75d3:	83 c4 10             	add    $0x10,%esp
		p->fn = fn;
    75d6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    75da:	8b 54 24 24          	mov    0x24(%esp),%edx
    75de:	89 50 04             	mov    %edx,0x4(%eax)
		p->jiffies = jiffies;
    75e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    75e5:	8b 54 24 20          	mov    0x20(%esp),%edx
    75e9:	89 10                	mov    %edx,(%eax)
		p->next = next_timer;
    75eb:	8b 93 c0 1e 00 00    	mov    0x1ec0(%ebx),%edx
    75f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    75f5:	89 50 08             	mov    %edx,0x8(%eax)
		next_timer = p;
    75f8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    75fc:	89 83 c0 1e 00 00    	mov    %eax,0x1ec0(%ebx)
		// 链表项按定时值从小到大排序.在排序时减去排在前面需要的滴答数,这样在处理定时器时只要查看链表头的第一项的定时是否到期即可.
		// [[?? 这段程序好像没有考虑周全.如果新插入的定时器值小于原来关一个定时器值时则根本没会进入循环中,但此时还是应该将紧随后面
		// 的一个定时器值减去新的第1个的定时值.即如果第1个定时值<=第2个,则第2个定时值扣除第1个的值即可,否则进入下面循环中进行处理.]]
		while (p->next && p->next->jiffies < p->jiffies) {
    7602:	eb 72                	jmp    7676 <add_timer+0x116>
			p->jiffies -= p->next->jiffies;
    7604:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7608:	8b 10                	mov    (%eax),%edx
    760a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    760e:	8b 40 08             	mov    0x8(%eax),%eax
    7611:	8b 00                	mov    (%eax),%eax
    7613:	29 c2                	sub    %eax,%edx
    7615:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7619:	89 10                	mov    %edx,(%eax)
			fn = p->fn;
    761b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    761f:	8b 40 04             	mov    0x4(%eax),%eax
    7622:	89 44 24 24          	mov    %eax,0x24(%esp)
			p->fn = p->next->fn;
    7626:	8b 44 24 0c          	mov    0xc(%esp),%eax
    762a:	8b 40 08             	mov    0x8(%eax),%eax
    762d:	8b 50 04             	mov    0x4(%eax),%edx
    7630:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7634:	89 50 04             	mov    %edx,0x4(%eax)
			p->next->fn = fn;
    7637:	8b 44 24 0c          	mov    0xc(%esp),%eax
    763b:	8b 40 08             	mov    0x8(%eax),%eax
    763e:	8b 54 24 24          	mov    0x24(%esp),%edx
    7642:	89 50 04             	mov    %edx,0x4(%eax)
			jiffies = p->jiffies;
    7645:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7649:	8b 00                	mov    (%eax),%eax
    764b:	89 44 24 20          	mov    %eax,0x20(%esp)
			p->jiffies = p->next->jiffies;
    764f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7653:	8b 40 08             	mov    0x8(%eax),%eax
    7656:	8b 10                	mov    (%eax),%edx
    7658:	8b 44 24 0c          	mov    0xc(%esp),%eax
    765c:	89 10                	mov    %edx,(%eax)
			p->next->jiffies = jiffies;
    765e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7662:	8b 40 08             	mov    0x8(%eax),%eax
    7665:	8b 54 24 20          	mov    0x20(%esp),%edx
    7669:	89 10                	mov    %edx,(%eax)
			p = p->next;
    766b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    766f:	8b 40 08             	mov    0x8(%eax),%eax
    7672:	89 44 24 0c          	mov    %eax,0xc(%esp)
		while (p->next && p->next->jiffies < p->jiffies) {
    7676:	8b 44 24 0c          	mov    0xc(%esp),%eax
    767a:	8b 40 08             	mov    0x8(%eax),%eax
    767d:	85 c0                	test   %eax,%eax
    767f:	74 17                	je     7698 <add_timer+0x138>
    7681:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7685:	8b 40 08             	mov    0x8(%eax),%eax
    7688:	8b 10                	mov    (%eax),%edx
    768a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    768e:	8b 00                	mov    (%eax),%eax
    7690:	39 c2                	cmp    %eax,%edx
    7692:	0f 8c 6c ff ff ff    	jl     7604 <add_timer+0xa4>
		}
		// 修正上述问题.
		if(p->next && p->next->jiffies >= p->jiffies) {
    7698:	8b 44 24 0c          	mov    0xc(%esp),%eax
    769c:	8b 40 08             	mov    0x8(%eax),%eax
    769f:	85 c0                	test   %eax,%eax
    76a1:	74 2f                	je     76d2 <add_timer+0x172>
    76a3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    76a7:	8b 40 08             	mov    0x8(%eax),%eax
    76aa:	8b 10                	mov    (%eax),%edx
    76ac:	8b 44 24 0c          	mov    0xc(%esp),%eax
    76b0:	8b 00                	mov    (%eax),%eax
    76b2:	39 c2                	cmp    %eax,%edx
    76b4:	7c 1c                	jl     76d2 <add_timer+0x172>
			p->next->jiffies -= p->jiffies;
    76b6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    76ba:	8b 40 08             	mov    0x8(%eax),%eax
    76bd:	8b 08                	mov    (%eax),%ecx
    76bf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    76c3:	8b 10                	mov    (%eax),%edx
    76c5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    76c9:	8b 40 08             	mov    0x8(%eax),%eax
    76cc:	29 d1                	sub    %edx,%ecx
    76ce:	89 ca                	mov    %ecx,%edx
    76d0:	89 10                	mov    %edx,(%eax)
		}
	}
	sti();
    76d2:	fb                   	sti    
    76d3:	eb 01                	jmp    76d6 <add_timer+0x176>
		return;
    76d5:	90                   	nop
}
    76d6:	83 c4 18             	add    $0x18,%esp
    76d9:	5b                   	pop    %ebx
    76da:	c3                   	ret    

000076db <do_timer>:

// 时钟中断C函数处理程序,在sys_call.s中的timer_interrupt被调用.
// 参数cpl是当前特权级0或3,是时钟中断发生时正被执行的代码选择符中的特权级.cpl=0时表示中断发生时正在执行内核代码,cpl=3时表示中断发生时正在执行用户
// 代码.对于一个进程由于执行时间片用完时,则进行任务切换.并执行一个计时更新工作.
void do_timer(long cpl)
{
    76db:	53                   	push   %ebx
    76dc:	83 ec 18             	sub    $0x18,%esp
    76df:	e8 16 f6 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    76e4:	81 c3 1c a9 02 00    	add    $0x2a91c,%ebx
	static int blanked = 0;

	// 首先判断是否经过了一定时间而让屏幕黑屏(blankcount).如果blankcount计数不为零,或者黑屏延时间隔时间blankinterval为0的话,那么若已经处理黑屏状态
	// (黑屏标志blanked=1),则让屏幕恢复显示.若blnkcount计数不为零,则递减之,并且复位黑屏标志.
	if (blankcount || !blankinterval) {
    76ea:	c7 c0 a8 3e 04 00    	mov    $0x43ea8,%eax
    76f0:	8b 00                	mov    (%eax),%eax
    76f2:	85 c0                	test   %eax,%eax
    76f4:	75 0c                	jne    7702 <do_timer+0x27>
    76f6:	c7 c0 a4 3e 04 00    	mov    $0x43ea4,%eax
    76fc:	8b 00                	mov    (%eax),%eax
    76fe:	85 c0                	test   %eax,%eax
    7700:	75 3a                	jne    773c <do_timer+0x61>
		if (blanked)
    7702:	8b 83 c4 1e 00 00    	mov    0x1ec4(%ebx),%eax
    7708:	85 c0                	test   %eax,%eax
    770a:	74 05                	je     7711 <do_timer+0x36>
			unblank_screen();
    770c:	e8 05 8a 01 00       	call   20116 <unblank_screen>
		if (blankcount)
    7711:	c7 c0 a8 3e 04 00    	mov    $0x43ea8,%eax
    7717:	8b 00                	mov    (%eax),%eax
    7719:	85 c0                	test   %eax,%eax
    771b:	74 13                	je     7730 <do_timer+0x55>
			blankcount--;
    771d:	c7 c0 a8 3e 04 00    	mov    $0x43ea8,%eax
    7723:	8b 00                	mov    (%eax),%eax
    7725:	8d 50 ff             	lea    -0x1(%eax),%edx
    7728:	c7 c0 a8 3e 04 00    	mov    $0x43ea8,%eax
    772e:	89 10                	mov    %edx,(%eax)
		blanked = 0;
    7730:	c7 83 c4 1e 00 00 00 	movl   $0x0,0x1ec4(%ebx)
    7737:	00 00 00 
    773a:	eb 19                	jmp    7755 <do_timer+0x7a>
	// 否则的话若黑屏标志末置位,则让屏幕黑屏,并且设置黑屏标志.
	} else if (!blanked) {
    773c:	8b 83 c4 1e 00 00    	mov    0x1ec4(%ebx),%eax
    7742:	85 c0                	test   %eax,%eax
    7744:	75 0f                	jne    7755 <do_timer+0x7a>
		blank_screen();
    7746:	e8 ab 89 01 00       	call   200f6 <blank_screen>
		blanked = 1;
    774b:	c7 83 c4 1e 00 00 01 	movl   $0x1,0x1ec4(%ebx)
    7752:	00 00 00 
	}
	// 接着处理硬盘操作超时问题.如果硬盘超时计数递减之后为0,则进行硬盘访问超时处理.
	if (hd_timeout)
    7755:	c7 c0 04 62 03 00    	mov    $0x36204,%eax
    775b:	8b 00                	mov    (%eax),%eax
    775d:	85 c0                	test   %eax,%eax
    775f:	74 24                	je     7785 <do_timer+0xaa>
		if (!--hd_timeout)
    7761:	c7 c0 04 62 03 00    	mov    $0x36204,%eax
    7767:	8b 00                	mov    (%eax),%eax
    7769:	8d 50 ff             	lea    -0x1(%eax),%edx
    776c:	c7 c0 04 62 03 00    	mov    $0x36204,%eax
    7772:	89 10                	mov    %edx,(%eax)
    7774:	c7 c0 04 62 03 00    	mov    $0x36204,%eax
    777a:	8b 00                	mov    (%eax),%eax
    777c:	85 c0                	test   %eax,%eax
    777e:	75 05                	jne    7785 <do_timer+0xaa>
			hd_times_out();							// 硬盘访问超时处理(blk_drv/hd.c).
    7780:	e8 03 29 01 00       	call   1a088 <hd_times_out>

	// 如果发声计数次数到,则关闭发声.(向0x61口发送命令,复位位0和1.位0控制8253计数器2的工作,位1控制扬声器.
	if (beepcount)									// 扬声器发声时间滴答数(chr_drv/console.c)
    7785:	c7 c0 ac 3e 04 00    	mov    $0x43eac,%eax
    778b:	8b 00                	mov    (%eax),%eax
    778d:	85 c0                	test   %eax,%eax
    778f:	74 24                	je     77b5 <do_timer+0xda>
		if (!--beepcount)
    7791:	c7 c0 ac 3e 04 00    	mov    $0x43eac,%eax
    7797:	8b 00                	mov    (%eax),%eax
    7799:	8d 50 ff             	lea    -0x1(%eax),%edx
    779c:	c7 c0 ac 3e 04 00    	mov    $0x43eac,%eax
    77a2:	89 10                	mov    %edx,(%eax)
    77a4:	c7 c0 ac 3e 04 00    	mov    $0x43eac,%eax
    77aa:	8b 00                	mov    (%eax),%eax
    77ac:	85 c0                	test   %eax,%eax
    77ae:	75 05                	jne    77b5 <do_timer+0xda>
			sysbeepstop();
    77b0:	e8 c8 87 01 00       	call   1ff7d <sysbeepstop>

	// 如果当前特权级(cpl)为0(最高,表示是内核程序在工作),则将内核代码时间stime递增;[Linus把内核程序统称为超级用户(superviser)的
	// 程序.这种称呼来自Intel CPU手册.]如果cpl>0,则表示是一般用户程序在工作,增加utime.
	if (cpl)
    77b5:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    77ba:	74 17                	je     77d3 <do_timer+0xf8>
		current->utime++;
    77bc:	8b 83 80 12 00 00    	mov    0x1280(%ebx),%eax
    77c2:	8b 90 e0 02 00 00    	mov    0x2e0(%eax),%edx
    77c8:	83 c2 01             	add    $0x1,%edx
    77cb:	89 90 e0 02 00 00    	mov    %edx,0x2e0(%eax)
    77d1:	eb 15                	jmp    77e8 <do_timer+0x10d>
	else
		current->stime++;
    77d3:	8b 83 80 12 00 00    	mov    0x1280(%ebx),%eax
    77d9:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    77df:	83 c2 01             	add    $0x1,%edx
    77e2:	89 90 e4 02 00 00    	mov    %edx,0x2e4(%eax)

	// 如果有定时器存在,则将链表第1个定时器的值减1.如果已等于0,则调用相应的处理程序,并将该处理程序指针置空.然后去掉该项定时器.next_timer是
	// 定时器链表的头指针.
	if (next_timer) {
    77e8:	8b 83 c0 1e 00 00    	mov    0x1ec0(%ebx),%eax
    77ee:	85 c0                	test   %eax,%eax
    77f0:	74 54                	je     7846 <do_timer+0x16b>
		next_timer->jiffies--;
    77f2:	8b 83 c0 1e 00 00    	mov    0x1ec0(%ebx),%eax
    77f8:	8b 10                	mov    (%eax),%edx
    77fa:	83 ea 01             	sub    $0x1,%edx
    77fd:	89 10                	mov    %edx,(%eax)
		while (next_timer && next_timer->jiffies <= 0) {
    77ff:	eb 2f                	jmp    7830 <do_timer+0x155>
			void (*fn)(void);						// 这里插入了一个函数指针定义!!

			fn = next_timer->fn;
    7801:	8b 83 c0 1e 00 00    	mov    0x1ec0(%ebx),%eax
    7807:	8b 40 04             	mov    0x4(%eax),%eax
    780a:	89 44 24 0c          	mov    %eax,0xc(%esp)
			next_timer->fn = NULL;
    780e:	8b 83 c0 1e 00 00    	mov    0x1ec0(%ebx),%eax
    7814:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			next_timer = next_timer->next;
    781b:	8b 83 c0 1e 00 00    	mov    0x1ec0(%ebx),%eax
    7821:	8b 40 08             	mov    0x8(%eax),%eax
    7824:	89 83 c0 1e 00 00    	mov    %eax,0x1ec0(%ebx)
			(fn)();									// 调用定时处理函数.
    782a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    782e:	ff d0                	call   *%eax
		while (next_timer && next_timer->jiffies <= 0) {
    7830:	8b 83 c0 1e 00 00    	mov    0x1ec0(%ebx),%eax
    7836:	85 c0                	test   %eax,%eax
    7838:	74 0c                	je     7846 <do_timer+0x16b>
    783a:	8b 83 c0 1e 00 00    	mov    0x1ec0(%ebx),%eax
    7840:	8b 00                	mov    (%eax),%eax
    7842:	85 c0                	test   %eax,%eax
    7844:	7e bb                	jle    7801 <do_timer+0x126>
		}
	}
	// 如果当前软盘控制器FDC的数字输出寄存器中马达启动位有置位的,则执行软盘定时程序.
	if (current_DOR & 0xf0)
    7846:	0f b6 83 64 00 00 00 	movzbl 0x64(%ebx),%eax
    784d:	0f b6 c0             	movzbl %al,%eax
    7850:	25 f0 00 00 00       	and    $0xf0,%eax
    7855:	85 c0                	test   %eax,%eax
    7857:	74 05                	je     785e <do_timer+0x183>
		do_floppy_timer();
    7859:	e8 0a fc ff ff       	call   7468 <do_floppy_timer>
	// 如果进程运行时间还没完,则退出.否则置当前任务运行计数值为0.并且若发生时钟中断时正在内核代码中运行则返回,否则调用执行调试函数.
	if ((--current->counter) > 0) return;
    785e:	8b 83 80 12 00 00    	mov    0x1280(%ebx),%eax
    7864:	8b 50 04             	mov    0x4(%eax),%edx
    7867:	83 ea 01             	sub    $0x1,%edx
    786a:	89 50 04             	mov    %edx,0x4(%eax)
    786d:	8b 40 04             	mov    0x4(%eax),%eax
    7870:	85 c0                	test   %eax,%eax
    7872:	7f 1b                	jg     788f <do_timer+0x1b4>
	current->counter = 0;
    7874:	8b 83 80 12 00 00    	mov    0x1280(%ebx),%eax
    787a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	if (!cpl) return;								// 对于内核态程序,不信赖counter值进行调试.
    7881:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    7886:	74 0a                	je     7892 <do_timer+0x1b7>
	schedule();
    7888:	e8 be f6 ff ff       	call   6f4b <schedule>
    788d:	eb 04                	jmp    7893 <do_timer+0x1b8>
	if ((--current->counter) > 0) return;
    788f:	90                   	nop
    7890:	eb 01                	jmp    7893 <do_timer+0x1b8>
	if (!cpl) return;								// 对于内核态程序,不信赖counter值进行调试.
    7892:	90                   	nop
}
    7893:	83 c4 18             	add    $0x18,%esp
    7896:	5b                   	pop    %ebx
    7897:	c3                   	ret    

00007898 <sys_alarm>:
// 进程数据结构中报警定时值alarm的单位是系统滴答（1滴答为10毫秒），它是系统开机起到设置定时操作时系统滴答值jiffies和转换成滴答
// 单位的定时值之和，即'jiffies + HZ*定时秒值'。而参数给出的是以秒为单位的定时值，因此本函数的主要操作是进行两个单位的转换。
// 其中常数HZ = 100,是内核系统运行频率。定义在inlucde/sched.h上。
// 参数seconds是新的定时时间值，单位是秒。
int sys_alarm(long seconds)
{
    7898:	83 ec 10             	sub    $0x10,%esp
    789b:	e8 97 51 00 00       	call   ca37 <__x86.get_pc_thunk.cx>
    78a0:	81 c1 60 a7 02 00    	add    $0x2a760,%ecx
	int old = current->alarm;
    78a6:	8b 81 80 12 00 00    	mov    0x1280(%ecx),%eax
    78ac:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    78b2:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if (old)
    78b6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    78bb:	74 1e                	je     78db <sys_alarm+0x43>
		old = (old - jiffies) / HZ;
    78bd:	8b 54 24 0c          	mov    0xc(%esp),%edx
    78c1:	8b 81 80 1b 00 00    	mov    0x1b80(%ecx),%eax
    78c7:	29 c2                	sub    %eax,%edx
    78c9:	89 d0                	mov    %edx,%eax
    78cb:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    78d0:	f7 e2                	mul    %edx
    78d2:	89 d0                	mov    %edx,%eax
    78d4:	c1 e8 05             	shr    $0x5,%eax
    78d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	current->alarm = (seconds>0)?(jiffies+HZ*seconds):0;
    78db:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    78e0:	7e 13                	jle    78f5 <sys_alarm+0x5d>
    78e2:	8b 44 24 14          	mov    0x14(%esp),%eax
    78e6:	6b c0 64             	imul   $0x64,%eax,%eax
    78e9:	89 c2                	mov    %eax,%edx
    78eb:	8b 81 80 1b 00 00    	mov    0x1b80(%ecx),%eax
    78f1:	01 c2                	add    %eax,%edx
    78f3:	eb 05                	jmp    78fa <sys_alarm+0x62>
    78f5:	ba 00 00 00 00       	mov    $0x0,%edx
    78fa:	8b 81 80 12 00 00    	mov    0x1280(%ecx),%eax
    7900:	89 90 dc 02 00 00    	mov    %edx,0x2dc(%eax)
	return (old);
    7906:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    790a:	83 c4 10             	add    $0x10,%esp
    790d:	c3                   	ret    

0000790e <sys_getpid>:

// 取当前进程号pid。
int sys_getpid(void)
{
    790e:	e8 df f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    7913:	05 ed a6 02 00       	add    $0x2a6ed,%eax
	return current->pid;
    7918:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    791e:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
}
    7924:	c3                   	ret    

00007925 <sys_getppid>:

// 取父进程号ppid。
int sys_getppid(void)
{
    7925:	e8 c8 f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    792a:	05 d6 a6 02 00       	add    $0x2a6d6,%eax
	return current->p_pptr->pid;
    792f:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    7935:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    793b:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
}
    7941:	c3                   	ret    

00007942 <sys_getuid>:

// 取用户uid。
int sys_getuid(void)
{
    7942:	e8 ab f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    7947:	05 b9 a6 02 00       	add    $0x2a6b9,%eax
	return current->uid;
    794c:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    7952:	0f b7 80 cc 02 00 00 	movzwl 0x2cc(%eax),%eax
    7959:	0f b7 c0             	movzwl %ax,%eax
}
    795c:	c3                   	ret    

0000795d <sys_geteuid>:

// 取有效的用户号euid。
int sys_geteuid(void)
{
    795d:	e8 90 f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    7962:	05 9e a6 02 00       	add    $0x2a69e,%eax
	return current->euid;
    7967:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    796d:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    7974:	0f b7 c0             	movzwl %ax,%eax
}
    7977:	c3                   	ret    

00007978 <sys_getgid>:

// 取组号gid。
int sys_getgid(void)
{
    7978:	e8 75 f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    797d:	05 83 a6 02 00       	add    $0x2a683,%eax
	return current->gid;
    7982:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    7988:	0f b7 80 d2 02 00 00 	movzwl 0x2d2(%eax),%eax
    798f:	0f b7 c0             	movzwl %ax,%eax
}
    7992:	c3                   	ret    

00007993 <sys_getegid>:

// 取有效的组号egid。
int sys_getegid(void)
{
    7993:	e8 5a f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    7998:	05 68 a6 02 00       	add    $0x2a668,%eax
	return current->egid;
    799d:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    79a3:	0f b7 80 d4 02 00 00 	movzwl 0x2d4(%eax),%eax
    79aa:	0f b7 c0             	movzwl %ax,%eax
}
    79ad:	c3                   	ret    

000079ae <sys_nice>:

// 系统调用功能 -- 降低对CPU的使用优先权（有人会用吗？）。
// 应该限制increment为大于0的值，否则可使优先仅增大！！
int sys_nice(long increment)
{
    79ae:	e8 3f f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    79b3:	05 4d a6 02 00       	add    $0x2a64d,%eax
	if (current->priority-increment > 0)
    79b8:	8b 90 80 12 00 00    	mov    0x1280(%eax),%edx
    79be:	8b 52 08             	mov    0x8(%edx),%edx
    79c1:	2b 54 24 04          	sub    0x4(%esp),%edx
    79c5:	85 d2                	test   %edx,%edx
    79c7:	7e 16                	jle    79df <sys_nice+0x31>
		current->priority -= increment;
    79c9:	8b 90 80 12 00 00    	mov    0x1280(%eax),%edx
    79cf:	8b 52 08             	mov    0x8(%edx),%edx
    79d2:	8b 80 80 12 00 00    	mov    0x1280(%eax),%eax
    79d8:	2b 54 24 04          	sub    0x4(%esp),%edx
    79dc:	89 50 08             	mov    %edx,0x8(%eax)
	return 0;
    79df:	b8 00 00 00 00       	mov    $0x0,%eax
}
    79e4:	c3                   	ret    

000079e5 <sched_init>:

// 内核调度程序的初始化子程序
void sched_init(void)
{
    79e5:	55                   	push   %ebp
    79e6:	57                   	push   %edi
    79e7:	56                   	push   %esi
    79e8:	53                   	push   %ebx
    79e9:	83 ec 18             	sub    $0x18,%esp
    79ec:	e8 01 f3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    79f1:	05 0f a6 02 00       	add    $0x2a60f,%eax
    79f6:	89 04 24             	mov    %eax,(%esp)
		panic("Struct sigaction MUST be 16 bytes");
	// 在全局描述符表中设置初始任务(任务0)的任务状态段描述符和局部数据表描述符.
	// FIRST_TSS_ENTRY和FIRST_LDT_ENTRY的值分别是4和5,定义在include/linux/sched.h中.gdt是一个描述符表数组(include/linux/head.h),
	// 实际上对应程序head.s中的他已描述符表基址(gdt).因此gdt+FIRST_TSS_ENTRY即为gdt[FIRST_TSS_ENTRY](即是gdt[4]),即gdt数组第4项的地址
	// 参见include/asm/system.h
	set_tss_desc(gdt + FIRST_TSS_ENTRY, &(init_task.task.tss));
    79f9:	8b 04 24             	mov    (%esp),%eax
    79fc:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a02:	8d 40 20             	lea    0x20(%eax),%eax
    7a05:	89 c5                	mov    %eax,%ebp
    7a07:	8b 04 24             	mov    (%esp),%eax
    7a0a:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a10:	8d 40 22             	lea    0x22(%eax),%eax
    7a13:	89 c6                	mov    %eax,%esi
    7a15:	8b 04 24             	mov    (%esp),%eax
    7a18:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a1e:	8d 40 24             	lea    0x24(%eax),%eax
    7a21:	89 c7                	mov    %eax,%edi
    7a23:	8b 04 24             	mov    (%esp),%eax
    7a26:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a2c:	8d 40 25             	lea    0x25(%eax),%eax
    7a2f:	89 44 24 04          	mov    %eax,0x4(%esp)
    7a33:	8b 04 24             	mov    (%esp),%eax
    7a36:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a3c:	8d 40 26             	lea    0x26(%eax),%eax
    7a3f:	89 c3                	mov    %eax,%ebx
    7a41:	8b 04 24             	mov    (%esp),%eax
    7a44:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a4a:	8d 40 27             	lea    0x27(%eax),%eax
    7a4d:	8b 0c 24             	mov    (%esp),%ecx
    7a50:	8d 91 10 06 00 00    	lea    0x610(%ecx),%edx
    7a56:	89 d1                	mov    %edx,%ecx
    7a58:	89 c2                	mov    %eax,%edx
    7a5a:	89 c8                	mov    %ecx,%eax
    7a5c:	89 d9                	mov    %ebx,%ecx
    7a5e:	89 f3                	mov    %esi,%ebx
    7a60:	89 fe                	mov    %edi,%esi
    7a62:	89 ef                	mov    %ebp,%edi
    7a64:	8b 6c 24 04          	mov    0x4(%esp),%ebp
    7a68:	66 c7 07 68 00       	movw   $0x68,(%edi)
    7a6d:	66 89 03             	mov    %ax,(%ebx)
    7a70:	c1 c8 10             	ror    $0x10,%eax
    7a73:	88 06                	mov    %al,(%esi)
    7a75:	c6 45 00 89          	movb   $0x89,0x0(%ebp)
    7a79:	c6 01 00             	movb   $0x0,(%ecx)
    7a7c:	88 22                	mov    %ah,(%edx)
    7a7e:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt + FIRST_LDT_ENTRY, &(init_task.task.ldt));
    7a81:	8b 04 24             	mov    (%esp),%eax
    7a84:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a8a:	8d 40 28             	lea    0x28(%eax),%eax
    7a8d:	89 c5                	mov    %eax,%ebp
    7a8f:	8b 04 24             	mov    (%esp),%eax
    7a92:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7a98:	8d 40 2a             	lea    0x2a(%eax),%eax
    7a9b:	89 c6                	mov    %eax,%esi
    7a9d:	8b 04 24             	mov    (%esp),%eax
    7aa0:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7aa6:	8d 40 2c             	lea    0x2c(%eax),%eax
    7aa9:	89 c7                	mov    %eax,%edi
    7aab:	8b 04 24             	mov    (%esp),%eax
    7aae:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7ab4:	8d 40 2d             	lea    0x2d(%eax),%eax
    7ab7:	89 44 24 04          	mov    %eax,0x4(%esp)
    7abb:	8b 04 24             	mov    (%esp),%eax
    7abe:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7ac4:	8d 40 2e             	lea    0x2e(%eax),%eax
    7ac7:	89 c3                	mov    %eax,%ebx
    7ac9:	8b 04 24             	mov    (%esp),%eax
    7acc:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7ad2:	8d 40 2f             	lea    0x2f(%eax),%eax
    7ad5:	8b 0c 24             	mov    (%esp),%ecx
    7ad8:	8d 91 f8 05 00 00    	lea    0x5f8(%ecx),%edx
    7ade:	89 d1                	mov    %edx,%ecx
    7ae0:	89 c2                	mov    %eax,%edx
    7ae2:	89 c8                	mov    %ecx,%eax
    7ae4:	89 d9                	mov    %ebx,%ecx
    7ae6:	89 f3                	mov    %esi,%ebx
    7ae8:	89 fe                	mov    %edi,%esi
    7aea:	89 ef                	mov    %ebp,%edi
    7aec:	8b 6c 24 04          	mov    0x4(%esp),%ebp
    7af0:	66 c7 07 68 00       	movw   $0x68,(%edi)
    7af5:	66 89 03             	mov    %ax,(%ebx)
    7af8:	c1 c8 10             	ror    $0x10,%eax
    7afb:	88 06                	mov    %al,(%esi)
    7afd:	c6 45 00 82          	movb   $0x82,0x0(%ebp)
    7b01:	c6 01 00             	movb   $0x0,(%ecx)
    7b04:	88 22                	mov    %ah,(%edx)
    7b06:	c1 c8 10             	ror    $0x10,%eax
	// 清任务数组和描述符表项(注意i=1开始,所以初始任务的描述符还在).描述符项结构定义在文件include/linux/head.h中.
	p = gdt + 2 + FIRST_TSS_ENTRY;
    7b09:	8b 04 24             	mov    (%esp),%eax
    7b0c:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    7b12:	8d 40 30             	lea    0x30(%eax),%eax
    7b15:	89 44 24 10          	mov    %eax,0x10(%esp)
	// 初始化除进程一以外的其他进程指针
	for(i = 1; i < NR_TASKS; i++) {
    7b19:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
    7b20:	00 
    7b21:	eb 51                	jmp    7b74 <sched_init+0x18f>
		task[i] = NULL;
    7b23:	8b 44 24 14          	mov    0x14(%esp),%eax
    7b27:	8b 0c 24             	mov    (%esp),%ecx
    7b2a:	c7 84 81 a0 12 00 00 	movl   $0x0,0x12a0(%ecx,%eax,4)
    7b31:	00 00 00 00 
		p->a = p->b = 0;
    7b35:	8b 44 24 10          	mov    0x10(%esp),%eax
    7b39:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    7b40:	8b 44 24 10          	mov    0x10(%esp),%eax
    7b44:	8b 50 04             	mov    0x4(%eax),%edx
    7b47:	8b 44 24 10          	mov    0x10(%esp),%eax
    7b4b:	89 10                	mov    %edx,(%eax)
		p++;
    7b4d:	83 44 24 10 08       	addl   $0x8,0x10(%esp)
		p->a = p->b = 0;
    7b52:	8b 44 24 10          	mov    0x10(%esp),%eax
    7b56:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    7b5d:	8b 44 24 10          	mov    0x10(%esp),%eax
    7b61:	8b 50 04             	mov    0x4(%eax),%edx
    7b64:	8b 44 24 10          	mov    0x10(%esp),%eax
    7b68:	89 10                	mov    %edx,(%eax)
		p++;
    7b6a:	83 44 24 10 08       	addl   $0x8,0x10(%esp)
	for(i = 1; i < NR_TASKS; i++) {
    7b6f:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
    7b74:	83 7c 24 14 3f       	cmpl   $0x3f,0x14(%esp)
    7b79:	7e a8                	jle    7b23 <sched_init+0x13e>
	}
	/* Clear NT, so that we won't have troubles with that later on */
	/* 清除标志寄存器中的位NT,这样以后就不会有麻烦 */
	// EFLAGS中的NT标志位用于控制任务的嵌套调用.当NT位置位时,那么当前中断任务执行IRET指令时就会引起任务切换.NT指出TSS中的back_link字段是否有效.
	// NT=0时无效.
	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
    7b7b:	9c                   	pushf  
    7b7c:	81 24 24 ff bf ff ff 	andl   $0xffffbfff,(%esp)
    7b83:	9d                   	popf   
	// 将任务0的TSS段选择符加载到任务寄存器tr.将局部描述符表段选择符加载到局部描述符表寄存器ldtr中.注意!!是将GDT中相应LDT描述符的选择符加载到ldtr.
	// 只明确加这一次,以后新任务LDT的加载,是CPU根据TSS中的LDT项自动加载.
	ltr(0);								// 定义在include/linux/sched.h
    7b84:	b8 20 00 00 00       	mov    $0x20,%eax
    7b89:	0f 00 d8             	ltr    %ax
	lldt(0);							// 其中参数(0)是任务号.
    7b8c:	b8 28 00 00 00       	mov    $0x28,%eax
    7b91:	0f 00 d0             	lldt   %ax
	// 下面代码用于初始化8253定时器.通道0,选择工作方式3,二进制计数方式.通道0的输出引脚接在中断控制主芯片的IRQ0上,它每10毫秒发出一个IRQ0请求.
	// LATCH是初始定时计数值.
	outb_p(0x36, 0x43);					/* binary, mode 3, LSB/MSB, ch 0 */
    7b94:	b8 36 00 00 00       	mov    $0x36,%eax
    7b99:	ba 43 00 00 00       	mov    $0x43,%edx
    7b9e:	ee                   	out    %al,(%dx)
    7b9f:	eb 00                	jmp    7ba1 <sched_init+0x1bc>
    7ba1:	eb 00                	jmp    7ba3 <sched_init+0x1be>
	outb_p(LATCH & 0xff, 0x40);			/* LSB */	// 定时值低字节
    7ba3:	b8 9b 00 00 00       	mov    $0x9b,%eax
    7ba8:	ba 40 00 00 00       	mov    $0x40,%edx
    7bad:	ee                   	out    %al,(%dx)
    7bae:	eb 00                	jmp    7bb0 <sched_init+0x1cb>
    7bb0:	eb 00                	jmp    7bb2 <sched_init+0x1cd>
	outb(LATCH >> 8, 0x40);				/* MSB */	// 定时值高字节
    7bb2:	b8 2e 00 00 00       	mov    $0x2e,%eax
    7bb7:	ba 40 00 00 00       	mov    $0x40,%edx
    7bbc:	ee                   	out    %al,(%dx)
	// 设置时钟中断处理程序句柄(设置时钟中断门).修改中断控制器屏蔽码,允许时钟中断.
	// 然后设置系统调用中断门.这两个设置中断描述衔表IDT中描述符的宏定义在文件include/asm/system.h中.两者的区别参见system.h文件开始处的说明.
	set_intr_gate(0x20, &timer_interrupt);
    7bbd:	8b 04 24             	mov    (%esp),%eax
    7bc0:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    7bc6:	8d 98 00 01 00 00    	lea    0x100(%eax),%ebx
    7bcc:	8b 04 24             	mov    (%esp),%eax
    7bcf:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    7bd5:	8d b0 04 01 00 00    	lea    0x104(%eax),%esi
    7bdb:	8b 04 24             	mov    (%esp),%eax
    7bde:	c7 c0 64 7d 00 00    	mov    $0x7d64,%eax
    7be4:	89 c2                	mov    %eax,%edx
    7be6:	b8 00 00 08 00       	mov    $0x80000,%eax
    7beb:	66 89 d0             	mov    %dx,%ax
    7bee:	66 ba 00 8e          	mov    $0x8e00,%dx
    7bf2:	89 03                	mov    %eax,(%ebx)
    7bf4:	89 16                	mov    %edx,(%esi)
	outb(inb_p(0x21) & ~0x01, 0x21);
    7bf6:	b8 21 00 00 00       	mov    $0x21,%eax
    7bfb:	89 c2                	mov    %eax,%edx
    7bfd:	ec                   	in     (%dx),%al
    7bfe:	eb 00                	jmp    7c00 <sched_init+0x21b>
    7c00:	eb 00                	jmp    7c02 <sched_init+0x21d>
    7c02:	88 44 24 0f          	mov    %al,0xf(%esp)
    7c06:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
    7c0b:	0f b6 c0             	movzbl %al,%eax
    7c0e:	83 e0 fe             	and    $0xfffffffe,%eax
    7c11:	ba 21 00 00 00       	mov    $0x21,%edx
    7c16:	ee                   	out    %al,(%dx)
	set_system_gate(0x80, &system_call);
    7c17:	8b 04 24             	mov    (%esp),%eax
    7c1a:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    7c20:	8d 98 00 04 00 00    	lea    0x400(%eax),%ebx
    7c26:	8b 04 24             	mov    (%esp),%eax
    7c29:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    7c2f:	8d b0 04 04 00 00    	lea    0x404(%eax),%esi
    7c35:	8b 04 24             	mov    (%esp),%eax
    7c38:	c7 c0 6c 7c 00 00    	mov    $0x7c6c,%eax
    7c3e:	89 c2                	mov    %eax,%edx
    7c40:	b8 00 00 08 00       	mov    $0x80000,%eax
    7c45:	66 89 d0             	mov    %dx,%ax
    7c48:	66 ba 00 ef          	mov    $0xef00,%dx
    7c4c:	89 03                	mov    %eax,(%ebx)
    7c4e:	89 16                	mov    %edx,(%esi)
}
    7c50:	90                   	nop
    7c51:	83 c4 18             	add    $0x18,%esp
    7c54:	5b                   	pop    %ebx
    7c55:	5e                   	pop    %esi
    7c56:	5f                   	pop    %edi
    7c57:	5d                   	pop    %ebp
    7c58:	c3                   	ret    
    7c59:	66 90                	xchg   %ax,%ax
    7c5b:	90                   	nop

00007c5c <bad_sys_call>:
    7c5c:	6a da                	push   $0xffffffda
    7c5e:	eb 50                	jmp    7cb0 <ret_from_sys_call>

00007c60 <reschedule>:
    7c60:	68 b0 7c 00 00       	push   $0x7cb0
    7c65:	e9 e1 f2 ff ff       	jmp    6f4b <schedule>
    7c6a:	66 90                	xchg   %ax,%ax

00007c6c <system_call>:
    7c6c:	1e                   	push   %ds
    7c6d:	06                   	push   %es
    7c6e:	0f a0                	push   %fs
    7c70:	50                   	push   %eax
    7c71:	52                   	push   %edx
    7c72:	51                   	push   %ecx
    7c73:	53                   	push   %ebx
    7c74:	ba 10 00 00 00       	mov    $0x10,%edx
    7c79:	8e da                	mov    %edx,%ds
    7c7b:	8e c2                	mov    %edx,%es
    7c7d:	ba 17 00 00 00       	mov    $0x17,%edx
    7c82:	8e e2                	mov    %edx,%fs
    7c84:	3b 05 60 20 03 00    	cmp    0x32060,%eax
    7c8a:	73 d0                	jae    7c5c <bad_sys_call>
    7c8c:	8b 1c 85 00 21 03 00 	mov    0x32100(,%eax,4),%ebx
    7c93:	83 fb 00             	cmp    $0x0,%ebx
    7c96:	75 05                	jne    7c9d <sys_call>
    7c98:	e8 ec 30 00 00       	call   ad89 <sys_default>

00007c9d <sys_call>:
    7c9d:	ff d3                	call   *%ebx
    7c9f:	50                   	push   %eax
    7ca0:	a1 80 32 03 00       	mov    0x33280,%eax
    7ca5:	83 38 00             	cmpl   $0x0,(%eax)
    7ca8:	75 b6                	jne    7c60 <reschedule>
    7caa:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    7cae:	74 b0                	je     7c60 <reschedule>

00007cb0 <ret_from_sys_call>:
    7cb0:	a1 80 32 03 00       	mov    0x33280,%eax
    7cb5:	3b 05 a0 32 03 00    	cmp    0x332a0,%eax
    7cbb:	74 34                	je     7cf1 <ret_from_sys_call+0x41>
    7cbd:	66 83 7c 24 24 0f    	cmpw   $0xf,0x24(%esp)
    7cc3:	75 2c                	jne    7cf1 <ret_from_sys_call+0x41>
    7cc5:	66 83 7c 24 30 17    	cmpw   $0x17,0x30(%esp)
    7ccb:	75 24                	jne    7cf1 <ret_from_sys_call+0x41>
    7ccd:	8b 58 0c             	mov    0xc(%eax),%ebx
    7cd0:	8b 88 10 02 00 00    	mov    0x210(%eax),%ecx
    7cd6:	f7 d1                	not    %ecx
    7cd8:	21 d9                	and    %ebx,%ecx
    7cda:	0f bc c9             	bsf    %ecx,%ecx
    7cdd:	74 12                	je     7cf1 <ret_from_sys_call+0x41>
    7cdf:	0f b3 cb             	btr    %ecx,%ebx
    7ce2:	89 58 0c             	mov    %ebx,0xc(%eax)
    7ce5:	41                   	inc    %ecx
    7ce6:	51                   	push   %ecx
    7ce7:	e8 50 49 00 00       	call   c63c <do_signal>
    7cec:	59                   	pop    %ecx
    7ced:	85 c0                	test   %eax,%eax
    7cef:	75 af                	jne    7ca0 <sys_call+0x3>
    7cf1:	58                   	pop    %eax
    7cf2:	5b                   	pop    %ebx
    7cf3:	59                   	pop    %ecx
    7cf4:	5a                   	pop    %edx
    7cf5:	83 c4 04             	add    $0x4,%esp
    7cf8:	0f a1                	pop    %fs
    7cfa:	07                   	pop    %es
    7cfb:	1f                   	pop    %ds
    7cfc:	cf                   	iret   
    7cfd:	8d 76 00             	lea    0x0(%esi),%esi

00007d00 <coprocessor_error>:
    7d00:	1e                   	push   %ds
    7d01:	06                   	push   %es
    7d02:	0f a0                	push   %fs
    7d04:	6a ff                	push   $0xffffffff
    7d06:	52                   	push   %edx
    7d07:	51                   	push   %ecx
    7d08:	53                   	push   %ebx
    7d09:	50                   	push   %eax
    7d0a:	b8 10 00 00 00       	mov    $0x10,%eax
    7d0f:	8e d8                	mov    %eax,%ds
    7d11:	8e c0                	mov    %eax,%es
    7d13:	b8 17 00 00 00       	mov    $0x17,%eax
    7d18:	8e e0                	mov    %eax,%fs
    7d1a:	68 b0 7c 00 00       	push   $0x7cb0
    7d1f:	e9 9c bd 01 00       	jmp    23ac0 <math_error>

00007d24 <device_not_available>:
    7d24:	1e                   	push   %ds
    7d25:	06                   	push   %es
    7d26:	0f a0                	push   %fs
    7d28:	6a ff                	push   $0xffffffff
    7d2a:	52                   	push   %edx
    7d2b:	51                   	push   %ecx
    7d2c:	53                   	push   %ebx
    7d2d:	50                   	push   %eax
    7d2e:	b8 10 00 00 00       	mov    $0x10,%eax
    7d33:	8e d8                	mov    %eax,%ds
    7d35:	8e c0                	mov    %eax,%es
    7d37:	b8 17 00 00 00       	mov    $0x17,%eax
    7d3c:	8e e0                	mov    %eax,%fs
    7d3e:	68 b0 7c 00 00       	push   $0x7cb0
    7d43:	0f 06                	clts   
    7d45:	0f 20 c0             	mov    %cr0,%eax
    7d48:	a9 04 00 00 00       	test   $0x4,%eax
    7d4d:	0f 84 88 f1 ff ff    	je     6edb <math_state_restore>
    7d53:	55                   	push   %ebp
    7d54:	56                   	push   %esi
    7d55:	57                   	push   %edi
    7d56:	6a 00                	push   $0x0
    7d58:	e8 f3 ba 01 00       	call   23850 <math_emulate>
    7d5d:	83 c4 04             	add    $0x4,%esp
    7d60:	5f                   	pop    %edi
    7d61:	5e                   	pop    %esi
    7d62:	5d                   	pop    %ebp
    7d63:	c3                   	ret    

00007d64 <timer_interrupt>:
    7d64:	1e                   	push   %ds
    7d65:	06                   	push   %es
    7d66:	0f a0                	push   %fs
    7d68:	6a ff                	push   $0xffffffff
    7d6a:	52                   	push   %edx
    7d6b:	51                   	push   %ecx
    7d6c:	53                   	push   %ebx
    7d6d:	50                   	push   %eax
    7d6e:	b8 10 00 00 00       	mov    $0x10,%eax
    7d73:	8e d8                	mov    %eax,%ds
    7d75:	8e c0                	mov    %eax,%es
    7d77:	b8 17 00 00 00       	mov    $0x17,%eax
    7d7c:	8e e0                	mov    %eax,%fs
    7d7e:	ff 05 80 3b 03 00    	incl   0x33b80
    7d84:	b0 20                	mov    $0x20,%al
    7d86:	e6 20                	out    %al,$0x20
    7d88:	8b 44 24 24          	mov    0x24(%esp),%eax
    7d8c:	83 e0 03             	and    $0x3,%eax
    7d8f:	50                   	push   %eax
    7d90:	e8 46 f9 ff ff       	call   76db <do_timer>
    7d95:	83 c4 04             	add    $0x4,%esp
    7d98:	e9 13 ff ff ff       	jmp    7cb0 <ret_from_sys_call>
    7d9d:	8d 76 00             	lea    0x0(%esi),%esi

00007da0 <sys_execve>:
    7da0:	8d 44 24 20          	lea    0x20(%esp),%eax
    7da4:	50                   	push   %eax
    7da5:	e8 e1 b0 00 00       	call   12e8b <do_execve>
    7daa:	83 c4 04             	add    $0x4,%esp
    7dad:	c3                   	ret    
    7dae:	66 90                	xchg   %ax,%ax

00007db0 <sys_fork>:
    7db0:	e8 5f 14 00 00       	call   9214 <find_empty_process>
    7db5:	85 c0                	test   %eax,%eax
    7db7:	78 0e                	js     7dc7 <sys_fork+0x17>
    7db9:	0f a8                	push   %gs
    7dbb:	56                   	push   %esi
    7dbc:	57                   	push   %edi
    7dbd:	55                   	push   %ebp
    7dbe:	50                   	push   %eax
    7dbf:	e8 bc 0d 00 00       	call   8b80 <copy_process>
    7dc4:	83 c4 14             	add    $0x14,%esp
    7dc7:	c3                   	ret    

00007dc8 <hd_interrupt>:
    7dc8:	50                   	push   %eax
    7dc9:	51                   	push   %ecx
    7dca:	52                   	push   %edx
    7dcb:	1e                   	push   %ds
    7dcc:	06                   	push   %es
    7dcd:	0f a0                	push   %fs
    7dcf:	b8 10 00 00 00       	mov    $0x10,%eax
    7dd4:	8e d8                	mov    %eax,%ds
    7dd6:	8e c0                	mov    %eax,%es
    7dd8:	b8 17 00 00 00       	mov    $0x17,%eax
    7ddd:	8e e0                	mov    %eax,%fs
    7ddf:	b0 20                	mov    $0x20,%al
    7de1:	e6 a0                	out    %al,$0xa0
    7de3:	eb 00                	jmp    7de5 <hd_interrupt+0x1d>
    7de5:	eb 00                	jmp    7de7 <hd_interrupt+0x1f>
    7de7:	31 d2                	xor    %edx,%edx
    7de9:	89 15 04 62 03 00    	mov    %edx,0x36204
    7def:	87 15 00 62 03 00    	xchg   %edx,0x36200
    7df5:	85 d2                	test   %edx,%edx
    7df7:	75 05                	jne    7dfe <hd_interrupt+0x36>
    7df9:	ba 4c 9e 01 00       	mov    $0x19e4c,%edx
    7dfe:	e6 20                	out    %al,$0x20
    7e00:	ff d2                	call   *%edx
    7e02:	0f a1                	pop    %fs
    7e04:	07                   	pop    %es
    7e05:	1f                   	pop    %ds
    7e06:	5a                   	pop    %edx
    7e07:	59                   	pop    %ecx
    7e08:	58                   	pop    %eax
    7e09:	cf                   	iret   

00007e0a <floppy_interrupt>:
    7e0a:	50                   	push   %eax
    7e0b:	51                   	push   %ecx
    7e0c:	52                   	push   %edx
    7e0d:	1e                   	push   %ds
    7e0e:	06                   	push   %es
    7e0f:	0f a0                	push   %fs
    7e11:	b8 10 00 00 00       	mov    $0x10,%eax
    7e16:	8e d8                	mov    %eax,%ds
    7e18:	8e c0                	mov    %eax,%es
    7e1a:	b8 17 00 00 00       	mov    $0x17,%eax
    7e1f:	8e e0                	mov    %eax,%fs
    7e21:	b0 20                	mov    $0x20,%al
    7e23:	e6 20                	out    %al,$0x20
    7e25:	31 c0                	xor    %eax,%eax
    7e27:	87 05 d4 61 03 00    	xchg   %eax,0x361d4
    7e2d:	85 c0                	test   %eax,%eax
    7e2f:	75 05                	jne    7e36 <floppy_interrupt+0x2c>
    7e31:	b8 b3 8e 01 00       	mov    $0x18eb3,%eax
    7e36:	ff d0                	call   *%eax
    7e38:	0f a1                	pop    %fs
    7e3a:	07                   	pop    %es
    7e3b:	1f                   	pop    %ds
    7e3c:	5a                   	pop    %edx
    7e3d:	59                   	pop    %ecx
    7e3e:	58                   	pop    %eax
    7e3f:	cf                   	iret   

00007e40 <parallel_interrupt>:
    7e40:	50                   	push   %eax
    7e41:	b0 20                	mov    $0x20,%al
    7e43:	e6 20                	out    %al,$0x20
    7e45:	58                   	pop    %eax
    7e46:	cf                   	iret   

00007e47 <die>:
void alignment_check(void);					// int46(kernel/asm.s)

// 该子程序用来打印出错中断的名称,出错号,调用程序的EIP,EFLAGS,ESP,fs段寄存器值,段的基址,段的长度,进程号pid,任务号,10字节指令码.如果
// 堆栈在用户数据段,则还打印16字节堆栈内容.这些信息可用于程序调试.
static void die(char * str, long esp_ptr, long nr)
{
    7e47:	57                   	push   %edi
    7e48:	56                   	push   %esi
    7e49:	53                   	push   %ebx
    7e4a:	83 ec 10             	sub    $0x10,%esp
    7e4d:	e8 a8 ee ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    7e52:	81 c3 ae a1 02 00    	add    $0x2a1ae,%ebx
	long * esp = (long *) esp_ptr;
    7e58:	8b 44 24 24          	mov    0x24(%esp),%eax
    7e5c:	89 44 24 08          	mov    %eax,0x8(%esp)
	int i;

	printk("%s: %04x\n\r",str, nr & 0xffff);
    7e60:	8b 44 24 28          	mov    0x28(%esp),%eax
    7e64:	0f b7 c0             	movzwl %ax,%eax
    7e67:	83 ec 04             	sub    $0x4,%esp
    7e6a:	50                   	push   %eax
    7e6b:	ff 74 24 28          	pushl  0x28(%esp)
    7e6f:	8d 83 58 42 ff ff    	lea    -0xbda8(%ebx),%eax
    7e75:	50                   	push   %eax
    7e76:	e8 b7 14 00 00       	call   9332 <printk>
    7e7b:	83 c4 10             	add    $0x10,%esp
	// 下行打印语句显示当前调用进程的CS:EIP,EFLAGS和SS:ESP的值.
	// (1) EIP:\t%04x:%p\n	-- esp[1]是段选择符(cs),esp[0]是eip
	// (2) EFLAGS:\t%p	-- esp[2]是eflags
	// (2) ESP:\t%04x:%p\n	-- esp[4]是原ss,esp[3]是原esp
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
		esp[1], esp[0], esp[2], esp[4], esp[3]);
    7e7e:	8b 44 24 08          	mov    0x8(%esp),%eax
    7e82:	83 c0 0c             	add    $0xc,%eax
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7e85:	8b 38                	mov    (%eax),%edi
		esp[1], esp[0], esp[2], esp[4], esp[3]);
    7e87:	8b 44 24 08          	mov    0x8(%esp),%eax
    7e8b:	83 c0 10             	add    $0x10,%eax
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7e8e:	8b 30                	mov    (%eax),%esi
		esp[1], esp[0], esp[2], esp[4], esp[3]);
    7e90:	8b 44 24 08          	mov    0x8(%esp),%eax
    7e94:	83 c0 08             	add    $0x8,%eax
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7e97:	8b 08                	mov    (%eax),%ecx
    7e99:	8b 44 24 08          	mov    0x8(%esp),%eax
    7e9d:	8b 10                	mov    (%eax),%edx
		esp[1], esp[0], esp[2], esp[4], esp[3]);
    7e9f:	8b 44 24 08          	mov    0x8(%esp),%eax
    7ea3:	83 c0 04             	add    $0x4,%eax
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7ea6:	8b 00                	mov    (%eax),%eax
    7ea8:	83 ec 08             	sub    $0x8,%esp
    7eab:	57                   	push   %edi
    7eac:	56                   	push   %esi
    7ead:	51                   	push   %ecx
    7eae:	52                   	push   %edx
    7eaf:	50                   	push   %eax
    7eb0:	8d 83 64 42 ff ff    	lea    -0xbd9c(%ebx),%eax
    7eb6:	50                   	push   %eax
    7eb7:	e8 76 14 00 00       	call   9332 <printk>
    7ebc:	83 c4 20             	add    $0x20,%esp
	printk("fs: %04x\n", _fs());
    7ebf:	66 8c e0             	mov    %fs,%ax
    7ec2:	89 c6                	mov    %eax,%esi
    7ec4:	89 f0                	mov    %esi,%eax
    7ec6:	0f b7 c0             	movzwl %ax,%eax
    7ec9:	83 ec 08             	sub    $0x8,%esp
    7ecc:	50                   	push   %eax
    7ecd:	8d 83 8a 42 ff ff    	lea    -0xbd76(%ebx),%eax
    7ed3:	50                   	push   %eax
    7ed4:	e8 59 14 00 00       	call   9332 <printk>
    7ed9:	83 c4 10             	add    $0x10,%esp
	printk("base: %p, limit: %p\n", get_base(current->ldt[1]), get_limit(0x17));
    7edc:	b8 17 00 00 00       	mov    $0x17,%eax
    7ee1:	0f 03 c0             	lsl    %ax,%eax
    7ee4:	40                   	inc    %eax
    7ee5:	89 44 24 04          	mov    %eax,0x4(%esp)
    7ee9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    7eed:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    7ef3:	8b 00                	mov    (%eax),%eax
    7ef5:	05 a0 03 00 00       	add    $0x3a0,%eax
    7efa:	8d 78 02             	lea    0x2(%eax),%edi
    7efd:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    7f03:	8b 00                	mov    (%eax),%eax
    7f05:	05 a0 03 00 00       	add    $0x3a0,%eax
    7f0a:	8d 70 04             	lea    0x4(%eax),%esi
    7f0d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    7f13:	8b 00                	mov    (%eax),%eax
    7f15:	05 a0 03 00 00       	add    $0x3a0,%eax
    7f1a:	83 c0 07             	add    $0x7,%eax
    7f1d:	8a 30                	mov    (%eax),%dh
    7f1f:	8a 16                	mov    (%esi),%dl
    7f21:	c1 e2 10             	shl    $0x10,%edx
    7f24:	66 8b 17             	mov    (%edi),%dx
    7f27:	89 d0                	mov    %edx,%eax
    7f29:	89 04 24             	mov    %eax,(%esp)
    7f2c:	8b 04 24             	mov    (%esp),%eax
    7f2f:	83 ec 04             	sub    $0x4,%esp
    7f32:	51                   	push   %ecx
    7f33:	50                   	push   %eax
    7f34:	8d 83 94 42 ff ff    	lea    -0xbd6c(%ebx),%eax
    7f3a:	50                   	push   %eax
    7f3b:	e8 f2 13 00 00       	call   9332 <printk>
    7f40:	83 c4 10             	add    $0x10,%esp
	if (esp[4] == 0x17) {						// 或原ss值为0x17(用户栈),则还打印出用户栈的4个长字值(16字节).
    7f43:	8b 44 24 08          	mov    0x8(%esp),%eax
    7f47:	83 c0 10             	add    $0x10,%eax
    7f4a:	8b 00                	mov    (%eax),%eax
    7f4c:	83 f8 17             	cmp    $0x17,%eax
    7f4f:	75 77                	jne    7fc8 <die+0x181>
		printk("Stack: ");
    7f51:	83 ec 0c             	sub    $0xc,%esp
    7f54:	8d 83 a9 42 ff ff    	lea    -0xbd57(%ebx),%eax
    7f5a:	50                   	push   %eax
    7f5b:	e8 d2 13 00 00       	call   9332 <printk>
    7f60:	83 c4 10             	add    $0x10,%esp
		for (i = 0; i < 4; i++)
    7f63:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    7f6a:	00 
    7f6b:	eb 42                	jmp    7faf <die+0x168>
			printk("%p ", get_seg_long(0x17, i + (long *)esp[3]));
    7f6d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7f71:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f78:	8b 44 24 08          	mov    0x8(%esp),%eax
    7f7c:	83 c0 0c             	add    $0xc,%eax
    7f7f:	8b 00                	mov    (%eax),%eax
    7f81:	01 d0                	add    %edx,%eax
    7f83:	89 c2                	mov    %eax,%edx
    7f85:	b8 17 00 00 00       	mov    $0x17,%eax
    7f8a:	0f a0                	push   %fs
    7f8c:	8e e0                	mov    %eax,%fs
    7f8e:	64 8b 02             	mov    %fs:(%edx),%eax
    7f91:	0f a1                	pop    %fs
    7f93:	89 c6                	mov    %eax,%esi
    7f95:	89 f0                	mov    %esi,%eax
    7f97:	83 ec 08             	sub    $0x8,%esp
    7f9a:	50                   	push   %eax
    7f9b:	8d 83 b1 42 ff ff    	lea    -0xbd4f(%ebx),%eax
    7fa1:	50                   	push   %eax
    7fa2:	e8 8b 13 00 00       	call   9332 <printk>
    7fa7:	83 c4 10             	add    $0x10,%esp
		for (i = 0; i < 4; i++)
    7faa:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    7faf:	83 7c 24 0c 03       	cmpl   $0x3,0xc(%esp)
    7fb4:	7e b7                	jle    7f6d <die+0x126>
		printk("\n");
    7fb6:	83 ec 0c             	sub    $0xc,%esp
    7fb9:	8d 83 b5 42 ff ff    	lea    -0xbd4b(%ebx),%eax
    7fbf:	50                   	push   %eax
    7fc0:	e8 6d 13 00 00       	call   9332 <printk>
    7fc5:	83 c4 10             	add    $0x10,%esp
	}
	str(i);										// 取当前运行任务的任务号(include/linux/sched.h).
    7fc8:	b8 00 00 00 00       	mov    $0x0,%eax
    7fcd:	66 0f 00 c8          	str    %ax
    7fd1:	83 e8 20             	sub    $0x20,%eax
    7fd4:	c1 e8 04             	shr    $0x4,%eax
    7fd7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	printk("Pid: %d, process nr: %d\n\r", current->pid, 0xffff & i);
    7fdb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7fdf:	0f b7 d0             	movzwl %ax,%edx
    7fe2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    7fe8:	8b 00                	mov    (%eax),%eax
    7fea:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    7ff0:	83 ec 04             	sub    $0x4,%esp
    7ff3:	52                   	push   %edx
    7ff4:	50                   	push   %eax
    7ff5:	8d 83 b7 42 ff ff    	lea    -0xbd49(%ebx),%eax
    7ffb:	50                   	push   %eax
    7ffc:	e8 31 13 00 00       	call   9332 <printk>
    8001:	83 c4 10             	add    $0x10,%esp
                        						// 进程号,任务号.
	for(i = 0; i < 10; i++)
    8004:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    800b:	00 
    800c:	eb 42                	jmp    8050 <die+0x209>
		printk("%02x ", 0xff & get_seg_byte(esp[1], (i+(char *)esp[0])));
    800e:	8b 44 24 08          	mov    0x8(%esp),%eax
    8012:	83 c0 04             	add    $0x4,%eax
    8015:	8b 00                	mov    (%eax),%eax
    8017:	8b 54 24 08          	mov    0x8(%esp),%edx
    801b:	8b 12                	mov    (%edx),%edx
    801d:	89 d1                	mov    %edx,%ecx
    801f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    8023:	01 ca                	add    %ecx,%edx
    8025:	0f a0                	push   %fs
    8027:	8e e0                	mov    %eax,%fs
    8029:	64 8a 02             	mov    %fs:(%edx),%al
    802c:	0f a1                	pop    %fs
    802e:	89 c6                	mov    %eax,%esi
    8030:	89 f0                	mov    %esi,%eax
    8032:	0f be c0             	movsbl %al,%eax
    8035:	0f b6 c0             	movzbl %al,%eax
    8038:	83 ec 08             	sub    $0x8,%esp
    803b:	50                   	push   %eax
    803c:	8d 83 d1 42 ff ff    	lea    -0xbd2f(%ebx),%eax
    8042:	50                   	push   %eax
    8043:	e8 ea 12 00 00       	call   9332 <printk>
    8048:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < 10; i++)
    804b:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    8050:	83 7c 24 0c 09       	cmpl   $0x9,0xc(%esp)
    8055:	7e b7                	jle    800e <die+0x1c7>
	printk("\n\r");
    8057:	83 ec 0c             	sub    $0xc,%esp
    805a:	8d 83 d7 42 ff ff    	lea    -0xbd29(%ebx),%eax
    8060:	50                   	push   %eax
    8061:	e8 cc 12 00 00       	call   9332 <printk>
    8066:	83 c4 10             	add    $0x10,%esp
	do_exit(11);								/* play segment exception */
    8069:	83 ec 0c             	sub    $0xc,%esp
    806c:	6a 0b                	push   $0xb
    806e:	e8 f1 38 00 00       	call   b964 <do_exit>
    8073:	83 c4 10             	add    $0x10,%esp
}
    8076:	90                   	nop
    8077:	83 c4 10             	add    $0x10,%esp
    807a:	5b                   	pop    %ebx
    807b:	5e                   	pop    %esi
    807c:	5f                   	pop    %edi
    807d:	c3                   	ret    

0000807e <do_double_fault>:

// 以下这些以do_开头的函数是asm.s中对应中断处理程序调用的C函数.
void do_double_fault(long esp, long error_code)
{
    807e:	83 ec 0c             	sub    $0xc,%esp
    8081:	e8 6c ec ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    8086:	05 7a 9f 02 00       	add    $0x29f7a,%eax
	die("double fault", esp, error_code);
    808b:	83 ec 04             	sub    $0x4,%esp
    808e:	ff 74 24 18          	pushl  0x18(%esp)
    8092:	ff 74 24 18          	pushl  0x18(%esp)
    8096:	8d 80 da 42 ff ff    	lea    -0xbd26(%eax),%eax
    809c:	50                   	push   %eax
    809d:	e8 a5 fd ff ff       	call   7e47 <die>
    80a2:	83 c4 10             	add    $0x10,%esp
}
    80a5:	90                   	nop
    80a6:	83 c4 0c             	add    $0xc,%esp
    80a9:	c3                   	ret    

000080aa <do_general_protection>:

void do_general_protection(long esp, long error_code)
{
    80aa:	83 ec 0c             	sub    $0xc,%esp
    80ad:	e8 40 ec ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    80b2:	05 4e 9f 02 00       	add    $0x29f4e,%eax
	die("general protection", esp, error_code);
    80b7:	83 ec 04             	sub    $0x4,%esp
    80ba:	ff 74 24 18          	pushl  0x18(%esp)
    80be:	ff 74 24 18          	pushl  0x18(%esp)
    80c2:	8d 80 e7 42 ff ff    	lea    -0xbd19(%eax),%eax
    80c8:	50                   	push   %eax
    80c9:	e8 79 fd ff ff       	call   7e47 <die>
    80ce:	83 c4 10             	add    $0x10,%esp
}
    80d1:	90                   	nop
    80d2:	83 c4 0c             	add    $0xc,%esp
    80d5:	c3                   	ret    

000080d6 <do_alignment_check>:

void do_alignment_check(long esp, long error_code)
{
    80d6:	83 ec 0c             	sub    $0xc,%esp
    80d9:	e8 14 ec ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    80de:	05 22 9f 02 00       	add    $0x29f22,%eax
    die("alignment check", esp, error_code);
    80e3:	83 ec 04             	sub    $0x4,%esp
    80e6:	ff 74 24 18          	pushl  0x18(%esp)
    80ea:	ff 74 24 18          	pushl  0x18(%esp)
    80ee:	8d 80 fa 42 ff ff    	lea    -0xbd06(%eax),%eax
    80f4:	50                   	push   %eax
    80f5:	e8 4d fd ff ff       	call   7e47 <die>
    80fa:	83 c4 10             	add    $0x10,%esp
}
    80fd:	90                   	nop
    80fe:	83 c4 0c             	add    $0xc,%esp
    8101:	c3                   	ret    

00008102 <do_divide_error>:

void do_divide_error(long esp, long error_code)
{
    8102:	83 ec 0c             	sub    $0xc,%esp
    8105:	e8 e8 eb ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    810a:	05 f6 9e 02 00       	add    $0x29ef6,%eax
	die("divide error", esp, error_code);
    810f:	83 ec 04             	sub    $0x4,%esp
    8112:	ff 74 24 18          	pushl  0x18(%esp)
    8116:	ff 74 24 18          	pushl  0x18(%esp)
    811a:	8d 80 0a 43 ff ff    	lea    -0xbcf6(%eax),%eax
    8120:	50                   	push   %eax
    8121:	e8 21 fd ff ff       	call   7e47 <die>
    8126:	83 c4 10             	add    $0x10,%esp
}
    8129:	90                   	nop
    812a:	83 c4 0c             	add    $0xc,%esp
    812d:	c3                   	ret    

0000812e <do_int3>:
// 参数是进入中断后被顺序压入堆栈的寄存器值.参见asm.s程序.
void do_int3(long * esp, long error_code,
		long fs, long es, long ds,
		long ebp, long esi, long edi,
		long edx, long ecx, long ebx, long eax)
{
    812e:	53                   	push   %ebx
    812f:	83 ec 18             	sub    $0x18,%esp
    8132:	e8 c3 eb ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    8137:	81 c3 c9 9e 02 00    	add    $0x29ec9,%ebx
	int tr;

	__asm__("str %%ax":"=a" (tr):"0" (0));		// 取任务寄存器值->tr
    813d:	b8 00 00 00 00       	mov    $0x0,%eax
    8142:	66 0f 00 c8          	str    %ax
    8146:	89 44 24 0c          	mov    %eax,0xc(%esp)
	printk("eax\t\tebx\t\tecx\t\tedx\n\r%8x\t%8x\t%8x\t%8x\n\r",
    814a:	83 ec 0c             	sub    $0xc,%esp
    814d:	ff 74 24 4c          	pushl  0x4c(%esp)
    8151:	ff 74 24 54          	pushl  0x54(%esp)
    8155:	ff 74 24 5c          	pushl  0x5c(%esp)
    8159:	ff 74 24 64          	pushl  0x64(%esp)
    815d:	8d 83 18 43 ff ff    	lea    -0xbce8(%ebx),%eax
    8163:	50                   	push   %eax
    8164:	e8 c9 11 00 00       	call   9332 <printk>
    8169:	83 c4 20             	add    $0x20,%esp
		eax, ebx, ecx, edx);
	printk("esi\t\tedi\t\tebp\t\tesp\n\r%8x\t%8x\t%8x\t%8x\n\r",
    816c:	8b 44 24 20          	mov    0x20(%esp),%eax
    8170:	83 ec 0c             	sub    $0xc,%esp
    8173:	50                   	push   %eax
    8174:	ff 74 24 44          	pushl  0x44(%esp)
    8178:	ff 74 24 50          	pushl  0x50(%esp)
    817c:	ff 74 24 50          	pushl  0x50(%esp)
    8180:	8d 83 40 43 ff ff    	lea    -0xbcc0(%ebx),%eax
    8186:	50                   	push   %eax
    8187:	e8 a6 11 00 00       	call   9332 <printk>
    818c:	83 c4 20             	add    $0x20,%esp
		esi, edi, ebp, (long) esp);
	printk("\n\rds\tes\tfs\ttr\n\r%4x\t%4x\t%4x\t%4x\n\r",
    818f:	83 ec 0c             	sub    $0xc,%esp
    8192:	ff 74 24 18          	pushl  0x18(%esp)
    8196:	ff 74 24 38          	pushl  0x38(%esp)
    819a:	ff 74 24 40          	pushl  0x40(%esp)
    819e:	ff 74 24 48          	pushl  0x48(%esp)
    81a2:	8d 83 68 43 ff ff    	lea    -0xbc98(%ebx),%eax
    81a8:	50                   	push   %eax
    81a9:	e8 84 11 00 00       	call   9332 <printk>
    81ae:	83 c4 20             	add    $0x20,%esp
		ds, es, fs, tr);
	printk("EIP: %8x   CS: %4x  EFLAGS: %8x\n\r", esp[0], esp[1], esp[2]);
    81b1:	8b 44 24 20          	mov    0x20(%esp),%eax
    81b5:	83 c0 08             	add    $0x8,%eax
    81b8:	8b 08                	mov    (%eax),%ecx
    81ba:	8b 44 24 20          	mov    0x20(%esp),%eax
    81be:	83 c0 04             	add    $0x4,%eax
    81c1:	8b 10                	mov    (%eax),%edx
    81c3:	8b 44 24 20          	mov    0x20(%esp),%eax
    81c7:	8b 00                	mov    (%eax),%eax
    81c9:	51                   	push   %ecx
    81ca:	52                   	push   %edx
    81cb:	50                   	push   %eax
    81cc:	8d 83 8c 43 ff ff    	lea    -0xbc74(%ebx),%eax
    81d2:	50                   	push   %eax
    81d3:	e8 5a 11 00 00       	call   9332 <printk>
    81d8:	83 c4 10             	add    $0x10,%esp
}
    81db:	90                   	nop
    81dc:	83 c4 18             	add    $0x18,%esp
    81df:	5b                   	pop    %ebx
    81e0:	c3                   	ret    

000081e1 <do_nmi>:

void do_nmi(long esp, long error_code)
{
    81e1:	83 ec 0c             	sub    $0xc,%esp
    81e4:	e8 09 eb ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    81e9:	05 17 9e 02 00       	add    $0x29e17,%eax
	die("nmi", esp, error_code);
    81ee:	83 ec 04             	sub    $0x4,%esp
    81f1:	ff 74 24 18          	pushl  0x18(%esp)
    81f5:	ff 74 24 18          	pushl  0x18(%esp)
    81f9:	8d 80 ae 43 ff ff    	lea    -0xbc52(%eax),%eax
    81ff:	50                   	push   %eax
    8200:	e8 42 fc ff ff       	call   7e47 <die>
    8205:	83 c4 10             	add    $0x10,%esp
}
    8208:	90                   	nop
    8209:	83 c4 0c             	add    $0xc,%esp
    820c:	c3                   	ret    

0000820d <do_debug>:

void do_debug(long esp, long error_code)
{
    820d:	83 ec 0c             	sub    $0xc,%esp
    8210:	e8 dd ea ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    8215:	05 eb 9d 02 00       	add    $0x29deb,%eax
	die("debug", esp, error_code);
    821a:	83 ec 04             	sub    $0x4,%esp
    821d:	ff 74 24 18          	pushl  0x18(%esp)
    8221:	ff 74 24 18          	pushl  0x18(%esp)
    8225:	8d 80 b2 43 ff ff    	lea    -0xbc4e(%eax),%eax
    822b:	50                   	push   %eax
    822c:	e8 16 fc ff ff       	call   7e47 <die>
    8231:	83 c4 10             	add    $0x10,%esp
}
    8234:	90                   	nop
    8235:	83 c4 0c             	add    $0xc,%esp
    8238:	c3                   	ret    

00008239 <do_overflow>:

void do_overflow(long esp, long error_code)
{
    8239:	83 ec 0c             	sub    $0xc,%esp
    823c:	e8 b1 ea ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    8241:	05 bf 9d 02 00       	add    $0x29dbf,%eax
	die("overflow", esp, error_code);
    8246:	83 ec 04             	sub    $0x4,%esp
    8249:	ff 74 24 18          	pushl  0x18(%esp)
    824d:	ff 74 24 18          	pushl  0x18(%esp)
    8251:	8d 80 b8 43 ff ff    	lea    -0xbc48(%eax),%eax
    8257:	50                   	push   %eax
    8258:	e8 ea fb ff ff       	call   7e47 <die>
    825d:	83 c4 10             	add    $0x10,%esp
}
    8260:	90                   	nop
    8261:	83 c4 0c             	add    $0xc,%esp
    8264:	c3                   	ret    

00008265 <do_bounds>:

void do_bounds(long esp, long error_code)
{
    8265:	83 ec 0c             	sub    $0xc,%esp
    8268:	e8 85 ea ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    826d:	05 93 9d 02 00       	add    $0x29d93,%eax
	die("bounds", esp, error_code);
    8272:	83 ec 04             	sub    $0x4,%esp
    8275:	ff 74 24 18          	pushl  0x18(%esp)
    8279:	ff 74 24 18          	pushl  0x18(%esp)
    827d:	8d 80 c1 43 ff ff    	lea    -0xbc3f(%eax),%eax
    8283:	50                   	push   %eax
    8284:	e8 be fb ff ff       	call   7e47 <die>
    8289:	83 c4 10             	add    $0x10,%esp
}
    828c:	90                   	nop
    828d:	83 c4 0c             	add    $0xc,%esp
    8290:	c3                   	ret    

00008291 <do_invalid_op>:

void do_invalid_op(long esp, long error_code)
{
    8291:	83 ec 0c             	sub    $0xc,%esp
    8294:	e8 59 ea ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    8299:	05 67 9d 02 00       	add    $0x29d67,%eax
	die("invalid operand", esp, error_code);
    829e:	83 ec 04             	sub    $0x4,%esp
    82a1:	ff 74 24 18          	pushl  0x18(%esp)
    82a5:	ff 74 24 18          	pushl  0x18(%esp)
    82a9:	8d 80 c8 43 ff ff    	lea    -0xbc38(%eax),%eax
    82af:	50                   	push   %eax
    82b0:	e8 92 fb ff ff       	call   7e47 <die>
    82b5:	83 c4 10             	add    $0x10,%esp
}
    82b8:	90                   	nop
    82b9:	83 c4 0c             	add    $0xc,%esp
    82bc:	c3                   	ret    

000082bd <do_device_not_available>:

void do_device_not_available(long esp, long error_code)
{
    82bd:	83 ec 0c             	sub    $0xc,%esp
    82c0:	e8 2d ea ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    82c5:	05 3b 9d 02 00       	add    $0x29d3b,%eax
	die("device not available", esp, error_code);
    82ca:	83 ec 04             	sub    $0x4,%esp
    82cd:	ff 74 24 18          	pushl  0x18(%esp)
    82d1:	ff 74 24 18          	pushl  0x18(%esp)
    82d5:	8d 80 d8 43 ff ff    	lea    -0xbc28(%eax),%eax
    82db:	50                   	push   %eax
    82dc:	e8 66 fb ff ff       	call   7e47 <die>
    82e1:	83 c4 10             	add    $0x10,%esp
}
    82e4:	90                   	nop
    82e5:	83 c4 0c             	add    $0xc,%esp
    82e8:	c3                   	ret    

000082e9 <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(long esp, long error_code)
{
    82e9:	83 ec 0c             	sub    $0xc,%esp
    82ec:	e8 01 ea ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    82f1:	05 0f 9d 02 00       	add    $0x29d0f,%eax
	die("coprocessor segment overrun", esp, error_code);
    82f6:	83 ec 04             	sub    $0x4,%esp
    82f9:	ff 74 24 18          	pushl  0x18(%esp)
    82fd:	ff 74 24 18          	pushl  0x18(%esp)
    8301:	8d 80 ed 43 ff ff    	lea    -0xbc13(%eax),%eax
    8307:	50                   	push   %eax
    8308:	e8 3a fb ff ff       	call   7e47 <die>
    830d:	83 c4 10             	add    $0x10,%esp
}
    8310:	90                   	nop
    8311:	83 c4 0c             	add    $0xc,%esp
    8314:	c3                   	ret    

00008315 <do_invalid_TSS>:

void do_invalid_TSS(long esp, long error_code)
{
    8315:	83 ec 0c             	sub    $0xc,%esp
    8318:	e8 d5 e9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    831d:	05 e3 9c 02 00       	add    $0x29ce3,%eax
	die("invalid TSS", esp, error_code);
    8322:	83 ec 04             	sub    $0x4,%esp
    8325:	ff 74 24 18          	pushl  0x18(%esp)
    8329:	ff 74 24 18          	pushl  0x18(%esp)
    832d:	8d 80 09 44 ff ff    	lea    -0xbbf7(%eax),%eax
    8333:	50                   	push   %eax
    8334:	e8 0e fb ff ff       	call   7e47 <die>
    8339:	83 c4 10             	add    $0x10,%esp
}
    833c:	90                   	nop
    833d:	83 c4 0c             	add    $0xc,%esp
    8340:	c3                   	ret    

00008341 <do_segment_not_present>:

void do_segment_not_present(long esp, long error_code)
{
    8341:	83 ec 0c             	sub    $0xc,%esp
    8344:	e8 a9 e9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    8349:	05 b7 9c 02 00       	add    $0x29cb7,%eax
	die("segment not present", esp, error_code);
    834e:	83 ec 04             	sub    $0x4,%esp
    8351:	ff 74 24 18          	pushl  0x18(%esp)
    8355:	ff 74 24 18          	pushl  0x18(%esp)
    8359:	8d 80 15 44 ff ff    	lea    -0xbbeb(%eax),%eax
    835f:	50                   	push   %eax
    8360:	e8 e2 fa ff ff       	call   7e47 <die>
    8365:	83 c4 10             	add    $0x10,%esp
}
    8368:	90                   	nop
    8369:	83 c4 0c             	add    $0xc,%esp
    836c:	c3                   	ret    

0000836d <do_stack_segment>:

void do_stack_segment(long esp, long error_code)
{
    836d:	83 ec 0c             	sub    $0xc,%esp
    8370:	e8 7d e9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    8375:	05 8b 9c 02 00       	add    $0x29c8b,%eax
	die("stack segment", esp, error_code);
    837a:	83 ec 04             	sub    $0x4,%esp
    837d:	ff 74 24 18          	pushl  0x18(%esp)
    8381:	ff 74 24 18          	pushl  0x18(%esp)
    8385:	8d 80 29 44 ff ff    	lea    -0xbbd7(%eax),%eax
    838b:	50                   	push   %eax
    838c:	e8 b6 fa ff ff       	call   7e47 <die>
    8391:	83 c4 10             	add    $0x10,%esp
}
    8394:	90                   	nop
    8395:	83 c4 0c             	add    $0xc,%esp
    8398:	c3                   	ret    

00008399 <do_coprocessor_error>:

void do_coprocessor_error(long esp, long error_code)
{
    8399:	83 ec 0c             	sub    $0xc,%esp
    839c:	e8 51 e9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    83a1:	05 5f 9c 02 00       	add    $0x29c5f,%eax
	if (last_task_used_math != current)
    83a6:	c7 c2 8c 3b 03 00    	mov    $0x33b8c,%edx
    83ac:	8b 0a                	mov    (%edx),%ecx
    83ae:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    83b4:	8b 12                	mov    (%edx),%edx
    83b6:	39 d1                	cmp    %edx,%ecx
    83b8:	75 1c                	jne    83d6 <do_coprocessor_error+0x3d>
		return;
	die("coprocessor error", esp, error_code);
    83ba:	83 ec 04             	sub    $0x4,%esp
    83bd:	ff 74 24 18          	pushl  0x18(%esp)
    83c1:	ff 74 24 18          	pushl  0x18(%esp)
    83c5:	8d 80 37 44 ff ff    	lea    -0xbbc9(%eax),%eax
    83cb:	50                   	push   %eax
    83cc:	e8 76 fa ff ff       	call   7e47 <die>
    83d1:	83 c4 10             	add    $0x10,%esp
    83d4:	eb 01                	jmp    83d7 <do_coprocessor_error+0x3e>
		return;
    83d6:	90                   	nop
}
    83d7:	83 c4 0c             	add    $0xc,%esp
    83da:	c3                   	ret    

000083db <do_reserved>:

void do_reserved(long esp, long error_code)
{
    83db:	83 ec 0c             	sub    $0xc,%esp
    83de:	e8 0f e9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    83e3:	05 1d 9c 02 00       	add    $0x29c1d,%eax
	die("reserved (15,17-47) error", esp, error_code);
    83e8:	83 ec 04             	sub    $0x4,%esp
    83eb:	ff 74 24 18          	pushl  0x18(%esp)
    83ef:	ff 74 24 18          	pushl  0x18(%esp)
    83f3:	8d 80 49 44 ff ff    	lea    -0xbbb7(%eax),%eax
    83f9:	50                   	push   %eax
    83fa:	e8 48 fa ff ff       	call   7e47 <die>
    83ff:	83 c4 10             	add    $0x10,%esp
}
    8402:	90                   	nop
    8403:	83 c4 0c             	add    $0xc,%esp
    8406:	c3                   	ret    

00008407 <trap_init>:
// 下面是异常(陷阱)中断程序初始化子程序.设置它们的中断调用门(中断向量).
// set_trap_gate()与set_system_gate()都使用了中断描述符表IDT中的陷阱门(Trap Gate),它们之间的主要区别在于前者设置的特权级为0,
// 后者是3.因此断点陷阱中断int3,溢出中断overflow和边界出错中断bounds可以由任何程序调用.这两个函数均是嵌入式汇编宏程序,参见
// include/asm/system.h
void trap_init(void)
{
    8407:	56                   	push   %esi
    8408:	53                   	push   %ebx
    8409:	83 ec 10             	sub    $0x10,%esp
    840c:	e8 26 46 00 00       	call   ca37 <__x86.get_pc_thunk.cx>
    8411:	81 c1 ef 9b 02 00    	add    $0x29bef,%ecx
	int i;

	set_trap_gate(0, &divide_error);							// 设置除操作出错的中断向量值.
    8417:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    841d:	89 c6                	mov    %eax,%esi
    841f:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8425:	8d 58 04             	lea    0x4(%eax),%ebx
    8428:	c7 c0 1f 88 00 00    	mov    $0x881f,%eax
    842e:	89 c2                	mov    %eax,%edx
    8430:	b8 00 00 08 00       	mov    $0x80000,%eax
    8435:	66 89 d0             	mov    %dx,%ax
    8438:	66 ba 00 8f          	mov    $0x8f00,%dx
    843c:	89 06                	mov    %eax,(%esi)
    843e:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(1, &debug);
    8440:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8446:	8d 58 08             	lea    0x8(%eax),%ebx
    8449:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    844f:	8d 70 0c             	lea    0xc(%eax),%esi
    8452:	c7 c0 54 88 00 00    	mov    $0x8854,%eax
    8458:	89 c2                	mov    %eax,%edx
    845a:	b8 00 00 08 00       	mov    $0x80000,%eax
    845f:	66 89 d0             	mov    %dx,%ax
    8462:	66 ba 00 8f          	mov    $0x8f00,%dx
    8466:	89 03                	mov    %eax,(%ebx)
    8468:	89 16                	mov    %edx,(%esi)
	set_trap_gate(2, &nmi);
    846a:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8470:	8d 58 10             	lea    0x10(%eax),%ebx
    8473:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8479:	8d 70 14             	lea    0x14(%eax),%esi
    847c:	c7 c0 5b 88 00 00    	mov    $0x885b,%eax
    8482:	89 c2                	mov    %eax,%edx
    8484:	b8 00 00 08 00       	mov    $0x80000,%eax
    8489:	66 89 d0             	mov    %dx,%ax
    848c:	66 ba 00 8f          	mov    $0x8f00,%dx
    8490:	89 03                	mov    %eax,(%ebx)
    8492:	89 16                	mov    %edx,(%esi)
	set_system_gate(3, &int3);									/* int3-5 can be called from all */
    8494:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    849a:	8d 58 18             	lea    0x18(%eax),%ebx
    849d:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    84a3:	8d 70 1c             	lea    0x1c(%eax),%esi
    84a6:	c7 c0 62 88 00 00    	mov    $0x8862,%eax
    84ac:	89 c2                	mov    %eax,%edx
    84ae:	b8 00 00 08 00       	mov    $0x80000,%eax
    84b3:	66 89 d0             	mov    %dx,%ax
    84b6:	66 ba 00 ef          	mov    $0xef00,%dx
    84ba:	89 03                	mov    %eax,(%ebx)
    84bc:	89 16                	mov    %edx,(%esi)
	set_system_gate(4, &overflow);
    84be:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    84c4:	8d 58 20             	lea    0x20(%eax),%ebx
    84c7:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    84cd:	8d 70 24             	lea    0x24(%eax),%esi
    84d0:	c7 c0 69 88 00 00    	mov    $0x8869,%eax
    84d6:	89 c2                	mov    %eax,%edx
    84d8:	b8 00 00 08 00       	mov    $0x80000,%eax
    84dd:	66 89 d0             	mov    %dx,%ax
    84e0:	66 ba 00 ef          	mov    $0xef00,%dx
    84e4:	89 03                	mov    %eax,(%ebx)
    84e6:	89 16                	mov    %edx,(%esi)
	set_system_gate(5, &bounds);
    84e8:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    84ee:	8d 58 28             	lea    0x28(%eax),%ebx
    84f1:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    84f7:	8d 70 2c             	lea    0x2c(%eax),%esi
    84fa:	c7 c0 70 88 00 00    	mov    $0x8870,%eax
    8500:	89 c2                	mov    %eax,%edx
    8502:	b8 00 00 08 00       	mov    $0x80000,%eax
    8507:	66 89 d0             	mov    %dx,%ax
    850a:	66 ba 00 ef          	mov    $0xef00,%dx
    850e:	89 03                	mov    %eax,(%ebx)
    8510:	89 16                	mov    %edx,(%esi)
	set_trap_gate(6, &invalid_op);
    8512:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8518:	8d 58 30             	lea    0x30(%eax),%ebx
    851b:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8521:	8d 70 34             	lea    0x34(%eax),%esi
    8524:	c7 c0 77 88 00 00    	mov    $0x8877,%eax
    852a:	89 c2                	mov    %eax,%edx
    852c:	b8 00 00 08 00       	mov    $0x80000,%eax
    8531:	66 89 d0             	mov    %dx,%ax
    8534:	66 ba 00 8f          	mov    $0x8f00,%dx
    8538:	89 03                	mov    %eax,(%ebx)
    853a:	89 16                	mov    %edx,(%esi)
	set_trap_gate(7, &device_not_available);					// 函数未实现
    853c:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8542:	8d 58 38             	lea    0x38(%eax),%ebx
    8545:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    854b:	8d 70 3c             	lea    0x3c(%eax),%esi
    854e:	c7 c0 24 7d 00 00    	mov    $0x7d24,%eax
    8554:	89 c2                	mov    %eax,%edx
    8556:	b8 00 00 08 00       	mov    $0x80000,%eax
    855b:	66 89 d0             	mov    %dx,%ax
    855e:	66 ba 00 8f          	mov    $0x8f00,%dx
    8562:	89 03                	mov    %eax,(%ebx)
    8564:	89 16                	mov    %edx,(%esi)
	set_trap_gate(8, &double_fault);
    8566:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    856c:	8d 58 40             	lea    0x40(%eax),%ebx
    856f:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8575:	8d 70 44             	lea    0x44(%eax),%esi
    8578:	c7 c0 a1 88 00 00    	mov    $0x88a1,%eax
    857e:	89 c2                	mov    %eax,%edx
    8580:	b8 00 00 08 00       	mov    $0x80000,%eax
    8585:	66 89 d0             	mov    %dx,%ax
    8588:	66 ba 00 8f          	mov    $0x8f00,%dx
    858c:	89 03                	mov    %eax,(%ebx)
    858e:	89 16                	mov    %edx,(%esi)
	set_trap_gate(9, &coprocessor_segment_overrun);
    8590:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8596:	8d 58 48             	lea    0x48(%eax),%ebx
    8599:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    859f:	8d 70 4c             	lea    0x4c(%eax),%esi
    85a2:	c7 c0 7e 88 00 00    	mov    $0x887e,%eax
    85a8:	89 c2                	mov    %eax,%edx
    85aa:	b8 00 00 08 00       	mov    $0x80000,%eax
    85af:	66 89 d0             	mov    %dx,%ax
    85b2:	66 ba 00 8f          	mov    $0x8f00,%dx
    85b6:	89 03                	mov    %eax,(%ebx)
    85b8:	89 16                	mov    %edx,(%esi)
	set_trap_gate(10, &invalid_TSS);
    85ba:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    85c0:	8d 58 50             	lea    0x50(%eax),%ebx
    85c3:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    85c9:	8d 70 54             	lea    0x54(%eax),%esi
    85cc:	c7 c0 d8 88 00 00    	mov    $0x88d8,%eax
    85d2:	89 c2                	mov    %eax,%edx
    85d4:	b8 00 00 08 00       	mov    $0x80000,%eax
    85d9:	66 89 d0             	mov    %dx,%ax
    85dc:	66 ba 00 8f          	mov    $0x8f00,%dx
    85e0:	89 03                	mov    %eax,(%ebx)
    85e2:	89 16                	mov    %edx,(%esi)
	set_trap_gate(11, &segment_not_present);
    85e4:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    85ea:	8d 58 58             	lea    0x58(%eax),%ebx
    85ed:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    85f3:	8d 70 5c             	lea    0x5c(%eax),%esi
    85f6:	c7 c0 df 88 00 00    	mov    $0x88df,%eax
    85fc:	89 c2                	mov    %eax,%edx
    85fe:	b8 00 00 08 00       	mov    $0x80000,%eax
    8603:	66 89 d0             	mov    %dx,%ax
    8606:	66 ba 00 8f          	mov    $0x8f00,%dx
    860a:	89 03                	mov    %eax,(%ebx)
    860c:	89 16                	mov    %edx,(%esi)
	set_trap_gate(12, &stack_segment);
    860e:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8614:	8d 58 60             	lea    0x60(%eax),%ebx
    8617:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    861d:	8d 70 64             	lea    0x64(%eax),%esi
    8620:	c7 c0 e6 88 00 00    	mov    $0x88e6,%eax
    8626:	89 c2                	mov    %eax,%edx
    8628:	b8 00 00 08 00       	mov    $0x80000,%eax
    862d:	66 89 d0             	mov    %dx,%ax
    8630:	66 ba 00 8f          	mov    $0x8f00,%dx
    8634:	89 03                	mov    %eax,(%ebx)
    8636:	89 16                	mov    %edx,(%esi)
	set_trap_gate(13, &general_protection);
    8638:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    863e:	8d 58 68             	lea    0x68(%eax),%ebx
    8641:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8647:	8d 70 6c             	lea    0x6c(%eax),%esi
    864a:	c7 c0 ed 88 00 00    	mov    $0x88ed,%eax
    8650:	89 c2                	mov    %eax,%edx
    8652:	b8 00 00 08 00       	mov    $0x80000,%eax
    8657:	66 89 d0             	mov    %dx,%ax
    865a:	66 ba 00 8f          	mov    $0x8f00,%dx
    865e:	89 03                	mov    %eax,(%ebx)
    8660:	89 16                	mov    %edx,(%esi)
	set_trap_gate(14, &page_fault);
    8662:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8668:	8d 58 70             	lea    0x70(%eax),%ebx
    866b:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8671:	8d 70 74             	lea    0x74(%eax),%esi
    8674:	c7 c0 cf e2 00 00    	mov    $0xe2cf,%eax
    867a:	89 c2                	mov    %eax,%edx
    867c:	b8 00 00 08 00       	mov    $0x80000,%eax
    8681:	66 89 d0             	mov    %dx,%ax
    8684:	66 ba 00 8f          	mov    $0x8f00,%dx
    8688:	89 03                	mov    %eax,(%ebx)
    868a:	89 16                	mov    %edx,(%esi)
	set_trap_gate(15, &reserved);
    868c:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8692:	8d 58 78             	lea    0x78(%eax),%ebx
    8695:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    869b:	8d 70 7c             	lea    0x7c(%eax),%esi
    869e:	c7 c0 85 88 00 00    	mov    $0x8885,%eax
    86a4:	89 c2                	mov    %eax,%edx
    86a6:	b8 00 00 08 00       	mov    $0x80000,%eax
    86ab:	66 89 d0             	mov    %dx,%ax
    86ae:	66 ba 00 8f          	mov    $0x8f00,%dx
    86b2:	89 03                	mov    %eax,(%ebx)
    86b4:	89 16                	mov    %edx,(%esi)
	set_trap_gate(16, &coprocessor_error);						// 函数未实现
    86b6:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    86bc:	8d 98 80 00 00 00    	lea    0x80(%eax),%ebx
    86c2:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    86c8:	8d b0 84 00 00 00    	lea    0x84(%eax),%esi
    86ce:	c7 c0 00 7d 00 00    	mov    $0x7d00,%eax
    86d4:	89 c2                	mov    %eax,%edx
    86d6:	b8 00 00 08 00       	mov    $0x80000,%eax
    86db:	66 89 d0             	mov    %dx,%ax
    86de:	66 ba 00 8f          	mov    $0x8f00,%dx
    86e2:	89 03                	mov    %eax,(%ebx)
    86e4:	89 16                	mov    %edx,(%esi)
	set_trap_gate(17, &alignment_check);
    86e6:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    86ec:	8d 98 88 00 00 00    	lea    0x88(%eax),%ebx
    86f2:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    86f8:	8d b0 8c 00 00 00    	lea    0x8c(%eax),%esi
    86fe:	c7 c0 f4 88 00 00    	mov    $0x88f4,%eax
    8704:	89 c2                	mov    %eax,%edx
    8706:	b8 00 00 08 00       	mov    $0x80000,%eax
    870b:	66 89 d0             	mov    %dx,%ax
    870e:	66 ba 00 8f          	mov    $0x8f00,%dx
    8712:	89 03                	mov    %eax,(%ebx)
    8714:	89 16                	mov    %edx,(%esi)
	// 下面把int17-47的陷阱门先均设置为reserved,以后各硬件初始化时会重新设置自己的陷阱门.
	for (i = 18; i < 48; i++)
    8716:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
    871d:	00 
    871e:	eb 47                	jmp    8767 <trap_init+0x360>
		set_trap_gate(i, &reserved);
    8720:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8724:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    872b:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8731:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    8734:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8738:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    873f:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8745:	01 d0                	add    %edx,%eax
    8747:	8d 70 04             	lea    0x4(%eax),%esi
    874a:	c7 c0 85 88 00 00    	mov    $0x8885,%eax
    8750:	89 c2                	mov    %eax,%edx
    8752:	b8 00 00 08 00       	mov    $0x80000,%eax
    8757:	66 89 d0             	mov    %dx,%ax
    875a:	66 ba 00 8f          	mov    $0x8f00,%dx
    875e:	89 03                	mov    %eax,(%ebx)
    8760:	89 16                	mov    %edx,(%esi)
	for (i = 18; i < 48; i++)
    8762:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    8767:	83 7c 24 0c 2f       	cmpl   $0x2f,0xc(%esp)
    876c:	7e b2                	jle    8720 <trap_init+0x319>
	// 设置协处理器中断0x2d(45)陷阱门描述符,并允许其产生中断请求.设置并行口中断描述符.
	set_trap_gate(45, &irq13);
    876e:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8774:	8d 98 68 01 00 00    	lea    0x168(%eax),%ebx
    877a:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    8780:	8d b0 6c 01 00 00    	lea    0x16c(%eax),%esi
    8786:	c7 c0 8c 88 00 00    	mov    $0x888c,%eax
    878c:	89 c2                	mov    %eax,%edx
    878e:	b8 00 00 08 00       	mov    $0x80000,%eax
    8793:	66 89 d0             	mov    %dx,%ax
    8796:	66 ba 00 8f          	mov    $0x8f00,%dx
    879a:	89 03                	mov    %eax,(%ebx)
    879c:	89 16                	mov    %edx,(%esi)
	outb_p(inb_p(0x21)&0xfb, 0x21);								// 允许8259A主芯片的IRQ2中断请求(连接从芯片)
    879e:	b8 21 00 00 00       	mov    $0x21,%eax
    87a3:	89 c2                	mov    %eax,%edx
    87a5:	ec                   	in     (%dx),%al
    87a6:	eb 00                	jmp    87a8 <trap_init+0x3a1>
    87a8:	eb 00                	jmp    87aa <trap_init+0x3a3>
    87aa:	88 44 24 0b          	mov    %al,0xb(%esp)
    87ae:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
    87b3:	0f b6 c0             	movzbl %al,%eax
    87b6:	25 fb 00 00 00       	and    $0xfb,%eax
    87bb:	ba 21 00 00 00       	mov    $0x21,%edx
    87c0:	ee                   	out    %al,(%dx)
    87c1:	eb 00                	jmp    87c3 <trap_init+0x3bc>
    87c3:	eb 00                	jmp    87c5 <trap_init+0x3be>
	outb(inb_p(0xA1)&0xdf, 0xA1);								// 允许8259A从芯片的IRQ13中断请求(协处理器中断)
    87c5:	b8 a1 00 00 00       	mov    $0xa1,%eax
    87ca:	89 c2                	mov    %eax,%edx
    87cc:	ec                   	in     (%dx),%al
    87cd:	eb 00                	jmp    87cf <trap_init+0x3c8>
    87cf:	eb 00                	jmp    87d1 <trap_init+0x3ca>
    87d1:	88 44 24 0a          	mov    %al,0xa(%esp)
    87d5:	0f b6 44 24 0a       	movzbl 0xa(%esp),%eax
    87da:	0f b6 c0             	movzbl %al,%eax
    87dd:	25 df 00 00 00       	and    $0xdf,%eax
    87e2:	ba a1 00 00 00       	mov    $0xa1,%edx
    87e7:	ee                   	out    %al,(%dx)
	set_trap_gate(39, &parallel_interrupt);						// 设置并行口1的中断0x27陷阱门描述符.
    87e8:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    87ee:	8d 98 38 01 00 00    	lea    0x138(%eax),%ebx
    87f4:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
    87fa:	8d b0 3c 01 00 00    	lea    0x13c(%eax),%esi
    8800:	c7 c0 40 7e 00 00    	mov    $0x7e40,%eax
    8806:	89 c2                	mov    %eax,%edx
    8808:	b8 00 00 08 00       	mov    $0x80000,%eax
    880d:	66 89 d0             	mov    %dx,%ax
    8810:	66 ba 00 8f          	mov    $0x8f00,%dx
    8814:	89 03                	mov    %eax,(%ebx)
    8816:	89 16                	mov    %edx,(%esi)
}
    8818:	90                   	nop
    8819:	83 c4 10             	add    $0x10,%esp
    881c:	5b                   	pop    %ebx
    881d:	5e                   	pop    %esi
    881e:	c3                   	ret    

0000881f <divide_error>:
    881f:	68 02 81 00 00       	push   $0x8102

00008824 <no_error_code>:
    8824:	87 04 24             	xchg   %eax,(%esp)
    8827:	53                   	push   %ebx
    8828:	51                   	push   %ecx
    8829:	52                   	push   %edx
    882a:	57                   	push   %edi
    882b:	56                   	push   %esi
    882c:	55                   	push   %ebp
    882d:	1e                   	push   %ds
    882e:	06                   	push   %es
    882f:	0f a0                	push   %fs
    8831:	6a 00                	push   $0x0
    8833:	8d 54 24 2c          	lea    0x2c(%esp),%edx
    8837:	52                   	push   %edx
    8838:	ba 10 00 00 00       	mov    $0x10,%edx
    883d:	8e da                	mov    %edx,%ds
    883f:	8e c2                	mov    %edx,%es
    8841:	8e e2                	mov    %edx,%fs
    8843:	ff d0                	call   *%eax
    8845:	83 c4 08             	add    $0x8,%esp
    8848:	0f a1                	pop    %fs
    884a:	07                   	pop    %es
    884b:	1f                   	pop    %ds
    884c:	5d                   	pop    %ebp
    884d:	5e                   	pop    %esi
    884e:	5f                   	pop    %edi
    884f:	5a                   	pop    %edx
    8850:	59                   	pop    %ecx
    8851:	5b                   	pop    %ebx
    8852:	58                   	pop    %eax
    8853:	cf                   	iret   

00008854 <debug>:
    8854:	68 2e 81 00 00       	push   $0x812e
    8859:	eb c9                	jmp    8824 <no_error_code>

0000885b <nmi>:
    885b:	68 e1 81 00 00       	push   $0x81e1
    8860:	eb c2                	jmp    8824 <no_error_code>

00008862 <int3>:
    8862:	68 2e 81 00 00       	push   $0x812e
    8867:	eb bb                	jmp    8824 <no_error_code>

00008869 <overflow>:
    8869:	68 39 82 00 00       	push   $0x8239
    886e:	eb b4                	jmp    8824 <no_error_code>

00008870 <bounds>:
    8870:	68 65 82 00 00       	push   $0x8265
    8875:	eb ad                	jmp    8824 <no_error_code>

00008877 <invalid_op>:
    8877:	68 91 82 00 00       	push   $0x8291
    887c:	eb a6                	jmp    8824 <no_error_code>

0000887e <coprocessor_segment_overrun>:
    887e:	68 e9 82 00 00       	push   $0x82e9
    8883:	eb 9f                	jmp    8824 <no_error_code>

00008885 <reserved>:
    8885:	68 db 83 00 00       	push   $0x83db
    888a:	eb 98                	jmp    8824 <no_error_code>

0000888c <irq13>:
    888c:	50                   	push   %eax
    888d:	30 c0                	xor    %al,%al
    888f:	e6 f0                	out    %al,$0xf0
    8891:	b0 20                	mov    $0x20,%al
    8893:	e6 20                	out    %al,$0x20
    8895:	eb 00                	jmp    8897 <irq13+0xb>
    8897:	eb 00                	jmp    8899 <irq13+0xd>
    8899:	e6 a0                	out    %al,$0xa0
    889b:	58                   	pop    %eax
    889c:	e9 5f f4 ff ff       	jmp    7d00 <coprocessor_error>

000088a1 <double_fault>:
    88a1:	68 7e 80 00 00       	push   $0x807e

000088a6 <error_code>:
    88a6:	87 44 24 04          	xchg   %eax,0x4(%esp)
    88aa:	87 1c 24             	xchg   %ebx,(%esp)
    88ad:	51                   	push   %ecx
    88ae:	52                   	push   %edx
    88af:	57                   	push   %edi
    88b0:	56                   	push   %esi
    88b1:	55                   	push   %ebp
    88b2:	1e                   	push   %ds
    88b3:	06                   	push   %es
    88b4:	0f a0                	push   %fs
    88b6:	50                   	push   %eax
    88b7:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    88bb:	50                   	push   %eax
    88bc:	b8 10 00 00 00       	mov    $0x10,%eax
    88c1:	8e d8                	mov    %eax,%ds
    88c3:	8e c0                	mov    %eax,%es
    88c5:	8e e0                	mov    %eax,%fs
    88c7:	ff d3                	call   *%ebx
    88c9:	83 c4 08             	add    $0x8,%esp
    88cc:	0f a1                	pop    %fs
    88ce:	07                   	pop    %es
    88cf:	1f                   	pop    %ds
    88d0:	5d                   	pop    %ebp
    88d1:	5e                   	pop    %esi
    88d2:	5f                   	pop    %edi
    88d3:	5a                   	pop    %edx
    88d4:	59                   	pop    %ecx
    88d5:	5b                   	pop    %ebx
    88d6:	58                   	pop    %eax
    88d7:	cf                   	iret   

000088d8 <invalid_TSS>:
    88d8:	68 15 83 00 00       	push   $0x8315
    88dd:	eb c7                	jmp    88a6 <error_code>

000088df <segment_not_present>:
    88df:	68 41 83 00 00       	push   $0x8341
    88e4:	eb c0                	jmp    88a6 <error_code>

000088e6 <stack_segment>:
    88e6:	68 6d 83 00 00       	push   $0x836d
    88eb:	eb b9                	jmp    88a6 <error_code>

000088ed <general_protection>:
    88ed:	68 aa 80 00 00       	push   $0x80aa
    88f2:	eb b2                	jmp    88a6 <error_code>

000088f4 <alignment_check>:
    88f4:	68 d6 80 00 00       	push   $0x80d6
    88f9:	eb ab                	jmp    88a6 <error_code>

000088fb <verify_area>:
// 可以通过设置该标志来达到使用本函数同样的目的.该函数对当前进程逻辑地址从addr到addr + size这一段范围以页为单位执行写操作前
// 的检测操作.由于检测判断是以页面为单位进行操作,因此程序首先需要找出addr所在页面开始地址start,然后start加上进程数据段基址,
// 使这个start变换成CPU 4GB线性空间中的地址.最后循环调用write_verify()对指定大小的内存空间进行写前验证.若页面是只读的,
// 则执行共享检验和复制页面操作(写时复制).
void verify_area(void * addr, int size)
{
    88fb:	56                   	push   %esi
    88fc:	53                   	push   %ebx
    88fd:	83 ec 14             	sub    $0x14,%esp
    8900:	e8 f5 e3 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    8905:	81 c3 fb 96 02 00    	add    $0x296fb,%ebx
	unsigned long start;

	// 首先将起始地址start调整为其所在页的左边界开始位置,同时相应地调整验证区域大小.下句中的start & 0xfff用来获得指定起始位置addr
	// (也即start)在所在页面中的偏移值,原验证范围size加上这个偏移值即扩展成以addr所在页面起始位置开始的范围值.因此在30行上也需要
	// 把验证开始位置start调整成页面边界值.
	start = (unsigned long) addr;
    890b:	8b 44 24 20          	mov    0x20(%esp),%eax
    890f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	size += start & 0xfff;
    8913:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8917:	25 ff 0f 00 00       	and    $0xfff,%eax
    891c:	89 c2                	mov    %eax,%edx
    891e:	8b 44 24 24          	mov    0x24(%esp),%eax
    8922:	01 d0                	add    %edx,%eax
    8924:	89 44 24 24          	mov    %eax,0x24(%esp)
	start &= 0xfffff000;					// 此时start是当前进程空间中的逻辑地址.
    8928:	81 64 24 0c 00 f0 ff 	andl   $0xfffff000,0xc(%esp)
    892f:	ff 
	// 下面把start加上进程数据段在线性地址空间中的起始基址,变成系统整个线性空间中的地址位置.对于Linux0.1x内核,其数据段和代码段在
	// 线性地址空间中的基址和限长均相同.然后循环进行写页面验证.若页面不可写,则复制页面.(mm/memory.c)
	start += get_base(current->ldt[2]);
    8930:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8936:	8b 00                	mov    (%eax),%eax
    8938:	05 a8 03 00 00       	add    $0x3a8,%eax
    893d:	8d 70 02             	lea    0x2(%eax),%esi
    8940:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8946:	8b 00                	mov    (%eax),%eax
    8948:	05 a8 03 00 00       	add    $0x3a8,%eax
    894d:	8d 48 04             	lea    0x4(%eax),%ecx
    8950:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8956:	8b 00                	mov    (%eax),%eax
    8958:	05 a8 03 00 00       	add    $0x3a8,%eax
    895d:	83 c0 07             	add    $0x7,%eax
    8960:	8a 30                	mov    (%eax),%dh
    8962:	8a 11                	mov    (%ecx),%dl
    8964:	c1 e2 10             	shl    $0x10,%edx
    8967:	66 8b 16             	mov    (%esi),%dx
    896a:	89 d0                	mov    %edx,%eax
    896c:	89 44 24 08          	mov    %eax,0x8(%esp)
    8970:	8b 44 24 08          	mov    0x8(%esp),%eax
    8974:	01 44 24 0c          	add    %eax,0xc(%esp)
	while (size > 0) {
    8978:	eb 1f                	jmp    8999 <verify_area+0x9e>
		size -= 4096;
    897a:	81 6c 24 24 00 10 00 	subl   $0x1000,0x24(%esp)
    8981:	00 
		write_verify(start);				// include/linux/sched.h
    8982:	83 ec 0c             	sub    $0xc,%esp
    8985:	ff 74 24 18          	pushl  0x18(%esp)
    8989:	e8 25 48 00 00       	call   d1b3 <write_verify>
    898e:	83 c4 10             	add    $0x10,%esp
		start += 4096;
    8991:	81 44 24 0c 00 10 00 	addl   $0x1000,0xc(%esp)
    8998:	00 
	while (size > 0) {
    8999:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    899e:	7f da                	jg     897a <verify_area+0x7f>
	}
}
    89a0:	90                   	nop
    89a1:	83 c4 14             	add    $0x14,%esp
    89a4:	5b                   	pop    %ebx
    89a5:	5e                   	pop    %esi
    89a6:	c3                   	ret    

000089a7 <copy_mem>:
// 复制内存页表.
// 参数nr是新任务号;p是新任务数据结构指针.该函数为新任务在线性地址空间中设置代码段和数据段基址,限长,并复制页表.由于Linux系统采用写时
// 复制(copy on write)技术,因此这里仅为新进程设置自己的页目录表项和页表项,而没有实际为新进程分配物理内存页面.此时新进程与其父进程
// 共享所有内存页面.操作成功返回0,否则返回出错号.
int copy_mem(int nr, struct task_struct * p)
{
    89a7:	57                   	push   %edi
    89a8:	56                   	push   %esi
    89a9:	53                   	push   %ebx
    89aa:	83 ec 30             	sub    $0x30,%esp
    89ad:	e8 48 e3 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    89b2:	81 c3 4e 96 02 00    	add    $0x2964e,%ebx

	// 首先取当前进程局部描述符表中代码段描述符和数据段描述符项中的段限长(字节数).
	// 0x0f是代码段选择符;0x17是数据段选择符.然后取当前进程代码段和数据段的线性地址空间中的基地址.由于Linux0.12内核还不支持代码和数据段分立的情况,
	// 因此这里需要检查代码段和数据段基址是否都相同,并且要求数据段的长度至少不小于代码段的长度,否则内核显示出错信息,并停止运行.
	// get_limit()和get_base()定义在include/linux/sched.h.
	code_limit = get_limit(0x0f);
    89b8:	b8 0f 00 00 00       	mov    $0xf,%eax
    89bd:	0f 03 c0             	lsl    %ax,%eax
    89c0:	40                   	inc    %eax
    89c1:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    89c5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    89c9:	89 44 24 28          	mov    %eax,0x28(%esp)
	data_limit = get_limit(0x17);
    89cd:	b8 17 00 00 00       	mov    $0x17,%eax
    89d2:	0f 03 c0             	lsl    %ax,%eax
    89d5:	40                   	inc    %eax
    89d6:	89 44 24 24          	mov    %eax,0x24(%esp)
    89da:	8b 44 24 24          	mov    0x24(%esp),%eax
    89de:	89 44 24 20          	mov    %eax,0x20(%esp)
	old_code_base = get_base(current->ldt[1]);
    89e2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    89e8:	8b 00                	mov    (%eax),%eax
    89ea:	05 a0 03 00 00       	add    $0x3a0,%eax
    89ef:	8d 70 02             	lea    0x2(%eax),%esi
    89f2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    89f8:	8b 00                	mov    (%eax),%eax
    89fa:	05 a0 03 00 00       	add    $0x3a0,%eax
    89ff:	8d 48 04             	lea    0x4(%eax),%ecx
    8a02:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8a08:	8b 00                	mov    (%eax),%eax
    8a0a:	05 a0 03 00 00       	add    $0x3a0,%eax
    8a0f:	83 c0 07             	add    $0x7,%eax
    8a12:	8a 30                	mov    (%eax),%dh
    8a14:	8a 11                	mov    (%ecx),%dl
    8a16:	c1 e2 10             	shl    $0x10,%edx
    8a19:	66 8b 16             	mov    (%esi),%dx
    8a1c:	89 d0                	mov    %edx,%eax
    8a1e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    8a22:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    8a26:	89 44 24 18          	mov    %eax,0x18(%esp)
	old_data_base = get_base(current->ldt[2]);
    8a2a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8a30:	8b 00                	mov    (%eax),%eax
    8a32:	05 a8 03 00 00       	add    $0x3a8,%eax
    8a37:	8d 78 02             	lea    0x2(%eax),%edi
    8a3a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8a40:	8b 00                	mov    (%eax),%eax
    8a42:	05 a8 03 00 00       	add    $0x3a8,%eax
    8a47:	8d 48 04             	lea    0x4(%eax),%ecx
    8a4a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8a50:	8b 00                	mov    (%eax),%eax
    8a52:	05 a8 03 00 00       	add    $0x3a8,%eax
    8a57:	83 c0 07             	add    $0x7,%eax
    8a5a:	8a 30                	mov    (%eax),%dh
    8a5c:	8a 11                	mov    (%ecx),%dl
    8a5e:	c1 e2 10             	shl    $0x10,%edx
    8a61:	66 8b 17             	mov    (%edi),%dx
    8a64:	89 d0                	mov    %edx,%eax
    8a66:	89 44 24 14          	mov    %eax,0x14(%esp)
    8a6a:	8b 44 24 14          	mov    0x14(%esp),%eax
    8a6e:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (old_data_base != old_code_base)
    8a72:	8b 44 24 10          	mov    0x10(%esp),%eax
    8a76:	3b 44 24 18          	cmp    0x18(%esp),%eax
    8a7a:	74 12                	je     8a8e <copy_mem+0xe7>
		panic("We don't support separate I&D");
    8a7c:	83 ec 0c             	sub    $0xc,%esp
    8a7f:	8d 83 64 44 ff ff    	lea    -0xbb9c(%ebx),%eax
    8a85:	50                   	push   %eax
    8a86:	e8 53 08 00 00       	call   92de <panic>
    8a8b:	83 c4 10             	add    $0x10,%esp
	if (data_limit < code_limit)
    8a8e:	8b 44 24 20          	mov    0x20(%esp),%eax
    8a92:	3b 44 24 28          	cmp    0x28(%esp),%eax
    8a96:	73 12                	jae    8aaa <copy_mem+0x103>
		panic("Bad data_limit");
    8a98:	83 ec 0c             	sub    $0xc,%esp
    8a9b:	8d 83 82 44 ff ff    	lea    -0xbb7e(%ebx),%eax
    8aa1:	50                   	push   %eax
    8aa2:	e8 37 08 00 00       	call   92de <panic>
    8aa7:	83 c4 10             	add    $0x10,%esp
	// 然后设置创建中的新进程在线性地址空间中的基地址等于(64MB*其任务号),并用该值设置新进程局部描述符表中段描述符中的基地址.接着设置新进程的页目录
	// 表项和页表项,即复制当前进程(父进程)的页目录表项和页表项.此时子进程共享父进程的内存页面.
	// 正常情况下copy_page_tables()返回0,否则表示出错,则释放刚申请的页表项.
	new_data_base = new_code_base = nr * TASK_SIZE;
    8aaa:	8b 44 24 40          	mov    0x40(%esp),%eax
    8aae:	c1 e0 1a             	shl    $0x1a,%eax
    8ab1:	89 44 24 0c          	mov    %eax,0xc(%esp)
    8ab5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8ab9:	89 44 24 08          	mov    %eax,0x8(%esp)
	p->start_code = new_code_base;
    8abd:	8b 44 24 44          	mov    0x44(%esp),%eax
    8ac1:	8b 54 24 0c          	mov    0xc(%esp),%edx
    8ac5:	89 90 18 02 00 00    	mov    %edx,0x218(%eax)
	set_base(p->ldt[1], new_code_base);
    8acb:	8b 44 24 44          	mov    0x44(%esp),%eax
    8acf:	05 a0 03 00 00       	add    $0x3a0,%eax
    8ad4:	8d 48 02             	lea    0x2(%eax),%ecx
    8ad7:	8b 44 24 44          	mov    0x44(%esp),%eax
    8adb:	05 a0 03 00 00       	add    $0x3a0,%eax
    8ae0:	8d 70 04             	lea    0x4(%eax),%esi
    8ae3:	8b 44 24 44          	mov    0x44(%esp),%eax
    8ae7:	05 a0 03 00 00       	add    $0x3a0,%eax
    8aec:	8d 78 07             	lea    0x7(%eax),%edi
    8aef:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8af3:	89 c2                	mov    %eax,%edx
    8af5:	66 89 11             	mov    %dx,(%ecx)
    8af8:	c1 ca 10             	ror    $0x10,%edx
    8afb:	88 16                	mov    %dl,(%esi)
    8afd:	88 37                	mov    %dh,(%edi)
    8aff:	89 d0                	mov    %edx,%eax
    8b01:	89 44 24 04          	mov    %eax,0x4(%esp)
	set_base(p->ldt[2], new_data_base);
    8b05:	8b 44 24 44          	mov    0x44(%esp),%eax
    8b09:	05 a8 03 00 00       	add    $0x3a8,%eax
    8b0e:	8d 48 02             	lea    0x2(%eax),%ecx
    8b11:	8b 44 24 44          	mov    0x44(%esp),%eax
    8b15:	05 a8 03 00 00       	add    $0x3a8,%eax
    8b1a:	8d 70 04             	lea    0x4(%eax),%esi
    8b1d:	8b 44 24 44          	mov    0x44(%esp),%eax
    8b21:	05 a8 03 00 00       	add    $0x3a8,%eax
    8b26:	8d 78 07             	lea    0x7(%eax),%edi
    8b29:	8b 44 24 08          	mov    0x8(%esp),%eax
    8b2d:	89 c2                	mov    %eax,%edx
    8b2f:	66 89 11             	mov    %dx,(%ecx)
    8b32:	c1 ca 10             	ror    $0x10,%edx
    8b35:	88 16                	mov    %dl,(%esi)
    8b37:	88 37                	mov    %dh,(%edi)
    8b39:	89 d0                	mov    %edx,%eax
    8b3b:	89 04 24             	mov    %eax,(%esp)
	if (copy_page_tables(old_data_base, new_data_base, data_limit)) {
    8b3e:	8b 44 24 20          	mov    0x20(%esp),%eax
    8b42:	83 ec 04             	sub    $0x4,%esp
    8b45:	50                   	push   %eax
    8b46:	ff 74 24 10          	pushl  0x10(%esp)
    8b4a:	ff 74 24 1c          	pushl  0x1c(%esp)
    8b4e:	e8 f8 40 00 00       	call   cc4b <copy_page_tables>
    8b53:	83 c4 10             	add    $0x10,%esp
    8b56:	85 c0                	test   %eax,%eax
    8b58:	74 1a                	je     8b74 <copy_mem+0x1cd>
		free_page_tables(new_data_base, data_limit);
    8b5a:	83 ec 08             	sub    $0x8,%esp
    8b5d:	ff 74 24 28          	pushl  0x28(%esp)
    8b61:	ff 74 24 14          	pushl  0x14(%esp)
    8b65:	e8 9b 3f 00 00       	call   cb05 <free_page_tables>
    8b6a:	83 c4 10             	add    $0x10,%esp
		return -ENOMEM;
    8b6d:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    8b72:	eb 05                	jmp    8b79 <copy_mem+0x1d2>
	}
	return 0;
    8b74:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b79:	83 c4 30             	add    $0x30,%esp
    8b7c:	5b                   	pop    %ebx
    8b7d:	5e                   	pop    %esi
    8b7e:	5f                   	pop    %edi
    8b7f:	c3                   	ret    

00008b80 <copy_process>:
// 其中参数nr是调用find_empty_process()分配的任务数组项号.
int copy_process(int nr, long ebp, long edi, long esi, long gs, long none,
		long ebx, long ecx, long edx, long orig_eax,
		long fs, long es, long ds,
		long eip, long cs, long eflags, long esp, long ss)
{
    8b80:	55                   	push   %ebp
    8b81:	57                   	push   %edi
    8b82:	56                   	push   %esi
    8b83:	53                   	push   %ebx
    8b84:	83 ec 2c             	sub    $0x2c,%esp
    8b87:	e8 66 e1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    8b8c:	05 74 94 02 00       	add    $0x29474,%eax
    8b91:	89 44 24 04          	mov    %eax,0x4(%esp)
	int i;
	struct file *f;

	// 首先为新任务数据结构分配内存.如果内存分配出错,则返回出错码并退出.然后将新任务结构指针放入任务数组的nr项中.其中nr为任务号,由前面
	// find_empty_process()返回.接着把当前进程任务结构复制到刚申请到的内存页面p开始处.
	p = (struct task_struct *) get_free_page();
    8b95:	8b 5c 24 04          	mov    0x4(%esp),%ebx
    8b99:	e8 4e 54 00 00       	call   dfec <get_free_page>
    8b9e:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!p)
    8ba2:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    8ba7:	75 0a                	jne    8bb3 <copy_process+0x33>
		return -EAGAIN;
    8ba9:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    8bae:	e9 59 06 00 00       	jmp    920c <copy_process+0x68c>
	task[nr] = p;
    8bb3:	8b 44 24 04          	mov    0x4(%esp),%eax
    8bb7:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    8bbd:	8b 54 24 40          	mov    0x40(%esp),%edx
    8bc1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    8bc5:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
	*p = *current;							/* NOTE! this doesn't copy the supervisor stack */	/* 注意!这样不会复制超级用户堆栈(只复制进程结构) */
    8bc8:	8b 44 24 04          	mov    0x4(%esp),%eax
    8bcc:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8bd2:	8b 00                	mov    (%eax),%eax
    8bd4:	8b 54 24 18          	mov    0x18(%esp),%edx
    8bd8:	89 c3                	mov    %eax,%ebx
    8bda:	b8 21 01 00 00       	mov    $0x121,%eax
    8bdf:	89 d7                	mov    %edx,%edi
    8be1:	89 de                	mov    %ebx,%esi
    8be3:	89 c1                	mov    %eax,%ecx
    8be5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	//	memcpy(p, current, sizeof(struct task_struct));
	// 随后对复制来的进程结构内容进行一些修改,作为新进程的任务结构.先将新进程的状态置为不可中断等待状态,以防止内核调试其执行.然后设置新进程
	// 的进程号pid,并初始化进程运行时间片值等于其priorty值(一般为16个嘀嗒).接着复位新进程的信号位图,报警定时值,会话(session)领导标志
	// leader,进程及其子进程在内核和用户态运行时间统计值,还设置进程开始运行的系统时间start_time.
	p->state = TASK_UNINTERRUPTIBLE;
    8be7:	8b 44 24 18          	mov    0x18(%esp),%eax
    8beb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	p->pid = last_pid;						// 新进程号.也由find_empty_process()得到.
    8bf1:	8b 44 24 04          	mov    0x4(%esp),%eax
    8bf5:	8b 90 c8 1e 00 00    	mov    0x1ec8(%eax),%edx
    8bfb:	8b 44 24 18          	mov    0x18(%esp),%eax
    8bff:	89 90 2c 02 00 00    	mov    %edx,0x22c(%eax)
	p->counter = p->priority;				// 运行时间片值(嘀嗒数).
    8c05:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c09:	8b 50 08             	mov    0x8(%eax),%edx
    8c0c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c10:	89 50 04             	mov    %edx,0x4(%eax)
	p->signal = 0;							// 信号位图.
    8c13:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c17:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	p->alarm = 0;							// 报警定时值(嘀嗒数).
    8c1e:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c22:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%eax)
    8c29:	00 00 00 
	p->leader = 0;							/* process leadership doesn't inherit */	/* 进程的领导权是不能继承的 */
    8c2c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c30:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
    8c37:	00 00 00 
	p->utime = p->stime = 0;				// 用户态时间和核心态运行时间.
    8c3a:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c3e:	c7 80 e4 02 00 00 00 	movl   $0x0,0x2e4(%eax)
    8c45:	00 00 00 
    8c48:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c4c:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    8c52:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c56:	89 90 e0 02 00 00    	mov    %edx,0x2e0(%eax)
	p->cutime = p->cstime = 0;				// 子进程用户态和核心态运行时间.
    8c5c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c60:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%eax)
    8c67:	00 00 00 
    8c6a:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c6e:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
    8c74:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c78:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%eax)
	p->start_time = jiffies;				// 进程开始运行时间(当前时间滴答数).
    8c7e:	8b 44 24 04          	mov    0x4(%esp),%eax
    8c82:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    8c88:	8b 00                	mov    (%eax),%eax
    8c8a:	89 c2                	mov    %eax,%edx
    8c8c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c90:	89 90 f0 02 00 00    	mov    %edx,0x2f0(%eax)
	// 再修改任务状态段TSS数据.由于系统给任务结构p分配了1页新内存,所以(PAGE_SIZE + (long) p)让esp0正好指向该页顶端.ss0:esp0用作程序在内核
	// 态执行时的栈.另外,在第3章中我们已经知道,每个任务在GDT表中都有两个段描述符,一个是任务的TSS段描述符,另一个是任务的LDT表段描述符.下面语句就是
	// 把GDT中本任务LDT段描述符的选择符保存在本任务的TSS段.当CPU执行切换任务时,会自动从TSS中把LDT段描述符的选择符加载到ldtr寄存器中.
	p->tss.back_link = 0;
    8c96:	8b 44 24 18          	mov    0x18(%esp),%eax
    8c9a:	c7 80 b0 03 00 00 00 	movl   $0x0,0x3b0(%eax)
    8ca1:	00 00 00 
	p->tss.esp0 = PAGE_SIZE + (long) p;		// 任务内核态栈指针.
    8ca4:	8b 44 24 18          	mov    0x18(%esp),%eax
    8ca8:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
    8cae:	8b 44 24 18          	mov    0x18(%esp),%eax
    8cb2:	89 90 b4 03 00 00    	mov    %edx,0x3b4(%eax)
	p->tss.ss0 = 0x10;              		// 内核态栈的段选择符(与内核数据段相同).
    8cb8:	8b 44 24 18          	mov    0x18(%esp),%eax
    8cbc:	c7 80 b8 03 00 00 10 	movl   $0x10,0x3b8(%eax)
    8cc3:	00 00 00 
	p->tss.eip = eip;						// 指令代码指针.
    8cc6:	8b 44 24 18          	mov    0x18(%esp),%eax
    8cca:	8b 54 24 74          	mov    0x74(%esp),%edx
    8cce:	89 90 d0 03 00 00    	mov    %edx,0x3d0(%eax)
	p->tss.eflags = eflags;					// 标志寄存器.
    8cd4:	8b 44 24 18          	mov    0x18(%esp),%eax
    8cd8:	8b 54 24 7c          	mov    0x7c(%esp),%edx
    8cdc:	89 90 d4 03 00 00    	mov    %edx,0x3d4(%eax)
	p->tss.eax = 0;							// 这是当fork()返回时新进程会返回0的原因所在.
    8ce2:	8b 44 24 18          	mov    0x18(%esp),%eax
    8ce6:	c7 80 d8 03 00 00 00 	movl   $0x0,0x3d8(%eax)
    8ced:	00 00 00 
	p->tss.ecx = ecx;
    8cf0:	8b 44 24 18          	mov    0x18(%esp),%eax
    8cf4:	8b 54 24 5c          	mov    0x5c(%esp),%edx
    8cf8:	89 90 dc 03 00 00    	mov    %edx,0x3dc(%eax)
	p->tss.edx = edx;
    8cfe:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d02:	8b 54 24 60          	mov    0x60(%esp),%edx
    8d06:	89 90 e0 03 00 00    	mov    %edx,0x3e0(%eax)
	p->tss.ebx = ebx;
    8d0c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d10:	8b 54 24 58          	mov    0x58(%esp),%edx
    8d14:	89 90 e4 03 00 00    	mov    %edx,0x3e4(%eax)
	p->tss.esp = esp;
    8d1a:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d1e:	8b 94 24 80 00 00 00 	mov    0x80(%esp),%edx
    8d25:	89 90 e8 03 00 00    	mov    %edx,0x3e8(%eax)
	p->tss.ebp = ebp;
    8d2b:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d2f:	8b 54 24 44          	mov    0x44(%esp),%edx
    8d33:	89 90 ec 03 00 00    	mov    %edx,0x3ec(%eax)
	p->tss.esi = esi;
    8d39:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d3d:	8b 54 24 4c          	mov    0x4c(%esp),%edx
    8d41:	89 90 f0 03 00 00    	mov    %edx,0x3f0(%eax)
	p->tss.edi = edi;
    8d47:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d4b:	8b 54 24 48          	mov    0x48(%esp),%edx
    8d4f:	89 90 f4 03 00 00    	mov    %edx,0x3f4(%eax)
	p->tss.es = es & 0xffff;				// 段寄存器仅16位有效.
    8d55:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    8d59:	0f b7 d0             	movzwl %ax,%edx
    8d5c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d60:	89 90 f8 03 00 00    	mov    %edx,0x3f8(%eax)
	p->tss.cs = cs & 0xffff;
    8d66:	8b 44 24 78          	mov    0x78(%esp),%eax
    8d6a:	0f b7 d0             	movzwl %ax,%edx
    8d6d:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d71:	89 90 fc 03 00 00    	mov    %edx,0x3fc(%eax)
	p->tss.ss = ss & 0xffff;
    8d77:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
    8d7e:	0f b7 d0             	movzwl %ax,%edx
    8d81:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d85:	89 90 00 04 00 00    	mov    %edx,0x400(%eax)
	p->tss.ds = ds & 0xffff;
    8d8b:	8b 44 24 70          	mov    0x70(%esp),%eax
    8d8f:	0f b7 d0             	movzwl %ax,%edx
    8d92:	8b 44 24 18          	mov    0x18(%esp),%eax
    8d96:	89 90 04 04 00 00    	mov    %edx,0x404(%eax)
	p->tss.fs = fs & 0xffff;
    8d9c:	8b 44 24 68          	mov    0x68(%esp),%eax
    8da0:	0f b7 d0             	movzwl %ax,%edx
    8da3:	8b 44 24 18          	mov    0x18(%esp),%eax
    8da7:	89 90 08 04 00 00    	mov    %edx,0x408(%eax)
	p->tss.gs = gs & 0xffff;
    8dad:	8b 44 24 50          	mov    0x50(%esp),%eax
    8db1:	0f b7 d0             	movzwl %ax,%edx
    8db4:	8b 44 24 18          	mov    0x18(%esp),%eax
    8db8:	89 90 0c 04 00 00    	mov    %edx,0x40c(%eax)
	p->tss.ldt = _LDT(nr);					// 任务局部表描述符的选择符(LDT描述符在GET中).
    8dbe:	8b 44 24 40          	mov    0x40(%esp),%eax
    8dc2:	c1 e0 04             	shl    $0x4,%eax
    8dc5:	83 c0 28             	add    $0x28,%eax
    8dc8:	89 c2                	mov    %eax,%edx
    8dca:	8b 44 24 18          	mov    0x18(%esp),%eax
    8dce:	89 90 10 04 00 00    	mov    %edx,0x410(%eax)
	p->tss.trace_bitmap = 0x80000000;		// (高16位有效).
    8dd4:	8b 44 24 18          	mov    0x18(%esp),%eax
    8dd8:	c7 80 14 04 00 00 00 	movl   $0x80000000,0x414(%eax)
    8ddf:	00 00 80 
	// 如果当前任务使用了协处理器,就保存其上下文.汇编指令clts用于清除控制寄存器CR0中的任务已交换(TS)标志.每当发生任务切换,CPU都会设置该标志.该标志用于管理
	// 数学协处理器:如果该标志置位,那么每个ESC指令都会被捕获(异常7).如果协处理器存在标志MP也同时置位的话,那么WAIT指令也会捕获.因此,如果任务切换发生在一个
	// ESC指令开始执行之后,则协处理器中的内容就可能需要在执行新的ESC指令之前保存起来.捕获处理句柄会保存协处理器的内容并复位TS标志.指令fnsave用于把协处理器的
	// 所有状态保存到目的操作数指定的内存区域中(tss.i387).
	if (last_task_used_math == current)
    8de2:	8b 44 24 04          	mov    0x4(%esp),%eax
    8de6:	c7 c0 8c 3b 03 00    	mov    $0x33b8c,%eax
    8dec:	8b 10                	mov    (%eax),%edx
    8dee:	8b 44 24 04          	mov    0x4(%esp),%eax
    8df2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8df8:	8b 00                	mov    (%eax),%eax
    8dfa:	39 c2                	cmp    %eax,%edx
    8dfc:	75 12                	jne    8e10 <copy_process+0x290>
		__asm__("clts ; fnsave %0 ; frstor %0"::"m" (p->tss.i387));
    8dfe:	8b 44 24 18          	mov    0x18(%esp),%eax
    8e02:	0f 06                	clts   
    8e04:	dd b0 18 04 00 00    	fnsave 0x418(%eax)
    8e0a:	dd a0 18 04 00 00    	frstor 0x418(%eax)
	// 接下来复制进程页表.即在线性地址空间设置新任务代码段和数据段描述符中的基址和限长,并复制页表.如果出错(返回值不是0),则复位任务数组中相应项并
	// 释放为该新任务分配的用于任务结构的内存页.
	if (copy_mem(nr, p)) {					// 返回不为0示出错.
    8e10:	83 ec 08             	sub    $0x8,%esp
    8e13:	ff 74 24 20          	pushl  0x20(%esp)
    8e17:	ff 74 24 4c          	pushl  0x4c(%esp)
    8e1b:	e8 87 fb ff ff       	call   89a7 <copy_mem>
    8e20:	83 c4 10             	add    $0x10,%esp
    8e23:	85 c0                	test   %eax,%eax
    8e25:	74 33                	je     8e5a <copy_process+0x2da>
		task[nr] = NULL;
    8e27:	8b 44 24 04          	mov    0x4(%esp),%eax
    8e2b:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    8e31:	8b 54 24 40          	mov    0x40(%esp),%edx
    8e35:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
		free_page((long) p);
    8e3c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8e40:	83 ec 0c             	sub    $0xc,%esp
    8e43:	50                   	push   %eax
    8e44:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    8e48:	e8 22 3c 00 00       	call   ca6f <free_page>
    8e4d:	83 c4 10             	add    $0x10,%esp
		return -EAGAIN;
    8e50:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    8e55:	e9 b2 03 00 00       	jmp    920c <copy_process+0x68c>
	}
	// 如果父进程中有文件是打开的,则将对应文件的打开次数增1.因为这里创建的子进程会与父进程共享这些打开的文件.将当前进程(父进程)的pwd,root和
	// executable引用次数均增1.与上面同样的道理,子进程也引用了这些i节点.
	for (i = 0; i < NR_OPEN; i++)
    8e5a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    8e61:	00 
    8e62:	eb 35                	jmp    8e99 <copy_process+0x319>
		if (f = p->filp[i])
    8e64:	8b 44 24 18          	mov    0x18(%esp),%eax
    8e68:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    8e6c:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    8e72:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    8e76:	89 44 24 14          	mov    %eax,0x14(%esp)
    8e7a:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    8e7f:	74 13                	je     8e94 <copy_process+0x314>
			f->f_count++;
    8e81:	8b 44 24 14          	mov    0x14(%esp),%eax
    8e85:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8e89:	8d 50 01             	lea    0x1(%eax),%edx
    8e8c:	8b 44 24 14          	mov    0x14(%esp),%eax
    8e90:	66 89 50 04          	mov    %dx,0x4(%eax)
	for (i = 0; i < NR_OPEN; i++)
    8e94:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    8e99:	83 7c 24 1c 13       	cmpl   $0x13,0x1c(%esp)
    8e9e:	7e c4                	jle    8e64 <copy_process+0x2e4>
	if (current->pwd)
    8ea0:	8b 44 24 04          	mov    0x4(%esp),%eax
    8ea4:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8eaa:	8b 00                	mov    (%eax),%eax
    8eac:	8b 80 34 03 00 00    	mov    0x334(%eax),%eax
    8eb2:	85 c0                	test   %eax,%eax
    8eb4:	74 1d                	je     8ed3 <copy_process+0x353>
		current->pwd->i_count++;
    8eb6:	8b 44 24 04          	mov    0x4(%esp),%eax
    8eba:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8ec0:	8b 00                	mov    (%eax),%eax
    8ec2:	8b 80 34 03 00 00    	mov    0x334(%eax),%eax
    8ec8:	0f b7 50 34          	movzwl 0x34(%eax),%edx
    8ecc:	83 c2 01             	add    $0x1,%edx
    8ecf:	66 89 50 34          	mov    %dx,0x34(%eax)
	if (current->root)
    8ed3:	8b 44 24 04          	mov    0x4(%esp),%eax
    8ed7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8edd:	8b 00                	mov    (%eax),%eax
    8edf:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
    8ee5:	85 c0                	test   %eax,%eax
    8ee7:	74 1d                	je     8f06 <copy_process+0x386>
		current->root->i_count++;
    8ee9:	8b 44 24 04          	mov    0x4(%esp),%eax
    8eed:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8ef3:	8b 00                	mov    (%eax),%eax
    8ef5:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
    8efb:	0f b7 50 34          	movzwl 0x34(%eax),%edx
    8eff:	83 c2 01             	add    $0x1,%edx
    8f02:	66 89 50 34          	mov    %dx,0x34(%eax)
	if (current->executable)
    8f06:	8b 44 24 04          	mov    0x4(%esp),%eax
    8f0a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8f10:	8b 00                	mov    (%eax),%eax
    8f12:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
    8f18:	85 c0                	test   %eax,%eax
    8f1a:	74 1d                	je     8f39 <copy_process+0x3b9>
		current->executable->i_count++;
    8f1c:	8b 44 24 04          	mov    0x4(%esp),%eax
    8f20:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8f26:	8b 00                	mov    (%eax),%eax
    8f28:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
    8f2e:	0f b7 50 34          	movzwl 0x34(%eax),%edx
    8f32:	83 c2 01             	add    $0x1,%edx
    8f35:	66 89 50 34          	mov    %dx,0x34(%eax)
	if (current->library)
    8f39:	8b 44 24 04          	mov    0x4(%esp),%eax
    8f3d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8f43:	8b 00                	mov    (%eax),%eax
    8f45:	8b 80 40 03 00 00    	mov    0x340(%eax),%eax
    8f4b:	85 c0                	test   %eax,%eax
    8f4d:	74 1d                	je     8f6c <copy_process+0x3ec>
		current->library->i_count++;
    8f4f:	8b 44 24 04          	mov    0x4(%esp),%eax
    8f53:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    8f59:	8b 00                	mov    (%eax),%eax
    8f5b:	8b 80 40 03 00 00    	mov    0x340(%eax),%eax
    8f61:	0f b7 50 34          	movzwl 0x34(%eax),%edx
    8f65:	83 c2 01             	add    $0x1,%edx
    8f68:	66 89 50 34          	mov    %dx,0x34(%eax)
	// 设置等于父进程的最新子进程指针.若当前进程确实还有其他子进程,则让比邻老兄进程的最年轻进程指针p_yspter指向新进程.最后把当前进程的最新子进程指针指向这个新进程.
	// 然后把新进程设置成就绪态.最后返回新进程号.
	// 另外,set_tss_desc()和set_ldt_desc()定义在include/asm/system.h文件中."gdt+(nr<<1)+FIRST_TSS_ENTRY"是任务nr的TSS描述符项在全局表中的地址.
	// 因为每个任务占用GDT表中2项,因此上式中要包括'(nr<<1)'.
	// 请注意,在任务切换时,任务寄存器tr会由CPU自动加载.
	set_tss_desc(gdt + (nr << 1) + FIRST_TSS_ENTRY, &(p->tss));
    8f6c:	8b 44 24 18          	mov    0x18(%esp),%eax
    8f70:	05 b0 03 00 00       	add    $0x3b0,%eax
    8f75:	89 c7                	mov    %eax,%edi
    8f77:	8b 44 24 40          	mov    0x40(%esp),%eax
    8f7b:	01 c0                	add    %eax,%eax
    8f7d:	83 c0 04             	add    $0x4,%eax
    8f80:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    8f87:	8b 44 24 04          	mov    0x4(%esp),%eax
    8f8b:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    8f91:	01 d0                	add    %edx,%eax
    8f93:	89 c5                	mov    %eax,%ebp
    8f95:	8b 44 24 40          	mov    0x40(%esp),%eax
    8f99:	01 c0                	add    %eax,%eax
    8f9b:	83 c0 04             	add    $0x4,%eax
    8f9e:	c1 e0 03             	shl    $0x3,%eax
    8fa1:	8d 50 02             	lea    0x2(%eax),%edx
    8fa4:	8b 44 24 04          	mov    0x4(%esp),%eax
    8fa8:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    8fae:	01 d0                	add    %edx,%eax
    8fb0:	89 44 24 08          	mov    %eax,0x8(%esp)
    8fb4:	8b 44 24 40          	mov    0x40(%esp),%eax
    8fb8:	01 c0                	add    %eax,%eax
    8fba:	83 c0 04             	add    $0x4,%eax
    8fbd:	c1 e0 03             	shl    $0x3,%eax
    8fc0:	8d 50 04             	lea    0x4(%eax),%edx
    8fc3:	8b 44 24 04          	mov    0x4(%esp),%eax
    8fc7:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    8fcd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    8fd0:	8b 44 24 40          	mov    0x40(%esp),%eax
    8fd4:	01 c0                	add    %eax,%eax
    8fd6:	83 c0 04             	add    $0x4,%eax
    8fd9:	c1 e0 03             	shl    $0x3,%eax
    8fdc:	8d 50 05             	lea    0x5(%eax),%edx
    8fdf:	8b 44 24 04          	mov    0x4(%esp),%eax
    8fe3:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    8fe9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    8fec:	8b 44 24 40          	mov    0x40(%esp),%eax
    8ff0:	01 c0                	add    %eax,%eax
    8ff2:	83 c0 04             	add    $0x4,%eax
    8ff5:	c1 e0 03             	shl    $0x3,%eax
    8ff8:	8d 50 06             	lea    0x6(%eax),%edx
    8ffb:	8b 44 24 04          	mov    0x4(%esp),%eax
    8fff:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    9005:	8d 34 02             	lea    (%edx,%eax,1),%esi
    9008:	8b 44 24 40          	mov    0x40(%esp),%eax
    900c:	01 c0                	add    %eax,%eax
    900e:	83 c0 04             	add    $0x4,%eax
    9011:	c1 e0 03             	shl    $0x3,%eax
    9014:	8d 50 07             	lea    0x7(%eax),%edx
    9017:	8b 44 24 04          	mov    0x4(%esp),%eax
    901b:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    9021:	01 d0                	add    %edx,%eax
    9023:	89 44 24 0c          	mov    %eax,0xc(%esp)
    9027:	89 da                	mov    %ebx,%edx
    9029:	89 f8                	mov    %edi,%eax
    902b:	89 f3                	mov    %esi,%ebx
    902d:	89 ee                	mov    %ebp,%esi
    902f:	8b 7c 24 0c          	mov    0xc(%esp),%edi
    9033:	8b 6c 24 08          	mov    0x8(%esp),%ebp
    9037:	66 c7 06 68 00       	movw   $0x68,(%esi)
    903c:	66 89 45 00          	mov    %ax,0x0(%ebp)
    9040:	c1 c8 10             	ror    $0x10,%eax
    9043:	88 02                	mov    %al,(%edx)
    9045:	c6 01 89             	movb   $0x89,(%ecx)
    9048:	c6 03 00             	movb   $0x0,(%ebx)
    904b:	88 27                	mov    %ah,(%edi)
    904d:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt + (nr << 1) + FIRST_LDT_ENTRY, &(p->ldt));
    9050:	8b 44 24 18          	mov    0x18(%esp),%eax
    9054:	05 98 03 00 00       	add    $0x398,%eax
    9059:	89 c7                	mov    %eax,%edi
    905b:	8b 44 24 40          	mov    0x40(%esp),%eax
    905f:	01 c0                	add    %eax,%eax
    9061:	83 c0 05             	add    $0x5,%eax
    9064:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    906b:	8b 44 24 04          	mov    0x4(%esp),%eax
    906f:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    9075:	01 d0                	add    %edx,%eax
    9077:	89 c5                	mov    %eax,%ebp
    9079:	8b 44 24 40          	mov    0x40(%esp),%eax
    907d:	01 c0                	add    %eax,%eax
    907f:	83 c0 05             	add    $0x5,%eax
    9082:	c1 e0 03             	shl    $0x3,%eax
    9085:	8d 50 02             	lea    0x2(%eax),%edx
    9088:	8b 44 24 04          	mov    0x4(%esp),%eax
    908c:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    9092:	01 d0                	add    %edx,%eax
    9094:	89 44 24 08          	mov    %eax,0x8(%esp)
    9098:	8b 44 24 40          	mov    0x40(%esp),%eax
    909c:	01 c0                	add    %eax,%eax
    909e:	83 c0 05             	add    $0x5,%eax
    90a1:	c1 e0 03             	shl    $0x3,%eax
    90a4:	8d 50 04             	lea    0x4(%eax),%edx
    90a7:	8b 44 24 04          	mov    0x4(%esp),%eax
    90ab:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    90b1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    90b4:	8b 44 24 40          	mov    0x40(%esp),%eax
    90b8:	01 c0                	add    %eax,%eax
    90ba:	83 c0 05             	add    $0x5,%eax
    90bd:	c1 e0 03             	shl    $0x3,%eax
    90c0:	8d 50 05             	lea    0x5(%eax),%edx
    90c3:	8b 44 24 04          	mov    0x4(%esp),%eax
    90c7:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    90cd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    90d0:	8b 44 24 40          	mov    0x40(%esp),%eax
    90d4:	01 c0                	add    %eax,%eax
    90d6:	83 c0 05             	add    $0x5,%eax
    90d9:	c1 e0 03             	shl    $0x3,%eax
    90dc:	8d 50 06             	lea    0x6(%eax),%edx
    90df:	8b 44 24 04          	mov    0x4(%esp),%eax
    90e3:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    90e9:	8d 34 02             	lea    (%edx,%eax,1),%esi
    90ec:	8b 44 24 40          	mov    0x40(%esp),%eax
    90f0:	01 c0                	add    %eax,%eax
    90f2:	83 c0 05             	add    $0x5,%eax
    90f5:	c1 e0 03             	shl    $0x3,%eax
    90f8:	8d 50 07             	lea    0x7(%eax),%edx
    90fb:	8b 44 24 04          	mov    0x4(%esp),%eax
    90ff:	c7 c0 b8 5c 00 00    	mov    $0x5cb8,%eax
    9105:	01 d0                	add    %edx,%eax
    9107:	89 44 24 0c          	mov    %eax,0xc(%esp)
    910b:	89 da                	mov    %ebx,%edx
    910d:	89 f8                	mov    %edi,%eax
    910f:	89 f3                	mov    %esi,%ebx
    9111:	89 ee                	mov    %ebp,%esi
    9113:	8b 7c 24 0c          	mov    0xc(%esp),%edi
    9117:	8b 6c 24 08          	mov    0x8(%esp),%ebp
    911b:	66 c7 06 68 00       	movw   $0x68,(%esi)
    9120:	66 89 45 00          	mov    %ax,0x0(%ebp)
    9124:	c1 c8 10             	ror    $0x10,%eax
    9127:	88 02                	mov    %al,(%edx)
    9129:	c6 01 82             	movb   $0x82,(%ecx)
    912c:	c6 03 00             	movb   $0x0,(%ebx)
    912f:	88 27                	mov    %ah,(%edi)
    9131:	c1 c8 10             	ror    $0x10,%eax
	p->p_pptr = current;				// 设置新进程的父进程指针.
    9134:	8b 44 24 04          	mov    0x4(%esp),%eax
    9138:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    913e:	8b 10                	mov    (%eax),%edx
    9140:	8b 44 24 18          	mov    0x18(%esp),%eax
    9144:	89 90 bc 02 00 00    	mov    %edx,0x2bc(%eax)
	p->p_cptr = 0;						// 复位新进程的最新子进程指针.
    914a:	8b 44 24 18          	mov    0x18(%esp),%eax
    914e:	c7 80 c0 02 00 00 00 	movl   $0x0,0x2c0(%eax)
    9155:	00 00 00 
	p->p_ysptr = 0;						// 复位新进程的比邻年轻兄弟进程指针.
    9158:	8b 44 24 18          	mov    0x18(%esp),%eax
    915c:	c7 80 c4 02 00 00 00 	movl   $0x0,0x2c4(%eax)
    9163:	00 00 00 
	p->p_osptr = current->p_cptr;		// 设置新进程的比邻老兄兄弟进程指针.
    9166:	8b 44 24 04          	mov    0x4(%esp),%eax
    916a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    9170:	8b 00                	mov    (%eax),%eax
    9172:	8b 90 c0 02 00 00    	mov    0x2c0(%eax),%edx
    9178:	8b 44 24 18          	mov    0x18(%esp),%eax
    917c:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%eax)
	if (p->p_osptr)						// 若新进程有老兄兄弟进程,则让其年轻进程兄弟指针指向新进程
    9182:	8b 44 24 18          	mov    0x18(%esp),%eax
    9186:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    918c:	85 c0                	test   %eax,%eax
    918e:	74 14                	je     91a4 <copy_process+0x624>
		p->p_osptr->p_ysptr = p;
    9190:	8b 44 24 18          	mov    0x18(%esp),%eax
    9194:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    919a:	8b 54 24 18          	mov    0x18(%esp),%edx
    919e:	89 90 c4 02 00 00    	mov    %edx,0x2c4(%eax)
	current->p_cptr = p;				// 让当前进程最新子进程指针指向新进程.
    91a4:	8b 44 24 04          	mov    0x4(%esp),%eax
    91a8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    91ae:	8b 00                	mov    (%eax),%eax
    91b0:	8b 54 24 18          	mov    0x18(%esp),%edx
    91b4:	89 90 c0 02 00 00    	mov    %edx,0x2c0(%eax)
	p->state = TASK_RUNNING;			/* do this last, just in case */        /* 设置进程状态为待运行状态栏 */
    91ba:	8b 44 24 18          	mov    0x18(%esp),%eax
    91be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	Log(LOG_INFO_TYPE, "<<<<< fork new process current_pid = %d, child_pid = %d, nr = %d >>>>>\n", current->pid, p->pid, nr);
    91c4:	8b 44 24 18          	mov    0x18(%esp),%eax
    91c8:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    91ce:	8b 44 24 04          	mov    0x4(%esp),%eax
    91d2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    91d8:	8b 00                	mov    (%eax),%eax
    91da:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    91e0:	83 ec 0c             	sub    $0xc,%esp
    91e3:	ff 74 24 4c          	pushl  0x4c(%esp)
    91e7:	52                   	push   %edx
    91e8:	50                   	push   %eax
    91e9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    91ed:	8d 80 94 44 ff ff    	lea    -0xbb6c(%eax),%eax
    91f3:	50                   	push   %eax
    91f4:	6a 00                	push   $0x0
    91f6:	8b 5c 24 24          	mov    0x24(%esp),%ebx
    91fa:	e8 a0 c9 01 00       	call   25b9f <Log>
    91ff:	83 c4 20             	add    $0x20,%esp
	return last_pid;        			// 返回新进程号
    9202:	8b 44 24 04          	mov    0x4(%esp),%eax
    9206:	8b 80 c8 1e 00 00    	mov    0x1ec8(%eax),%eax
}
    920c:	83 c4 2c             	add    $0x2c,%esp
    920f:	5b                   	pop    %ebx
    9210:	5e                   	pop    %esi
    9211:	5f                   	pop    %edi
    9212:	5d                   	pop    %ebp
    9213:	c3                   	ret    

00009214 <find_empty_process>:

// 为新进程取得不重复的进程号last_pid.函数返回在任务数组中的任务号(数组项).
int find_empty_process(void)
{
    9214:	83 ec 10             	sub    $0x10,%esp
    9217:	e8 d6 da ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    921c:	05 e4 8d 02 00       	add    $0x28de4,%eax
    9221:	eb 01                	jmp    9224 <find_empty_process+0x10>
	int i;

	// 首先获取新的进程号.如果last_pid增1后超出进程号的正数表示范围,则重新从1开始使用pid号.然后在任务数组中搜索刚设置的pid号是
	// 否已经被任何任务使用.如果是则跳转到函数开始处理重新获得一个pid号.接着在任务数组中为新任务寻找一个空闲项,并返回项号.last_pid是一
	// 个全局变量,不用返回.如果此时任务数组中64个项已经被全部占用,则返回出错码.
	repeat:
    9223:	90                   	nop
		if ((++last_pid) < 0) last_pid = 1;
    9224:	8b 90 c8 1e 00 00    	mov    0x1ec8(%eax),%edx
    922a:	83 c2 01             	add    $0x1,%edx
    922d:	89 90 c8 1e 00 00    	mov    %edx,0x1ec8(%eax)
    9233:	8b 90 c8 1e 00 00    	mov    0x1ec8(%eax),%edx
    9239:	85 d2                	test   %edx,%edx
    923b:	79 0a                	jns    9247 <find_empty_process+0x33>
    923d:	c7 80 c8 1e 00 00 01 	movl   $0x1,0x1ec8(%eax)
    9244:	00 00 00 
		for(i = 0 ; i < NR_TASKS ; i++)
    9247:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    924e:	00 
    924f:	eb 50                	jmp    92a1 <find_empty_process+0x8d>
			if (task[i] && ((task[i]->pid == last_pid) ||
    9251:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    9257:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    925b:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
    925e:	85 d2                	test   %edx,%edx
    9260:	74 3a                	je     929c <find_empty_process+0x88>
    9262:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    9268:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    926c:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
    926f:	8b 8a 2c 02 00 00    	mov    0x22c(%edx),%ecx
    9275:	8b 90 c8 1e 00 00    	mov    0x1ec8(%eax),%edx
    927b:	39 d1                	cmp    %edx,%ecx
    927d:	74 a4                	je     9223 <find_empty_process+0xf>
				        (task[i]->pgrp == last_pid)))
    927f:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    9285:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    9289:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
    928c:	8b 8a 30 02 00 00    	mov    0x230(%edx),%ecx
    9292:	8b 90 c8 1e 00 00    	mov    0x1ec8(%eax),%edx
			if (task[i] && ((task[i]->pid == last_pid) ||
    9298:	39 d1                	cmp    %edx,%ecx
    929a:	74 87                	je     9223 <find_empty_process+0xf>
		for(i = 0 ; i < NR_TASKS ; i++)
    929c:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    92a1:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    92a6:	7e a9                	jle    9251 <find_empty_process+0x3d>
				goto repeat;
	for(i = 1 ; i < NR_TASKS ; i++)
    92a8:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    92af:	00 
    92b0:	eb 1c                	jmp    92ce <find_empty_process+0xba>
		if (!task[i])
    92b2:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    92b8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    92bc:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
    92bf:	85 d2                	test   %edx,%edx
    92c1:	75 06                	jne    92c9 <find_empty_process+0xb5>
			return i;
    92c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    92c7:	eb 11                	jmp    92da <find_empty_process+0xc6>
	for(i = 1 ; i < NR_TASKS ; i++)
    92c9:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    92ce:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    92d3:	7e dd                	jle    92b2 <find_empty_process+0x9e>
	return -EAGAIN;
    92d5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
    92da:	83 c4 10             	add    $0x10,%esp
    92dd:	c3                   	ret    

000092de <panic>:
// 如果当前进程是任务0的话,还说明是交换任务出错,并且还没有运行文件系统同步函数.
// 函数名前的关键字volatile用于告诉编译器gcc该函数不会返回.这样可让gcc产生更好一些的代码,更重要的是使用这个关键字
// 以避免产生某些(未初始化变量的)假警告信息.
// 等同于现在gcc的函数属性说明:void panic(const char *s) __attribute__((noreturn));
void panic(const char * s)
{
    92de:	53                   	push   %ebx
    92df:	83 ec 08             	sub    $0x8,%esp
    92e2:	e8 13 da ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    92e7:	81 c3 19 8d 02 00    	add    $0x28d19,%ebx
	printk("Kernel panic: %s\n\r", s);
    92ed:	83 ec 08             	sub    $0x8,%esp
    92f0:	ff 74 24 18          	pushl  0x18(%esp)
    92f4:	8d 83 dc 44 ff ff    	lea    -0xbb24(%ebx),%eax
    92fa:	50                   	push   %eax
    92fb:	e8 32 00 00 00       	call   9332 <printk>
    9300:	83 c4 10             	add    $0x10,%esp
	if (current == task[0])
    9303:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    9309:	8b 10                	mov    (%eax),%edx
    930b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    9311:	8b 00                	mov    (%eax),%eax
    9313:	39 c2                	cmp    %eax,%edx
    9315:	75 14                	jne    932b <panic+0x4d>
		printk("In swapper task - not syncing\n\r");
    9317:	83 ec 0c             	sub    $0xc,%esp
    931a:	8d 83 f0 44 ff ff    	lea    -0xbb10(%ebx),%eax
    9320:	50                   	push   %eax
    9321:	e8 0c 00 00 00       	call   9332 <printk>
    9326:	83 c4 10             	add    $0x10,%esp
    9329:	eb 05                	jmp    9330 <panic+0x52>
	else
		sys_sync();
    932b:	e8 69 6e 00 00       	call   10199 <sys_sync>
	for(;;);
    9330:	eb fe                	jmp    9330 <panic+0x52>

00009332 <printk>:
// 函数vsprintf()定义在linux/kernel/vsprintf.c中
extern int vsprintf(char * buf, const char * fmt, va_list args);

// 内核使用的显示函数.
int printk(const char *fmt, ...)
{
    9332:	53                   	push   %ebx
    9333:	83 ec 18             	sub    $0x18,%esp
    9336:	e8 bf d9 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    933b:	81 c3 c5 8c 02 00    	add    $0x28cc5,%ebx
	va_list args;							// va_list实际上是一个字符指针类型.
	int i;

	// 运行参数处理开始函数.然后使用格式串fmt将参数列表args输出到buf中.返回值i等于输出字符串的长度.再运行参数处理结束函数.最后调用控制台显示
	// 函数并返回显示字符数.
	va_start(args, fmt);
    9341:	8d 44 24 24          	lea    0x24(%esp),%eax
    9345:	89 44 24 0c          	mov    %eax,0xc(%esp)
	i = vsprintf(buf, fmt, args);
    9349:	8b 44 24 20          	mov    0x20(%esp),%eax
    934d:	83 ec 04             	sub    $0x4,%esp
    9350:	ff 74 24 10          	pushl  0x10(%esp)
    9354:	50                   	push   %eax
    9355:	8d 83 e0 1e 00 00    	lea    0x1ee0(%ebx),%eax
    935b:	50                   	push   %eax
    935c:	e8 34 03 00 00       	call   9695 <vsprintf>
    9361:	83 c4 10             	add    $0x10,%esp
    9364:	89 44 24 08          	mov    %eax,0x8(%esp)
	va_end(args);
	console_print(buf);						// chr_drv/console.c
    9368:	83 ec 0c             	sub    $0xc,%esp
    936b:	8d 83 e0 1e 00 00    	lea    0x1ee0(%ebx),%eax
    9371:	50                   	push   %eax
    9372:	e8 bf 6d 01 00       	call   20136 <console_print>
    9377:	83 c4 10             	add    $0x10,%esp
	return i;
    937a:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    937e:	83 c4 18             	add    $0x18,%esp
    9381:	5b                   	pop    %ebx
    9382:	c3                   	ret    

00009383 <strlen>:
// 计算字符串长度.
// 参数:s - 字符串
// %0 - ecx(__res),%1 - edi(字符串指针s),%2 - eax(0),%3 - ecx(0xffffffff).
// 返回:返回字符串长度.
static inline int strlen(const char * s)
{
    9383:	57                   	push   %edi
    9384:	e8 69 d9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9389:	05 77 8c 02 00       	add    $0x28c77,%eax
register int __res __asm__("cx");       					// __res是寄存器变量(ecx).
__asm__(
    938e:	8b 54 24 08          	mov    0x8(%esp),%edx
    9392:	b8 00 00 00 00       	mov    $0x0,%eax
    9397:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    939c:	89 d7                	mov    %edx,%edi
    939e:	fc                   	cld    
    939f:	f2 ae                	repnz scas %es:(%edi),%al
    93a1:	f7 d1                	not    %ecx
    93a3:	49                   	dec    %ecx
	"repne\n\t"												// al(0)与字符串中字符es:[edi比较,
	"scasb\n\t"												// 若不相等就一直比较.
	"notl %0\n\t"											// ecx取反.
	"decl %0"												// ecx--,得字符串的长度值.
	:"=c" (__res):"D" (s), "a" (0), "0" (0xffffffff));
return __res;												// 返回字符串长度值.
    93a4:	89 c8                	mov    %ecx,%eax
}
    93a6:	5f                   	pop    %edi
    93a7:	c3                   	ret    

000093a8 <skip_atoi>:
/* 我们使用下面的定义,这样我们就可以不使用ctype库了 */
#define is_digit(c)	((c) >= '0' && (c) <= '9')	// 判断字符c是否为数字字符.

// 该函数将字符数字串转换成整数.输入是数字串指针的指针,返回是结果数值.另外指针将前移.
static int skip_atoi(const char **s)
{
    93a8:	53                   	push   %ebx
    93a9:	83 ec 10             	sub    $0x10,%esp
    93ac:	e8 41 d9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    93b1:	05 4f 8c 02 00       	add    $0x28c4f,%eax
	int i = 0;
    93b6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    93bd:	00 

	while (is_digit(**s))
    93be:	eb 2d                	jmp    93ed <skip_atoi+0x45>
		i = i*10 + *((*s)++) - '0';
    93c0:	8b 54 24 0c          	mov    0xc(%esp),%edx
    93c4:	89 d0                	mov    %edx,%eax
    93c6:	c1 e0 02             	shl    $0x2,%eax
    93c9:	01 d0                	add    %edx,%eax
    93cb:	01 c0                	add    %eax,%eax
    93cd:	89 c3                	mov    %eax,%ebx
    93cf:	8b 44 24 18          	mov    0x18(%esp),%eax
    93d3:	8b 00                	mov    (%eax),%eax
    93d5:	8d 48 01             	lea    0x1(%eax),%ecx
    93d8:	8b 54 24 18          	mov    0x18(%esp),%edx
    93dc:	89 0a                	mov    %ecx,(%edx)
    93de:	0f b6 00             	movzbl (%eax),%eax
    93e1:	0f be c0             	movsbl %al,%eax
    93e4:	01 d8                	add    %ebx,%eax
    93e6:	83 e8 30             	sub    $0x30,%eax
    93e9:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (is_digit(**s))
    93ed:	8b 44 24 18          	mov    0x18(%esp),%eax
    93f1:	8b 00                	mov    (%eax),%eax
    93f3:	0f b6 00             	movzbl (%eax),%eax
    93f6:	3c 2f                	cmp    $0x2f,%al
    93f8:	7e 0d                	jle    9407 <skip_atoi+0x5f>
    93fa:	8b 44 24 18          	mov    0x18(%esp),%eax
    93fe:	8b 00                	mov    (%eax),%eax
    9400:	0f b6 00             	movzbl (%eax),%eax
    9403:	3c 39                	cmp    $0x39,%al
    9405:	7e b9                	jle    93c0 <skip_atoi+0x18>
	return i;
    9407:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    940b:	83 c4 10             	add    $0x10,%esp
    940e:	5b                   	pop    %ebx
    940f:	c3                   	ret    

00009410 <number>:
// 将整数转换为指定进制的字符串.
// 输入: num-整数; base-进制; size-字符串长度;precision-数字长度(精度);type-类型选项.
// 输出: 数字转换成字符串后指向该字符串末端后面的指针.
static char * number(char * str, int num, int base, int size, int precision
	,int type)
{
    9410:	83 ec 40             	sub    $0x40,%esp
    9413:	e8 da d8 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9418:	05 e8 8b 02 00       	add    $0x28be8,%eax
	char c,sign,tmp[36];
	const char *digits="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    941d:	8d 90 10 45 ff ff    	lea    -0xbaf0(%eax),%edx
    9423:	89 54 24 38          	mov    %edx,0x38(%esp)
	int i;

	// 如果类型type指出用小写字母,则定义小写字母集.
	// 如果类型指出要左调整(靠左边界),则屏蔽类型中的填零标志.
	// 如果进制基数小于2或大于36,则退出处理,即本程序只能处理基数在2-36之间的数.
	if (type & SMALL) digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    9427:	8b 54 24 58          	mov    0x58(%esp),%edx
    942b:	83 e2 40             	and    $0x40,%edx
    942e:	85 d2                	test   %edx,%edx
    9430:	74 0a                	je     943c <number+0x2c>
    9432:	8d 80 38 45 ff ff    	lea    -0xbac8(%eax),%eax
    9438:	89 44 24 38          	mov    %eax,0x38(%esp)
	if (type & LEFT) type &= ~ZEROPAD;
    943c:	8b 44 24 58          	mov    0x58(%esp),%eax
    9440:	83 e0 10             	and    $0x10,%eax
    9443:	85 c0                	test   %eax,%eax
    9445:	74 05                	je     944c <number+0x3c>
    9447:	83 64 24 58 fe       	andl   $0xfffffffe,0x58(%esp)
	if (base < 2 || base > 36)
    944c:	83 7c 24 4c 01       	cmpl   $0x1,0x4c(%esp)
    9451:	7e 07                	jle    945a <number+0x4a>
    9453:	83 7c 24 4c 24       	cmpl   $0x24,0x4c(%esp)
    9458:	7e 0a                	jle    9464 <number+0x54>
		return 0;
    945a:	b8 00 00 00 00       	mov    $0x0,%eax
    945f:	e9 2d 02 00 00       	jmp    9691 <number+0x281>
	// 如果类型指出要填零,则置字符变量c='0',否则c等于空格字符.
	// 如果类型指出是带符号数并且数值num小于0,则置符号变量sign=负号,并使num取绝对值.
	// 否则如果类型指出是加号,则置sign=加号,否则若类型带空格标志则sign=空格,否则置0.
	c = (type & ZEROPAD) ? '0' : ' ' ;
    9464:	8b 44 24 58          	mov    0x58(%esp),%eax
    9468:	83 e0 01             	and    $0x1,%eax
    946b:	85 c0                	test   %eax,%eax
    946d:	74 07                	je     9476 <number+0x66>
    946f:	b8 30 00 00 00       	mov    $0x30,%eax
    9474:	eb 05                	jmp    947b <number+0x6b>
    9476:	b8 20 00 00 00       	mov    $0x20,%eax
    947b:	88 44 24 33          	mov    %al,0x33(%esp)
	if (type & SIGN && num < 0) {
    947f:	8b 44 24 58          	mov    0x58(%esp),%eax
    9483:	83 e0 02             	and    $0x2,%eax
    9486:	85 c0                	test   %eax,%eax
    9488:	74 12                	je     949c <number+0x8c>
    948a:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
    948f:	79 0b                	jns    949c <number+0x8c>
		sign = '-';
    9491:	c6 44 24 3f 2d       	movb   $0x2d,0x3f(%esp)
		num = -num;
    9496:	f7 5c 24 48          	negl   0x48(%esp)
    949a:	eb 20                	jmp    94bc <number+0xac>
	} else
		sign = (type & PLUS) ? '+' : ((type & SPACE) ? ' ' : 0);
    949c:	8b 44 24 58          	mov    0x58(%esp),%eax
    94a0:	83 e0 04             	and    $0x4,%eax
    94a3:	85 c0                	test   %eax,%eax
    94a5:	75 0c                	jne    94b3 <number+0xa3>
    94a7:	8b 44 24 58          	mov    0x58(%esp),%eax
    94ab:	c1 e0 02             	shl    $0x2,%eax
    94ae:	83 e0 20             	and    $0x20,%eax
    94b1:	eb 05                	jmp    94b8 <number+0xa8>
    94b3:	b8 2b 00 00 00       	mov    $0x2b,%eax
    94b8:	88 44 24 3f          	mov    %al,0x3f(%esp)
	// 若带符号,则宽度值减1.若类型指出是特殊转换,则对十六进制宽度再减少2位(用于0x),对于八进制宽度减1(用于八进制转换结果前放一个零).
	if (sign) size--;
    94bc:	80 7c 24 3f 00       	cmpb   $0x0,0x3f(%esp)
    94c1:	74 05                	je     94c8 <number+0xb8>
    94c3:	83 6c 24 50 01       	subl   $0x1,0x50(%esp)
	if (type & SPECIAL)
    94c8:	8b 44 24 58          	mov    0x58(%esp),%eax
    94cc:	83 e0 20             	and    $0x20,%eax
    94cf:	85 c0                	test   %eax,%eax
    94d1:	74 1a                	je     94ed <number+0xdd>
		if (base == 16) size -= 2;
    94d3:	83 7c 24 4c 10       	cmpl   $0x10,0x4c(%esp)
    94d8:	75 07                	jne    94e1 <number+0xd1>
    94da:	83 6c 24 50 02       	subl   $0x2,0x50(%esp)
    94df:	eb 0c                	jmp    94ed <number+0xdd>
		else if (base == 8) size--;
    94e1:	83 7c 24 4c 08       	cmpl   $0x8,0x4c(%esp)
    94e6:	75 05                	jne    94ed <number+0xdd>
    94e8:	83 6c 24 50 01       	subl   $0x1,0x50(%esp)
	// 如果数值num为0,则临时字符串='0';否则根据给定的基数将数值num转换成字符形式.
	i = 0;
    94ed:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
    94f4:	00 
	if (num == 0)
    94f5:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
    94fa:	75 48                	jne    9544 <number+0x134>
		tmp[i++] = '0';
    94fc:	8b 44 24 34          	mov    0x34(%esp),%eax
    9500:	8d 50 01             	lea    0x1(%eax),%edx
    9503:	89 54 24 34          	mov    %edx,0x34(%esp)
    9507:	c6 44 04 08 30       	movb   $0x30,0x8(%esp,%eax,1)
    950c:	eb 3d                	jmp    954b <number+0x13b>
	else while (num != 0)
		tmp[i++] = digits[do_div(num, base)];
    950e:	8b 44 24 48          	mov    0x48(%esp),%eax
    9512:	ba 00 00 00 00       	mov    $0x0,%edx
    9517:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
    951b:	f7 f1                	div    %ecx
    951d:	89 44 24 48          	mov    %eax,0x48(%esp)
    9521:	89 54 24 2c          	mov    %edx,0x2c(%esp)
    9525:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    9529:	89 c2                	mov    %eax,%edx
    952b:	8b 44 24 38          	mov    0x38(%esp),%eax
    952f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    9532:	8b 44 24 34          	mov    0x34(%esp),%eax
    9536:	8d 50 01             	lea    0x1(%eax),%edx
    9539:	89 54 24 34          	mov    %edx,0x34(%esp)
    953d:	0f b6 11             	movzbl (%ecx),%edx
    9540:	88 54 04 08          	mov    %dl,0x8(%esp,%eax,1)
	else while (num != 0)
    9544:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
    9549:	75 c3                	jne    950e <number+0xfe>
	// 若数值字符个数大于精度值,则精度值扩展为数字个数值.
	// 宽度值size减去用于存放数值字符的个数.
	if (i > precision) precision = i;
    954b:	8b 44 24 34          	mov    0x34(%esp),%eax
    954f:	3b 44 24 54          	cmp    0x54(%esp),%eax
    9553:	7e 08                	jle    955d <number+0x14d>
    9555:	8b 44 24 34          	mov    0x34(%esp),%eax
    9559:	89 44 24 54          	mov    %eax,0x54(%esp)
	size -= precision;
    955d:	8b 44 24 54          	mov    0x54(%esp),%eax
    9561:	29 44 24 50          	sub    %eax,0x50(%esp)
	// 从这里真正开始形成所需要的转换结果,并暂时放在字符串str中.
	// 若类型中没有填零(ZEROPAD)和左靠齐(左调整)标志,则在str中首先填放剩余宽度值指出的空格数.若需带符号位,则存入符号.
	if (!(type & (ZEROPAD + LEFT)))
    9565:	8b 44 24 58          	mov    0x58(%esp),%eax
    9569:	83 e0 11             	and    $0x11,%eax
    956c:	85 c0                	test   %eax,%eax
    956e:	75 1f                	jne    958f <number+0x17f>
		while(size-- > 0)
    9570:	eb 0e                	jmp    9580 <number+0x170>
			*str++ = ' ';
    9572:	8b 44 24 44          	mov    0x44(%esp),%eax
    9576:	8d 50 01             	lea    0x1(%eax),%edx
    9579:	89 54 24 44          	mov    %edx,0x44(%esp)
    957d:	c6 00 20             	movb   $0x20,(%eax)
		while(size-- > 0)
    9580:	8b 44 24 50          	mov    0x50(%esp),%eax
    9584:	8d 50 ff             	lea    -0x1(%eax),%edx
    9587:	89 54 24 50          	mov    %edx,0x50(%esp)
    958b:	85 c0                	test   %eax,%eax
    958d:	7f e3                	jg     9572 <number+0x162>
	if (sign)
    958f:	80 7c 24 3f 00       	cmpb   $0x0,0x3f(%esp)
    9594:	74 12                	je     95a8 <number+0x198>
		*str++ = sign;
    9596:	8b 44 24 44          	mov    0x44(%esp),%eax
    959a:	8d 50 01             	lea    0x1(%eax),%edx
    959d:	89 54 24 44          	mov    %edx,0x44(%esp)
    95a1:	0f b6 54 24 3f       	movzbl 0x3f(%esp),%edx
    95a6:	88 10                	mov    %dl,(%eax)
	// 若类型指出是特殊转换,则对于八进制转换结果头一位放置一个'0';而对于十六进制则存放'0x'.
	if (type & SPECIAL)
    95a8:	8b 44 24 58          	mov    0x58(%esp),%eax
    95ac:	83 e0 20             	and    $0x20,%eax
    95af:	85 c0                	test   %eax,%eax
    95b1:	74 41                	je     95f4 <number+0x1e4>
		if (base == 8)
    95b3:	83 7c 24 4c 08       	cmpl   $0x8,0x4c(%esp)
    95b8:	75 10                	jne    95ca <number+0x1ba>
			*str++ = '0';
    95ba:	8b 44 24 44          	mov    0x44(%esp),%eax
    95be:	8d 50 01             	lea    0x1(%eax),%edx
    95c1:	89 54 24 44          	mov    %edx,0x44(%esp)
    95c5:	c6 00 30             	movb   $0x30,(%eax)
    95c8:	eb 2a                	jmp    95f4 <number+0x1e4>
		else if (base == 16) {
    95ca:	83 7c 24 4c 10       	cmpl   $0x10,0x4c(%esp)
    95cf:	75 23                	jne    95f4 <number+0x1e4>
			*str++ = '0';
    95d1:	8b 44 24 44          	mov    0x44(%esp),%eax
    95d5:	8d 50 01             	lea    0x1(%eax),%edx
    95d8:	89 54 24 44          	mov    %edx,0x44(%esp)
    95dc:	c6 00 30             	movb   $0x30,(%eax)
			*str++ = digits[33];						// 'X'或'x'
    95df:	8b 44 24 44          	mov    0x44(%esp),%eax
    95e3:	8d 50 01             	lea    0x1(%eax),%edx
    95e6:	89 54 24 44          	mov    %edx,0x44(%esp)
    95ea:	8b 54 24 38          	mov    0x38(%esp),%edx
    95ee:	0f b6 52 21          	movzbl 0x21(%edx),%edx
    95f2:	88 10                	mov    %dl,(%eax)
		}
	// 若类型中没有左调整(左靠齐)标志,则在剩余宽度中存放c字符('0'或空格)
	if (!(type & LEFT))
    95f4:	8b 44 24 58          	mov    0x58(%esp),%eax
    95f8:	83 e0 10             	and    $0x10,%eax
    95fb:	85 c0                	test   %eax,%eax
    95fd:	75 33                	jne    9632 <number+0x222>
		while(size-- > 0)
    95ff:	eb 12                	jmp    9613 <number+0x203>
			*str++ = c;
    9601:	8b 44 24 44          	mov    0x44(%esp),%eax
    9605:	8d 50 01             	lea    0x1(%eax),%edx
    9608:	89 54 24 44          	mov    %edx,0x44(%esp)
    960c:	0f b6 54 24 33       	movzbl 0x33(%esp),%edx
    9611:	88 10                	mov    %dl,(%eax)
		while(size-- > 0)
    9613:	8b 44 24 50          	mov    0x50(%esp),%eax
    9617:	8d 50 ff             	lea    -0x1(%eax),%edx
    961a:	89 54 24 50          	mov    %edx,0x50(%esp)
    961e:	85 c0                	test   %eax,%eax
    9620:	7f df                	jg     9601 <number+0x1f1>
	// 此时i存有数值num的数字个数.若数字个数小于精度值,则str中放入(精度值-i)个'0'.
	while(i < precision--)
    9622:	eb 0e                	jmp    9632 <number+0x222>
		*str++ = '0';
    9624:	8b 44 24 44          	mov    0x44(%esp),%eax
    9628:	8d 50 01             	lea    0x1(%eax),%edx
    962b:	89 54 24 44          	mov    %edx,0x44(%esp)
    962f:	c6 00 30             	movb   $0x30,(%eax)
	while(i < precision--)
    9632:	8b 44 24 54          	mov    0x54(%esp),%eax
    9636:	8d 50 ff             	lea    -0x1(%eax),%edx
    9639:	89 54 24 54          	mov    %edx,0x54(%esp)
    963d:	39 44 24 34          	cmp    %eax,0x34(%esp)
    9641:	7c e1                	jl     9624 <number+0x214>
	// 将数值转换好的数字字符填入str中.共i个.
	while(i-- > 0)
    9643:	eb 1a                	jmp    965f <number+0x24f>
		*str++ = tmp[i];
    9645:	8b 44 24 44          	mov    0x44(%esp),%eax
    9649:	8d 50 01             	lea    0x1(%eax),%edx
    964c:	89 54 24 44          	mov    %edx,0x44(%esp)
    9650:	8d 4c 24 08          	lea    0x8(%esp),%ecx
    9654:	8b 54 24 34          	mov    0x34(%esp),%edx
    9658:	01 ca                	add    %ecx,%edx
    965a:	0f b6 12             	movzbl (%edx),%edx
    965d:	88 10                	mov    %dl,(%eax)
	while(i-- > 0)
    965f:	8b 44 24 34          	mov    0x34(%esp),%eax
    9663:	8d 50 ff             	lea    -0x1(%eax),%edx
    9666:	89 54 24 34          	mov    %edx,0x34(%esp)
    966a:	85 c0                	test   %eax,%eax
    966c:	7f d7                	jg     9645 <number+0x235>
	// 若宽度值仍大于零,则表示类型标志中有左靠齐标志.则在剩余宽度中放入空格.
	while(size-- > 0)
    966e:	eb 0e                	jmp    967e <number+0x26e>
		*str++ = ' ';
    9670:	8b 44 24 44          	mov    0x44(%esp),%eax
    9674:	8d 50 01             	lea    0x1(%eax),%edx
    9677:	89 54 24 44          	mov    %edx,0x44(%esp)
    967b:	c6 00 20             	movb   $0x20,(%eax)
	while(size-- > 0)
    967e:	8b 44 24 50          	mov    0x50(%esp),%eax
    9682:	8d 50 ff             	lea    -0x1(%eax),%edx
    9685:	89 54 24 50          	mov    %edx,0x50(%esp)
    9689:	85 c0                	test   %eax,%eax
    968b:	7f e3                	jg     9670 <number+0x260>
	return str;											// 返回转换好的指向字符串末端后的指针.
    968d:	8b 44 24 44          	mov    0x44(%esp),%eax
}
    9691:	83 c4 40             	add    $0x40,%esp
    9694:	c3                   	ret    

00009695 <vsprintf>:

// 下面函数是送格式化输出到字符串中.
// 为了能在内核中使用格式化的输出,Linus在内核实现了该C标准函数.
// 其中参数fmt是格式字符串;args是个数变化的值;buf是输出字符串缓冲区.
int vsprintf(char *buf, const char *fmt, va_list args)
{
    9695:	53                   	push   %ebx
    9696:	83 ec 30             	sub    $0x30,%esp
    9699:	e8 5c d6 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    969e:	81 c3 62 89 02 00    	add    $0x28962,%ebx
				   											number of chars for from string */
														/* min.整数数字个数;max.字符串中字符个数 */
	int qualifier;										/* 'h', 'l', or 'L' for integer fields */	/* 'h','l',或 'L'用于整数字段 */

	// 首先将字符指针指向buf,然后扫描格式字符串,对各个格式转换指示进行相应的处理.
	for (str=buf ; *fmt ; ++fmt) {
    96a4:	8b 44 24 38          	mov    0x38(%esp),%eax
    96a8:	89 44 24 24          	mov    %eax,0x24(%esp)
    96ac:	e9 47 04 00 00       	jmp    9af8 <.L63+0x51>
		// 格式转换指示字符串均'%'开始,这里从fmt格式字符串中扫描'%',寻找格式转换字符串的开始.不是格式指示的一般字符均被依次存入str.
		if (*fmt != '%') {
    96b1:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    96b5:	0f b6 00             	movzbl (%eax),%eax
    96b8:	3c 25                	cmp    $0x25,%al
    96ba:	74 19                	je     96d5 <vsprintf+0x40>
			*str++ = *fmt;
    96bc:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    96c0:	8b 44 24 24          	mov    0x24(%esp),%eax
    96c4:	8d 48 01             	lea    0x1(%eax),%ecx
    96c7:	89 4c 24 24          	mov    %ecx,0x24(%esp)
    96cb:	0f b6 12             	movzbl (%edx),%edx
    96ce:	88 10                	mov    %dl,(%eax)
			continue;
    96d0:	e9 18 04 00 00       	jmp    9aed <.L63+0x46>
		}

		// 下面取得格式指示字符串中的标志域,并将标志常量放入flags变量中.
		/* process flags */
		flags = 0;
    96d5:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    96dc:	00 
		repeat:
			++fmt;		/* this also skips first '%' */
    96dd:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    96e1:	83 c0 01             	add    $0x1,%eax
    96e4:	89 44 24 3c          	mov    %eax,0x3c(%esp)
			switch (*fmt) {
    96e8:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    96ec:	0f b6 00             	movzbl (%eax),%eax
    96ef:	0f be c0             	movsbl %al,%eax
    96f2:	83 e8 20             	sub    $0x20,%eax
    96f5:	83 f8 10             	cmp    $0x10,%eax
    96f8:	77 31                	ja     972b <.L49>
    96fa:	c1 e0 02             	shl    $0x2,%eax
    96fd:	8b 84 18 60 45 ff ff 	mov    -0xbaa0(%eax,%ebx,1),%eax
    9704:	01 d8                	add    %ebx,%eax
    9706:	ff e0                	jmp    *%eax

00009708 <.L54>:
				case '-': flags |= LEFT; goto repeat;		// 左靠齐调整
    9708:	83 4c 24 1c 10       	orl    $0x10,0x1c(%esp)
    970d:	eb ce                	jmp    96dd <vsprintf+0x48>

0000970f <.L53>:
				case '+': flags |= PLUS; goto repeat;		// 放加号
    970f:	83 4c 24 1c 04       	orl    $0x4,0x1c(%esp)
    9714:	eb c7                	jmp    96dd <vsprintf+0x48>

00009716 <.L50>:
				case ' ': flags |= SPACE; goto repeat;		// 放空格
    9716:	83 4c 24 1c 08       	orl    $0x8,0x1c(%esp)
    971b:	eb c0                	jmp    96dd <vsprintf+0x48>

0000971d <.L52>:
				case '#': flags |= SPECIAL; goto repeat;	// 是特殊转换
    971d:	83 4c 24 1c 20       	orl    $0x20,0x1c(%esp)
    9722:	eb b9                	jmp    96dd <vsprintf+0x48>

00009724 <.L55>:
				case '0': flags |= ZEROPAD; goto repeat;	// 要填零(即'0')
    9724:	83 4c 24 1c 01       	orl    $0x1,0x1c(%esp)
    9729:	eb b2                	jmp    96dd <vsprintf+0x48>

0000972b <.L49>:
				}

		// 取当前参数字段宽度域值,放入field_width变量中.如果宽度域中是数值则直接其为宽度值.如果宽度域中是字符'*',表示下一个参数指定宽度.因此
		// 调用va_arg取宽度值.若此时宽度值小于0,则该负数表示其带有标志域'-'标志(左靠齐),因此还需在标志变量中添入该标志,并将字段宽度值取为其绝对值.
		/* get field width */
		field_width = -1;
    972b:	c7 44 24 18 ff ff ff 	movl   $0xffffffff,0x18(%esp)
    9732:	ff 
		if (is_digit(*fmt))
    9733:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9737:	0f b6 00             	movzbl (%eax),%eax
    973a:	3c 2f                	cmp    $0x2f,%al
    973c:	7e 1e                	jle    975c <.L49+0x31>
    973e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9742:	0f b6 00             	movzbl (%eax),%eax
    9745:	3c 39                	cmp    $0x39,%al
    9747:	7f 13                	jg     975c <.L49+0x31>
			field_width = skip_atoi(&fmt);
    9749:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    974d:	50                   	push   %eax
    974e:	e8 55 fc ff ff       	call   93a8 <skip_atoi>
    9753:	83 c4 04             	add    $0x4,%esp
    9756:	89 44 24 18          	mov    %eax,0x18(%esp)
    975a:	eb 36                	jmp    9792 <.L49+0x67>
		else if (*fmt == '*') {
    975c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9760:	0f b6 00             	movzbl (%eax),%eax
    9763:	3c 2a                	cmp    $0x2a,%al
    9765:	75 2b                	jne    9792 <.L49+0x67>
			/* it's the next argument */
			++fmt;
    9767:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    976b:	83 c0 01             	add    $0x1,%eax
    976e:	89 44 24 3c          	mov    %eax,0x3c(%esp)
			field_width = va_arg(args, int);
    9772:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    9777:	8b 44 24 40          	mov    0x40(%esp),%eax
    977b:	8b 40 fc             	mov    -0x4(%eax),%eax
    977e:	89 44 24 18          	mov    %eax,0x18(%esp)
			if (field_width < 0) {
    9782:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    9787:	79 09                	jns    9792 <.L49+0x67>
				field_width = -field_width;
    9789:	f7 5c 24 18          	negl   0x18(%esp)
				flags |= LEFT;
    978d:	83 4c 24 1c 10       	orl    $0x10,0x1c(%esp)
		}

	// 下面这段代码,取格式转换串的精度域,并放入precision变量中.精度域开始的标志是'.'.其处理过程与上面宽度域的类似.如果精度域中是数值则直接取其为
	// 精度值.如果精度域中是字符'*',表示下一个参数指定精度.因此调用va_arg取精度值.若此时宽度值小于0,则将字段精度值取为0.
		/* get the precision */
		precision = -1;
    9792:	c7 44 24 14 ff ff ff 	movl   $0xffffffff,0x14(%esp)
    9799:	ff 
		if (*fmt == '.') {
    979a:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    979e:	0f b6 00             	movzbl (%eax),%eax
    97a1:	3c 2e                	cmp    $0x2e,%al
    97a3:	75 69                	jne    980e <.L49+0xe3>
			++fmt;
    97a5:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    97a9:	83 c0 01             	add    $0x1,%eax
    97ac:	89 44 24 3c          	mov    %eax,0x3c(%esp)
			if (is_digit(*fmt))
    97b0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    97b4:	0f b6 00             	movzbl (%eax),%eax
    97b7:	3c 2f                	cmp    $0x2f,%al
    97b9:	7e 1e                	jle    97d9 <.L49+0xae>
    97bb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    97bf:	0f b6 00             	movzbl (%eax),%eax
    97c2:	3c 39                	cmp    $0x39,%al
    97c4:	7f 13                	jg     97d9 <.L49+0xae>
				precision = skip_atoi(&fmt);
    97c6:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    97ca:	50                   	push   %eax
    97cb:	e8 d8 fb ff ff       	call   93a8 <skip_atoi>
    97d0:	83 c4 04             	add    $0x4,%esp
    97d3:	89 44 24 14          	mov    %eax,0x14(%esp)
    97d7:	eb 26                	jmp    97ff <.L49+0xd4>
			else if (*fmt == '*') {
    97d9:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    97dd:	0f b6 00             	movzbl (%eax),%eax
    97e0:	3c 2a                	cmp    $0x2a,%al
    97e2:	75 1b                	jne    97ff <.L49+0xd4>
				/* it's the next argument */
                                ++fmt;
    97e4:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    97e8:	83 c0 01             	add    $0x1,%eax
    97eb:	89 44 24 3c          	mov    %eax,0x3c(%esp)
				precision = va_arg(args, int);
    97ef:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    97f4:	8b 44 24 40          	mov    0x40(%esp),%eax
    97f8:	8b 40 fc             	mov    -0x4(%eax),%eax
    97fb:	89 44 24 14          	mov    %eax,0x14(%esp)
			}
			if (precision < 0)
    97ff:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    9804:	79 08                	jns    980e <.L49+0xe3>
				precision = 0;
    9806:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    980d:	00 
		}

		// 下面这段代码分析长度修饰符,并将其存入qualifer变量.
		/* get the conversion qualifier */
		qualifier = -1;
    980e:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
    9815:	ff 
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
    9816:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    981a:	0f b6 00             	movzbl (%eax),%eax
    981d:	3c 68                	cmp    $0x68,%al
    981f:	74 16                	je     9837 <.L49+0x10c>
    9821:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9825:	0f b6 00             	movzbl (%eax),%eax
    9828:	3c 6c                	cmp    $0x6c,%al
    982a:	74 0b                	je     9837 <.L49+0x10c>
    982c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9830:	0f b6 00             	movzbl (%eax),%eax
    9833:	3c 4c                	cmp    $0x4c,%al
    9835:	75 19                	jne    9850 <.L49+0x125>
			qualifier = *fmt;
    9837:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    983b:	0f b6 00             	movzbl (%eax),%eax
    983e:	0f be c0             	movsbl %al,%eax
    9841:	89 44 24 10          	mov    %eax,0x10(%esp)
			++fmt;
    9845:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9849:	83 c0 01             	add    $0x1,%eax
    984c:	89 44 24 3c          	mov    %eax,0x3c(%esp)
		}

		// 下面分析转换指示符.
		switch (*fmt) {
    9850:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9854:	0f b6 00             	movzbl (%eax),%eax
    9857:	0f be c0             	movsbl %al,%eax
    985a:	83 e8 58             	sub    $0x58,%eax
    985d:	83 f8 20             	cmp    $0x20,%eax
    9860:	0f 87 41 02 00 00    	ja     9aa7 <.L63>
    9866:	c1 e0 02             	shl    $0x2,%eax
    9869:	8b 84 18 a4 45 ff ff 	mov    -0xba5c(%eax,%ebx,1),%eax
    9870:	01 d8                	add    %ebx,%eax
    9872:	ff e0                	jmp    *%eax

00009874 <.L66>:
		// 如果转换指示符是'c',则表示对应参数应是字符.此时如果标志域表明不是左靠齐,则该字段前面放入'宽度域值-1'个空格字符,然后再放入参数字符.如果
		// 宽度域还大于0,则表示左靠齐,则在参数字符后面添加'宽度值-1'个空格字符.
		case 'c':
			if (!(flags & LEFT))
    9874:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    9878:	83 e0 10             	and    $0x10,%eax
    987b:	85 c0                	test   %eax,%eax
    987d:	75 1c                	jne    989b <.L66+0x27>
				while (--field_width > 0)
    987f:	eb 0e                	jmp    988f <.L66+0x1b>
					*str++ = ' ';
    9881:	8b 44 24 24          	mov    0x24(%esp),%eax
    9885:	8d 50 01             	lea    0x1(%eax),%edx
    9888:	89 54 24 24          	mov    %edx,0x24(%esp)
    988c:	c6 00 20             	movb   $0x20,(%eax)
				while (--field_width > 0)
    988f:	83 6c 24 18 01       	subl   $0x1,0x18(%esp)
    9894:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    9899:	7f e6                	jg     9881 <.L66+0xd>
			*str++ = (unsigned char) va_arg(args, int);
    989b:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    98a0:	8b 44 24 40          	mov    0x40(%esp),%eax
    98a4:	83 e8 04             	sub    $0x4,%eax
    98a7:	8b 08                	mov    (%eax),%ecx
    98a9:	8b 44 24 24          	mov    0x24(%esp),%eax
    98ad:	8d 50 01             	lea    0x1(%eax),%edx
    98b0:	89 54 24 24          	mov    %edx,0x24(%esp)
    98b4:	89 ca                	mov    %ecx,%edx
    98b6:	88 10                	mov    %dl,(%eax)
			while (--field_width > 0)
    98b8:	eb 0e                	jmp    98c8 <.L66+0x54>
				*str++ = ' ';
    98ba:	8b 44 24 24          	mov    0x24(%esp),%eax
    98be:	8d 50 01             	lea    0x1(%eax),%edx
    98c1:	89 54 24 24          	mov    %edx,0x24(%esp)
    98c5:	c6 00 20             	movb   $0x20,(%eax)
			while (--field_width > 0)
    98c8:	83 6c 24 18 01       	subl   $0x1,0x18(%esp)
    98cd:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    98d2:	7f e6                	jg     98ba <.L66+0x46>
			break;
    98d4:	e9 14 02 00 00       	jmp    9aed <.L63+0x46>

000098d9 <.L71>:

		// 如果转换指示符是's',则表示对应参数是字符串.首先取参数字符串的长度,若其超过了精度域值,则扩展精度=字符串长度.此时如果标志域表明不是左靠齐,
		// 则该字段前放入'宽度值-字符串长度'个空格字符.然后再放入参数字符串.如果宽度域还大于0,则表示为左靠齐,则在参数字符串后面添加'宽度值-字符串长
		// 度'个空格字符.
		case 's':
			s = va_arg(args, char *);
    98d9:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    98de:	8b 44 24 40          	mov    0x40(%esp),%eax
    98e2:	8b 40 fc             	mov    -0x4(%eax),%eax
    98e5:	89 44 24 20          	mov    %eax,0x20(%esp)
			len = strlen(s);
    98e9:	ff 74 24 20          	pushl  0x20(%esp)
    98ed:	e8 91 fa ff ff       	call   9383 <strlen>
    98f2:	83 c4 04             	add    $0x4,%esp
    98f5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
			if (precision < 0)
    98f9:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    98fe:	79 0a                	jns    990a <.L71+0x31>
				precision = len;
    9900:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    9904:	89 44 24 14          	mov    %eax,0x14(%esp)
    9908:	eb 12                	jmp    991c <.L71+0x43>
			else if (len > precision)
    990a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    990e:	3b 44 24 14          	cmp    0x14(%esp),%eax
    9912:	7e 08                	jle    991c <.L71+0x43>
				len = precision;
    9914:	8b 44 24 14          	mov    0x14(%esp),%eax
    9918:	89 44 24 2c          	mov    %eax,0x2c(%esp)

			if (!(flags & LEFT))
    991c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    9920:	83 e0 10             	and    $0x10,%eax
    9923:	85 c0                	test   %eax,%eax
    9925:	75 21                	jne    9948 <.L71+0x6f>
				while (len < field_width--)
    9927:	eb 0e                	jmp    9937 <.L71+0x5e>
					*str++ = ' ';
    9929:	8b 44 24 24          	mov    0x24(%esp),%eax
    992d:	8d 50 01             	lea    0x1(%eax),%edx
    9930:	89 54 24 24          	mov    %edx,0x24(%esp)
    9934:	c6 00 20             	movb   $0x20,(%eax)
				while (len < field_width--)
    9937:	8b 44 24 18          	mov    0x18(%esp),%eax
    993b:	8d 50 ff             	lea    -0x1(%eax),%edx
    993e:	89 54 24 18          	mov    %edx,0x18(%esp)
    9942:	39 44 24 2c          	cmp    %eax,0x2c(%esp)
    9946:	7c e1                	jl     9929 <.L71+0x50>
			for (i = 0; i < len; ++i)
    9948:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    994f:	00 
    9950:	eb 20                	jmp    9972 <.L71+0x99>
				*str++ = *s++;
    9952:	8b 54 24 20          	mov    0x20(%esp),%edx
    9956:	8d 42 01             	lea    0x1(%edx),%eax
    9959:	89 44 24 20          	mov    %eax,0x20(%esp)
    995d:	8b 44 24 24          	mov    0x24(%esp),%eax
    9961:	8d 48 01             	lea    0x1(%eax),%ecx
    9964:	89 4c 24 24          	mov    %ecx,0x24(%esp)
    9968:	0f b6 12             	movzbl (%edx),%edx
    996b:	88 10                	mov    %dl,(%eax)
			for (i = 0; i < len; ++i)
    996d:	83 44 24 28 01       	addl   $0x1,0x28(%esp)
    9972:	8b 44 24 28          	mov    0x28(%esp),%eax
    9976:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
    997a:	7c d6                	jl     9952 <.L71+0x79>
			while (len < field_width--)
    997c:	eb 0e                	jmp    998c <.L71+0xb3>
				*str++ = ' ';
    997e:	8b 44 24 24          	mov    0x24(%esp),%eax
    9982:	8d 50 01             	lea    0x1(%eax),%edx
    9985:	89 54 24 24          	mov    %edx,0x24(%esp)
    9989:	c6 00 20             	movb   $0x20,(%eax)
			while (len < field_width--)
    998c:	8b 44 24 18          	mov    0x18(%esp),%eax
    9990:	8d 50 ff             	lea    -0x1(%eax),%edx
    9993:	89 54 24 18          	mov    %edx,0x18(%esp)
    9997:	39 44 24 2c          	cmp    %eax,0x2c(%esp)
    999b:	7c e1                	jl     997e <.L71+0xa5>
			break;
    999d:	e9 4b 01 00 00       	jmp    9aed <.L63+0x46>

000099a2 <.L69>:

		// 如果格式转换符是'o',表示需将对应的参数转换成八进制数的字符串.调用number()函数处理.
		case 'o':
			str = number(str, va_arg(args, unsigned long), 8,
    99a2:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    99a7:	8b 44 24 40          	mov    0x40(%esp),%eax
    99ab:	83 e8 04             	sub    $0x4,%eax
    99ae:	8b 00                	mov    (%eax),%eax
    99b0:	ff 74 24 1c          	pushl  0x1c(%esp)
    99b4:	ff 74 24 18          	pushl  0x18(%esp)
    99b8:	ff 74 24 20          	pushl  0x20(%esp)
    99bc:	6a 08                	push   $0x8
    99be:	50                   	push   %eax
    99bf:	ff 74 24 38          	pushl  0x38(%esp)
    99c3:	e8 48 fa ff ff       	call   9410 <number>
    99c8:	83 c4 18             	add    $0x18,%esp
    99cb:	89 44 24 24          	mov    %eax,0x24(%esp)
				field_width, precision, flags);
			break;
    99cf:	e9 19 01 00 00       	jmp    9aed <.L63+0x46>

000099d4 <.L70>:

		// 如果格式转换符是'p',表示对应参数是一个指针类型.此时若该参数没有设置宽度域,则默认宽度为8,并且需要添零.然后调用number()函数进行处理.
		case 'p':
			if (field_width == -1) {
    99d4:	83 7c 24 18 ff       	cmpl   $0xffffffff,0x18(%esp)
    99d9:	75 0d                	jne    99e8 <.L70+0x14>
				field_width = 8;
    99db:	c7 44 24 18 08 00 00 	movl   $0x8,0x18(%esp)
    99e2:	00 
				flags |= ZEROPAD;
    99e3:	83 4c 24 1c 01       	orl    $0x1,0x1c(%esp)
			}
			str = number(str,
				(unsigned long) va_arg(args, void *), 16,
    99e8:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    99ed:	8b 44 24 40          	mov    0x40(%esp),%eax
    99f1:	83 e8 04             	sub    $0x4,%eax
    99f4:	8b 00                	mov    (%eax),%eax
			str = number(str,
    99f6:	ff 74 24 1c          	pushl  0x1c(%esp)
    99fa:	ff 74 24 18          	pushl  0x18(%esp)
    99fe:	ff 74 24 20          	pushl  0x20(%esp)
    9a02:	6a 10                	push   $0x10
    9a04:	50                   	push   %eax
    9a05:	ff 74 24 38          	pushl  0x38(%esp)
    9a09:	e8 02 fa ff ff       	call   9410 <number>
    9a0e:	83 c4 18             	add    $0x18,%esp
    9a11:	89 44 24 24          	mov    %eax,0x24(%esp)
				field_width, precision, flags);
			break;
    9a15:	e9 d3 00 00 00       	jmp    9aed <.L63+0x46>

00009a1a <.L73>:

		// 如果格式转换指示是'x'或'X',则表示对应参数需要打印成十六进制数输出.'x'表示用定字母表示.
		case 'x':
			flags |= SMALL;
    9a1a:	83 4c 24 1c 40       	orl    $0x40,0x1c(%esp)

00009a1f <.L64>:
		case 'X':
			str = number(str, va_arg(args, unsigned long), 16,
    9a1f:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    9a24:	8b 44 24 40          	mov    0x40(%esp),%eax
    9a28:	83 e8 04             	sub    $0x4,%eax
    9a2b:	8b 00                	mov    (%eax),%eax
    9a2d:	ff 74 24 1c          	pushl  0x1c(%esp)
    9a31:	ff 74 24 18          	pushl  0x18(%esp)
    9a35:	ff 74 24 20          	pushl  0x20(%esp)
    9a39:	6a 10                	push   $0x10
    9a3b:	50                   	push   %eax
    9a3c:	ff 74 24 38          	pushl  0x38(%esp)
    9a40:	e8 cb f9 ff ff       	call   9410 <number>
    9a45:	83 c4 18             	add    $0x18,%esp
    9a48:	89 44 24 24          	mov    %eax,0x24(%esp)
				field_width, precision, flags);
			break;
    9a4c:	e9 9c 00 00 00       	jmp    9aed <.L63+0x46>

00009a51 <.L67>:

		// 如果格式转换字符是'd','i'或'u',则表示对应参数是整数,'d','i'代表符号整数,因此需要加上带符号标志.'u'代表无符号整数.
		case 'd':
		case 'i':
			flags |= SIGN;
    9a51:	83 4c 24 1c 02       	orl    $0x2,0x1c(%esp)

00009a56 <.L72>:
		case 'u':
			str = number(str, va_arg(args, unsigned long), 10,
    9a56:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    9a5b:	8b 44 24 40          	mov    0x40(%esp),%eax
    9a5f:	83 e8 04             	sub    $0x4,%eax
    9a62:	8b 00                	mov    (%eax),%eax
    9a64:	ff 74 24 1c          	pushl  0x1c(%esp)
    9a68:	ff 74 24 18          	pushl  0x18(%esp)
    9a6c:	ff 74 24 20          	pushl  0x20(%esp)
    9a70:	6a 0a                	push   $0xa
    9a72:	50                   	push   %eax
    9a73:	ff 74 24 38          	pushl  0x38(%esp)
    9a77:	e8 94 f9 ff ff       	call   9410 <number>
    9a7c:	83 c4 18             	add    $0x18,%esp
    9a7f:	89 44 24 24          	mov    %eax,0x24(%esp)
				field_width, precision, flags);
			break;
    9a83:	eb 68                	jmp    9aed <.L63+0x46>

00009a85 <.L68>:

		// 若格式转换指示符是'n',则表示要把目前为止转换输出字符数保存到对应参数指针指定的位置中.首先利用va_arg()取得该参数指针,然后将已经转换好
		// 的字符数存入该指示的位置.
		case 'n':
			ip = va_arg(args, int *);
    9a85:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    9a8a:	8b 44 24 40          	mov    0x40(%esp),%eax
    9a8e:	8b 40 fc             	mov    -0x4(%eax),%eax
    9a91:	89 44 24 0c          	mov    %eax,0xc(%esp)
			*ip = (str - buf);
    9a95:	8b 54 24 24          	mov    0x24(%esp),%edx
    9a99:	8b 44 24 38          	mov    0x38(%esp),%eax
    9a9d:	29 c2                	sub    %eax,%edx
    9a9f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9aa3:	89 10                	mov    %edx,(%eax)
			break;
    9aa5:	eb 46                	jmp    9aed <.L63+0x46>

00009aa7 <.L63>:

		// 若格式转换符不是'%',则表示格式字符串有错,直接将一个'%'写入输出串中.
		// 如果格式转换符的位置处还有字符,则也直接将该字符写入输出串中,并返回前面继续处理格式字符串.否则表示已经处理到格式字符串的结尾处,则退出循环.
		default:
			if (*fmt != '%')
    9aa7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9aab:	0f b6 00             	movzbl (%eax),%eax
    9aae:	3c 25                	cmp    $0x25,%al
    9ab0:	74 0e                	je     9ac0 <.L63+0x19>
				*str++ = '%';
    9ab2:	8b 44 24 24          	mov    0x24(%esp),%eax
    9ab6:	8d 50 01             	lea    0x1(%eax),%edx
    9ab9:	89 54 24 24          	mov    %edx,0x24(%esp)
    9abd:	c6 00 25             	movb   $0x25,(%eax)
			if (*fmt)
    9ac0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9ac4:	0f b6 00             	movzbl (%eax),%eax
    9ac7:	84 c0                	test   %al,%al
    9ac9:	74 16                	je     9ae1 <.L63+0x3a>
				*str++ = *fmt;
    9acb:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    9acf:	8b 44 24 24          	mov    0x24(%esp),%eax
    9ad3:	8d 48 01             	lea    0x1(%eax),%ecx
    9ad6:	89 4c 24 24          	mov    %ecx,0x24(%esp)
    9ada:	0f b6 12             	movzbl (%edx),%edx
    9add:	88 10                	mov    %dl,(%eax)
			else
				--fmt;
			break;
    9adf:	eb 0b                	jmp    9aec <.L63+0x45>
				--fmt;
    9ae1:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9ae5:	83 e8 01             	sub    $0x1,%eax
    9ae8:	89 44 24 3c          	mov    %eax,0x3c(%esp)
			break;
    9aec:	90                   	nop
	for (str=buf ; *fmt ; ++fmt) {
    9aed:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9af1:	83 c0 01             	add    $0x1,%eax
    9af4:	89 44 24 3c          	mov    %eax,0x3c(%esp)
    9af8:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    9afc:	0f b6 00             	movzbl (%eax),%eax
    9aff:	84 c0                	test   %al,%al
    9b01:	0f 85 aa fb ff ff    	jne    96b1 <vsprintf+0x1c>
		}
	}
	*str = '\0';										// 最后在转换好的字符串结尾处添上null.
    9b07:	8b 44 24 24          	mov    0x24(%esp),%eax
    9b0b:	c6 00 00             	movb   $0x0,(%eax)
	return str - buf;									// 返回转换好的字符串长度值.
    9b0e:	8b 54 24 24          	mov    0x24(%esp),%edx
    9b12:	8b 44 24 38          	mov    0x38(%esp),%eax
    9b16:	29 c2                	sub    %eax,%edx
    9b18:	89 d0                	mov    %edx,%eax
}
    9b1a:	83 c4 30             	add    $0x30,%esp
    9b1d:	5b                   	pop    %ebx
    9b1e:	c3                   	ret    

00009b1f <get_fs_byte>:
//// 读取fs段中指定地址处的字节.
// 参数:addr - 指定的内存地址.
// %0 - (返回的字节_v);%1 - (内存地址addr)
// 返回:返回内存fs[addr]处的字节.
static inline unsigned char get_fs_byte(const char * addr)
{
    9b1f:	53                   	push   %ebx
    9b20:	e8 cd d1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9b25:	05 db 84 02 00       	add    $0x284db,%eax
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    9b2a:	8b 44 24 08          	mov    0x8(%esp),%eax
    9b2e:	64 8a 00             	mov    %fs:(%eax),%al
    9b31:	89 c3                	mov    %eax,%ebx
	return _v;
    9b33:	89 d8                	mov    %ebx,%eax
}
    9b35:	5b                   	pop    %ebx
    9b36:	c3                   	ret    

00009b37 <get_fs_word>:
//// 读取fs段中指定地址处的字.
// 参数:addr - 指定的内存地址.
// %0 - (返回的字_v);%1 - (内存地址addr)
// 返回:返回内存fs:[addr]处的字.
static inline unsigned short get_fs_word(const unsigned short *addr)
{
    9b37:	83 ec 10             	sub    $0x10,%esp
    9b3a:	e8 b3 d1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9b3f:	05 c1 84 02 00       	add    $0x284c1,%eax
	unsigned short _v;

	__asm__ ("movw %%fs:%1,%0":"=q" (_v):"m" (*addr));
    9b44:	8b 44 24 14          	mov    0x14(%esp),%eax
    9b48:	64 66 8b 00          	mov    %fs:(%eax),%ax
    9b4c:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	return _v;
    9b51:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
}
    9b56:	83 c4 10             	add    $0x10,%esp
    9b59:	c3                   	ret    

00009b5a <get_fs_long>:
//// 读取fs段中指定地址处的长字(4字节).
// 参数:addr - 指定的内存地址.
// %0 - (返回的长字_v);%1 - (内存地址addr)
// 返回:返回内存fs:[addr]处的长字.
static inline unsigned long get_fs_long(const unsigned long *addr)
{
    9b5a:	83 ec 10             	sub    $0x10,%esp
    9b5d:	e8 90 d1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9b62:	05 9e 84 02 00       	add    $0x2849e,%eax
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    9b67:	8b 44 24 14          	mov    0x14(%esp),%eax
    9b6b:	64 8b 00             	mov    %fs:(%eax),%eax
    9b6e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
    9b72:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    9b76:	83 c4 10             	add    $0x10,%esp
    9b79:	c3                   	ret    

00009b7a <put_fs_byte>:

//// 将一字节存放在fs段中指定内存地址处.
// 参数:val - 字节值;addr - 内存地址.
// %0 - 寄存器(字节值val);%1 - (内存地址addr).
static inline void put_fs_byte(char val,char *addr)
{
    9b7a:	83 ec 04             	sub    $0x4,%esp
    9b7d:	e8 70 d1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9b82:	05 7e 84 02 00       	add    $0x2847e,%eax
    9b87:	8b 44 24 08          	mov    0x8(%esp),%eax
    9b8b:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    9b8e:	0f b6 04 24          	movzbl (%esp),%eax
    9b92:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9b96:	64 88 02             	mov    %al,%fs:(%edx)
}
    9b99:	90                   	nop
    9b9a:	83 c4 04             	add    $0x4,%esp
    9b9d:	c3                   	ret    

00009b9e <put_fs_word>:

//// 将一字存放在fs段中指定内存地址处.
// 参数:val - 字值;addr - 内存地址.
// %0 - 寄存器(字值val);%1 - (内存地址addr).
static inline void put_fs_word(short val,short * addr)
{
    9b9e:	83 ec 04             	sub    $0x4,%esp
    9ba1:	e8 4c d1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9ba6:	05 5a 84 02 00       	add    $0x2845a,%eax
    9bab:	8b 44 24 08          	mov    0x8(%esp),%eax
    9baf:	66 89 04 24          	mov    %ax,(%esp)
__asm__ ("movw %0,%%fs:%1"::"q" (val),"m" (*addr));
    9bb3:	0f b7 04 24          	movzwl (%esp),%eax
    9bb7:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9bbb:	64 66 89 02          	mov    %ax,%fs:(%edx)
}
    9bbf:	90                   	nop
    9bc0:	83 c4 04             	add    $0x4,%esp
    9bc3:	c3                   	ret    

00009bc4 <put_fs_long>:

//// 将一长字存放在fs段中指定内存地址处.
// 参数:val - 长字值;addr - 内存地址.
// %0 - 寄存器(长字值val);%1 - (内存地址addr).
static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
    9bc4:	e8 29 d1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9bc9:	05 37 84 02 00       	add    $0x28437,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    9bce:	8b 44 24 04          	mov    0x4(%esp),%eax
    9bd2:	8b 54 24 08          	mov    0x8(%esp),%edx
    9bd6:	64 89 02             	mov    %eax,%fs:(%edx)
}
    9bd9:	90                   	nop
    9bda:	c3                   	ret    

00009bdb <memset>:

// 用字符填写指定长度内存块.
// 用字符c填写s指向的内存区域,共填count字节.
// %0 - eax(字符c),%1 - edi(内存地址),%2 - ecx(字节数count).
static inline void * memset(void * s, char c, int count)
{
    9bdb:	57                   	push   %edi
    9bdc:	83 ec 04             	sub    $0x4,%esp
    9bdf:	e8 0e d1 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9be4:	05 1c 84 02 00       	add    $0x2841c,%eax
    9be9:	8b 44 24 10          	mov    0x10(%esp),%eax
    9bed:	88 04 24             	mov    %al,(%esp)
__asm__(
    9bf0:	0f b6 04 24          	movzbl (%esp),%eax
    9bf4:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9bf8:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    9bfc:	89 d7                	mov    %edx,%edi
    9bfe:	fc                   	cld    
    9bff:	57                   	push   %edi
    9c00:	f3 aa                	rep stos %al,%es:(%edi)
    9c02:	5f                   	pop    %edi
		"rep\n\t"											// 重复ecx指定的次数,执行.
		"stosb\n\t"											// 将al中字符存入es:[edi]中,并且edi++.
		"popl %%edi"
		::"a" (c), "D" (s), "c" (count)
		:);
return s;
    9c03:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    9c07:	83 c4 04             	add    $0x4,%esp
    9c0a:	5f                   	pop    %edi
    9c0b:	c3                   	ret    

00009c0c <sys_ftime>:
extern int session_of_pgrp(int pgrp);

// 返回日期和时间（ftime - Fetch time）。
// 以下返回值是-ENOSYS的系统调用函数均表示在本版本内核中还未实现。
int sys_ftime()
{
    9c0c:	e8 e1 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c11:	05 ef 83 02 00       	add    $0x283ef,%eax
	return -ENOSYS;
    9c16:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9c1b:	c3                   	ret    

00009c1c <sys_break>:

int sys_break()
{
    9c1c:	e8 d1 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c21:	05 df 83 02 00       	add    $0x283df,%eax
	return -ENOSYS;
    9c26:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9c2b:	c3                   	ret    

00009c2c <sys_ptrace>:

// 用于当前进程对子进程进行高度（debugging）。
int sys_ptrace()
{
    9c2c:	e8 c1 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c31:	05 cf 83 02 00       	add    $0x283cf,%eax
	return -ENOSYS;
    9c36:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9c3b:	c3                   	ret    

00009c3c <sys_stty>:

// 改变并打印终端行设置。
int sys_stty()
{
    9c3c:	e8 b1 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c41:	05 bf 83 02 00       	add    $0x283bf,%eax
	return -ENOSYS;
    9c46:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9c4b:	c3                   	ret    

00009c4c <sys_gtty>:

// 取终端行设置信息。
int sys_gtty()
{
    9c4c:	e8 a1 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c51:	05 af 83 02 00       	add    $0x283af,%eax
	return -ENOSYS;
    9c56:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9c5b:	c3                   	ret    

00009c5c <sys_rename>:

// 修改文件名。
int sys_rename()
{
    9c5c:	e8 91 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c61:	05 9f 83 02 00       	add    $0x2839f,%eax
	return -ENOSYS;
    9c66:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9c6b:	c3                   	ret    

00009c6c <sys_prof>:

int sys_prof()
{
    9c6c:	e8 81 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c71:	05 8f 83 02 00       	add    $0x2838f,%eax
	return -ENOSYS;
    9c76:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9c7b:	c3                   	ret    

00009c7c <sys_setregid>:
 */
// 设置当前任务的实际以及/或者有效组ID（gid）。如果任务没有超级用户特权，那么只能互换其实际组ID和有效组ID。
// 如果任务具有超级用户特权，就能任意设置有效的和实际的组ID。保留的gid（saved gid）被设置成与有效gid。实际
// 组ID是指进程当前的gid。
int sys_setregid(int rgid, int egid)
{
    9c7c:	e8 71 d0 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9c81:	05 7f 83 02 00       	add    $0x2837f,%eax
	if (rgid > 0) {
    9c86:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    9c8b:	7e 47                	jle    9cd4 <sys_setregid+0x58>
		if ((current->gid == rgid) ||
    9c8d:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9c93:	8b 12                	mov    (%edx),%edx
    9c95:	0f b7 92 d2 02 00 00 	movzwl 0x2d2(%edx),%edx
    9c9c:	0f b7 d2             	movzwl %dx,%edx
    9c9f:	39 54 24 04          	cmp    %edx,0x4(%esp)
    9ca3:	74 14                	je     9cb9 <sys_setregid+0x3d>
		    suser())
    9ca5:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9cab:	8b 12                	mov    (%edx),%edx
    9cad:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
		if ((current->gid == rgid) ||
    9cb4:	66 85 d2             	test   %dx,%dx
    9cb7:	75 15                	jne    9cce <sys_setregid+0x52>
			current->gid = rgid;
    9cb9:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9cbf:	8b 12                	mov    (%edx),%edx
    9cc1:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    9cc5:	66 89 8a d2 02 00 00 	mov    %cx,0x2d2(%edx)
    9ccc:	eb 06                	jmp    9cd4 <sys_setregid+0x58>
		else
			return(-EPERM);
    9cce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9cd3:	c3                   	ret    
	}
	if (egid > 0) {
    9cd4:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    9cd9:	7e 72                	jle    9d4d <sys_setregid+0xd1>
		if ((current->gid == egid) ||
    9cdb:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9ce1:	8b 12                	mov    (%edx),%edx
    9ce3:	0f b7 92 d2 02 00 00 	movzwl 0x2d2(%edx),%edx
    9cea:	0f b7 d2             	movzwl %dx,%edx
    9ced:	39 54 24 08          	cmp    %edx,0x8(%esp)
    9cf1:	74 2c                	je     9d1f <sys_setregid+0xa3>
		    (current->egid == egid) ||
    9cf3:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9cf9:	8b 12                	mov    (%edx),%edx
    9cfb:	0f b7 92 d4 02 00 00 	movzwl 0x2d4(%edx),%edx
    9d02:	0f b7 d2             	movzwl %dx,%edx
		if ((current->gid == egid) ||
    9d05:	39 54 24 08          	cmp    %edx,0x8(%esp)
    9d09:	74 14                	je     9d1f <sys_setregid+0xa3>
		    suser()) {
    9d0b:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9d11:	8b 12                	mov    (%edx),%edx
    9d13:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
		    (current->egid == egid) ||
    9d1a:	66 85 d2             	test   %dx,%dx
    9d1d:	75 28                	jne    9d47 <sys_setregid+0xcb>
			current->egid = egid;
    9d1f:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9d25:	8b 12                	mov    (%edx),%edx
    9d27:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    9d2b:	66 89 8a d4 02 00 00 	mov    %cx,0x2d4(%edx)
			current->sgid = egid;
    9d32:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    9d38:	8b 00                	mov    (%eax),%eax
    9d3a:	8b 54 24 08          	mov    0x8(%esp),%edx
    9d3e:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%eax)
    9d45:	eb 06                	jmp    9d4d <sys_setregid+0xd1>
		} else
			return(-EPERM);
    9d47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9d4c:	c3                   	ret    
	}
	return 0;
    9d4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9d52:	c3                   	ret    

00009d53 <sys_setgid>:
 */
// 设置进程组号（gid）。如果任务没有超级用户特权，它可以使用setgid()将其有效gid（effective gid）设置为成其保留
// gid（saved git）或其实际git（real gid）。如果任务有超级用户特权，则实际gid、有效gid和保留gid都被设置成参数
// 指定的gid。
int sys_setgid(int gid)
{
    9d53:	e8 9a cf ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9d58:	05 a8 82 02 00       	add    $0x282a8,%eax
	if (suser())
    9d5d:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9d63:	8b 12                	mov    (%edx),%edx
    9d65:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
    9d6c:	66 85 d2             	test   %dx,%dx
    9d6f:	75 41                	jne    9db2 <sys_setgid+0x5f>
		current->gid = current->egid = current->sgid = gid;
    9d71:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9d77:	8b 0a                	mov    (%edx),%ecx
    9d79:	8b 54 24 04          	mov    0x4(%esp),%edx
    9d7d:	66 89 91 d6 02 00 00 	mov    %dx,0x2d6(%ecx)
    9d84:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9d8a:	8b 12                	mov    (%edx),%edx
    9d8c:	0f b7 89 d6 02 00 00 	movzwl 0x2d6(%ecx),%ecx
    9d93:	66 89 8a d4 02 00 00 	mov    %cx,0x2d4(%edx)
    9d9a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    9da0:	8b 00                	mov    (%eax),%eax
    9da2:	0f b7 92 d4 02 00 00 	movzwl 0x2d4(%edx),%edx
    9da9:	66 89 90 d2 02 00 00 	mov    %dx,0x2d2(%eax)
    9db0:	eb 4b                	jmp    9dfd <sys_setgid+0xaa>
	else if ((gid == current->gid) || (gid == current->sgid))
    9db2:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9db8:	8b 12                	mov    (%edx),%edx
    9dba:	0f b7 92 d2 02 00 00 	movzwl 0x2d2(%edx),%edx
    9dc1:	0f b7 d2             	movzwl %dx,%edx
    9dc4:	39 54 24 04          	cmp    %edx,0x4(%esp)
    9dc8:	74 18                	je     9de2 <sys_setgid+0x8f>
    9dca:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9dd0:	8b 12                	mov    (%edx),%edx
    9dd2:	0f b7 92 d6 02 00 00 	movzwl 0x2d6(%edx),%edx
    9dd9:	0f b7 d2             	movzwl %dx,%edx
    9ddc:	39 54 24 04          	cmp    %edx,0x4(%esp)
    9de0:	75 15                	jne    9df7 <sys_setgid+0xa4>
		current->egid = gid;
    9de2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    9de8:	8b 00                	mov    (%eax),%eax
    9dea:	8b 54 24 04          	mov    0x4(%esp),%edx
    9dee:	66 89 90 d4 02 00 00 	mov    %dx,0x2d4(%eax)
    9df5:	eb 06                	jmp    9dfd <sys_setgid+0xaa>
	else
		return -EPERM;
    9df7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9dfc:	c3                   	ret    
	return 0;
    9dfd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9e02:	c3                   	ret    

00009e03 <sys_acct>:

// 打开或关闭进程计账功能。
int sys_acct()
{
    9e03:	e8 ea ce ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9e08:	05 f8 81 02 00       	add    $0x281f8,%eax
	return -ENOSYS;
    9e0d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9e12:	c3                   	ret    

00009e13 <sys_phys>:

// 映射任意物理内在到进程的虚拟地址空间。
int sys_phys()
{
    9e13:	e8 da ce ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9e18:	05 e8 81 02 00       	add    $0x281e8,%eax
	return -ENOSYS;
    9e1d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9e22:	c3                   	ret    

00009e23 <sys_lock>:

int sys_lock()
{
    9e23:	e8 ca ce ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9e28:	05 d8 81 02 00       	add    $0x281d8,%eax
	return -ENOSYS;
    9e2d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9e32:	c3                   	ret    

00009e33 <sys_mpx>:

int sys_mpx()
{
    9e33:	e8 ba ce ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9e38:	05 c8 81 02 00       	add    $0x281c8,%eax
	return -ENOSYS;
    9e3d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9e42:	c3                   	ret    

00009e43 <sys_ulimit>:

int sys_ulimit()
{
    9e43:	e8 aa ce ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9e48:	05 b8 81 02 00       	add    $0x281b8,%eax
	return -ENOSYS;
    9e4d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9e52:	c3                   	ret    

00009e53 <sys_time>:

// 返回从1970年1月1日00:00:00 GMT开始计时的时间值（秒）。如果tloc不为null，则时间值也存储在那里。
// 由于参数是一个指针，而其所指位置在用户空间，因此需要使用函数put_fs_long()来访问该值。在进入内核中运行时，段
// 寄存器fs默认地指向当前用户数据空间。因此该函数就可利用fs来访问用户空间中的值。
int sys_time(long * tloc)
{
    9e53:	53                   	push   %ebx
    9e54:	83 ec 18             	sub    $0x18,%esp
    9e57:	e8 db 2b 00 00       	call   ca37 <__x86.get_pc_thunk.cx>
    9e5c:	81 c1 a4 81 02 00    	add    $0x281a4,%ecx
	int i;

	i = CURRENT_TIME;
    9e62:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    9e68:	8b 10                	mov    (%eax),%edx
    9e6a:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    9e70:	8b 00                	mov    (%eax),%eax
    9e72:	01 d0                	add    %edx,%eax
    9e74:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    9e79:	f7 e2                	mul    %edx
    9e7b:	c1 ea 05             	shr    $0x5,%edx
    9e7e:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    9e84:	8b 00                	mov    (%eax),%eax
    9e86:	01 d0                	add    %edx,%eax
    9e88:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (tloc) {
    9e8c:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    9e91:	74 27                	je     9eba <sys_time+0x67>
		verify_area(tloc,4);            				// 验证内存容量是否够（这里是4字节）。
    9e93:	83 ec 08             	sub    $0x8,%esp
    9e96:	6a 04                	push   $0x4
    9e98:	ff 74 24 2c          	pushl  0x2c(%esp)
    9e9c:	89 cb                	mov    %ecx,%ebx
    9e9e:	e8 58 ea ff ff       	call   88fb <verify_area>
    9ea3:	83 c4 10             	add    $0x10,%esp
		put_fs_long(i,(unsigned long *)tloc);   		// 放入用户数据段tloc处。
    9ea6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9eaa:	83 ec 08             	sub    $0x8,%esp
    9ead:	ff 74 24 28          	pushl  0x28(%esp)
    9eb1:	50                   	push   %eax
    9eb2:	e8 0d fd ff ff       	call   9bc4 <put_fs_long>
    9eb7:	83 c4 10             	add    $0x10,%esp
	}
	return i;
    9eba:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    9ebe:	83 c4 18             	add    $0x18,%esp
    9ec1:	5b                   	pop    %ebx
    9ec2:	c3                   	ret    

00009ec3 <sys_setreuid>:
 * 用setuid()和保存的gid的程序将会与POSIX 100%兼容。
 */
// 设置任务的实际以及/或者有效的用户ID（uid）。如果任务没有超级用户特权，那么只能互换其实际的uid和有效的uid。如果
// 任务具有超级用户特权，就能任意设置有效的和实际的用户ID。保存的uid（saved uid）被设置成与有效uid同值。
int sys_setreuid(int ruid, int euid)
{
    9ec3:	83 ec 10             	sub    $0x10,%esp
    9ec6:	e8 27 ce ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9ecb:	05 35 81 02 00       	add    $0x28135,%eax
	int old_ruid = current->uid;
    9ed0:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9ed6:	8b 12                	mov    (%edx),%edx
    9ed8:	0f b7 92 cc 02 00 00 	movzwl 0x2cc(%edx),%edx
    9edf:	0f b7 d2             	movzwl %dx,%edx
    9ee2:	89 54 24 0c          	mov    %edx,0xc(%esp)

	if (ruid > 0) {
    9ee6:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    9eeb:	7e 55                	jle    9f42 <sys_setreuid+0x7f>
		if ((current->euid == ruid) ||
    9eed:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9ef3:	8b 12                	mov    (%edx),%edx
    9ef5:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
    9efc:	0f b7 d2             	movzwl %dx,%edx
    9eff:	39 54 24 14          	cmp    %edx,0x14(%esp)
    9f03:	74 1e                	je     9f23 <sys_setreuid+0x60>
    9f05:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9f09:	3b 54 24 14          	cmp    0x14(%esp),%edx
    9f0d:	74 14                	je     9f23 <sys_setreuid+0x60>
                    (old_ruid == ruid) ||
		    suser())
    9f0f:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9f15:	8b 12                	mov    (%edx),%edx
    9f17:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
                    (old_ruid == ruid) ||
    9f1e:	66 85 d2             	test   %dx,%dx
    9f21:	75 15                	jne    9f38 <sys_setreuid+0x75>
			current->uid = ruid;
    9f23:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9f29:	8b 12                	mov    (%edx),%edx
    9f2b:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    9f2f:	66 89 8a cc 02 00 00 	mov    %cx,0x2cc(%edx)
    9f36:	eb 0a                	jmp    9f42 <sys_setreuid+0x7f>
		else
			return(-EPERM);
    9f38:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9f3d:	e9 84 00 00 00       	jmp    9fc6 <sys_setreuid+0x103>
	}
	if (euid > 0) {
    9f42:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    9f47:	7e 78                	jle    9fc1 <sys_setreuid+0xfe>
		if ((old_ruid == euid) ||
    9f49:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9f4d:	3b 54 24 18          	cmp    0x18(%esp),%edx
    9f51:	74 2c                	je     9f7f <sys_setreuid+0xbc>
                    (current->euid == euid) ||
    9f53:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9f59:	8b 12                	mov    (%edx),%edx
    9f5b:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
    9f62:	0f b7 d2             	movzwl %dx,%edx
		if ((old_ruid == euid) ||
    9f65:	39 54 24 18          	cmp    %edx,0x18(%esp)
    9f69:	74 14                	je     9f7f <sys_setreuid+0xbc>
		    suser()) {
    9f6b:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9f71:	8b 12                	mov    (%edx),%edx
    9f73:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
                    (current->euid == euid) ||
    9f7a:	66 85 d2             	test   %dx,%dx
    9f7d:	75 28                	jne    9fa7 <sys_setreuid+0xe4>
			current->euid = euid;
    9f7f:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9f85:	8b 12                	mov    (%edx),%edx
    9f87:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    9f8b:	66 89 8a ce 02 00 00 	mov    %cx,0x2ce(%edx)
			current->suid = euid;
    9f92:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    9f98:	8b 00                	mov    (%eax),%eax
    9f9a:	8b 54 24 18          	mov    0x18(%esp),%edx
    9f9e:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%eax)
    9fa5:	eb 1a                	jmp    9fc1 <sys_setreuid+0xfe>
		} else {
			current->uid = old_ruid;
    9fa7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    9fad:	8b 00                	mov    (%eax),%eax
    9faf:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9fb3:	66 89 90 cc 02 00 00 	mov    %dx,0x2cc(%eax)
			return(-EPERM);
    9fba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9fbf:	eb 05                	jmp    9fc6 <sys_setreuid+0x103>
		}
	}
	return 0;
    9fc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9fc6:	83 c4 10             	add    $0x10,%esp
    9fc9:	c3                   	ret    

00009fca <sys_setuid>:
 */
// 设置任务用户ID（uid）。如果任务没有超级用户特权，它可以使用setuid()将其有效的uid（effective uid）设置成其保存
// 的uid（saved uid）或其实际的uid（real uid）。如果用户有超级用户特权，则实际的uid、有效的uid和保存的uid都会被
// 设置成参数指定的uid。
int sys_setuid(int uid)
{
    9fca:	e8 23 cd ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    9fcf:	05 31 80 02 00       	add    $0x28031,%eax
	if (suser())
    9fd4:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9fda:	8b 12                	mov    (%edx),%edx
    9fdc:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
    9fe3:	66 85 d2             	test   %dx,%dx
    9fe6:	75 41                	jne    a029 <sys_setuid+0x5f>
		current->uid = current->euid = current->suid = uid;
    9fe8:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    9fee:	8b 0a                	mov    (%edx),%ecx
    9ff0:	8b 54 24 04          	mov    0x4(%esp),%edx
    9ff4:	66 89 91 d0 02 00 00 	mov    %dx,0x2d0(%ecx)
    9ffb:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a001:	8b 12                	mov    (%edx),%edx
    a003:	0f b7 89 d0 02 00 00 	movzwl 0x2d0(%ecx),%ecx
    a00a:	66 89 8a ce 02 00 00 	mov    %cx,0x2ce(%edx)
    a011:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a017:	8b 00                	mov    (%eax),%eax
    a019:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
    a020:	66 89 90 cc 02 00 00 	mov    %dx,0x2cc(%eax)
    a027:	eb 4b                	jmp    a074 <sys_setuid+0xaa>
	else if ((uid == current->uid) || (uid == current->suid))
    a029:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a02f:	8b 12                	mov    (%edx),%edx
    a031:	0f b7 92 cc 02 00 00 	movzwl 0x2cc(%edx),%edx
    a038:	0f b7 d2             	movzwl %dx,%edx
    a03b:	39 54 24 04          	cmp    %edx,0x4(%esp)
    a03f:	74 18                	je     a059 <sys_setuid+0x8f>
    a041:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a047:	8b 12                	mov    (%edx),%edx
    a049:	0f b7 92 d0 02 00 00 	movzwl 0x2d0(%edx),%edx
    a050:	0f b7 d2             	movzwl %dx,%edx
    a053:	39 54 24 04          	cmp    %edx,0x4(%esp)
    a057:	75 15                	jne    a06e <sys_setuid+0xa4>
		current->euid = uid;
    a059:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a05f:	8b 00                	mov    (%eax),%eax
    a061:	8b 54 24 04          	mov    0x4(%esp),%edx
    a065:	66 89 90 ce 02 00 00 	mov    %dx,0x2ce(%eax)
    a06c:	eb 06                	jmp    a074 <sys_setuid+0xaa>
	else
		return -EPERM;
    a06e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a073:	c3                   	ret    
	return(0);
    a074:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a079:	c3                   	ret    

0000a07a <sys_stime>:
// 调用进程必须具有超级用户权限。其中HZ=100,是内核系统运行频率。
// 由于参数是一个指针，而其所指位置在用户空间，因此需要使用函数get_fs_long()来访问该值。在进入内核中运行时，段
// 寄存器fs被默认地指向当前用户数据空间。因此该函数就可利用fs来访问用户空间中的值。函数参数提供的当前时间值减去
// 系统已经运行的时间秒值（jiffies/HZ）即是开机时间秒值。
int sys_stime(long * tptr)
{
    a07a:	53                   	push   %ebx
    a07b:	e8 7a cc ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a080:	81 c3 80 7f 02 00    	add    $0x27f80,%ebx
	if (!suser())
    a086:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a08c:	8b 00                	mov    (%eax),%eax
    a08e:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    a095:	66 85 c0             	test   %ax,%ax
    a098:	74 07                	je     a0a1 <sys_stime+0x27>
		return -EPERM;          					// 如果不是超级用户则出错返回（许可）。
    a09a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a09f:	eb 3f                	jmp    a0e0 <sys_stime+0x66>
	startup_time = get_fs_long((unsigned long *)tptr) - jiffies / HZ;
    a0a1:	ff 74 24 08          	pushl  0x8(%esp)
    a0a5:	e8 b0 fa ff ff       	call   9b5a <get_fs_long>
    a0aa:	83 c4 04             	add    $0x4,%esp
    a0ad:	89 c1                	mov    %eax,%ecx
    a0af:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    a0b5:	8b 00                	mov    (%eax),%eax
    a0b7:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a0bc:	f7 e2                	mul    %edx
    a0be:	89 d0                	mov    %edx,%eax
    a0c0:	c1 e8 05             	shr    $0x5,%eax
    a0c3:	29 c1                	sub    %eax,%ecx
    a0c5:	89 ca                	mov    %ecx,%edx
    a0c7:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    a0cd:	89 10                	mov    %edx,(%eax)
	jiffies_offset = 0;
    a0cf:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    a0d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 0;
    a0db:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a0e0:	5b                   	pop    %ebx
    a0e1:	c3                   	ret    

0000a0e2 <sys_times>:

// 获取当前任务运行时间统计值。
// 在tbuf所指用户数据空间处返回tms结构的任务运行时间统计值。tms结构中包括进程用户运行时间、内核（系统）时间、子进
// 程用户运行时间、子进程系统运行时间。函数返回值是系统运行到当前的嘀嗒数。
int sys_times(struct tms * tbuf)
{
    a0e2:	53                   	push   %ebx
    a0e3:	83 ec 08             	sub    $0x8,%esp
    a0e6:	e8 0f cc ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a0eb:	81 c3 15 7f 02 00    	add    $0x27f15,%ebx
	if (tbuf) {
    a0f1:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    a0f6:	0f 84 96 00 00 00    	je     a192 <sys_times+0xb0>
		verify_area(tbuf,sizeof *tbuf);
    a0fc:	83 ec 08             	sub    $0x8,%esp
    a0ff:	6a 10                	push   $0x10
    a101:	ff 74 24 1c          	pushl  0x1c(%esp)
    a105:	e8 f1 e7 ff ff       	call   88fb <verify_area>
    a10a:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);
    a10d:	8b 44 24 10          	mov    0x10(%esp),%eax
    a111:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a117:	8b 12                	mov    (%edx),%edx
    a119:	8b 92 e0 02 00 00    	mov    0x2e0(%edx),%edx
    a11f:	83 ec 08             	sub    $0x8,%esp
    a122:	50                   	push   %eax
    a123:	52                   	push   %edx
    a124:	e8 9b fa ff ff       	call   9bc4 <put_fs_long>
    a129:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);
    a12c:	8b 44 24 10          	mov    0x10(%esp),%eax
    a130:	8d 50 04             	lea    0x4(%eax),%edx
    a133:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a139:	8b 00                	mov    (%eax),%eax
    a13b:	8b 80 e4 02 00 00    	mov    0x2e4(%eax),%eax
    a141:	83 ec 08             	sub    $0x8,%esp
    a144:	52                   	push   %edx
    a145:	50                   	push   %eax
    a146:	e8 79 fa ff ff       	call   9bc4 <put_fs_long>
    a14b:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);
    a14e:	8b 44 24 10          	mov    0x10(%esp),%eax
    a152:	8d 50 08             	lea    0x8(%eax),%edx
    a155:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a15b:	8b 00                	mov    (%eax),%eax
    a15d:	8b 80 e8 02 00 00    	mov    0x2e8(%eax),%eax
    a163:	83 ec 08             	sub    $0x8,%esp
    a166:	52                   	push   %edx
    a167:	50                   	push   %eax
    a168:	e8 57 fa ff ff       	call   9bc4 <put_fs_long>
    a16d:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);
    a170:	8b 44 24 10          	mov    0x10(%esp),%eax
    a174:	8d 50 0c             	lea    0xc(%eax),%edx
    a177:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a17d:	8b 00                	mov    (%eax),%eax
    a17f:	8b 80 ec 02 00 00    	mov    0x2ec(%eax),%eax
    a185:	83 ec 08             	sub    $0x8,%esp
    a188:	52                   	push   %edx
    a189:	50                   	push   %eax
    a18a:	e8 35 fa ff ff       	call   9bc4 <put_fs_long>
    a18f:	83 c4 10             	add    $0x10,%esp
	}
	return jiffies;
    a192:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    a198:	8b 00                	mov    (%eax),%eax
}
    a19a:	83 c4 08             	add    $0x8,%esp
    a19d:	5b                   	pop    %ebx
    a19e:	c3                   	ret    

0000a19f <sys_brk>:

// 当参数end_data_seg数值合理，并且系统确实有足够内存，而且进程没有超越其最大数据段大小时，该函数设置数据段末尾为
// end_data_seg指定的值。该值必须大于代码结尾并且要小于堆栈结尾16KB。返回值是数据段的新结尾值（如果返回值与要求不
// 同，则表明有错误发生)。该函数并不被用户直接调用，而由libc库函数进行包装，并且返回值也不一样。
int sys_brk(unsigned long end_data_seg)
{
    a19f:	e8 4e cb ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    a1a4:	05 5c 7e 02 00       	add    $0x27e5c,%eax
	// 如果参数值大于代码结尾，并且小于（堆栈 - 16KB），则设置新数据段结尾值。
	if (end_data_seg >= current->end_code &&
    a1a9:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a1af:	8b 12                	mov    (%edx),%edx
    a1b1:	8b 92 1c 02 00 00    	mov    0x21c(%edx),%edx
    a1b7:	39 54 24 04          	cmp    %edx,0x4(%esp)
    a1bb:	72 2c                	jb     a1e9 <sys_brk+0x4a>
	    end_data_seg < current->start_stack - 16384)
    a1bd:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a1c3:	8b 12                	mov    (%edx),%edx
    a1c5:	8b 92 28 02 00 00    	mov    0x228(%edx),%edx
    a1cb:	81 ea 00 40 00 00    	sub    $0x4000,%edx
	if (end_data_seg >= current->end_code &&
    a1d1:	39 54 24 04          	cmp    %edx,0x4(%esp)
    a1d5:	73 12                	jae    a1e9 <sys_brk+0x4a>
		current->brk = end_data_seg;
    a1d7:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a1dd:	8b 12                	mov    (%edx),%edx
    a1df:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    a1e3:	89 8a 24 02 00 00    	mov    %ecx,0x224(%edx)
	return current->brk;            			// 返回进程当前的数据段结尾值。
    a1e9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a1ef:	8b 00                	mov    (%eax),%eax
    a1f1:	8b 80 24 02 00 00    	mov    0x224(%eax),%eax
}
    a1f7:	c3                   	ret    

0000a1f8 <sys_setpgid>:
// 设置指定进程pid的进程组号为pgid。
// 参数pid是指定进程的进程号。如果它为0,则让pid等于当前进程的进程号。参数pgid是指定的进程组号。如果它为0,则让它等于
// 进程组号。如果该函数用于将进程从一个进程组移到另一个进程组，则这两个进程组必须属于同一个会话（session）。在这种情
// 况下，参数pgid指定了要加入的现在进程组ID，此时该组的会话ID必须与将要加入进程的相同。
int sys_setpgid(int pid, int pgid)
{
    a1f8:	53                   	push   %ebx
    a1f9:	83 ec 18             	sub    $0x18,%esp
    a1fc:	e8 f9 ca ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a201:	81 c3 ff 7d 02 00    	add    $0x27dff,%ebx
	int i;

	// 如果参数pid为0,则pid取值为当前进程的进程号pid。如果参数pgid为0,则pgid也取值为当前进程的pid。[??这里与POSIX标
	// 准的描述有出入]。若pgid小于0,则返回无效错误码。
	if (!pid)
    a207:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    a20c:	75 12                	jne    a220 <sys_setpgid+0x28>
		pid = current->pid;
    a20e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a214:	8b 00                	mov    (%eax),%eax
    a216:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    a21c:	89 44 24 20          	mov    %eax,0x20(%esp)
	if (!pgid)
    a220:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    a225:	75 12                	jne    a239 <sys_setpgid+0x41>
		pgid = current->pid;
    a227:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a22d:	8b 00                	mov    (%eax),%eax
    a22f:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    a235:	89 44 24 24          	mov    %eax,0x24(%esp)
	if (pgid < 0)
    a239:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    a23e:	79 0a                	jns    a24a <sys_setpgid+0x52>
		return -EINVAL;
    a240:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    a245:	e9 28 01 00 00       	jmp    a372 <sys_setpgid+0x17a>
	// 扫描任务数组，查找指定进程号pid的任务。如果找到了进程号是pid的进程，并且该进程的父进程就是当前进程或者该进程就是当
	// 前进程，那么若该任务已经是会话首领，则出错返回。若该任务的会话号（session）与当前进程的不同，或者指定的进程组号pgid
	// 与pid不同并且pgid进程组所属会话号与当前进程所属会话号不同，则也出错返回。否则把查找到的进程的pgrp设置为pgid，并
	// 返回0。若没有找到指定pid的进程，则返回进程不存在出错码。
	for (i = 0 ; i < NR_TASKS ; i++)
    a24a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a251:	00 
    a252:	e9 0b 01 00 00       	jmp    a362 <sys_setpgid+0x16a>
		if (task[i] && (task[i]->pid == pid) && ((task[i]->p_pptr == current) || (task[i] == current))) {
    a257:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    a25d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a261:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a264:	85 c0                	test   %eax,%eax
    a266:	0f 84 f1 00 00 00    	je     a35d <sys_setpgid+0x165>
    a26c:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    a272:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a276:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a279:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    a27f:	39 44 24 20          	cmp    %eax,0x20(%esp)
    a283:	0f 85 d4 00 00 00    	jne    a35d <sys_setpgid+0x165>
    a289:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    a28f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a293:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a296:	8b 90 bc 02 00 00    	mov    0x2bc(%eax),%edx
    a29c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a2a2:	8b 00                	mov    (%eax),%eax
    a2a4:	39 c2                	cmp    %eax,%edx
    a2a6:	74 1d                	je     a2c5 <sys_setpgid+0xcd>
    a2a8:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    a2ae:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a2b2:	8b 14 90             	mov    (%eax,%edx,4),%edx
    a2b5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a2bb:	8b 00                	mov    (%eax),%eax
    a2bd:	39 c2                	cmp    %eax,%edx
    a2bf:	0f 85 98 00 00 00    	jne    a35d <sys_setpgid+0x165>
			if (task[i]->leader)
    a2c5:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    a2cb:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a2cf:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a2d2:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
    a2d8:	85 c0                	test   %eax,%eax
    a2da:	74 0a                	je     a2e6 <sys_setpgid+0xee>
				return -EPERM;
    a2dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a2e1:	e9 8c 00 00 00       	jmp    a372 <sys_setpgid+0x17a>
			if ((task[i]->session != current->session) ||
    a2e6:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    a2ec:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a2f0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a2f3:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    a2f9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a2ff:	8b 00                	mov    (%eax),%eax
    a301:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    a307:	39 c2                	cmp    %eax,%edx
    a309:	75 2d                	jne    a338 <sys_setpgid+0x140>
    a30b:	8b 44 24 24          	mov    0x24(%esp),%eax
    a30f:	3b 44 24 20          	cmp    0x20(%esp),%eax
    a313:	74 2a                	je     a33f <sys_setpgid+0x147>
			    ((pgid != pid) &&
			     (session_of_pgrp(pgid) != current->session)))
    a315:	83 ec 0c             	sub    $0xc,%esp
    a318:	ff 74 24 30          	pushl  0x30(%esp)
    a31c:	e8 bb 12 00 00       	call   b5dc <session_of_pgrp>
    a321:	83 c4 10             	add    $0x10,%esp
    a324:	89 c2                	mov    %eax,%edx
    a326:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a32c:	8b 00                	mov    (%eax),%eax
    a32e:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
			    ((pgid != pid) &&
    a334:	39 c2                	cmp    %eax,%edx
    a336:	74 07                	je     a33f <sys_setpgid+0x147>
				return -EPERM;
    a338:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a33d:	eb 33                	jmp    a372 <sys_setpgid+0x17a>
			task[i]->pgrp = pgid;
    a33f:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    a345:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a349:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a34c:	8b 54 24 24          	mov    0x24(%esp),%edx
    a350:	89 90 30 02 00 00    	mov    %edx,0x230(%eax)
			return 0;
    a356:	b8 00 00 00 00       	mov    $0x0,%eax
    a35b:	eb 15                	jmp    a372 <sys_setpgid+0x17a>
	for (i = 0 ; i < NR_TASKS ; i++)
    a35d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    a362:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    a367:	0f 8e ea fe ff ff    	jle    a257 <sys_setpgid+0x5f>
		}
	return -ESRCH;
    a36d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
    a372:	83 c4 18             	add    $0x18,%esp
    a375:	5b                   	pop    %ebx
    a376:	c3                   	ret    

0000a377 <sys_getpgrp>:

// 返回当前进程的进程组号。与getpgid(0)等同。
int sys_getpgrp(void)
{
    a377:	e8 76 c9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    a37c:	05 84 7c 02 00       	add    $0x27c84,%eax
	return current->pgrp;
    a381:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a387:	8b 00                	mov    (%eax),%eax
    a389:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
}
    a38f:	c3                   	ret    

0000a390 <sys_setsid>:

// 创建一个会话（session）（即设置其leader = 1），并且设置其会话号=其组号=其进程号。
// 如果当前进程已是会话首领并且不是超级用户，则出错返回。否则设置当前进程为新会话首领（leader = 1），并且设置当前进程会话
// 号session和组号pgrp都等于进程号pid，而且设置当前进程没有控制终端。最后系统调用返回会话号。
int sys_setsid(void)
{
    a390:	e8 5d c9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    a395:	05 6b 7c 02 00       	add    $0x27c6b,%eax
	if (current->leader && !suser())
    a39a:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a3a0:	8b 12                	mov    (%edx),%edx
    a3a2:	8b 92 38 02 00 00    	mov    0x238(%edx),%edx
    a3a8:	85 d2                	test   %edx,%edx
    a3aa:	74 1a                	je     a3c6 <sys_setsid+0x36>
    a3ac:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a3b2:	8b 12                	mov    (%edx),%edx
    a3b4:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
    a3bb:	66 85 d2             	test   %dx,%dx
    a3be:	74 06                	je     a3c6 <sys_setsid+0x36>
		return -EPERM;
    a3c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a3c5:	c3                   	ret    
	current->leader = 1;
    a3c6:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a3cc:	8b 12                	mov    (%edx),%edx
    a3ce:	c7 82 38 02 00 00 01 	movl   $0x1,0x238(%edx)
    a3d5:	00 00 00 
	current->session = current->pgrp = current->pid;
    a3d8:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a3de:	8b 0a                	mov    (%edx),%ecx
    a3e0:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a3e6:	8b 12                	mov    (%edx),%edx
    a3e8:	8b 89 2c 02 00 00    	mov    0x22c(%ecx),%ecx
    a3ee:	89 8a 30 02 00 00    	mov    %ecx,0x230(%edx)
    a3f4:	c7 c1 80 32 03 00    	mov    $0x33280,%ecx
    a3fa:	8b 09                	mov    (%ecx),%ecx
    a3fc:	8b 92 30 02 00 00    	mov    0x230(%edx),%edx
    a402:	89 91 34 02 00 00    	mov    %edx,0x234(%ecx)
	current->tty = -1;      				// 表示当前进程没有控制终端。
    a408:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a40e:	8b 12                	mov    (%edx),%edx
    a410:	c7 82 2c 03 00 00 ff 	movl   $0xffffffff,0x32c(%edx)
    a417:	ff ff ff 
	return current->pgrp;
    a41a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a420:	8b 00                	mov    (%eax),%eax
    a422:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
}
    a428:	c3                   	ret    

0000a429 <sys_getgroups>:
// 取当前进程其他辅助用户组号。
// 任务数据结构中groups[]数组保存着进程同时所属的多个用户组号。该数组共NGROUPS个项，若某项值是NOGROUP（即为-1），则
// 表示从该项开始以后所有项都空闲。否则数组项中保存的是用户组号。
// 参数gidsetsize是获取的用户组号个数；grouplist是存储这些用户组号的用户空间缓存。
int sys_getgroups(int gidsetsize, gid_t *grouplist)
{
    a429:	53                   	push   %ebx
    a42a:	83 ec 18             	sub    $0x18,%esp
    a42d:	e8 c8 c8 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a432:	81 c3 ce 7b 02 00    	add    $0x27bce,%ebx

	// 首先验证grouplist指针所指的用户缓存空间是否足够，然后从当前进程结构的groups[]数组中逐个取得用户组号并复制到用户缓存
	// 中。在复制过程中，如果groups[]中的项数大于给定的参数gitsetsize所指定的个数，则表示用户给出的缓存太小，不能容下当前
	// 进程所有组号，因此此次取组号操作会出错返回。若复制过程正常，则函数最后会返回复制的用户组号个数。（gidsetsize - gid
	// set size，用户组号集大小）。
	if (gidsetsize)
    a438:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    a43d:	74 16                	je     a455 <sys_getgroups+0x2c>
		verify_area(grouplist, sizeof(gid_t) * gidsetsize);
    a43f:	8b 44 24 20          	mov    0x20(%esp),%eax
    a443:	01 c0                	add    %eax,%eax
    a445:	83 ec 08             	sub    $0x8,%esp
    a448:	50                   	push   %eax
    a449:	ff 74 24 30          	pushl  0x30(%esp)
    a44d:	e8 a9 e4 ff ff       	call   88fb <verify_area>
    a452:	83 c4 10             	add    $0x10,%esp

	for (i = 0; (i < NGROUPS) && (current->groups[i] != NOGROUP); i++, grouplist++) {
    a455:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a45c:	00 
    a45d:	eb 49                	jmp    a4a8 <sys_getgroups+0x7f>
		if (gidsetsize) {
    a45f:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    a464:	74 38                	je     a49e <sys_getgroups+0x75>
			if (i >= gidsetsize)
    a466:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a46a:	3b 44 24 20          	cmp    0x20(%esp),%eax
    a46e:	7c 07                	jl     a477 <sys_getgroups+0x4e>
				return -EINVAL;
    a470:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    a475:	eb 57                	jmp    a4ce <sys_getgroups+0xa5>
			put_fs_word(current->groups[i], (short *) grouplist);
    a477:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a47d:	8b 00                	mov    (%eax),%eax
    a47f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a483:	81 c2 8c 00 00 00    	add    $0x8c,%edx
    a489:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    a48d:	98                   	cwtl   
    a48e:	83 ec 08             	sub    $0x8,%esp
    a491:	ff 74 24 2c          	pushl  0x2c(%esp)
    a495:	50                   	push   %eax
    a496:	e8 03 f7 ff ff       	call   9b9e <put_fs_word>
    a49b:	83 c4 10             	add    $0x10,%esp
	for (i = 0; (i < NGROUPS) && (current->groups[i] != NOGROUP); i++, grouplist++) {
    a49e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    a4a3:	83 44 24 24 02       	addl   $0x2,0x24(%esp)
    a4a8:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
    a4ad:	7f 1b                	jg     a4ca <sys_getgroups+0xa1>
    a4af:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a4b5:	8b 00                	mov    (%eax),%eax
    a4b7:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a4bb:	81 c2 8c 00 00 00    	add    $0x8c,%edx
    a4c1:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    a4c5:	83 f8 ff             	cmp    $0xffffffff,%eax
    a4c8:	75 95                	jne    a45f <sys_getgroups+0x36>
		}
	}
	return(i);              				// 返回实际含有的用户组号个数。
    a4ca:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    a4ce:	83 c4 18             	add    $0x18,%esp
    a4d1:	5b                   	pop    %ebx
    a4d2:	c3                   	ret    

0000a4d3 <sys_setgroups>:

// 设置当前进程同时所属的其他辅助用户组号。
// 参数gidsetsize是将设置的用户组号个数；grouplist是含有用户组号的用户空间缓存。
int sys_setgroups(int gidsetsize, gid_t *grouplist)
{
    a4d3:	53                   	push   %ebx
    a4d4:	83 ec 10             	sub    $0x10,%esp
    a4d7:	e8 1e c8 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a4dc:	81 c3 24 7b 02 00    	add    $0x27b24,%ebx
	int	i;

	// 首先查权限和参数的有效性。只有超级用户可以修改或设置当前进程的辅助用户组号，而且设置的项数不能超过进程的groups[NGROUPS]
	// 数组的容量。然后从用户缓冲中逐个复制用户组号，共gidsetsize个。如果复制的个数没有填满group[]，则在随后一项上填上值为-1
	// 的项（NOGROUP）。最后函数返回0。
	if (!suser())
    a4e2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a4e8:	8b 00                	mov    (%eax),%eax
    a4ea:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    a4f1:	66 85 c0             	test   %ax,%ax
    a4f4:	74 07                	je     a4fd <sys_setgroups+0x2a>
		return -EPERM;
    a4f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a4fb:	eb 79                	jmp    a576 <sys_setgroups+0xa3>
	if (gidsetsize > NGROUPS)
    a4fd:	83 7c 24 18 20       	cmpl   $0x20,0x18(%esp)
    a502:	7e 07                	jle    a50b <sys_setgroups+0x38>
		return -EINVAL;
    a504:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    a509:	eb 6b                	jmp    a576 <sys_setgroups+0xa3>
	for (i = 0; i < gidsetsize; i++, grouplist++) {
    a50b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a512:	00 
    a513:	eb 31                	jmp    a546 <sys_setgroups+0x73>
		current->groups[i] = get_fs_word((unsigned short *) grouplist);
    a515:	ff 74 24 1c          	pushl  0x1c(%esp)
    a519:	e8 19 f6 ff ff       	call   9b37 <get_fs_word>
    a51e:	83 c4 04             	add    $0x4,%esp
    a521:	89 c2                	mov    %eax,%edx
    a523:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a529:	8b 00                	mov    (%eax),%eax
    a52b:	0f b7 d2             	movzwl %dx,%edx
    a52e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    a532:	81 c1 8c 00 00 00    	add    $0x8c,%ecx
    a538:	89 54 88 0c          	mov    %edx,0xc(%eax,%ecx,4)
	for (i = 0; i < gidsetsize; i++, grouplist++) {
    a53c:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    a541:	83 44 24 1c 02       	addl   $0x2,0x1c(%esp)
    a546:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a54a:	3b 44 24 18          	cmp    0x18(%esp),%eax
    a54e:	7c c5                	jl     a515 <sys_setgroups+0x42>
	}
	if (i < NGROUPS)
    a550:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
    a555:	7f 1a                	jg     a571 <sys_setgroups+0x9e>
		current->groups[i] = NOGROUP;
    a557:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a55d:	8b 00                	mov    (%eax),%eax
    a55f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a563:	81 c2 8c 00 00 00    	add    $0x8c,%edx
    a569:	c7 44 90 0c ff ff ff 	movl   $0xffffffff,0xc(%eax,%edx,4)
    a570:	ff 
	return 0;
    a571:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a576:	83 c4 10             	add    $0x10,%esp
    a579:	5b                   	pop    %ebx
    a57a:	c3                   	ret    

0000a57b <in_group_p>:

// 检查当前进程是否在指定的用户组grp中.是则返回1,否则返回0.
int in_group_p(gid_t grp)
{
    a57b:	83 ec 14             	sub    $0x14,%esp
    a57e:	e8 6f c7 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    a583:	05 7d 7a 02 00       	add    $0x27a7d,%eax
    a588:	8b 54 24 18          	mov    0x18(%esp),%edx
    a58c:	66 89 14 24          	mov    %dx,(%esp)
	int	i;

	// 如果当前进程的有效组号就是grp,则表示进程属于grp进程组.函数返回1.否则就在进程的辅助用户组数组中扫描是否有grp进程组号.若
	// 有则函数也返回1.若扫描到值为NOGROUP的项,表示已扫描完全部有效项没有发现匹配的组号,因此函数返回0.
	if (grp == current->egid)
    a590:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a596:	8b 12                	mov    (%edx),%edx
    a598:	0f b7 92 d4 02 00 00 	movzwl 0x2d4(%edx),%edx
    a59f:	66 39 14 24          	cmp    %dx,(%esp)
    a5a3:	75 07                	jne    a5ac <in_group_p+0x31>
		return 1;
    a5a5:	b8 01 00 00 00       	mov    $0x1,%eax
    a5aa:	eb 5e                	jmp    a60a <in_group_p+0x8f>

	for (i = 0; i < NGROUPS; i++) {
    a5ac:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    a5b3:	00 
    a5b4:	eb 45                	jmp    a5fb <in_group_p+0x80>
		if (current->groups[i] == NOGROUP)
    a5b6:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a5bc:	8b 12                	mov    (%edx),%edx
    a5be:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    a5c2:	81 c1 8c 00 00 00    	add    $0x8c,%ecx
    a5c8:	8b 54 8a 0c          	mov    0xc(%edx,%ecx,4),%edx
    a5cc:	83 fa ff             	cmp    $0xffffffff,%edx
    a5cf:	74 33                	je     a604 <in_group_p+0x89>
			break;
		if (current->groups[i] == grp)
    a5d1:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    a5d7:	8b 12                	mov    (%edx),%edx
    a5d9:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    a5dd:	81 c1 8c 00 00 00    	add    $0x8c,%ecx
    a5e3:	8b 4c 8a 0c          	mov    0xc(%edx,%ecx,4),%ecx
    a5e7:	0f b7 14 24          	movzwl (%esp),%edx
    a5eb:	39 d1                	cmp    %edx,%ecx
    a5ed:	75 07                	jne    a5f6 <in_group_p+0x7b>
			return 1;
    a5ef:	b8 01 00 00 00       	mov    $0x1,%eax
    a5f4:	eb 14                	jmp    a60a <in_group_p+0x8f>
	for (i = 0; i < NGROUPS; i++) {
    a5f6:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
    a5fb:	83 7c 24 10 1f       	cmpl   $0x1f,0x10(%esp)
    a600:	7e b4                	jle    a5b6 <in_group_p+0x3b>
    a602:	eb 01                	jmp    a605 <in_group_p+0x8a>
			break;
    a604:	90                   	nop
	}
	return 0;
    a605:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a60a:	83 c4 14             	add    $0x14,%esp
    a60d:	c3                   	ret    

0000a60e <sys_uname>:
	UTS_SYSNAME, UTS_NODENAME, UTS_RELEASE, UTS_VERSION, UTS_MACHINE
};

// 获取系统名称等信息。
int sys_uname(struct utsname * name)
{
    a60e:	53                   	push   %ebx
    a60f:	83 ec 18             	sub    $0x18,%esp
    a612:	e8 e3 c6 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a617:	81 c3 e9 79 02 00    	add    $0x279e9,%ebx
	int i;

	if (!name) return -ERROR;
    a61d:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    a622:	75 07                	jne    a62b <sys_uname+0x1d>
    a624:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
    a629:	eb 57                	jmp    a682 <sys_uname+0x74>
	verify_area(name,sizeof *name);
    a62b:	83 ec 08             	sub    $0x8,%esp
    a62e:	6a 2d                	push   $0x2d
    a630:	ff 74 24 2c          	pushl  0x2c(%esp)
    a634:	e8 c2 e2 ff ff       	call   88fb <verify_area>
    a639:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < sizeof *name; i++)
    a63c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a643:	00 
    a644:	eb 2e                	jmp    a674 <sys_uname+0x66>
		put_fs_byte(((char *) &thisname)[i], i + (char *) name);
    a646:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a64a:	8b 44 24 20          	mov    0x20(%esp),%eax
    a64e:	01 c2                	add    %eax,%edx
    a650:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    a654:	8d 83 80 00 00 00    	lea    0x80(%ebx),%eax
    a65a:	01 c8                	add    %ecx,%eax
    a65c:	0f b6 00             	movzbl (%eax),%eax
    a65f:	0f be c0             	movsbl %al,%eax
    a662:	83 ec 08             	sub    $0x8,%esp
    a665:	52                   	push   %edx
    a666:	50                   	push   %eax
    a667:	e8 0e f5 ff ff       	call   9b7a <put_fs_byte>
    a66c:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < sizeof *name; i++)
    a66f:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    a674:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a678:	83 f8 2c             	cmp    $0x2c,%eax
    a67b:	76 c9                	jbe    a646 <sys_uname+0x38>
	return 0;
    a67d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a682:	83 c4 18             	add    $0x18,%esp
    a685:	5b                   	pop    %ebx
    a686:	c3                   	ret    

0000a687 <sys_sethostname>:
 * 通过调用uname()只能实现sethostname和gethostname。
 */
// 设置系统主机名（系统的网络节点名）。
// 参数name指针指向用户数据区中含有主机名字符串的缓冲区；len是主机名字符串长度。
int sys_sethostname(char *name, int len)
{
    a687:	53                   	push   %ebx
    a688:	83 ec 10             	sub    $0x10,%esp
    a68b:	e8 6a c6 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a690:	81 c3 70 79 02 00    	add    $0x27970,%ebx
	int	i;

	// 系统主机名只能由超级用户设置或修改，并且主机名长度不能超过最大长度MAXHOSTNAMELEN。
	if (!suser())
    a696:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a69c:	8b 00                	mov    (%eax),%eax
    a69e:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    a6a5:	66 85 c0             	test   %ax,%ax
    a6a8:	74 0a                	je     a6b4 <sys_sethostname+0x2d>
		return -EPERM;
    a6aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a6af:	e9 92 00 00 00       	jmp    a746 <sys_sethostname+0xbf>
	if (len > MAXHOSTNAMELEN)
    a6b4:	83 7c 24 1c 08       	cmpl   $0x8,0x1c(%esp)
    a6b9:	7e 0a                	jle    a6c5 <sys_sethostname+0x3e>
		return -EINVAL;
    a6bb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    a6c0:	e9 81 00 00 00       	jmp    a746 <sys_sethostname+0xbf>
	for (i = 0; i < len; i++) {
    a6c5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a6cc:	00 
    a6cd:	eb 3b                	jmp    a70a <sys_sethostname+0x83>
		if ((thisname.nodename[i] = get_fs_byte(name + i)) == 0)
    a6cf:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a6d3:	8b 44 24 18          	mov    0x18(%esp),%eax
    a6d7:	01 d0                	add    %edx,%eax
    a6d9:	50                   	push   %eax
    a6da:	e8 40 f4 ff ff       	call   9b1f <get_fs_byte>
    a6df:	83 c4 04             	add    $0x4,%esp
    a6e2:	89 c1                	mov    %eax,%ecx
    a6e4:	8d 93 89 00 00 00    	lea    0x89(%ebx),%edx
    a6ea:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a6ee:	01 d0                	add    %edx,%eax
    a6f0:	88 08                	mov    %cl,(%eax)
    a6f2:	8d 93 89 00 00 00    	lea    0x89(%ebx),%edx
    a6f8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a6fc:	01 d0                	add    %edx,%eax
    a6fe:	0f b6 00             	movzbl (%eax),%eax
    a701:	84 c0                	test   %al,%al
    a703:	74 11                	je     a716 <sys_sethostname+0x8f>
	for (i = 0; i < len; i++) {
    a705:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    a70a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a70e:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
    a712:	7c bb                	jl     a6cf <sys_sethostname+0x48>
    a714:	eb 01                	jmp    a717 <sys_sethostname+0x90>
			break;
    a716:	90                   	nop
	}
	// 在复制完毕后，如果用户提供的字符串没有包含NULL字符，那么若复制的主机名长度还没有超过MAXHOSTNAMELEN，则在主机名字
	// 符串后添加一个NULL。若已经填满MAXHOSTNAMELEN个字符，则把最后一个字符改成NULL字符。即thisname.nodename[min(
	// i,MAXHOSTNAMELEN)] = 0。
	if (thisname.nodename[i]) {
    a717:	8d 93 89 00 00 00    	lea    0x89(%ebx),%edx
    a71d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a721:	01 d0                	add    %edx,%eax
    a723:	0f b6 00             	movzbl (%eax),%eax
    a726:	84 c0                	test   %al,%al
    a728:	74 17                	je     a741 <sys_sethostname+0xba>
		thisname.nodename[i > MAXHOSTNAMELEN ? MAXHOSTNAMELEN : i] = 0;
    a72a:	b8 08 00 00 00       	mov    $0x8,%eax
    a72f:	83 7c 24 0c 08       	cmpl   $0x8,0xc(%esp)
    a734:	0f 4e 44 24 0c       	cmovle 0xc(%esp),%eax
    a739:	c6 84 03 89 00 00 00 	movb   $0x0,0x89(%ebx,%eax,1)
    a740:	00 
	}
	return 0;
    a741:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a746:	83 c4 10             	add    $0x10,%esp
    a749:	5b                   	pop    %ebx
    a74a:	c3                   	ret    

0000a74b <sys_getrlimit>:
// 界限（hard limit，即硬限制）。rlim[]数组的每一项对应系统对当前进程一种资源的界限信息。Linux 0.12系统共对6种资源
// 规定了界限，即RLIM_NLIMITS=6。请参考头文件include/sys/resource.h说明。
// 参数resource指定我们咨询的资源名称，实际上它是任务结构中rlim[]数组的索引项值。
// 参数rlim是指向rlimit结构的用户缓冲区指针，用于存放取得的资源界限信息。
int sys_getrlimit(int resource, struct rlimit *rlim)
{
    a74b:	53                   	push   %ebx
    a74c:	83 ec 08             	sub    $0x8,%esp
    a74f:	e8 a6 c5 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a754:	81 c3 ac 78 02 00    	add    $0x278ac,%ebx
	// 所咨询的资源resource实际上是进程任务结构中rlim[]数组的索引项值。该索引值当然不能大于数组的最大项数RLIM_NLIMITS。
	// 在验证过rlim指针所指用户缓冲足够以后，这里就把参数指定的资源resource结构信息复制到用户缓冲区中，并返回0。
	if (resource >= RLIM_NLIMITS)
    a75a:	83 7c 24 10 05       	cmpl   $0x5,0x10(%esp)
    a75f:	7e 07                	jle    a768 <sys_getrlimit+0x1d>
		return -EINVAL;
    a761:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    a766:	eb 60                	jmp    a7c8 <sys_getrlimit+0x7d>
	verify_area(rlim, sizeof *rlim);
    a768:	83 ec 08             	sub    $0x8,%esp
    a76b:	6a 08                	push   $0x8
    a76d:	ff 74 24 20          	pushl  0x20(%esp)
    a771:	e8 85 e1 ff ff       	call   88fb <verify_area>
    a776:	83 c4 10             	add    $0x10,%esp
	put_fs_long(current->rlim[resource].rlim_cur,           // 当前（软）限制值。
    a779:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a77f:	8b 00                	mov    (%eax),%eax
    a781:	8b 54 24 10          	mov    0x10(%esp),%edx
    a785:	83 c2 5e             	add    $0x5e,%edx
    a788:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
    a78c:	83 ec 08             	sub    $0x8,%esp
    a78f:	ff 74 24 1c          	pushl  0x1c(%esp)
    a793:	50                   	push   %eax
    a794:	e8 2b f4 ff ff       	call   9bc4 <put_fs_long>
    a799:	83 c4 10             	add    $0x10,%esp
		    (unsigned long *) rlim);
	put_fs_long(current->rlim[resource].rlim_max,           // 系统（硬）限制值。
    a79c:	8b 44 24 14          	mov    0x14(%esp),%eax
    a7a0:	8d 50 04             	lea    0x4(%eax),%edx
    a7a3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a7a9:	8b 00                	mov    (%eax),%eax
    a7ab:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    a7af:	83 c1 5e             	add    $0x5e,%ecx
    a7b2:	8b 44 c8 08          	mov    0x8(%eax,%ecx,8),%eax
    a7b6:	83 ec 08             	sub    $0x8,%esp
    a7b9:	52                   	push   %edx
    a7ba:	50                   	push   %eax
    a7bb:	e8 04 f4 ff ff       	call   9bc4 <put_fs_long>
    a7c0:	83 c4 10             	add    $0x10,%esp
		    ((unsigned long *) rlim) + 1);
	return 0;
    a7c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a7c8:	83 c4 08             	add    $0x8,%esp
    a7cb:	5b                   	pop    %ebx
    a7cc:	c3                   	ret    

0000a7cd <sys_setrlimit>:

// 设置当前进程指定资源的界限值。
// 参数resource指定我们设置界限的资源名称，实际上它是任务结构中rlim[]数组的索引项值。
// 参数rlim是指向rlimit结构的用户缓冲区指针，用于内核读取新的资源界限信息。
int sys_setrlimit(int resource, struct rlimit *rlim)
{
    a7cd:	53                   	push   %ebx
    a7ce:	83 ec 10             	sub    $0x10,%esp
    a7d1:	e8 24 c5 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a7d6:	81 c3 2a 78 02 00    	add    $0x2782a,%ebx

	// 首先判断参数resource（任务结构rlim[]项索引值）有效性。然后先让rlimit结构指针old指向进程任务结构中指定资源的当前
	// rlimit结构信息。接着把用户提供的资源界限信息复制到临时rlimit结构new中。此时如果判断出new结构中的软界限值或硬界限
	// 值大于进程该资源原硬界限值，并且当前不是超级用户的话，就返回许可出错。否则表示new中信息合理或者进程是超级用户进程，
	// 则修改原进程指定资源信息等于new结构中的信息，并成功返回0。
	if (resource >= RLIM_NLIMITS)
    a7dc:	83 7c 24 18 05       	cmpl   $0x5,0x18(%esp)
    a7e1:	7e 0a                	jle    a7ed <sys_setrlimit+0x20>
		return -EINVAL;
    a7e3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    a7e8:	e9 8e 00 00 00       	jmp    a87b <sys_setrlimit+0xae>
	old = current->rlim + resource;
    a7ed:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a7f3:	8b 00                	mov    (%eax),%eax
    a7f5:	8d 90 f4 02 00 00    	lea    0x2f4(%eax),%edx
    a7fb:	8b 44 24 18          	mov    0x18(%esp),%eax
    a7ff:	c1 e0 03             	shl    $0x3,%eax
    a802:	01 d0                	add    %edx,%eax
    a804:	89 44 24 0c          	mov    %eax,0xc(%esp)
	new.rlim_cur = get_fs_long((unsigned long *) rlim);
    a808:	ff 74 24 1c          	pushl  0x1c(%esp)
    a80c:	e8 49 f3 ff ff       	call   9b5a <get_fs_long>
    a811:	83 c4 04             	add    $0x4,%esp
    a814:	89 44 24 04          	mov    %eax,0x4(%esp)
	new.rlim_max = get_fs_long(((unsigned long *) rlim) + 1);
    a818:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a81c:	83 c0 04             	add    $0x4,%eax
    a81f:	50                   	push   %eax
    a820:	e8 35 f3 ff ff       	call   9b5a <get_fs_long>
    a825:	83 c4 04             	add    $0x4,%esp
    a828:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (((new.rlim_cur > old->rlim_max) || (new.rlim_max > old->rlim_max)) && !suser())
    a82c:	8b 54 24 04          	mov    0x4(%esp),%edx
    a830:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a834:	8b 40 04             	mov    0x4(%eax),%eax
    a837:	39 c2                	cmp    %eax,%edx
    a839:	7f 0f                	jg     a84a <sys_setrlimit+0x7d>
    a83b:	8b 54 24 08          	mov    0x8(%esp),%edx
    a83f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a843:	8b 40 04             	mov    0x4(%eax),%eax
    a846:	39 c2                	cmp    %eax,%edx
    a848:	7e 1b                	jle    a865 <sys_setrlimit+0x98>
    a84a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a850:	8b 00                	mov    (%eax),%eax
    a852:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    a859:	66 85 c0             	test   %ax,%ax
    a85c:	74 07                	je     a865 <sys_setrlimit+0x98>
		return -EPERM;
    a85e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a863:	eb 16                	jmp    a87b <sys_setrlimit+0xae>
	*old = new;
    a865:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    a869:	8b 44 24 04          	mov    0x4(%esp),%eax
    a86d:	8b 54 24 08          	mov    0x8(%esp),%edx
    a871:	89 01                	mov    %eax,(%ecx)
    a873:	89 51 04             	mov    %edx,0x4(%ecx)
	return 0;
    a876:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a87b:	83 c4 10             	add    $0x10,%esp
    a87e:	5b                   	pop    %ebx
    a87f:	c3                   	ret    

0000a880 <sys_getrusage>:
// 获取指定进程的资源利用信息。
// 本系统调用提供当前进程或其已终止的和等待着的子进程资源使用情况。如果参数who等于RUSAGE_SELF，则返回当前进程的资源利用
// 信息。如果指定进程who是RUSAGE_CHILDREN，则返回当前进程的已终止和等待着的子进程资源利用信息。符号常数RUSAGE_SELF和
// RUSAGE_CHILDREN以及rusage结构都定义在include/sys/resource.h文件中。
int sys_getrusage(int who, struct rusage *ru)
{
    a880:	53                   	push   %ebx
    a881:	83 ec 68             	sub    $0x68,%esp
    a884:	e8 71 c4 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    a889:	81 c3 77 77 02 00    	add    $0x27777,%ebx
	struct rusage r;
	unsigned long	*lp, *lpend, *dest;

	// 首先判断参数指定进程的有效性。如果who即不是RUSAGE_SELF（指定当前进程），也不是RUSAGE_CHILDREN（指定子进程），则以
	// 无效参数码返回。否则在验证了指针ru指定的用户缓冲区域后，把临时rusage结构区域r清零。
	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN)
    a88f:	83 7c 24 70 00       	cmpl   $0x0,0x70(%esp)
    a894:	74 11                	je     a8a7 <sys_getrusage+0x27>
    a896:	83 7c 24 70 ff       	cmpl   $0xffffffff,0x70(%esp)
    a89b:	74 0a                	je     a8a7 <sys_getrusage+0x27>
		return -EINVAL;
    a89d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    a8a2:	e9 44 02 00 00       	jmp    aaeb <sys_getrusage+0x26b>
	verify_area(ru, sizeof *ru);
    a8a7:	83 ec 08             	sub    $0x8,%esp
    a8aa:	6a 48                	push   $0x48
    a8ac:	ff b4 24 80 00 00 00 	pushl  0x80(%esp)
    a8b3:	e8 43 e0 ff ff       	call   88fb <verify_area>
    a8b8:	83 c4 10             	add    $0x10,%esp
	memset((char *) &r, 0, sizeof(r));
    a8bb:	83 ec 04             	sub    $0x4,%esp
    a8be:	6a 48                	push   $0x48
    a8c0:	6a 00                	push   $0x0
    a8c2:	8d 44 24 18          	lea    0x18(%esp),%eax
    a8c6:	50                   	push   %eax
    a8c7:	e8 0f f3 ff ff       	call   9bdb <memset>
    a8cc:	83 c4 10             	add    $0x10,%esp
	// 若参数who是RUSAGE_SELF，则复制当前进程资源利用信息到r结构中。若指定进程who是RUSAGE_CHILDREN，则复制当前进程的已终止
	// 和等待着的子进程资源利用信息到临时rusage结构r中。宏CT_TO_SECS和CT_TO_USECS用于把系统当前嘀嗒数转换成用秒值加微秒值
	// 表示。它们定义在include/linux/sched.h文件中。jiffies_offset是系统嘀嗒数误差调整数。
	if (who == RUSAGE_SELF) {
    a8cf:	83 7c 24 70 00       	cmpl   $0x0,0x70(%esp)
    a8d4:	0f 85 e5 00 00 00    	jne    a9bf <sys_getrusage+0x13f>
		r.ru_utime.tv_sec = CT_TO_SECS(current->utime);
    a8da:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a8e0:	8b 00                	mov    (%eax),%eax
    a8e2:	8b 88 e0 02 00 00    	mov    0x2e0(%eax),%ecx
    a8e8:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a8ed:	89 c8                	mov    %ecx,%eax
    a8ef:	f7 ea                	imul   %edx
    a8f1:	c1 fa 05             	sar    $0x5,%edx
    a8f4:	89 c8                	mov    %ecx,%eax
    a8f6:	c1 f8 1f             	sar    $0x1f,%eax
    a8f9:	29 c2                	sub    %eax,%edx
    a8fb:	89 d0                	mov    %edx,%eax
    a8fd:	89 44 24 0c          	mov    %eax,0xc(%esp)
		r.ru_utime.tv_usec = CT_TO_USECS(current->utime);
    a901:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a907:	8b 00                	mov    (%eax),%eax
    a909:	8b 88 e0 02 00 00    	mov    0x2e0(%eax),%ecx
    a90f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a914:	89 c8                	mov    %ecx,%eax
    a916:	f7 ea                	imul   %edx
    a918:	c1 fa 05             	sar    $0x5,%edx
    a91b:	89 c8                	mov    %ecx,%eax
    a91d:	c1 f8 1f             	sar    $0x1f,%eax
    a920:	29 c2                	sub    %eax,%edx
    a922:	89 d0                	mov    %edx,%eax
    a924:	6b c0 64             	imul   $0x64,%eax,%eax
    a927:	29 c1                	sub    %eax,%ecx
    a929:	89 c8                	mov    %ecx,%eax
    a92b:	69 c8 40 42 0f 00    	imul   $0xf4240,%eax,%ecx
    a931:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a936:	89 c8                	mov    %ecx,%eax
    a938:	f7 ea                	imul   %edx
    a93a:	c1 fa 05             	sar    $0x5,%edx
    a93d:	89 c8                	mov    %ecx,%eax
    a93f:	c1 f8 1f             	sar    $0x1f,%eax
    a942:	29 c2                	sub    %eax,%edx
    a944:	89 d0                	mov    %edx,%eax
    a946:	89 44 24 10          	mov    %eax,0x10(%esp)
		r.ru_stime.tv_sec = CT_TO_SECS(current->stime);
    a94a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a950:	8b 00                	mov    (%eax),%eax
    a952:	8b 88 e4 02 00 00    	mov    0x2e4(%eax),%ecx
    a958:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a95d:	89 c8                	mov    %ecx,%eax
    a95f:	f7 ea                	imul   %edx
    a961:	c1 fa 05             	sar    $0x5,%edx
    a964:	89 c8                	mov    %ecx,%eax
    a966:	c1 f8 1f             	sar    $0x1f,%eax
    a969:	29 c2                	sub    %eax,%edx
    a96b:	89 d0                	mov    %edx,%eax
    a96d:	89 44 24 14          	mov    %eax,0x14(%esp)
		r.ru_stime.tv_usec = CT_TO_USECS(current->stime);
    a971:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a977:	8b 00                	mov    (%eax),%eax
    a979:	8b 88 e4 02 00 00    	mov    0x2e4(%eax),%ecx
    a97f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a984:	89 c8                	mov    %ecx,%eax
    a986:	f7 ea                	imul   %edx
    a988:	c1 fa 05             	sar    $0x5,%edx
    a98b:	89 c8                	mov    %ecx,%eax
    a98d:	c1 f8 1f             	sar    $0x1f,%eax
    a990:	29 c2                	sub    %eax,%edx
    a992:	89 d0                	mov    %edx,%eax
    a994:	6b c0 64             	imul   $0x64,%eax,%eax
    a997:	29 c1                	sub    %eax,%ecx
    a999:	89 c8                	mov    %ecx,%eax
    a99b:	69 c8 40 42 0f 00    	imul   $0xf4240,%eax,%ecx
    a9a1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a9a6:	89 c8                	mov    %ecx,%eax
    a9a8:	f7 ea                	imul   %edx
    a9aa:	c1 fa 05             	sar    $0x5,%edx
    a9ad:	89 c8                	mov    %ecx,%eax
    a9af:	c1 f8 1f             	sar    $0x1f,%eax
    a9b2:	29 c2                	sub    %eax,%edx
    a9b4:	89 d0                	mov    %edx,%eax
    a9b6:	89 44 24 18          	mov    %eax,0x18(%esp)
    a9ba:	e9 e0 00 00 00       	jmp    aa9f <sys_getrusage+0x21f>
	} else {
		r.ru_utime.tv_sec = CT_TO_SECS(current->cutime);
    a9bf:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a9c5:	8b 00                	mov    (%eax),%eax
    a9c7:	8b 88 e8 02 00 00    	mov    0x2e8(%eax),%ecx
    a9cd:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a9d2:	89 c8                	mov    %ecx,%eax
    a9d4:	f7 ea                	imul   %edx
    a9d6:	c1 fa 05             	sar    $0x5,%edx
    a9d9:	89 c8                	mov    %ecx,%eax
    a9db:	c1 f8 1f             	sar    $0x1f,%eax
    a9de:	29 c2                	sub    %eax,%edx
    a9e0:	89 d0                	mov    %edx,%eax
    a9e2:	89 44 24 0c          	mov    %eax,0xc(%esp)
		r.ru_utime.tv_usec = CT_TO_USECS(current->cutime);
    a9e6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    a9ec:	8b 00                	mov    (%eax),%eax
    a9ee:	8b 88 e8 02 00 00    	mov    0x2e8(%eax),%ecx
    a9f4:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    a9f9:	89 c8                	mov    %ecx,%eax
    a9fb:	f7 ea                	imul   %edx
    a9fd:	c1 fa 05             	sar    $0x5,%edx
    aa00:	89 c8                	mov    %ecx,%eax
    aa02:	c1 f8 1f             	sar    $0x1f,%eax
    aa05:	29 c2                	sub    %eax,%edx
    aa07:	89 d0                	mov    %edx,%eax
    aa09:	6b c0 64             	imul   $0x64,%eax,%eax
    aa0c:	29 c1                	sub    %eax,%ecx
    aa0e:	89 c8                	mov    %ecx,%eax
    aa10:	69 c8 40 42 0f 00    	imul   $0xf4240,%eax,%ecx
    aa16:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    aa1b:	89 c8                	mov    %ecx,%eax
    aa1d:	f7 ea                	imul   %edx
    aa1f:	c1 fa 05             	sar    $0x5,%edx
    aa22:	89 c8                	mov    %ecx,%eax
    aa24:	c1 f8 1f             	sar    $0x1f,%eax
    aa27:	29 c2                	sub    %eax,%edx
    aa29:	89 d0                	mov    %edx,%eax
    aa2b:	89 44 24 10          	mov    %eax,0x10(%esp)
		r.ru_stime.tv_sec = CT_TO_SECS(current->cstime);
    aa2f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    aa35:	8b 00                	mov    (%eax),%eax
    aa37:	8b 88 ec 02 00 00    	mov    0x2ec(%eax),%ecx
    aa3d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    aa42:	89 c8                	mov    %ecx,%eax
    aa44:	f7 ea                	imul   %edx
    aa46:	c1 fa 05             	sar    $0x5,%edx
    aa49:	89 c8                	mov    %ecx,%eax
    aa4b:	c1 f8 1f             	sar    $0x1f,%eax
    aa4e:	29 c2                	sub    %eax,%edx
    aa50:	89 d0                	mov    %edx,%eax
    aa52:	89 44 24 14          	mov    %eax,0x14(%esp)
		r.ru_stime.tv_usec = CT_TO_USECS(current->cstime);
    aa56:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    aa5c:	8b 00                	mov    (%eax),%eax
    aa5e:	8b 88 ec 02 00 00    	mov    0x2ec(%eax),%ecx
    aa64:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    aa69:	89 c8                	mov    %ecx,%eax
    aa6b:	f7 ea                	imul   %edx
    aa6d:	c1 fa 05             	sar    $0x5,%edx
    aa70:	89 c8                	mov    %ecx,%eax
    aa72:	c1 f8 1f             	sar    $0x1f,%eax
    aa75:	29 c2                	sub    %eax,%edx
    aa77:	89 d0                	mov    %edx,%eax
    aa79:	6b c0 64             	imul   $0x64,%eax,%eax
    aa7c:	29 c1                	sub    %eax,%ecx
    aa7e:	89 c8                	mov    %ecx,%eax
    aa80:	69 c8 40 42 0f 00    	imul   $0xf4240,%eax,%ecx
    aa86:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    aa8b:	89 c8                	mov    %ecx,%eax
    aa8d:	f7 ea                	imul   %edx
    aa8f:	c1 fa 05             	sar    $0x5,%edx
    aa92:	89 c8                	mov    %ecx,%eax
    aa94:	c1 f8 1f             	sar    $0x1f,%eax
    aa97:	29 c2                	sub    %eax,%edx
    aa99:	89 d0                	mov    %edx,%eax
    aa9b:	89 44 24 18          	mov    %eax,0x18(%esp)
	}
	// 然后让lp指针指向r结构，lpend指向r结构末尾处，而dest指针指向用户空间中的ru结构。最后把r中信息复制到用户空间ru结构中，并
	// 返回0。
	lp = (unsigned long *) &r;
    aa9f:	8d 44 24 0c          	lea    0xc(%esp),%eax
    aaa3:	89 44 24 5c          	mov    %eax,0x5c(%esp)
	lpend = (unsigned long *) (&r + 1);
    aaa7:	8d 44 24 0c          	lea    0xc(%esp),%eax
    aaab:	83 c0 48             	add    $0x48,%eax
    aaae:	89 44 24 54          	mov    %eax,0x54(%esp)
	dest = (unsigned long *) ru;
    aab2:	8b 44 24 74          	mov    0x74(%esp),%eax
    aab6:	89 44 24 58          	mov    %eax,0x58(%esp)
	for (; lp < lpend; lp++, dest++)
    aaba:	eb 20                	jmp    aadc <sys_getrusage+0x25c>
		put_fs_long(*lp, dest);
    aabc:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    aac0:	8b 00                	mov    (%eax),%eax
    aac2:	83 ec 08             	sub    $0x8,%esp
    aac5:	ff 74 24 60          	pushl  0x60(%esp)
    aac9:	50                   	push   %eax
    aaca:	e8 f5 f0 ff ff       	call   9bc4 <put_fs_long>
    aacf:	83 c4 10             	add    $0x10,%esp
	for (; lp < lpend; lp++, dest++)
    aad2:	83 44 24 5c 04       	addl   $0x4,0x5c(%esp)
    aad7:	83 44 24 58 04       	addl   $0x4,0x58(%esp)
    aadc:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    aae0:	3b 44 24 54          	cmp    0x54(%esp),%eax
    aae4:	72 d6                	jb     aabc <sys_getrusage+0x23c>
	return(0);
    aae6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    aaeb:	83 c4 68             	add    $0x68,%esp
    aaee:	5b                   	pop    %ebx
    aaef:	c3                   	ret    

0000aaf0 <sys_gettimeofday>:
// 取得系统当前时间，并用指定格式返回。
// timeval结构和timezone结构都定义在include/sys/time.h文件中。timeval结构含有秒和微秒（tv_sec和tv_usec）两个
// 字段。timezone结构含有本地距格林尼治标准时间以西的分钟数（tz_minuteswest）和夏令时间调整类型（tz_dsttime）两上
// 字段。（dst -- Daylight Savings Time）
int sys_gettimeofday(struct timeval *tv, struct timezone *tz)
{
    aaf0:	56                   	push   %esi
    aaf1:	53                   	push   %ebx
    aaf2:	83 ec 04             	sub    $0x4,%esp
    aaf5:	e8 00 c2 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    aafa:	81 c3 06 75 02 00    	add    $0x27506,%ebx
	// 如果参数给定的timeval结构指针不空，则在该结构中返回当前时间（秒值和微秒值）;
	// 如果参数给定的用户数据空间中timezone结构的指针不空，则也返回该结构的信息。
	// 程序中startup_time是系统开机时间（秒值）。宏CT_TO_SECS和CT_TO_USECS用于把系统当前嘀嗒数转换成用秒值加微秒值表示。
	// 它们定义在include/linux/sched.h文件中。jiffies_offset是系统嘀嗒数误差调整数。
	if (tv) {
    ab00:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    ab05:	0f 84 95 00 00 00    	je     aba0 <sys_gettimeofday+0xb0>
		verify_area(tv, sizeof *tv);
    ab0b:	83 ec 08             	sub    $0x8,%esp
    ab0e:	6a 08                	push   $0x8
    ab10:	ff 74 24 1c          	pushl  0x1c(%esp)
    ab14:	e8 e2 dd ff ff       	call   88fb <verify_area>
    ab19:	83 c4 10             	add    $0x10,%esp
		put_fs_long(startup_time + CT_TO_SECS(jiffies + jiffies_offset),
    ab1c:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    ab22:	8b 10                	mov    (%eax),%edx
    ab24:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    ab2a:	8b 00                	mov    (%eax),%eax
    ab2c:	01 d0                	add    %edx,%eax
    ab2e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    ab33:	f7 e2                	mul    %edx
    ab35:	c1 ea 05             	shr    $0x5,%edx
    ab38:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    ab3e:	8b 00                	mov    (%eax),%eax
    ab40:	01 d0                	add    %edx,%eax
    ab42:	83 ec 08             	sub    $0x8,%esp
    ab45:	ff 74 24 18          	pushl  0x18(%esp)
    ab49:	50                   	push   %eax
    ab4a:	e8 75 f0 ff ff       	call   9bc4 <put_fs_long>
    ab4f:	83 c4 10             	add    $0x10,%esp
			    (unsigned long *) tv);
		put_fs_long(CT_TO_USECS(jiffies + jiffies_offset),
    ab52:	8b 44 24 10          	mov    0x10(%esp),%eax
    ab56:	8d 70 04             	lea    0x4(%eax),%esi
    ab59:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    ab5f:	8b 10                	mov    (%eax),%edx
    ab61:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    ab67:	8b 00                	mov    (%eax),%eax
    ab69:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ab6c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    ab71:	89 c8                	mov    %ecx,%eax
    ab73:	f7 e2                	mul    %edx
    ab75:	89 d0                	mov    %edx,%eax
    ab77:	c1 e8 05             	shr    $0x5,%eax
    ab7a:	6b c0 64             	imul   $0x64,%eax,%eax
    ab7d:	29 c1                	sub    %eax,%ecx
    ab7f:	89 c8                	mov    %ecx,%eax
    ab81:	69 c0 40 42 0f 00    	imul   $0xf4240,%eax,%eax
    ab87:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    ab8c:	f7 e2                	mul    %edx
    ab8e:	89 d0                	mov    %edx,%eax
    ab90:	c1 e8 05             	shr    $0x5,%eax
    ab93:	83 ec 08             	sub    $0x8,%esp
    ab96:	56                   	push   %esi
    ab97:	50                   	push   %eax
    ab98:	e8 27 f0 ff ff       	call   9bc4 <put_fs_long>
    ab9d:	83 c4 10             	add    $0x10,%esp
			    ((unsigned long *) tv) + 1);
	}
	if (tz) {
    aba0:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    aba5:	74 41                	je     abe8 <sys_gettimeofday+0xf8>
		verify_area(tz, sizeof *tz);
    aba7:	83 ec 08             	sub    $0x8,%esp
    abaa:	6a 08                	push   $0x8
    abac:	ff 74 24 20          	pushl  0x20(%esp)
    abb0:	e8 46 dd ff ff       	call   88fb <verify_area>
    abb5:	83 c4 10             	add    $0x10,%esp
		put_fs_long(sys_tz.tz_minuteswest, (unsigned long *) tz);
    abb8:	8b 83 e0 22 00 00    	mov    0x22e0(%ebx),%eax
    abbe:	83 ec 08             	sub    $0x8,%esp
    abc1:	ff 74 24 1c          	pushl  0x1c(%esp)
    abc5:	50                   	push   %eax
    abc6:	e8 f9 ef ff ff       	call   9bc4 <put_fs_long>
    abcb:	83 c4 10             	add    $0x10,%esp
		put_fs_long(sys_tz.tz_dsttime, ((unsigned long *) tz) + 1);
    abce:	8b 44 24 14          	mov    0x14(%esp),%eax
    abd2:	83 c0 04             	add    $0x4,%eax
    abd5:	8b 93 e4 22 00 00    	mov    0x22e4(%ebx),%edx
    abdb:	83 ec 08             	sub    $0x8,%esp
    abde:	50                   	push   %eax
    abdf:	52                   	push   %edx
    abe0:	e8 df ef ff ff       	call   9bc4 <put_fs_long>
    abe5:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
    abe8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    abed:	83 c4 04             	add    $0x4,%esp
    abf0:	5b                   	pop    %ebx
    abf1:	5e                   	pop    %esi
    abf2:	c3                   	ret    

0000abf3 <sys_settimeofday>:
 */
// 设置系统当前时间。
// 参数tv是指向用户数据区中timeval结构信息的指针。参数tz是用户数据区中timezone结构的指针。该操作需要超级用户权限。如果
// 两者皆为空，则什么也不做，函数返回0。
int sys_settimeofday(struct timeval *tv, struct timezone *tz)
{
    abf3:	56                   	push   %esi
    abf4:	53                   	push   %ebx
    abf5:	83 ec 14             	sub    $0x14,%esp
    abf8:	e8 fd c0 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    abfd:	81 c3 03 74 02 00    	add    $0x27403,%ebx
	static int	firsttime = 1;
	void 		adjust_clock();

	// 设置系统当前时间需要超级用户权限。如果tz指针不空，则设置系统时区信息。即复制用户timezone结构信息到系统中的sys_tz结构
	// 中。如果是第1次调用本系统调用并且参数tv指针不空，则调整系统时钟值。
	if (!suser())
    ac03:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ac09:	8b 00                	mov    (%eax),%eax
    ac0b:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    ac12:	66 85 c0             	test   %ax,%ax
    ac15:	74 0a                	je     ac21 <sys_settimeofday+0x2e>
		return -EPERM;
    ac17:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ac1c:	e9 f6 00 00 00       	jmp    ad17 <sys_settimeofday+0x124>
	if (tz) {
    ac21:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    ac26:	74 48                	je     ac70 <sys_settimeofday+0x7d>
		sys_tz.tz_minuteswest = get_fs_long((unsigned long *) tz);
    ac28:	ff 74 24 24          	pushl  0x24(%esp)
    ac2c:	e8 29 ef ff ff       	call   9b5a <get_fs_long>
    ac31:	83 c4 04             	add    $0x4,%esp
    ac34:	89 83 e0 22 00 00    	mov    %eax,0x22e0(%ebx)
		sys_tz.tz_dsttime = get_fs_long(((unsigned long *) tz)+1);
    ac3a:	8b 44 24 24          	mov    0x24(%esp),%eax
    ac3e:	83 c0 04             	add    $0x4,%eax
    ac41:	50                   	push   %eax
    ac42:	e8 13 ef ff ff       	call   9b5a <get_fs_long>
    ac47:	83 c4 04             	add    $0x4,%esp
    ac4a:	89 83 e4 22 00 00    	mov    %eax,0x22e4(%ebx)
		if (firsttime) {
    ac50:	8b 83 b0 00 00 00    	mov    0xb0(%ebx),%eax
    ac56:	85 c0                	test   %eax,%eax
    ac58:	74 16                	je     ac70 <sys_settimeofday+0x7d>
			firsttime = 0;
    ac5a:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
    ac61:	00 00 00 
			if (!tv)
    ac64:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    ac69:	75 05                	jne    ac70 <sys_settimeofday+0x7d>
				adjust_clock();
    ac6b:	e8 ad 00 00 00       	call   ad1d <adjust_clock>
		}
	}
	// 如果参数的timeval结构指针tv不空，则用该结构信息设置系统时钟。首先从tv所指处获取以秒值（sec）加微秒值（usec）表示的系统
	// 时间，然后用秒值修改系统开机时间全局变量startup_time值，并用微秒值设置系统嘀嗒误差值jiffies_offset。
	if (tv) {
    ac70:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    ac75:	0f 84 97 00 00 00    	je     ad12 <sys_settimeofday+0x11f>
		int sec, usec;

		sec = get_fs_long((unsigned long *)tv);
    ac7b:	83 ec 0c             	sub    $0xc,%esp
    ac7e:	ff 74 24 2c          	pushl  0x2c(%esp)
    ac82:	e8 d3 ee ff ff       	call   9b5a <get_fs_long>
    ac87:	83 c4 10             	add    $0x10,%esp
    ac8a:	89 44 24 0c          	mov    %eax,0xc(%esp)
		usec = get_fs_long(((unsigned long *)tv) + 1);
    ac8e:	8b 44 24 20          	mov    0x20(%esp),%eax
    ac92:	83 c0 04             	add    $0x4,%eax
    ac95:	83 ec 0c             	sub    $0xc,%esp
    ac98:	50                   	push   %eax
    ac99:	e8 bc ee ff ff       	call   9b5a <get_fs_long>
    ac9e:	83 c4 10             	add    $0x10,%esp
    aca1:	89 44 24 08          	mov    %eax,0x8(%esp)

		startup_time = sec - jiffies / HZ;
    aca5:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    aca9:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    acaf:	8b 00                	mov    (%eax),%eax
    acb1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    acb6:	f7 e2                	mul    %edx
    acb8:	89 d0                	mov    %edx,%eax
    acba:	c1 e8 05             	shr    $0x5,%eax
    acbd:	29 c1                	sub    %eax,%ecx
    acbf:	89 ca                	mov    %ecx,%edx
    acc1:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    acc7:	89 10                	mov    %edx,(%eax)
		jiffies_offset = usec * HZ / 1000000 - jiffies % HZ;
    acc9:	8b 44 24 08          	mov    0x8(%esp),%eax
    accd:	6b c8 64             	imul   $0x64,%eax,%ecx
    acd0:	ba 83 de 1b 43       	mov    $0x431bde83,%edx
    acd5:	89 c8                	mov    %ecx,%eax
    acd7:	f7 ea                	imul   %edx
    acd9:	c1 fa 12             	sar    $0x12,%edx
    acdc:	89 c8                	mov    %ecx,%eax
    acde:	c1 f8 1f             	sar    $0x1f,%eax
    ace1:	29 c2                	sub    %eax,%edx
    ace3:	89 d0                	mov    %edx,%eax
    ace5:	89 c6                	mov    %eax,%esi
    ace7:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    aced:	8b 08                	mov    (%eax),%ecx
    acef:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    acf4:	89 c8                	mov    %ecx,%eax
    acf6:	f7 e2                	mul    %edx
    acf8:	89 d0                	mov    %edx,%eax
    acfa:	c1 e8 05             	shr    $0x5,%eax
    acfd:	6b c0 64             	imul   $0x64,%eax,%eax
    ad00:	29 c1                	sub    %eax,%ecx
    ad02:	89 c8                	mov    %ecx,%eax
    ad04:	29 c6                	sub    %eax,%esi
    ad06:	89 f0                	mov    %esi,%eax
    ad08:	89 c2                	mov    %eax,%edx
    ad0a:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    ad10:	89 10                	mov    %edx,(%eax)
	}
	return 0;
    ad12:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ad17:	83 c4 14             	add    $0x14,%esp
    ad1a:	5b                   	pop    %ebx
    ad1b:	5e                   	pop    %esi
    ad1c:	c3                   	ret    

0000ad1d <adjust_clock>:
 * 法是完全不依赖于CMOS时钟，而是让系统通过NTP（网络时钟协议）或者timed（时间服务器）获得时间，如果机器联上网的话...。
 */
// 把系统启动时间调整为以GMT为标准的时间。
// startup_time是秒值，因此这里需要把时区分钟值乘上60。
void adjust_clock()
{
    ad1d:	e8 d0 bf ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    ad22:	05 de 72 02 00       	add    $0x272de,%eax
	startup_time += sys_tz.tz_minuteswest * 60;
    ad27:	8b 90 e0 22 00 00    	mov    0x22e0(%eax),%edx
    ad2d:	6b d2 3c             	imul   $0x3c,%edx,%edx
    ad30:	89 d1                	mov    %edx,%ecx
    ad32:	c7 c2 84 3b 03 00    	mov    $0x33b84,%edx
    ad38:	8b 12                	mov    (%edx),%edx
    ad3a:	01 ca                	add    %ecx,%edx
    ad3c:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    ad42:	89 10                	mov    %edx,(%eax)
}
    ad44:	90                   	nop
    ad45:	c3                   	ret    

0000ad46 <sys_umask>:

// 设置当前进程创建文件属性屏蔽码为mask & 0777。并返回原屏蔽码。
int sys_umask(int mask)
{
    ad46:	83 ec 10             	sub    $0x10,%esp
    ad49:	e8 a4 bf ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    ad4e:	05 b2 72 02 00       	add    $0x272b2,%eax
	int old = current->umask;
    ad53:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    ad59:	8b 12                	mov    (%edx),%edx
    ad5b:	0f b7 92 30 03 00 00 	movzwl 0x330(%edx),%edx
    ad62:	0f b7 d2             	movzwl %dx,%edx
    ad65:	89 54 24 0c          	mov    %edx,0xc(%esp)

	current->umask = mask & 0777;
    ad69:	8b 54 24 14          	mov    0x14(%esp),%edx
    ad6d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ad73:	8b 00                	mov    (%eax),%eax
    ad75:	66 81 e2 ff 01       	and    $0x1ff,%dx
    ad7a:	66 89 90 30 03 00 00 	mov    %dx,0x330(%eax)
	return (old);
    ad81:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    ad85:	83 c4 10             	add    $0x10,%esp
    ad88:	c3                   	ret    

0000ad89 <sys_default>:

// 用于捕获未实现的System Call调用。
int sys_default(unsigned long arg1, unsigned long arg2, unsigned long arg3, unsigned long code){
    ad89:	53                   	push   %ebx
    ad8a:	83 ec 08             	sub    $0x8,%esp
    ad8d:	e8 68 bf ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    ad92:	81 c3 6e 72 02 00    	add    $0x2726e,%ebx
    printk("System Call Number:%d\r\n",code);
    ad98:	83 ec 08             	sub    $0x8,%esp
    ad9b:	ff 74 24 24          	pushl  0x24(%esp)
    ad9f:	8d 83 28 46 ff ff    	lea    -0xb9d8(%ebx),%eax
    ada5:	50                   	push   %eax
    ada6:	e8 87 e5 ff ff       	call   9332 <printk>
    adab:	83 c4 10             	add    $0x10,%esp
    printk("Arg1:%X\r\n",arg1);
    adae:	83 ec 08             	sub    $0x8,%esp
    adb1:	ff 74 24 18          	pushl  0x18(%esp)
    adb5:	8d 83 40 46 ff ff    	lea    -0xb9c0(%ebx),%eax
    adbb:	50                   	push   %eax
    adbc:	e8 71 e5 ff ff       	call   9332 <printk>
    adc1:	83 c4 10             	add    $0x10,%esp
    printk("Arg2:%X\r\n",arg2);
    adc4:	83 ec 08             	sub    $0x8,%esp
    adc7:	ff 74 24 1c          	pushl  0x1c(%esp)
    adcb:	8d 83 4a 46 ff ff    	lea    -0xb9b6(%ebx),%eax
    add1:	50                   	push   %eax
    add2:	e8 5b e5 ff ff       	call   9332 <printk>
    add7:	83 c4 10             	add    $0x10,%esp
    printk("Arg3:%X\r\n",arg3);
    adda:	83 ec 08             	sub    $0x8,%esp
    addd:	ff 74 24 20          	pushl  0x20(%esp)
    ade1:	8d 83 54 46 ff ff    	lea    -0xb9ac(%ebx),%eax
    ade7:	50                   	push   %eax
    ade8:	e8 45 e5 ff ff       	call   9332 <printk>
    aded:	83 c4 10             	add    $0x10,%esp
    for(;;);
    adf0:	eb fe                	jmp    adf0 <sys_default+0x67>

0000adf2 <put_fs_long>:
{
    adf2:	e8 fb be ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    adf7:	05 09 72 02 00       	add    $0x27209,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    adfc:	8b 44 24 04          	mov    0x4(%esp),%eax
    ae00:	8b 54 24 08          	mov    0x8(%esp),%edx
    ae04:	64 89 02             	mov    %eax,%fs:(%edx)
}
    ae07:	90                   	nop
    ae08:	c3                   	ret    

0000ae09 <release>:
// 释放指定进程占用的任务槽及其任务数据结构占用的内在页面。
// 参数p是任务数据结构指针。该函数在后面的sys_kill()和sys_waitpid()函数中被调用。扫描任务指针数组表task[]
// 以寻找指定的任务。如果找到，则首先清空该任务槽，然后释放该任务数据结构所占用的内在页面，最后执行调度函数并返回
// 立即退出。如果在任务数组表中没有找到指定任务对应的项，则内核panic。
void release(struct task_struct * p)
{
    ae09:	53                   	push   %ebx
    ae0a:	83 ec 18             	sub    $0x18,%esp
    ae0d:	e8 e8 be ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    ae12:	81 c3 ee 71 02 00    	add    $0x271ee,%ebx
	int i;

	// 如果给定的任务结构指针为NULL则退出。如果该指针指向当前进程则显示警告信息退出。
	if (!p)
    ae18:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    ae1d:	0f 84 01 01 00 00    	je     af24 <release+0x11b>
		return;
	if (p == current) {
    ae23:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ae29:	8b 00                	mov    (%eax),%eax
    ae2b:	39 44 24 20          	cmp    %eax,0x20(%esp)
    ae2f:	75 17                	jne    ae48 <release+0x3f>
		printk("task releasing itself\n\r");
    ae31:	83 ec 0c             	sub    $0xc,%esp
    ae34:	8d 83 60 46 ff ff    	lea    -0xb9a0(%ebx),%eax
    ae3a:	50                   	push   %eax
    ae3b:	e8 f2 e4 ff ff       	call   9332 <printk>
    ae40:	83 c4 10             	add    $0x10,%esp
		return;
    ae43:	e9 dd 00 00 00       	jmp    af25 <release+0x11c>
	}
	// 扫描任务结构指针数组，寻找指定的任务p。如果找到，则置空任务指针数组中对应项，并且更新任务结构之间的关联指针，释放
	// 任务p数据结构占用的内在页面。最后在执行调度程序返回后退出。如果没有找到指定的任务p，则说明内核代码出错了，则显示出错
	// 信息并死机。
	// 更新链接部分的代码会把指定任务p从双向链表中删除。
	for (i = 1 ; i < NR_TASKS ; i++)
    ae48:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    ae4f:	00 
    ae50:	e9 b0 00 00 00       	jmp    af05 <release+0xfc>
		if (task[i] == p) {
    ae55:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    ae5b:	8b 54 24 0c          	mov    0xc(%esp),%edx
    ae5f:	8b 04 90             	mov    (%eax,%edx,4),%eax
    ae62:	39 44 24 20          	cmp    %eax,0x20(%esp)
    ae66:	0f 85 94 00 00 00    	jne    af00 <release+0xf7>
			task[i] = NULL;
    ae6c:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    ae72:	8b 54 24 0c          	mov    0xc(%esp),%edx
    ae76:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
			// 指向比邻的老进程。如果任务p就是最新的子进程，则还需要更新其父进程的最新子进程指针cptr为指向p的比邻子进程。
			// 指针osptr（old sibling pointer）指向比p先创建的兄弟进程。
			// 指针ysptr（younger sibling pointer）指向比p后创建的兄弟进程。
			// 指针pptr（parent pointer）指向p的父进程。
			// 指针cptr（child pointer）是父进程指向最新（最后）创建的子进程。
			if (p->p_osptr)
    ae7d:	8b 44 24 20          	mov    0x20(%esp),%eax
    ae81:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    ae87:	85 c0                	test   %eax,%eax
    ae89:	74 1a                	je     aea5 <release+0x9c>
				p->p_osptr->p_ysptr = p->p_ysptr;
    ae8b:	8b 44 24 20          	mov    0x20(%esp),%eax
    ae8f:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    ae95:	8b 54 24 20          	mov    0x20(%esp),%edx
    ae99:	8b 92 c4 02 00 00    	mov    0x2c4(%edx),%edx
    ae9f:	89 90 c4 02 00 00    	mov    %edx,0x2c4(%eax)
			if (p->p_ysptr)
    aea5:	8b 44 24 20          	mov    0x20(%esp),%eax
    aea9:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    aeaf:	85 c0                	test   %eax,%eax
    aeb1:	74 1c                	je     aecf <release+0xc6>
				p->p_ysptr->p_osptr = p->p_osptr;
    aeb3:	8b 44 24 20          	mov    0x20(%esp),%eax
    aeb7:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    aebd:	8b 54 24 20          	mov    0x20(%esp),%edx
    aec1:	8b 92 c8 02 00 00    	mov    0x2c8(%edx),%edx
    aec7:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%eax)
    aecd:	eb 1a                	jmp    aee9 <release+0xe0>
			else
				p->p_pptr->p_cptr = p->p_osptr;
    aecf:	8b 44 24 20          	mov    0x20(%esp),%eax
    aed3:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    aed9:	8b 54 24 20          	mov    0x20(%esp),%edx
    aedd:	8b 92 c8 02 00 00    	mov    0x2c8(%edx),%edx
    aee3:	89 90 c0 02 00 00    	mov    %edx,0x2c0(%eax)
			// 释放要释放的进程数据结构占用的那页内存
			free_page((long)p);
    aee9:	8b 44 24 20          	mov    0x20(%esp),%eax
    aeed:	83 ec 0c             	sub    $0xc,%esp
    aef0:	50                   	push   %eax
    aef1:	e8 79 1b 00 00       	call   ca6f <free_page>
    aef6:	83 c4 10             	add    $0x10,%esp
			// 重新调度进程
			schedule();
    aef9:	e8 4d c0 ff ff       	call   6f4b <schedule>
			return;
    aefe:	eb 25                	jmp    af25 <release+0x11c>
	for (i = 1 ; i < NR_TASKS ; i++)
    af00:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    af05:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    af0a:	0f 8e 45 ff ff ff    	jle    ae55 <release+0x4c>
		}
	panic("trying to release non-existent task");
    af10:	83 ec 0c             	sub    $0xc,%esp
    af13:	8d 83 78 46 ff ff    	lea    -0xb988(%ebx),%eax
    af19:	50                   	push   %eax
    af1a:	e8 bf e3 ff ff       	call   92de <panic>
    af1f:	83 c4 10             	add    $0x10,%esp
    af22:	eb 01                	jmp    af25 <release+0x11c>
		return;
    af24:	90                   	nop
}
    af25:	83 c4 18             	add    $0x18,%esp
    af28:	5b                   	pop    %ebx
    af29:	c3                   	ret    

0000af2a <bad_task_ptr>:
/*
 * 检查task[]数组中是否存在一个指定的task_struct结构指针p。
 */
// 检测任务结构指针p。
int bad_task_ptr(struct task_struct *p)
{
    af2a:	83 ec 10             	sub    $0x10,%esp
    af2d:	e8 c0 bd ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    af32:	05 ce 70 02 00       	add    $0x270ce,%eax
	int 	i;

	if (!p)
    af37:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    af3c:	75 07                	jne    af45 <bad_task_ptr+0x1b>
		return 0;
    af3e:	b8 00 00 00 00       	mov    $0x0,%eax
    af43:	eb 35                	jmp    af7a <bad_task_ptr+0x50>
	for (i = 0 ; i < NR_TASKS ; i++)
    af45:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    af4c:	00 
    af4d:	eb 1f                	jmp    af6e <bad_task_ptr+0x44>
		if (task[i] == p)
    af4f:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    af55:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    af59:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
    af5c:	39 54 24 14          	cmp    %edx,0x14(%esp)
    af60:	75 07                	jne    af69 <bad_task_ptr+0x3f>
			return 0;
    af62:	b8 00 00 00 00       	mov    $0x0,%eax
    af67:	eb 11                	jmp    af7a <bad_task_ptr+0x50>
	for (i = 0 ; i < NR_TASKS ; i++)
    af69:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    af6e:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    af73:	7e da                	jle    af4f <bad_task_ptr+0x25>
	return 1;
    af75:	b8 01 00 00 00       	mov    $0x1,%eax
}
    af7a:	83 c4 10             	add    $0x10,%esp
    af7d:	c3                   	ret    

0000af7e <audit_ptree>:
 * 该函数看上去要比实际的恐怖....其实我们仅仅验证了指针p_ysptr和p_osptr构成的双向链表，并检查
 * 了链表与指针p_cptr和p_pptr构成的进程树之间的关系。
 */
// 检查进程树。
void audit_ptree()
{
    af7e:	56                   	push   %esi
    af7f:	53                   	push   %ebx
    af80:	83 ec 14             	sub    $0x14,%esp
    af83:	e8 72 bd ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    af88:	81 c3 78 70 02 00    	add    $0x27078,%ebx
	int	i;

	// 扫描系统中的除任务0以外的所有任务，检查它们中4个指针（pptr、cptr、ysptr和osptr）的正确性。若任务数组槽（项）
	// 为空则跳过。
	for (i = 1 ; i < NR_TASKS ; i++) {
    af8e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    af95:	00 
    af96:	e9 1c 05 00 00       	jmp    b4b7 <audit_ptree+0x539>
		if (!task[i])
    af9b:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    afa1:	8b 54 24 0c          	mov    0xc(%esp),%edx
    afa5:	8b 04 90             	mov    (%eax,%edx,4),%eax
    afa8:	85 c0                	test   %eax,%eax
    afaa:	0f 84 01 05 00 00    	je     b4b1 <audit_ptree+0x533>
			continue;
		// 如果任务的父进程指针p_pptr没的指向任何进程（即在任务数组中存在），则显示警告信息“警告，pid号N的父进程链接有问题”。
		// 以下语句对cptr、ysptr和osptr进行类似操作。
		if (bad_task_ptr(task[i]->p_pptr))
    afb0:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    afb6:	8b 54 24 0c          	mov    0xc(%esp),%edx
    afba:	8b 04 90             	mov    (%eax,%edx,4),%eax
    afbd:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    afc3:	50                   	push   %eax
    afc4:	e8 61 ff ff ff       	call   af2a <bad_task_ptr>
    afc9:	83 c4 04             	add    $0x4,%esp
    afcc:	85 c0                	test   %eax,%eax
    afce:	74 26                	je     aff6 <audit_ptree+0x78>
			printk("Warning, pid %d's parent link is bad\n",
				task[i]->pid);
    afd0:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    afd6:	8b 54 24 0c          	mov    0xc(%esp),%edx
    afda:	8b 04 90             	mov    (%eax,%edx,4),%eax
			printk("Warning, pid %d's parent link is bad\n",
    afdd:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    afe3:	83 ec 08             	sub    $0x8,%esp
    afe6:	50                   	push   %eax
    afe7:	8d 83 9c 46 ff ff    	lea    -0xb964(%ebx),%eax
    afed:	50                   	push   %eax
    afee:	e8 3f e3 ff ff       	call   9332 <printk>
    aff3:	83 c4 10             	add    $0x10,%esp
		if (bad_task_ptr(task[i]->p_cptr))
    aff6:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    affc:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b000:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b003:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    b009:	83 ec 0c             	sub    $0xc,%esp
    b00c:	50                   	push   %eax
    b00d:	e8 18 ff ff ff       	call   af2a <bad_task_ptr>
    b012:	83 c4 10             	add    $0x10,%esp
    b015:	85 c0                	test   %eax,%eax
    b017:	74 26                	je     b03f <audit_ptree+0xc1>
			printk("Warning, pid %d's child link is bad\n",
				task[i]->pid);
    b019:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b01f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b023:	8b 04 90             	mov    (%eax,%edx,4),%eax
			printk("Warning, pid %d's child link is bad\n",
    b026:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b02c:	83 ec 08             	sub    $0x8,%esp
    b02f:	50                   	push   %eax
    b030:	8d 83 c4 46 ff ff    	lea    -0xb93c(%ebx),%eax
    b036:	50                   	push   %eax
    b037:	e8 f6 e2 ff ff       	call   9332 <printk>
    b03c:	83 c4 10             	add    $0x10,%esp
		if (bad_task_ptr(task[i]->p_ysptr))
    b03f:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b045:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b049:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b04c:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    b052:	83 ec 0c             	sub    $0xc,%esp
    b055:	50                   	push   %eax
    b056:	e8 cf fe ff ff       	call   af2a <bad_task_ptr>
    b05b:	83 c4 10             	add    $0x10,%esp
    b05e:	85 c0                	test   %eax,%eax
    b060:	74 26                	je     b088 <audit_ptree+0x10a>
			printk("Warning, pid %d's ys link is bad\n",
				task[i]->pid);
    b062:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b068:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b06c:	8b 04 90             	mov    (%eax,%edx,4),%eax
			printk("Warning, pid %d's ys link is bad\n",
    b06f:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b075:	83 ec 08             	sub    $0x8,%esp
    b078:	50                   	push   %eax
    b079:	8d 83 ec 46 ff ff    	lea    -0xb914(%ebx),%eax
    b07f:	50                   	push   %eax
    b080:	e8 ad e2 ff ff       	call   9332 <printk>
    b085:	83 c4 10             	add    $0x10,%esp
		if (bad_task_ptr(task[i]->p_osptr))
    b088:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b08e:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b092:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b095:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    b09b:	83 ec 0c             	sub    $0xc,%esp
    b09e:	50                   	push   %eax
    b09f:	e8 86 fe ff ff       	call   af2a <bad_task_ptr>
    b0a4:	83 c4 10             	add    $0x10,%esp
    b0a7:	85 c0                	test   %eax,%eax
    b0a9:	74 26                	je     b0d1 <audit_ptree+0x153>
			printk("Warning, pid %d's os link is bad\n",
				task[i]->pid);
    b0ab:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b0b1:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b0b5:	8b 04 90             	mov    (%eax,%edx,4),%eax
			printk("Warning, pid %d's os link is bad\n",
    b0b8:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b0be:	83 ec 08             	sub    $0x8,%esp
    b0c1:	50                   	push   %eax
    b0c2:	8d 83 10 47 ff ff    	lea    -0xb8f0(%ebx),%eax
    b0c8:	50                   	push   %eax
    b0c9:	e8 64 e2 ff ff       	call   9332 <printk>
    b0ce:	83 c4 10             	add    $0x10,%esp
		// 如果任务的父进程指针p_pptr指向了自己，则显示警告信息“警告，pid号N的父进程链接指针指向了自己”。以下语句对cptr、ysptr
		// 和osptr进行类似操作。
		if (task[i]->p_pptr == task[i])
    b0d1:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b0d7:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b0db:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b0de:	8b 88 bc 02 00 00    	mov    0x2bc(%eax),%ecx
    b0e4:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b0ea:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b0ee:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b0f1:	39 c1                	cmp    %eax,%ecx
    b0f3:	75 12                	jne    b107 <audit_ptree+0x189>
			printk("Warning, pid %d parent link points to self\n");
    b0f5:	83 ec 0c             	sub    $0xc,%esp
    b0f8:	8d 83 34 47 ff ff    	lea    -0xb8cc(%ebx),%eax
    b0fe:	50                   	push   %eax
    b0ff:	e8 2e e2 ff ff       	call   9332 <printk>
    b104:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_cptr == task[i])
    b107:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b10d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b111:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b114:	8b 88 c0 02 00 00    	mov    0x2c0(%eax),%ecx
    b11a:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b120:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b124:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b127:	39 c1                	cmp    %eax,%ecx
    b129:	75 12                	jne    b13d <audit_ptree+0x1bf>
			printk("Warning, pid %d child link points to self\n");
    b12b:	83 ec 0c             	sub    $0xc,%esp
    b12e:	8d 83 60 47 ff ff    	lea    -0xb8a0(%ebx),%eax
    b134:	50                   	push   %eax
    b135:	e8 f8 e1 ff ff       	call   9332 <printk>
    b13a:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_ysptr == task[i])
    b13d:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b143:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b147:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b14a:	8b 88 c4 02 00 00    	mov    0x2c4(%eax),%ecx
    b150:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b156:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b15a:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b15d:	39 c1                	cmp    %eax,%ecx
    b15f:	75 12                	jne    b173 <audit_ptree+0x1f5>
			printk("Warning, pid %d ys link points to self\n");
    b161:	83 ec 0c             	sub    $0xc,%esp
    b164:	8d 83 8c 47 ff ff    	lea    -0xb874(%ebx),%eax
    b16a:	50                   	push   %eax
    b16b:	e8 c2 e1 ff ff       	call   9332 <printk>
    b170:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_osptr == task[i])
    b173:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b179:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b17d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b180:	8b 88 c8 02 00 00    	mov    0x2c8(%eax),%ecx
    b186:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b18c:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b190:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b193:	39 c1                	cmp    %eax,%ecx
    b195:	75 12                	jne    b1a9 <audit_ptree+0x22b>
			printk("Warning, pid %d os link points to self\n");
    b197:	83 ec 0c             	sub    $0xc,%esp
    b19a:	8d 83 b4 47 ff ff    	lea    -0xb84c(%ebx),%eax
    b1a0:	50                   	push   %eax
    b1a1:	e8 8c e1 ff ff       	call   9332 <printk>
    b1a6:	83 c4 10             	add    $0x10,%esp
		// 如果任务有比自己先创建的比邻兄弟进程，那么就检查它们是否有共同的父进程，并检查这个老兄弟进程的ysptr指针是否正确地指向本
		// 进程。否则显示警告信息。
		if (task[i]->p_osptr) {
    b1a9:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b1af:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b1b3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b1b6:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    b1bc:	85 c0                	test   %eax,%eax
    b1be:	0f 84 f7 00 00 00    	je     b2bb <audit_ptree+0x33d>
			if (task[i]->p_pptr != task[i]->p_osptr->p_pptr)
    b1c4:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b1ca:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b1ce:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b1d1:	8b 88 bc 02 00 00    	mov    0x2bc(%eax),%ecx
    b1d7:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b1dd:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b1e1:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b1e4:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    b1ea:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    b1f0:	39 c1                	cmp    %eax,%ecx
    b1f2:	74 5d                	je     b251 <audit_ptree+0x2d3>
				printk(
			"Warning, pid %d older sibling %d parent is %d\n",
				task[i]->pid, task[i]->p_osptr->pid,
				task[i]->p_osptr->p_pptr->pid);
    b1f4:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b1fa:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b1fe:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b201:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    b207:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
				printk(
    b20d:	8b 88 2c 02 00 00    	mov    0x22c(%eax),%ecx
				task[i]->pid, task[i]->p_osptr->pid,
    b213:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b219:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b21d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b220:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
				printk(
    b226:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
				task[i]->pid, task[i]->p_osptr->pid,
    b22c:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b232:	8b 74 24 0c          	mov    0xc(%esp),%esi
    b236:	8b 04 b0             	mov    (%eax,%esi,4),%eax
				printk(
    b239:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b23f:	51                   	push   %ecx
    b240:	52                   	push   %edx
    b241:	50                   	push   %eax
    b242:	8d 83 dc 47 ff ff    	lea    -0xb824(%ebx),%eax
    b248:	50                   	push   %eax
    b249:	e8 e4 e0 ff ff       	call   9332 <printk>
    b24e:	83 c4 10             	add    $0x10,%esp
			if (task[i]->p_osptr->p_ysptr != task[i])
    b251:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b257:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b25b:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b25e:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    b264:	8b 88 c4 02 00 00    	mov    0x2c4(%eax),%ecx
    b26a:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b270:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b274:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b277:	39 c1                	cmp    %eax,%ecx
    b279:	74 40                	je     b2bb <audit_ptree+0x33d>
				printk(
		"Warning, pid %d older sibling %d has mismatched ys link\n",
				task[i]->pid, task[i]->p_osptr->pid);
    b27b:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b281:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b285:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b288:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
				printk(
    b28e:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
				task[i]->pid, task[i]->p_osptr->pid);
    b294:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b29a:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    b29e:	8b 04 88             	mov    (%eax,%ecx,4),%eax
				printk(
    b2a1:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b2a7:	83 ec 04             	sub    $0x4,%esp
    b2aa:	52                   	push   %edx
    b2ab:	50                   	push   %eax
    b2ac:	8d 83 0c 48 ff ff    	lea    -0xb7f4(%ebx),%eax
    b2b2:	50                   	push   %eax
    b2b3:	e8 7a e0 ff ff       	call   9332 <printk>
    b2b8:	83 c4 10             	add    $0x10,%esp
		}
		// 如果任务有比自己后创建的比邻兄弟进程，那么就检查它们是否有共同的父进程，并检查这个小弟进程的osptr指针是否正确地指向本进程
		// 否则显示警告信息。
		if (task[i]->p_ysptr) {
    b2bb:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b2c1:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b2c5:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b2c8:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    b2ce:	85 c0                	test   %eax,%eax
    b2d0:	0f 84 f7 00 00 00    	je     b3cd <audit_ptree+0x44f>
			if (task[i]->p_pptr != task[i]->p_ysptr->p_pptr)
    b2d6:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b2dc:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b2e0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b2e3:	8b 88 bc 02 00 00    	mov    0x2bc(%eax),%ecx
    b2e9:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b2ef:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b2f3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b2f6:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    b2fc:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    b302:	39 c1                	cmp    %eax,%ecx
    b304:	74 5d                	je     b363 <audit_ptree+0x3e5>
				printk(
			"Warning, pid %d younger sibling %d parent is %d\n",
				task[i]->pid, task[i]->p_osptr->pid,
				task[i]->p_osptr->p_pptr->pid);
    b306:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b30c:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b310:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b313:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    b319:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
				printk(
    b31f:	8b 88 2c 02 00 00    	mov    0x22c(%eax),%ecx
				task[i]->pid, task[i]->p_osptr->pid,
    b325:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b32b:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b32f:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b332:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
				printk(
    b338:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
				task[i]->pid, task[i]->p_osptr->pid,
    b33e:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b344:	8b 74 24 0c          	mov    0xc(%esp),%esi
    b348:	8b 04 b0             	mov    (%eax,%esi,4),%eax
				printk(
    b34b:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b351:	51                   	push   %ecx
    b352:	52                   	push   %edx
    b353:	50                   	push   %eax
    b354:	8d 83 48 48 ff ff    	lea    -0xb7b8(%ebx),%eax
    b35a:	50                   	push   %eax
    b35b:	e8 d2 df ff ff       	call   9332 <printk>
    b360:	83 c4 10             	add    $0x10,%esp
			if (task[i]->p_ysptr->p_osptr != task[i])
    b363:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b369:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b36d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b370:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    b376:	8b 88 c8 02 00 00    	mov    0x2c8(%eax),%ecx
    b37c:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b382:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b386:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b389:	39 c1                	cmp    %eax,%ecx
    b38b:	74 40                	je     b3cd <audit_ptree+0x44f>
				printk(
		"Warning, pid %d younger sibling %d has mismatched os link\n",
				task[i]->pid, task[i]->p_ysptr->pid);
    b38d:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b393:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b397:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b39a:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
				printk(
    b3a0:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
				task[i]->pid, task[i]->p_ysptr->pid);
    b3a6:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b3ac:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    b3b0:	8b 04 88             	mov    (%eax,%ecx,4),%eax
				printk(
    b3b3:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b3b9:	83 ec 04             	sub    $0x4,%esp
    b3bc:	52                   	push   %edx
    b3bd:	50                   	push   %eax
    b3be:	8d 83 7c 48 ff ff    	lea    -0xb784(%ebx),%eax
    b3c4:	50                   	push   %eax
    b3c5:	e8 68 df ff ff       	call   9332 <printk>
    b3ca:	83 c4 10             	add    $0x10,%esp
		}
		// 如果任务的最新子进程指针cptr不空，那么检查该子进程的父进程是否为本进程，并检查该子进程的小弟进程指针yspter是否为空。若不是
		// 则显示警告信息。
		if (task[i]->p_cptr) {
    b3cd:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b3d3:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b3d7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b3da:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    b3e0:	85 c0                	test   %eax,%eax
    b3e2:	0f 84 ca 00 00 00    	je     b4b2 <audit_ptree+0x534>
			if (task[i]->p_cptr->p_pptr != task[i])
    b3e8:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b3ee:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b3f2:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b3f5:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    b3fb:	8b 88 bc 02 00 00    	mov    0x2bc(%eax),%ecx
    b401:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b407:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b40b:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b40e:	39 c1                	cmp    %eax,%ecx
    b410:	74 40                	je     b452 <audit_ptree+0x4d4>
				printk(
			"Warning, pid %d youngest child %d has mismatched parent link\n",
				task[i]->pid, task[i]->p_cptr->pid);
    b412:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b418:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b41c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b41f:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
				printk(
    b425:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
				task[i]->pid, task[i]->p_cptr->pid);
    b42b:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b431:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    b435:	8b 04 88             	mov    (%eax,%ecx,4),%eax
				printk(
    b438:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b43e:	83 ec 04             	sub    $0x4,%esp
    b441:	52                   	push   %edx
    b442:	50                   	push   %eax
    b443:	8d 83 b8 48 ff ff    	lea    -0xb748(%ebx),%eax
    b449:	50                   	push   %eax
    b44a:	e8 e3 de ff ff       	call   9332 <printk>
    b44f:	83 c4 10             	add    $0x10,%esp
			if (task[i]->p_cptr->p_ysptr)
    b452:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b458:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b45c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b45f:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    b465:	8b 80 c4 02 00 00    	mov    0x2c4(%eax),%eax
    b46b:	85 c0                	test   %eax,%eax
    b46d:	74 43                	je     b4b2 <audit_ptree+0x534>
				printk(
			"Warning, pid %d youngest child %d has non-NULL ys link\n",
				task[i]->pid, task[i]->p_cptr->pid);
    b46f:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b475:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b479:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b47c:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
				printk(
    b482:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
				task[i]->pid, task[i]->p_cptr->pid);
    b488:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b48e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    b492:	8b 04 88             	mov    (%eax,%ecx,4),%eax
				printk(
    b495:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b49b:	83 ec 04             	sub    $0x4,%esp
    b49e:	52                   	push   %edx
    b49f:	50                   	push   %eax
    b4a0:	8d 83 f8 48 ff ff    	lea    -0xb708(%ebx),%eax
    b4a6:	50                   	push   %eax
    b4a7:	e8 86 de ff ff       	call   9332 <printk>
    b4ac:	83 c4 10             	add    $0x10,%esp
    b4af:	eb 01                	jmp    b4b2 <audit_ptree+0x534>
			continue;
    b4b1:	90                   	nop
	for (i = 1 ; i < NR_TASKS ; i++) {
    b4b2:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    b4b7:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    b4bc:	0f 8e d9 fa ff ff    	jle    af9b <audit_ptree+0x1d>
		}
	}
}
    b4c2:	90                   	nop
    b4c3:	83 c4 14             	add    $0x14,%esp
    b4c6:	5b                   	pop    %ebx
    b4c7:	5e                   	pop    %esi
    b4c8:	c3                   	ret    

0000b4c9 <send_sig>:

// 向指定任务p发送信号sig，权限为priv。
// 参数：sig - 信号值；p - 指定任务的指针；priv - 强制发送信号的标志。即不需要考虑进程用户属性或级别而能发
// 送信号sig并退出，否则返回未许可错误号。
static inline int send_sig(long sig, struct task_struct * p, int priv)
{
    b4c9:	53                   	push   %ebx
    b4ca:	e8 23 b8 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    b4cf:	05 31 6b 02 00       	add    $0x26b31,%eax
	// 如果没有权限，并且当前进程的有效用户ID与进程p的不同，并且也不是超级用户，则说明没有向p发送信号的权利。suser()
	// 定义为（current->euid==0），用于判断是否为超级用户。
	if (!p)
    b4d4:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b4d9:	75 0a                	jne    b4e5 <send_sig+0x1c>
		return -EINVAL;
    b4db:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b4e0:	e9 f5 00 00 00       	jmp    b5da <send_sig+0x111>
	if (!priv && (current->euid != p->euid) && !suser())
    b4e5:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    b4ea:	75 3d                	jne    b529 <send_sig+0x60>
    b4ec:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    b4f2:	8b 12                	mov    (%edx),%edx
    b4f4:	0f b7 8a ce 02 00 00 	movzwl 0x2ce(%edx),%ecx
    b4fb:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b4ff:	0f b7 92 ce 02 00 00 	movzwl 0x2ce(%edx),%edx
    b506:	66 39 d1             	cmp    %dx,%cx
    b509:	74 1e                	je     b529 <send_sig+0x60>
    b50b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    b511:	8b 00                	mov    (%eax),%eax
    b513:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    b51a:	66 85 c0             	test   %ax,%ax
    b51d:	74 0a                	je     b529 <send_sig+0x60>
		return -EPERM;
    b51f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b524:	e9 b1 00 00 00       	jmp    b5da <send_sig+0x111>
	// 若需要发送的信号是SIGKILL或SIGCONT，那么如果此时接收信号的进程p正处于停止状态就置其为就绪（运行）状态。然后
	// 修改进程p的信号位图signal，去掉（复位）会导致进程停止的信号SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU。
	if ((sig == SIGKILL) || (sig == SIGCONT)) {
    b529:	83 7c 24 08 09       	cmpl   $0x9,0x8(%esp)
    b52e:	74 07                	je     b537 <send_sig+0x6e>
    b530:	83 7c 24 08 12       	cmpl   $0x12,0x8(%esp)
    b535:	75 38                	jne    b56f <send_sig+0xa6>
		if (p->state == TASK_STOPPED)
    b537:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b53b:	8b 00                	mov    (%eax),%eax
    b53d:	83 f8 04             	cmp    $0x4,%eax
    b540:	75 0a                	jne    b54c <send_sig+0x83>
			p->state = TASK_RUNNING;
    b542:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b546:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		p->exit_code = 0;
    b54c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b550:	c7 80 14 02 00 00 00 	movl   $0x0,0x214(%eax)
    b557:	00 00 00 
		p->signal &= ~( (1 << (SIGSTOP - 1)) | (1 << (SIGTSTP - 1)) |
    b55a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b55e:	8b 40 0c             	mov    0xc(%eax),%eax
    b561:	25 ff ff c3 ff       	and    $0xffc3ffff,%eax
    b566:	89 c2                	mov    %eax,%edx
    b568:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b56c:	89 50 0c             	mov    %edx,0xc(%eax)
				(1 << (SIGTTIN - 1)) | (1 << (SIGTTOU - 1)) );
	}
	/* If the signal will be ignored, don't even post it */
    /* 如果要发送的信号sig将被进程p忽略掉，那么就根本不用发送 */
	if ((int) p->sigaction[sig - 1].sa_handler == 1)
    b56f:	8b 44 24 08          	mov    0x8(%esp),%eax
    b573:	8d 50 ff             	lea    -0x1(%eax),%edx
    b576:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b57a:	83 c2 01             	add    $0x1,%edx
    b57d:	c1 e2 04             	shl    $0x4,%edx
    b580:	01 d0                	add    %edx,%eax
    b582:	8b 00                	mov    (%eax),%eax
    b584:	83 f8 01             	cmp    $0x1,%eax
    b587:	75 07                	jne    b590 <send_sig+0xc7>
		return 0;
    b589:	b8 00 00 00 00       	mov    $0x0,%eax
    b58e:	eb 4a                	jmp    b5da <send_sig+0x111>
	/* Depends on order SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU */
   	/* 以下判断依赖于SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU */
	// 如果信号是SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU之一，那么说明要让接收信号的进程p停止运行。因此（若p的信号位图
	// 中有SIGCONT置位）就需要复位位图中继续运行的信号。
	if ((sig >= SIGSTOP) && (sig <= SIGTTOU))
    b590:	83 7c 24 08 12       	cmpl   $0x12,0x8(%esp)
    b595:	7e 1c                	jle    b5b3 <send_sig+0xea>
    b597:	83 7c 24 08 16       	cmpl   $0x16,0x8(%esp)
    b59c:	7f 15                	jg     b5b3 <send_sig+0xea>
		p->signal &= ~(1 << (SIGCONT - 1));
    b59e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5a2:	8b 40 0c             	mov    0xc(%eax),%eax
    b5a5:	25 ff ff fd ff       	and    $0xfffdffff,%eax
    b5aa:	89 c2                	mov    %eax,%edx
    b5ac:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5b0:	89 50 0c             	mov    %edx,0xc(%eax)
	/* Actually deliver the signal */
    /* 最后，我们向进程p发送信号p */
	p->signal |= (1 << (sig - 1));
    b5b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5b7:	8b 40 0c             	mov    0xc(%eax),%eax
    b5ba:	8b 54 24 08          	mov    0x8(%esp),%edx
    b5be:	83 ea 01             	sub    $0x1,%edx
    b5c1:	bb 01 00 00 00       	mov    $0x1,%ebx
    b5c6:	89 d1                	mov    %edx,%ecx
    b5c8:	d3 e3                	shl    %cl,%ebx
    b5ca:	89 da                	mov    %ebx,%edx
    b5cc:	09 c2                	or     %eax,%edx
    b5ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5d2:	89 50 0c             	mov    %edx,0xc(%eax)
	return 0;
    b5d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b5da:	5b                   	pop    %ebx
    b5db:	c3                   	ret    

0000b5dc <session_of_pgrp>:

// 根据进程组号pgrp取得进程组所属的会话号。
// 扫描任务数组，寻找进程组号为pgrp的进程，并返回其会话号。如果没有找到指定的进程组号pgrp的任何进程，则返回-1.
int session_of_pgrp(int pgrp)
{
    b5dc:	83 ec 10             	sub    $0x10,%esp
    b5df:	e8 0e b7 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    b5e4:	05 1c 6a 02 00       	add    $0x26a1c,%eax
	struct task_struct **p;

 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    b5e9:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b5ef:	8d 92 fc 00 00 00    	lea    0xfc(%edx),%edx
    b5f5:	89 54 24 0c          	mov    %edx,0xc(%esp)
    b5f9:	eb 25                	jmp    b620 <session_of_pgrp+0x44>
		if ((*p)->pgrp == pgrp)
    b5fb:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b5ff:	8b 12                	mov    (%edx),%edx
    b601:	8b 92 30 02 00 00    	mov    0x230(%edx),%edx
    b607:	39 54 24 14          	cmp    %edx,0x14(%esp)
    b60b:	75 0e                	jne    b61b <session_of_pgrp+0x3f>
			return((*p)->session);
    b60d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b611:	8b 00                	mov    (%eax),%eax
    b613:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    b619:	eb 16                	jmp    b631 <session_of_pgrp+0x55>
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    b61b:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    b620:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b626:	39 54 24 0c          	cmp    %edx,0xc(%esp)
    b62a:	77 cf                	ja     b5fb <session_of_pgrp+0x1f>
	return -1;
    b62c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    b631:	83 c4 10             	add    $0x10,%esp
    b634:	c3                   	ret    

0000b635 <kill_pg>:
// 参数：pgrp - 指定的进程组号；sig - 指定的信号；priv - 权限。
// 即向指定进程组pgrp中的每个进程发送指定信号sig。只要向一个进程发送成功最后就会返回0，否则如果没有找到指定进程
// 组号pgrp的任何一个进程，则返回出错号-ESRCH，若找到进程组号是pgrp的进程，但是发送信号失败，则返回发送失败的
// 错误码。
int kill_pg(int pgrp, int sig, int priv)
{
    b635:	53                   	push   %ebx
    b636:	83 ec 10             	sub    $0x10,%esp
    b639:	e8 bc b6 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    b63e:	81 c3 c2 69 02 00    	add    $0x269c2,%ebx
	struct task_struct **p;
	int err,retval = -ESRCH;                // -ESRCH表示指定的进程不存在。
    b644:	c7 44 24 08 fd ff ff 	movl   $0xfffffffd,0x8(%esp)
    b64b:	ff 
	int found = 0;
    b64c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    b653:	00 

	// 首先判断给定的信号和进程组号是否有效。然后扫描系统中所有任务。若扫描到进程组号为pgrp的进程，就向其发送信号sig。
	// 只要有一次信号发送成功，函数最后就会返回0。
	if (sig < 1 || sig > 32 || pgrp <= 0)
    b654:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    b659:	7e 0e                	jle    b669 <kill_pg+0x34>
    b65b:	83 7c 24 1c 20       	cmpl   $0x20,0x1c(%esp)
    b660:	7f 07                	jg     b669 <kill_pg+0x34>
    b662:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    b667:	7f 07                	jg     b670 <kill_pg+0x3b>
		return -EINVAL;
    b669:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b66e:	eb 7c                	jmp    b6ec <kill_pg+0xb7>
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    b670:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b676:	8d 80 fc 00 00 00    	lea    0xfc(%eax),%eax
    b67c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b680:	eb 4c                	jmp    b6ce <kill_pg+0x99>
		if ((*p)->pgrp == pgrp) {
    b682:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b686:	8b 00                	mov    (%eax),%eax
    b688:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    b68e:	39 44 24 18          	cmp    %eax,0x18(%esp)
    b692:	75 35                	jne    b6c9 <kill_pg+0x94>
			if (sig && (err = send_sig(sig, *p, priv)))
    b694:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    b699:	74 29                	je     b6c4 <kill_pg+0x8f>
    b69b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b69f:	8b 00                	mov    (%eax),%eax
    b6a1:	ff 74 24 20          	pushl  0x20(%esp)
    b6a5:	50                   	push   %eax
    b6a6:	ff 74 24 24          	pushl  0x24(%esp)
    b6aa:	e8 1a fe ff ff       	call   b4c9 <send_sig>
    b6af:	83 c4 0c             	add    $0xc,%esp
    b6b2:	89 04 24             	mov    %eax,(%esp)
    b6b5:	83 3c 24 00          	cmpl   $0x0,(%esp)
    b6b9:	74 09                	je     b6c4 <kill_pg+0x8f>
				retval = err;
    b6bb:	8b 04 24             	mov    (%esp),%eax
    b6be:	89 44 24 08          	mov    %eax,0x8(%esp)
    b6c2:	eb 05                	jmp    b6c9 <kill_pg+0x94>
			else
				found++;
    b6c4:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    b6c9:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    b6ce:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b6d4:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    b6d8:	77 a8                	ja     b682 <kill_pg+0x4d>
		}
	return(found ? 0 : retval);
    b6da:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    b6df:	75 06                	jne    b6e7 <kill_pg+0xb2>
    b6e1:	8b 44 24 08          	mov    0x8(%esp),%eax
    b6e5:	eb 05                	jmp    b6ec <kill_pg+0xb7>
    b6e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b6ec:	83 c4 10             	add    $0x10,%esp
    b6ef:	5b                   	pop    %ebx
    b6f0:	c3                   	ret    

0000b6f1 <kill_proc>:
// 终止进程（向进程发送信号）。
// 参数：pid - 进程号；sig - 指定信号；priv - 权限。
// 即向进程号为pid的进程发送指定信号sig。若找到指定pid的进程，那么若信号发送成功，则返回0，否则返回信号发送出错。
// 如果没有找到指定进程号pid的进程，则返回出错号-ESRCH（指定进程不存在）。
int kill_proc(int pid, int sig, int priv)
{
    b6f1:	83 ec 10             	sub    $0x10,%esp
    b6f4:	e8 f9 b5 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    b6f9:	05 07 69 02 00       	add    $0x26907,%eax
 	struct task_struct **p;

	if (sig < 1 || sig > 32)
    b6fe:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    b703:	7e 07                	jle    b70c <kill_proc+0x1b>
    b705:	83 7c 24 18 20       	cmpl   $0x20,0x18(%esp)
    b70a:	7e 07                	jle    b713 <kill_proc+0x22>
		return -EINVAL;
    b70c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b711:	eb 61                	jmp    b774 <kill_proc+0x83>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    b713:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b719:	8d 92 fc 00 00 00    	lea    0xfc(%edx),%edx
    b71f:	89 54 24 0c          	mov    %edx,0xc(%esp)
    b723:	eb 3e                	jmp    b763 <kill_proc+0x72>
		if ((*p)->pid == pid)
    b725:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b729:	8b 12                	mov    (%edx),%edx
    b72b:	8b 92 2c 02 00 00    	mov    0x22c(%edx),%edx
    b731:	39 54 24 14          	cmp    %edx,0x14(%esp)
    b735:	75 27                	jne    b75e <kill_proc+0x6d>
			return(sig ? send_sig(sig, *p, priv) : 0);
    b737:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    b73c:	74 19                	je     b757 <kill_proc+0x66>
    b73e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b742:	8b 00                	mov    (%eax),%eax
    b744:	ff 74 24 1c          	pushl  0x1c(%esp)
    b748:	50                   	push   %eax
    b749:	ff 74 24 20          	pushl  0x20(%esp)
    b74d:	e8 77 fd ff ff       	call   b4c9 <send_sig>
    b752:	83 c4 0c             	add    $0xc,%esp
    b755:	eb 1d                	jmp    b774 <kill_proc+0x83>
    b757:	b8 00 00 00 00       	mov    $0x0,%eax
    b75c:	eb 16                	jmp    b774 <kill_proc+0x83>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    b75e:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    b763:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b769:	39 54 24 0c          	cmp    %edx,0xc(%esp)
    b76d:	77 b6                	ja     b725 <kill_proc+0x34>
	return(-ESRCH);
    b76f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
    b774:	83 c4 10             	add    $0x10,%esp
    b777:	c3                   	ret    

0000b778 <sys_kill>:
// 如果pid<-1，则信号sig将发送给进程组-pid的所有进程。
// 如果信号sig为0，则不发送信号，但仍会进行错误检查。如果成功则返回0.
// 该函数扫描任务数组表，并根据pid对满足条件的进程发送指定信号sig。若pid等于0，表明当前进程是进程组组长，因此需要
// 向所有组内的进程强制发送信号sig。
int sys_kill(int pid, int sig)
{
    b778:	53                   	push   %ebx
    b779:	83 ec 10             	sub    $0x10,%esp
    b77c:	e8 79 b5 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    b781:	81 c3 7f 68 02 00    	add    $0x2687f,%ebx
	struct task_struct **p = NR_TASKS + task;       // p指向任务数组最后一项。
    b787:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b78d:	8d 80 00 01 00 00    	lea    0x100(%eax),%eax
    b793:	89 44 24 0c          	mov    %eax,0xc(%esp)
	int err, retval = 0;
    b797:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b79e:	00 

	if (!pid)
    b79f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    b7a4:	75 1f                	jne    b7c5 <sys_kill+0x4d>
		return(kill_pg(current->pid, sig, 0));
    b7a6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    b7ac:	8b 00                	mov    (%eax),%eax
    b7ae:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    b7b4:	6a 00                	push   $0x0
    b7b6:	ff 74 24 20          	pushl  0x20(%esp)
    b7ba:	50                   	push   %eax
    b7bb:	e8 75 fe ff ff       	call   b635 <kill_pg>
    b7c0:	83 c4 0c             	add    $0xc,%esp
    b7c3:	eb 78                	jmp    b83d <sys_kill+0xc5>
	if (pid == -1) {
    b7c5:	83 7c 24 18 ff       	cmpl   $0xffffffff,0x18(%esp)
    b7ca:	75 41                	jne    b80d <sys_kill+0x95>
		while (--p > &FIRST_TASK)
    b7cc:	eb 28                	jmp    b7f6 <sys_kill+0x7e>
			if (err = send_sig(sig, *p, 0))
    b7ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b7d2:	8b 00                	mov    (%eax),%eax
    b7d4:	6a 00                	push   $0x0
    b7d6:	50                   	push   %eax
    b7d7:	ff 74 24 24          	pushl  0x24(%esp)
    b7db:	e8 e9 fc ff ff       	call   b4c9 <send_sig>
    b7e0:	83 c4 0c             	add    $0xc,%esp
    b7e3:	89 44 24 04          	mov    %eax,0x4(%esp)
    b7e7:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    b7ec:	74 08                	je     b7f6 <sys_kill+0x7e>
				retval = err;
    b7ee:	8b 44 24 04          	mov    0x4(%esp),%eax
    b7f2:	89 44 24 08          	mov    %eax,0x8(%esp)
		while (--p > &FIRST_TASK)
    b7f6:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    b7fb:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    b801:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    b805:	77 c7                	ja     b7ce <sys_kill+0x56>
		return(retval);
    b807:	8b 44 24 08          	mov    0x8(%esp),%eax
    b80b:	eb 30                	jmp    b83d <sys_kill+0xc5>
	}
	if (pid < 0)
    b80d:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    b812:	79 17                	jns    b82b <sys_kill+0xb3>
		return(kill_pg(-pid, sig, 0));
    b814:	8b 44 24 18          	mov    0x18(%esp),%eax
    b818:	f7 d8                	neg    %eax
    b81a:	6a 00                	push   $0x0
    b81c:	ff 74 24 20          	pushl  0x20(%esp)
    b820:	50                   	push   %eax
    b821:	e8 0f fe ff ff       	call   b635 <kill_pg>
    b826:	83 c4 0c             	add    $0xc,%esp
    b829:	eb 12                	jmp    b83d <sys_kill+0xc5>
	/* Normal kill */
	return(kill_proc(pid, sig, 0));
    b82b:	6a 00                	push   $0x0
    b82d:	ff 74 24 20          	pushl  0x20(%esp)
    b831:	ff 74 24 20          	pushl  0x20(%esp)
    b835:	e8 b7 fe ff ff       	call   b6f1 <kill_proc>
    b83a:	83 c4 0c             	add    $0xc,%esp
}
    b83d:	83 c4 10             	add    $0x10,%esp
    b840:	5b                   	pop    %ebx
    b841:	c3                   	ret    

0000b842 <is_orphaned_pgrp>:
// 扫描任务数组。如果任务项空，或者进程的组号与指定的不同，或者进程已经处于僵死状态。或者进程的父进程是init进程，
// 则说明扫描的进程不是指定进程组的成员，或者不满足要求，于是跳过。否则说明该进程是指定组的成员并且其父进程不是init
// 进程。此时如果该进程父进程的组号不等于指定的组号pgrp，但父进程的会话号等于进程的会话号，则说明它们同属于一个会话。
// 因此指定的pgrp进程组肯定不是孤儿进程组。否则......
int is_orphaned_pgrp(int pgrp)
{
    b842:	83 ec 10             	sub    $0x10,%esp
    b845:	e8 a8 b4 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    b84a:	05 b6 67 02 00       	add    $0x267b6,%eax
	struct task_struct **p;

	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    b84f:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b855:	8d 92 fc 00 00 00    	lea    0xfc(%edx),%edx
    b85b:	89 54 24 0c          	mov    %edx,0xc(%esp)
    b85f:	e9 87 00 00 00       	jmp    b8eb <is_orphaned_pgrp+0xa9>
		if (!(*p) ||
    b864:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b868:	8b 12                	mov    (%edx),%edx
    b86a:	85 d2                	test   %edx,%edx
    b86c:	74 77                	je     b8e5 <is_orphaned_pgrp+0xa3>
		    ((*p)->pgrp != pgrp) ||
    b86e:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b872:	8b 12                	mov    (%edx),%edx
    b874:	8b 92 30 02 00 00    	mov    0x230(%edx),%edx
		if (!(*p) ||
    b87a:	39 54 24 14          	cmp    %edx,0x14(%esp)
    b87e:	75 65                	jne    b8e5 <is_orphaned_pgrp+0xa3>
		    ((*p)->state == TASK_ZOMBIE) ||
    b880:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b884:	8b 12                	mov    (%edx),%edx
    b886:	8b 12                	mov    (%edx),%edx
		    ((*p)->pgrp != pgrp) ||
    b888:	83 fa 03             	cmp    $0x3,%edx
    b88b:	74 58                	je     b8e5 <is_orphaned_pgrp+0xa3>
		    ((*p)->p_pptr->pid == 1))
    b88d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b891:	8b 12                	mov    (%edx),%edx
    b893:	8b 92 bc 02 00 00    	mov    0x2bc(%edx),%edx
    b899:	8b 92 2c 02 00 00    	mov    0x22c(%edx),%edx
		    ((*p)->state == TASK_ZOMBIE) ||
    b89f:	83 fa 01             	cmp    $0x1,%edx
    b8a2:	74 41                	je     b8e5 <is_orphaned_pgrp+0xa3>
			continue;
		if (((*p)->p_pptr->pgrp != pgrp) &&
    b8a4:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b8a8:	8b 12                	mov    (%edx),%edx
    b8aa:	8b 92 bc 02 00 00    	mov    0x2bc(%edx),%edx
    b8b0:	8b 92 30 02 00 00    	mov    0x230(%edx),%edx
    b8b6:	39 54 24 14          	cmp    %edx,0x14(%esp)
    b8ba:	74 2a                	je     b8e6 <is_orphaned_pgrp+0xa4>
		    ((*p)->p_pptr->session == (*p)->session))
    b8bc:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b8c0:	8b 12                	mov    (%edx),%edx
    b8c2:	8b 92 bc 02 00 00    	mov    0x2bc(%edx),%edx
    b8c8:	8b 8a 34 02 00 00    	mov    0x234(%edx),%ecx
    b8ce:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b8d2:	8b 12                	mov    (%edx),%edx
    b8d4:	8b 92 34 02 00 00    	mov    0x234(%edx),%edx
		if (((*p)->p_pptr->pgrp != pgrp) &&
    b8da:	39 d1                	cmp    %edx,%ecx
    b8dc:	75 08                	jne    b8e6 <is_orphaned_pgrp+0xa4>
			return 0;
    b8de:	b8 00 00 00 00       	mov    $0x0,%eax
    b8e3:	eb 1b                	jmp    b900 <is_orphaned_pgrp+0xbe>
			continue;
    b8e5:	90                   	nop
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    b8e6:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    b8eb:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b8f1:	39 54 24 0c          	cmp    %edx,0xc(%esp)
    b8f5:	0f 87 69 ff ff ff    	ja     b864 <is_orphaned_pgrp+0x22>
	}
	return(1);	/* (sighing) "Often!" */        /* (唉）是孤儿进程组！ */
    b8fb:	b8 01 00 00 00       	mov    $0x1,%eax
}
    b900:	83 c4 10             	add    $0x10,%esp
    b903:	c3                   	ret    

0000b904 <has_stopped_jobs>:

// 判断进程组中是否含有处于停止状态的作业（进程组）。有则返回1；无则返回0.
// 查找方法是扫描整个任务数组。检查属于指定组pgrp的任何进程是否处于停止状态。
static int has_stopped_jobs(int pgrp)
{
    b904:	83 ec 10             	sub    $0x10,%esp
    b907:	e8 e6 b3 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    b90c:	05 f4 66 02 00       	add    $0x266f4,%eax
	struct task_struct ** p;

	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    b911:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b917:	8d 92 fc 00 00 00    	lea    0xfc(%edx),%edx
    b91d:	89 54 24 0c          	mov    %edx,0xc(%esp)
    b921:	eb 2c                	jmp    b94f <has_stopped_jobs+0x4b>
		if ((*p)->pgrp != pgrp)
    b923:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b927:	8b 12                	mov    (%edx),%edx
    b929:	8b 92 30 02 00 00    	mov    0x230(%edx),%edx
    b92f:	39 54 24 14          	cmp    %edx,0x14(%esp)
    b933:	75 14                	jne    b949 <has_stopped_jobs+0x45>
			continue;
		if ((*p)->state == TASK_STOPPED)
    b935:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b939:	8b 12                	mov    (%edx),%edx
    b93b:	8b 12                	mov    (%edx),%edx
    b93d:	83 fa 04             	cmp    $0x4,%edx
    b940:	75 08                	jne    b94a <has_stopped_jobs+0x46>
			return(1);
    b942:	b8 01 00 00 00       	mov    $0x1,%eax
    b947:	eb 17                	jmp    b960 <has_stopped_jobs+0x5c>
			continue;
    b949:	90                   	nop
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    b94a:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    b94f:	c7 c2 a0 32 03 00    	mov    $0x332a0,%edx
    b955:	39 54 24 0c          	cmp    %edx,0xc(%esp)
    b959:	77 c8                	ja     b923 <has_stopped_jobs+0x1f>
	}
	return(0);
    b95b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b960:	83 c4 10             	add    $0x10,%esp
    b963:	c3                   	ret    

0000b964 <do_exit>:

// 程序退出处理函数。
// 该函数将根据进程自身的特性对其进行处理，并把当前进程状态设置成僵死状态TASK_ZOMBIE，最后调用调度函数schedule()去
// 执行其他进程，不再返回。
void do_exit(long code)
{
    b964:	57                   	push   %edi
    b965:	56                   	push   %esi
    b966:	53                   	push   %ebx
    b967:	83 ec 20             	sub    $0x20,%esp
    b96a:	e8 8b b3 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    b96f:	81 c3 91 66 02 00    	add    $0x26691,%ebx
	// 首先释放当前进程代码段和数据段所占的内存页。函数free_page_tables()的第1个参数（get_base()返回值）指明在CPU线性
	// 地址空间中起始其地址，第2个（get_limit()返回值）说明欲释放的字节长度值。get_base()宏中的current->ldt[1]给出进程
	// 代码段描述符的位置（current->ldt[2]给出进程数据段描述符的位置）；get_limit()中的0x0f是进程代码段的选择符（0x17是
	// 进程数据段的选择符）。即在取段其地址时使用该段的描述符所处地址作为参数，取段长度时使用该段的选择符作为参数。
	// free_page_tables()函数位于mm/memory.c文件；get_base()和get_limit()宏位于include/linux/sched.h头文件。
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
    b975:	b8 0f 00 00 00       	mov    $0xf,%eax
    b97a:	0f 03 c0             	lsl    %ax,%eax
    b97d:	40                   	inc    %eax
    b97e:	89 44 24 10          	mov    %eax,0x10(%esp)
    b982:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    b986:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    b98c:	8b 00                	mov    (%eax),%eax
    b98e:	05 a0 03 00 00       	add    $0x3a0,%eax
    b993:	8d 78 02             	lea    0x2(%eax),%edi
    b996:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    b99c:	8b 00                	mov    (%eax),%eax
    b99e:	05 a0 03 00 00       	add    $0x3a0,%eax
    b9a3:	8d 70 04             	lea    0x4(%eax),%esi
    b9a6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    b9ac:	8b 00                	mov    (%eax),%eax
    b9ae:	05 a0 03 00 00       	add    $0x3a0,%eax
    b9b3:	83 c0 07             	add    $0x7,%eax
    b9b6:	8a 30                	mov    (%eax),%dh
    b9b8:	8a 16                	mov    (%esi),%dl
    b9ba:	c1 e2 10             	shl    $0x10,%edx
    b9bd:	66 8b 17             	mov    (%edi),%dx
    b9c0:	89 d0                	mov    %edx,%eax
    b9c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b9c6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b9ca:	83 ec 08             	sub    $0x8,%esp
    b9cd:	51                   	push   %ecx
    b9ce:	50                   	push   %eax
    b9cf:	e8 31 11 00 00       	call   cb05 <free_page_tables>
    b9d4:	83 c4 10             	add    $0x10,%esp
	free_page_tables(get_base(current->ldt[2]), get_limit(0x17));
    b9d7:	b8 17 00 00 00       	mov    $0x17,%eax
    b9dc:	0f 03 c0             	lsl    %ax,%eax
    b9df:	40                   	inc    %eax
    b9e0:	89 44 24 08          	mov    %eax,0x8(%esp)
    b9e4:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    b9e8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    b9ee:	8b 00                	mov    (%eax),%eax
    b9f0:	05 a8 03 00 00       	add    $0x3a8,%eax
    b9f5:	8d 78 02             	lea    0x2(%eax),%edi
    b9f8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    b9fe:	8b 00                	mov    (%eax),%eax
    ba00:	05 a8 03 00 00       	add    $0x3a8,%eax
    ba05:	8d 70 04             	lea    0x4(%eax),%esi
    ba08:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ba0e:	8b 00                	mov    (%eax),%eax
    ba10:	05 a8 03 00 00       	add    $0x3a8,%eax
    ba15:	83 c0 07             	add    $0x7,%eax
    ba18:	8a 30                	mov    (%eax),%dh
    ba1a:	8a 16                	mov    (%esi),%dl
    ba1c:	c1 e2 10             	shl    $0x10,%edx
    ba1f:	66 8b 17             	mov    (%edi),%dx
    ba22:	89 d0                	mov    %edx,%eax
    ba24:	89 44 24 04          	mov    %eax,0x4(%esp)
    ba28:	8b 44 24 04          	mov    0x4(%esp),%eax
    ba2c:	83 ec 08             	sub    $0x8,%esp
    ba2f:	51                   	push   %ecx
    ba30:	50                   	push   %eax
    ba31:	e8 cf 10 00 00       	call   cb05 <free_page_tables>
    ba36:	83 c4 10             	add    $0x10,%esp
	// 然后关闭当前进程打开着的所有文件。再对当前进程的工作目录pwd、根目录root、执行程序文件的i节点以及库文件进行同步操作，
	// 放回各个i节点并分别置空（释放）。接着把当前进程的状态设置为僵死状态（TASK_ZOMBIE），并设置进程退出码。
	for (i = 0 ; i < NR_OPEN ; i++)
    ba39:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    ba40:	00 
    ba41:	eb 2e                	jmp    ba71 <do_exit+0x10d>
		if (current->filp[i])
    ba43:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ba49:	8b 00                	mov    (%eax),%eax
    ba4b:	8b 54 24 18          	mov    0x18(%esp),%edx
    ba4f:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    ba55:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    ba59:	85 c0                	test   %eax,%eax
    ba5b:	74 0f                	je     ba6c <do_exit+0x108>
			sys_close(i);
    ba5d:	83 ec 0c             	sub    $0xc,%esp
    ba60:	ff 74 24 24          	pushl  0x24(%esp)
    ba64:	e8 34 32 00 00       	call   ec9d <sys_close>
    ba69:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_OPEN ; i++)
    ba6c:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
    ba71:	83 7c 24 18 13       	cmpl   $0x13,0x18(%esp)
    ba76:	7e cb                	jle    ba43 <do_exit+0xdf>
	Log(LOG_INFO_TYPE, "<<<<< sys_exit process pid = %d, exit_code = %d >>>>>\n", current->pid, code);
    ba78:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ba7e:	8b 00                	mov    (%eax),%eax
    ba80:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    ba86:	ff 74 24 30          	pushl  0x30(%esp)
    ba8a:	50                   	push   %eax
    ba8b:	8d 83 30 49 ff ff    	lea    -0xb6d0(%ebx),%eax
    ba91:	50                   	push   %eax
    ba92:	6a 00                	push   $0x0
    ba94:	e8 06 a1 01 00       	call   25b9f <Log>
    ba99:	83 c4 10             	add    $0x10,%esp
	iput(current->pwd);
    ba9c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    baa2:	8b 00                	mov    (%eax),%eax
    baa4:	8b 80 34 03 00 00    	mov    0x334(%eax),%eax
    baaa:	83 ec 0c             	sub    $0xc,%esp
    baad:	50                   	push   %eax
    baae:	e8 ef 3d 00 00       	call   f8a2 <iput>
    bab3:	83 c4 10             	add    $0x10,%esp
	current->pwd = NULL;
    bab6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    babc:	8b 00                	mov    (%eax),%eax
    babe:	c7 80 34 03 00 00 00 	movl   $0x0,0x334(%eax)
    bac5:	00 00 00 
	iput(current->root);
    bac8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bace:	8b 00                	mov    (%eax),%eax
    bad0:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
    bad6:	83 ec 0c             	sub    $0xc,%esp
    bad9:	50                   	push   %eax
    bada:	e8 c3 3d 00 00       	call   f8a2 <iput>
    badf:	83 c4 10             	add    $0x10,%esp
	current->root = NULL;
    bae2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bae8:	8b 00                	mov    (%eax),%eax
    baea:	c7 80 38 03 00 00 00 	movl   $0x0,0x338(%eax)
    baf1:	00 00 00 
	iput(current->executable);
    baf4:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bafa:	8b 00                	mov    (%eax),%eax
    bafc:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
    bb02:	83 ec 0c             	sub    $0xc,%esp
    bb05:	50                   	push   %eax
    bb06:	e8 97 3d 00 00       	call   f8a2 <iput>
    bb0b:	83 c4 10             	add    $0x10,%esp
	current->executable = NULL;
    bb0e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb14:	8b 00                	mov    (%eax),%eax
    bb16:	c7 80 3c 03 00 00 00 	movl   $0x0,0x33c(%eax)
    bb1d:	00 00 00 
	iput(current->library);
    bb20:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb26:	8b 00                	mov    (%eax),%eax
    bb28:	8b 80 40 03 00 00    	mov    0x340(%eax),%eax
    bb2e:	83 ec 0c             	sub    $0xc,%esp
    bb31:	50                   	push   %eax
    bb32:	e8 6b 3d 00 00       	call   f8a2 <iput>
    bb37:	83 c4 10             	add    $0x10,%esp
	current->library = NULL;
    bb3a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb40:	8b 00                	mov    (%eax),%eax
    bb42:	c7 80 40 03 00 00 00 	movl   $0x0,0x340(%eax)
    bb49:	00 00 00 
	current->state = TASK_ZOMBIE;
    bb4c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb52:	8b 00                	mov    (%eax),%eax
    bb54:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	current->exit_code = code;
    bb5a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb60:	8b 00                	mov    (%eax),%eax
    bb62:	8b 54 24 30          	mov    0x30(%esp),%edx
    bb66:	89 90 14 02 00 00    	mov    %edx,0x214(%eax)
     * 组将变成一个孤儿进程组。
     */
	// POSIX 3.2.2.2（1991版）是关于exit()函数的说明。如果父进程所在的进程组与当前进程的不同，但都处于同一个会话
	// （session）中，并且当前进程所在进程组将要变成孤儿进程了并且当前进程的进程组中含有处于停止状态的作业（进程），
	// 那么就要向这个当前进程的进程组发送两个信号：SIGHUP和SIGCONT。
	if ((current->p_pptr->pgrp != current->pgrp) &&
    bb6c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb72:	8b 00                	mov    (%eax),%eax
    bb74:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    bb7a:	8b 90 30 02 00 00    	mov    0x230(%eax),%edx
    bb80:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb86:	8b 00                	mov    (%eax),%eax
    bb88:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bb8e:	39 c2                	cmp    %eax,%edx
    bb90:	0f 84 9e 00 00 00    	je     bc34 <do_exit+0x2d0>
	    (current->p_pptr->session == current->session) &&
    bb96:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bb9c:	8b 00                	mov    (%eax),%eax
    bb9e:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    bba4:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    bbaa:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bbb0:	8b 00                	mov    (%eax),%eax
    bbb2:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
	if ((current->p_pptr->pgrp != current->pgrp) &&
    bbb8:	39 c2                	cmp    %eax,%edx
    bbba:	75 78                	jne    bc34 <do_exit+0x2d0>
	    is_orphaned_pgrp(current->pgrp) &&
    bbbc:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bbc2:	8b 00                	mov    (%eax),%eax
    bbc4:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bbca:	83 ec 0c             	sub    $0xc,%esp
    bbcd:	50                   	push   %eax
    bbce:	e8 6f fc ff ff       	call   b842 <is_orphaned_pgrp>
    bbd3:	83 c4 10             	add    $0x10,%esp
	    (current->p_pptr->session == current->session) &&
    bbd6:	85 c0                	test   %eax,%eax
    bbd8:	74 5a                	je     bc34 <do_exit+0x2d0>
	    has_stopped_jobs(current->pgrp)) {
    bbda:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bbe0:	8b 00                	mov    (%eax),%eax
    bbe2:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bbe8:	83 ec 0c             	sub    $0xc,%esp
    bbeb:	50                   	push   %eax
    bbec:	e8 13 fd ff ff       	call   b904 <has_stopped_jobs>
    bbf1:	83 c4 10             	add    $0x10,%esp
	    is_orphaned_pgrp(current->pgrp) &&
    bbf4:	85 c0                	test   %eax,%eax
    bbf6:	74 3c                	je     bc34 <do_exit+0x2d0>
		kill_pg(current->pgrp,SIGHUP,1);
    bbf8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bbfe:	8b 00                	mov    (%eax),%eax
    bc00:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bc06:	83 ec 04             	sub    $0x4,%esp
    bc09:	6a 01                	push   $0x1
    bc0b:	6a 01                	push   $0x1
    bc0d:	50                   	push   %eax
    bc0e:	e8 22 fa ff ff       	call   b635 <kill_pg>
    bc13:	83 c4 10             	add    $0x10,%esp
		kill_pg(current->pgrp,SIGCONT,1);
    bc16:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bc1c:	8b 00                	mov    (%eax),%eax
    bc1e:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bc24:	83 ec 04             	sub    $0x4,%esp
    bc27:	6a 01                	push   $0x1
    bc29:	6a 12                	push   $0x12
    bc2b:	50                   	push   %eax
    bc2c:	e8 04 fa ff ff       	call   b635 <kill_pg>
    bc31:	83 c4 10             	add    $0x10,%esp
	}
	/* Let father know we died */           /* 通知父进程当前进程将终止 */
	current->p_pptr->signal |= (1 << (SIGCHLD - 1));
    bc34:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bc3a:	8b 00                	mov    (%eax),%eax
    bc3c:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    bc42:	8b 50 0c             	mov    0xc(%eax),%edx
    bc45:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bc4b:	8b 00                	mov    (%eax),%eax
    bc4d:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    bc53:	81 ca 00 00 01 00    	or     $0x10000,%edx
    bc59:	89 50 0c             	mov    %edx,0xc(%eax)
     * B. 检查当前进程的退出是否会造成任何进程组变成孤儿进程组。如果有，并且有处于停止状态
     * （TASK_STOPPED）的组员，则向它们发送一个SIGHUP信号和一个SIGCONT信号。（POSIX 3.2.2.2节要求）
     */
	// 如果当前进程有子进程（其p_cptr指针指向最近创建的子进程），则让进程1（init进程）成为其所有子进程的父进程。如果
	// 子进程已经处于僵死状态，则向init进程（父进程）发送子进程已终止信号SIGCHLD。
	if (p = current->p_cptr) {
    bc5c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bc62:	8b 00                	mov    (%eax),%eax
    bc64:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    bc6a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    bc6e:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    bc73:	0f 84 63 01 00 00    	je     bddc <do_exit+0x478>
		while (1) {
			p->p_pptr = task[1];
    bc79:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bc7f:	8b 50 04             	mov    0x4(%eax),%edx
    bc82:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bc86:	89 90 bc 02 00 00    	mov    %edx,0x2bc(%eax)
			if (p->state == TASK_ZOMBIE)
    bc8c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bc90:	8b 00                	mov    (%eax),%eax
    bc92:	83 f8 03             	cmp    $0x3,%eax
    bc95:	75 1e                	jne    bcb5 <do_exit+0x351>
				task[1]->signal |= (1 << (SIGCHLD - 1));
    bc97:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bc9d:	8b 40 04             	mov    0x4(%eax),%eax
    bca0:	8b 50 0c             	mov    0xc(%eax),%edx
    bca3:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bca9:	8b 40 04             	mov    0x4(%eax),%eax
    bcac:	81 ca 00 00 01 00    	or     $0x10000,%edx
    bcb2:	89 50 0c             	mov    %edx,0xc(%eax)
             * 因此现在子进程所有进程组将变成孤儿进程组了。
             */
			// 如果子进程与当前进程不在同一个进程组但属于同一个session中，并且当前进程所在进程组将要变成孤儿进程了，并且当前
			// 进程的进程组中含有处于停止状态的作业（进程），那么就要向这个当前进程的进程组发送两个信号：SIGHUP和SIGCONT。如果
			// 该子进程有兄弟进程，则继续循环处理这些兄弟进程。
			if ((p->pgrp != current->pgrp) &&
    bcb5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bcb9:	8b 90 30 02 00 00    	mov    0x230(%eax),%edx
    bcbf:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bcc5:	8b 00                	mov    (%eax),%eax
    bcc7:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bccd:	39 c2                	cmp    %eax,%edx
    bccf:	0f 84 84 00 00 00    	je     bd59 <do_exit+0x3f5>
			    (p->session == current->session) &&
    bcd5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bcd9:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    bcdf:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bce5:	8b 00                	mov    (%eax),%eax
    bce7:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
			if ((p->pgrp != current->pgrp) &&
    bced:	39 c2                	cmp    %eax,%edx
    bcef:	75 68                	jne    bd59 <do_exit+0x3f5>
			    is_orphaned_pgrp(p->pgrp) &&
    bcf1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bcf5:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bcfb:	83 ec 0c             	sub    $0xc,%esp
    bcfe:	50                   	push   %eax
    bcff:	e8 3e fb ff ff       	call   b842 <is_orphaned_pgrp>
    bd04:	83 c4 10             	add    $0x10,%esp
			    (p->session == current->session) &&
    bd07:	85 c0                	test   %eax,%eax
    bd09:	74 4e                	je     bd59 <do_exit+0x3f5>
			    has_stopped_jobs(p->pgrp)) {
    bd0b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bd0f:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bd15:	83 ec 0c             	sub    $0xc,%esp
    bd18:	50                   	push   %eax
    bd19:	e8 e6 fb ff ff       	call   b904 <has_stopped_jobs>
    bd1e:	83 c4 10             	add    $0x10,%esp
			    is_orphaned_pgrp(p->pgrp) &&
    bd21:	85 c0                	test   %eax,%eax
    bd23:	74 34                	je     bd59 <do_exit+0x3f5>
				kill_pg(p->pgrp,SIGHUP,1);
    bd25:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bd29:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bd2f:	83 ec 04             	sub    $0x4,%esp
    bd32:	6a 01                	push   $0x1
    bd34:	6a 01                	push   $0x1
    bd36:	50                   	push   %eax
    bd37:	e8 f9 f8 ff ff       	call   b635 <kill_pg>
    bd3c:	83 c4 10             	add    $0x10,%esp
				kill_pg(p->pgrp,SIGCONT,1);
    bd3f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bd43:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bd49:	83 ec 04             	sub    $0x4,%esp
    bd4c:	6a 01                	push   $0x1
    bd4e:	6a 12                	push   $0x12
    bd50:	50                   	push   %eax
    bd51:	e8 df f8 ff ff       	call   b635 <kill_pg>
    bd56:	83 c4 10             	add    $0x10,%esp
			}
			if (p->p_osptr) {
    bd59:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bd5d:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    bd63:	85 c0                	test   %eax,%eax
    bd65:	74 13                	je     bd7a <do_exit+0x416>
				p = p->p_osptr;
    bd67:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bd6b:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    bd71:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			p->p_pptr = task[1];
    bd75:	e9 ff fe ff ff       	jmp    bc79 <do_exit+0x315>
             */
			// 通过上面处理，当前进程子进程的所有兄弟子进程都已经处理过。此时p指向最老的兄弟子进程。于是把这些兄弟子进程全部加入
			// init进程的子进程双向链表表头部中。加入后，init进程的p_cptr指向当前进程原子进程中最年轻的（the youngest）子进程
			// 而原子进程中最老的（the oldest）兄弟子进程p_osptr指向原init进程的最年轻进程，而原init进程中最年轻进程的p_ysptr
			// 指向原子进程中最老的兄弟子进程。最后把当前进程的p_cptr指针置空，并退出循环。
			p->p_osptr = task[1]->p_cptr;
    bd7a:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bd80:	8b 40 04             	mov    0x4(%eax),%eax
    bd83:	8b 90 c0 02 00 00    	mov    0x2c0(%eax),%edx
    bd89:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    bd8d:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%eax)
			task[1]->p_cptr->p_ysptr = p;
    bd93:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bd99:	8b 40 04             	mov    0x4(%eax),%eax
    bd9c:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    bda2:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    bda6:	89 90 c4 02 00 00    	mov    %edx,0x2c4(%eax)
			task[1]->p_cptr = current->p_cptr;
    bdac:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bdb2:	8b 10                	mov    (%eax),%edx
    bdb4:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bdba:	8b 40 04             	mov    0x4(%eax),%eax
    bdbd:	8b 92 c0 02 00 00    	mov    0x2c0(%edx),%edx
    bdc3:	89 90 c0 02 00 00    	mov    %edx,0x2c0(%eax)
			current->p_cptr = 0;
    bdc9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bdcf:	8b 00                	mov    (%eax),%eax
    bdd1:	c7 80 c0 02 00 00 00 	movl   $0x0,0x2c0(%eax)
    bdd8:	00 00 00 
			break;
    bddb:	90                   	nop
		}
	}
	// 如果当前进程是会话头领（leader）进程，那么若它有控制终端，则首先向使用该控制终端的进程组发送挂断信号SIGHUP，然后释放
	// 该终端。接着扫描任务数组，把属于当前进程会话中进程的终端置空（取消）。
	if (current->leader) {
    bddc:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bde2:	8b 00                	mov    (%eax),%eax
    bde4:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
    bdea:	85 c0                	test   %eax,%eax
    bdec:	0f 84 15 01 00 00    	je     bf07 <do_exit+0x5a3>
		struct task_struct **p;
		struct tty_struct *tty;

		if (current->tty >= 0) {
    bdf2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bdf8:	8b 00                	mov    (%eax),%eax
    bdfa:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
    be00:	85 c0                	test   %eax,%eax
    be02:	0f 88 ae 00 00 00    	js     beb6 <do_exit+0x552>
			tty = TTY_TABLE(current->tty);
    be08:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    be0e:	8b 00                	mov    (%eax),%eax
    be10:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
    be16:	85 c0                	test   %eax,%eax
    be18:	74 50                	je     be6a <do_exit+0x506>
    be1a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    be20:	8b 00                	mov    (%eax),%eax
    be22:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
    be28:	83 f8 3f             	cmp    $0x3f,%eax
    be2b:	7f 20                	jg     be4d <do_exit+0x4e9>
    be2d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    be33:	8b 00                	mov    (%eax),%eax
    be35:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
    be3b:	83 e8 01             	sub    $0x1,%eax
    be3e:	c1 e0 06             	shl    $0x6,%eax
    be41:	89 c2                	mov    %eax,%edx
    be43:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
    be49:	01 d0                	add    %edx,%eax
    be4b:	eb 32                	jmp    be7f <do_exit+0x51b>
    be4d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    be53:	8b 00                	mov    (%eax),%eax
    be55:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
    be5b:	c1 e0 06             	shl    $0x6,%eax
    be5e:	89 c2                	mov    %eax,%edx
    be60:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
    be66:	01 d0                	add    %edx,%eax
    be68:	eb 15                	jmp    be7f <do_exit+0x51b>
    be6a:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
    be70:	8b 00                	mov    (%eax),%eax
    be72:	c1 e0 06             	shl    $0x6,%eax
    be75:	89 c2                	mov    %eax,%edx
    be77:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
    be7d:	01 d0                	add    %edx,%eax
    be7f:	89 04 24             	mov    %eax,(%esp)
			if (tty->pgrp>0)
    be82:	8b 04 24             	mov    (%esp),%eax
    be85:	8b 40 24             	mov    0x24(%eax),%eax
    be88:	85 c0                	test   %eax,%eax
    be8a:	7e 16                	jle    bea2 <do_exit+0x53e>
				kill_pg(tty->pgrp, SIGHUP, 1);
    be8c:	8b 04 24             	mov    (%esp),%eax
    be8f:	8b 40 24             	mov    0x24(%eax),%eax
    be92:	83 ec 04             	sub    $0x4,%esp
    be95:	6a 01                	push   $0x1
    be97:	6a 01                	push   $0x1
    be99:	50                   	push   %eax
    be9a:	e8 96 f7 ff ff       	call   b635 <kill_pg>
    be9f:	83 c4 10             	add    $0x10,%esp
			tty->pgrp = 0;
    bea2:	8b 04 24             	mov    (%esp),%eax
    bea5:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
			tty->session = 0;
    beac:	8b 04 24             	mov    (%esp),%eax
    beaf:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
		}
	 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    beb6:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bebc:	8d 80 fc 00 00 00    	lea    0xfc(%eax),%eax
    bec2:	89 44 24 14          	mov    %eax,0x14(%esp)
    bec6:	eb 33                	jmp    befb <do_exit+0x597>
			if ((*p)->session == current->session)
    bec8:	8b 44 24 14          	mov    0x14(%esp),%eax
    becc:	8b 00                	mov    (%eax),%eax
    bece:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    bed4:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    beda:	8b 00                	mov    (%eax),%eax
    bedc:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    bee2:	39 c2                	cmp    %eax,%edx
    bee4:	75 10                	jne    bef6 <do_exit+0x592>
				(*p)->tty = -1;
    bee6:	8b 44 24 14          	mov    0x14(%esp),%eax
    beea:	8b 00                	mov    (%eax),%eax
    beec:	c7 80 2c 03 00 00 ff 	movl   $0xffffffff,0x32c(%eax)
    bef3:	ff ff ff 
	 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    bef6:	83 6c 24 14 04       	subl   $0x4,0x14(%esp)
    befb:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    bf01:	39 44 24 14          	cmp    %eax,0x14(%esp)
    bf05:	77 c1                	ja     bec8 <do_exit+0x564>
	}
	// 如果当前进程上次使用过协处理器，则把记录此信息的指针置空。若定义了调试进程树符号，则调用进程树检测显示函数。最后调用调度
	// 函数，重新调度进程运行，以让父进程能够处理僵死进程的其他善后事宜。
	if (last_task_used_math == current)
    bf07:	c7 c0 8c 3b 03 00    	mov    $0x33b8c,%eax
    bf0d:	8b 10                	mov    (%eax),%edx
    bf0f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bf15:	8b 00                	mov    (%eax),%eax
    bf17:	39 c2                	cmp    %eax,%edx
    bf19:	75 0c                	jne    bf27 <do_exit+0x5c3>
		last_task_used_math = NULL;
    bf1b:	c7 c0 8c 3b 03 00    	mov    $0x33b8c,%eax
    bf21:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#ifdef DEBUG_PROC_TREE
	audit_ptree();
    bf27:	e8 52 f0 ff ff       	call   af7e <audit_ptree>
#endif
	schedule();
    bf2c:	e8 1a b0 ff ff       	call   6f4b <schedule>
}
    bf31:	90                   	nop
    bf32:	83 c4 20             	add    $0x20,%esp
    bf35:	5b                   	pop    %ebx
    bf36:	5e                   	pop    %esi
    bf37:	5f                   	pop    %edi
    bf38:	c3                   	ret    

0000bf39 <sys_exit>:
// 系统调用exit()。终止进程。
// 参数error_code是用户程序提供的退出状态信息，只有低字节有效。把error_code左移8位是wait()或waitpid()函数的要求。
// 低字节中将用来保存wait()的状态信息。例如，如果进程处于暂停状态（TASK_STOPPED），那么其低字节就等于0x7f。参见
// sys/wait.h文件。wait()或waitpid()利用这些宏就可以取得子进程的退出状态码或子进程终止的原因（信号）。
int sys_exit(int error_code)
{
    bf39:	83 ec 0c             	sub    $0xc,%esp
    bf3c:	e8 b1 ad ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    bf41:	05 bf 60 02 00       	add    $0x260bf,%eax
	do_exit((error_code & 0xff) << 8);
    bf46:	8b 44 24 10          	mov    0x10(%esp),%eax
    bf4a:	c1 e0 08             	shl    $0x8,%eax
    bf4d:	0f b7 c0             	movzwl %ax,%eax
    bf50:	83 ec 0c             	sub    $0xc,%esp
    bf53:	50                   	push   %eax
    bf54:	e8 0b fa ff ff       	call   b964 <do_exit>
    bf59:	83 c4 10             	add    $0x10,%esp
}
    bf5c:	90                   	nop
    bf5d:	83 c4 0c             	add    $0xc,%esp
    bf60:	c3                   	ret    

0000bf61 <sys_waitpid>:
// 若options = WUNTRACED，表示如果子进程是停止的，也马上返回（无须跟踪）。
// 若options = WNOHANG，表示如果没有子进程退出或终止就马上返回。
// 如果返回状态指针stat_addr不为空，则就将状态信息保存到那里。
// 参数pid是进程号；*stat_addr是保存状态信息位置的指针；options是waitpid选项。
int sys_waitpid(pid_t pid, unsigned long * stat_addr, int options)
{
    bf61:	53                   	push   %ebx
    bf62:	83 ec 18             	sub    $0x18,%esp
    bf65:	e8 90 ad ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    bf6a:	81 c3 96 60 02 00    	add    $0x26096,%ebx
	int flag;               				// 该标志用于后面所选出的子进程处于就绪或睡眠态。
	struct task_struct *p;
	unsigned long oldblocked;

	// 首先验证将在存放状态信息的位置处内在空间足够。然后复位标志flag。接着从当前进程的最年轻子进程开始扫描子进程兄弟链表。
	verify_area(stat_addr, 4);
    bf70:	83 ec 08             	sub    $0x8,%esp
    bf73:	6a 04                	push   $0x4
    bf75:	ff 74 24 30          	pushl  0x30(%esp)
    bf79:	e8 7d c9 ff ff       	call   88fb <verify_area>
    bf7e:	83 c4 10             	add    $0x10,%esp
repeat:
	flag = 0;
    bf81:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    bf88:	00 
	for (p = current->p_cptr ; p ; p = p->p_osptr) {
    bf89:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bf8f:	8b 00                	mov    (%eax),%eax
    bf91:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    bf97:	89 44 24 08          	mov    %eax,0x8(%esp)
    bf9b:	e9 bf 01 00 00       	jmp    c15f <sys_waitpid+0x1fe>
		// 如果等待的子进程号pid>0，但与被扫描子进程p的pid不相等，说明它是当前进程另外的子进程，于是跳过该进程，接着扫描下一
		// 个进程。
		if (pid > 0) {
    bfa0:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    bfa5:	7e 15                	jle    bfbc <sys_waitpid+0x5b>
			if (p->pid != pid)
    bfa7:	8b 44 24 08          	mov    0x8(%esp),%eax
    bfab:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    bfb1:	39 44 24 20          	cmp    %eax,0x20(%esp)
    bfb5:	74 4c                	je     c003 <sys_waitpid+0xa2>
				continue;
    bfb7:	e9 95 01 00 00       	jmp    c151 <sys_waitpid+0x1f0>
		// 否则，如果指定等待进程的pid=0，表示正在等待进程组号等于当前进程组号的任何子进程。如果此时被扫描进程p的进程组号与当前
		// 进程的组号不等，则跳过。
		} else if (!pid) {
    bfbc:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    bfc1:	75 21                	jne    bfe4 <sys_waitpid+0x83>
			if (p->pgrp != current->pgrp)
    bfc3:	8b 44 24 08          	mov    0x8(%esp),%eax
    bfc7:	8b 90 30 02 00 00    	mov    0x230(%eax),%edx
    bfcd:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    bfd3:	8b 00                	mov    (%eax),%eax
    bfd5:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bfdb:	39 c2                	cmp    %eax,%edx
    bfdd:	74 24                	je     c003 <sys_waitpid+0xa2>
				continue;
    bfdf:	e9 6d 01 00 00       	jmp    c151 <sys_waitpid+0x1f0>
		// 否则，如果指定的pid<-1，表示正在等待进程组号等于pid绝对值的任何子进程。如果此时被扫描进程p的组号与pid的绝对值
		// 不等，则跳过。
		} else if (pid != -1) {
    bfe4:	83 7c 24 20 ff       	cmpl   $0xffffffff,0x20(%esp)
    bfe9:	74 18                	je     c003 <sys_waitpid+0xa2>
			if (p->pgrp != -pid)
    bfeb:	8b 44 24 08          	mov    0x8(%esp),%eax
    bfef:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    bff5:	8b 54 24 20          	mov    0x20(%esp),%edx
    bff9:	f7 da                	neg    %edx
    bffb:	39 d0                	cmp    %edx,%eax
    bffd:	0f 85 4a 01 00 00    	jne    c14d <sys_waitpid+0x1ec>
		// pid等于-1）。接下来根据这个子进程p所处的状态来处理。
		// 当子进程p停止状态时，如果此时参数选项options中WUNTRACED标志没有置位，表示程序无须立刻返回，或者子进程此时的退出码等于
		// 0，于是继续扫描处理其他子进程。如果WUNTRACED置位且子进程退出码不为0,则把退出码移入高字节，同状态信息0x7f进行或运算后
		// 放入*stat_addr，在复位子进程退出码后立刻返回子进程号pid。这里0x7f表示的返回状态使WIFSTOPPED()宏为值。参见include/
		// sys/wait.h。
		switch (p->state) {
    c003:	8b 44 24 08          	mov    0x8(%esp),%eax
    c007:	8b 00                	mov    (%eax),%eax
    c009:	83 f8 03             	cmp    $0x3,%eax
    c00c:	74 67                	je     c075 <sys_waitpid+0x114>
    c00e:	83 f8 04             	cmp    $0x4,%eax
    c011:	0f 85 2c 01 00 00    	jne    c143 <sys_waitpid+0x1e2>
			case TASK_STOPPED:
				if (!(options & WUNTRACED) ||
    c017:	8b 44 24 28          	mov    0x28(%esp),%eax
    c01b:	83 e0 02             	and    $0x2,%eax
    c01e:	85 c0                	test   %eax,%eax
    c020:	0f 84 2a 01 00 00    	je     c150 <sys_waitpid+0x1ef>
				    !p->exit_code)
    c026:	8b 44 24 08          	mov    0x8(%esp),%eax
    c02a:	8b 80 14 02 00 00    	mov    0x214(%eax),%eax
				if (!(options & WUNTRACED) ||
    c030:	85 c0                	test   %eax,%eax
    c032:	0f 84 18 01 00 00    	je     c150 <sys_waitpid+0x1ef>
					continue;
				put_fs_long((p->exit_code << 8) | 0x7f,
    c038:	8b 44 24 08          	mov    0x8(%esp),%eax
    c03c:	8b 80 14 02 00 00    	mov    0x214(%eax),%eax
    c042:	c1 e0 08             	shl    $0x8,%eax
    c045:	83 c8 7f             	or     $0x7f,%eax
    c048:	83 ec 08             	sub    $0x8,%esp
    c04b:	ff 74 24 2c          	pushl  0x2c(%esp)
    c04f:	50                   	push   %eax
    c050:	e8 9d ed ff ff       	call   adf2 <put_fs_long>
    c055:	83 c4 10             	add    $0x10,%esp
					stat_addr);
				p->exit_code = 0;
    c058:	8b 44 24 08          	mov    0x8(%esp),%eax
    c05c:	c7 80 14 02 00 00 00 	movl   $0x0,0x214(%eax)
    c063:	00 00 00 
				return p->pid;
    c066:	8b 44 24 08          	mov    0x8(%esp),%eax
    c06a:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    c070:	e9 a4 01 00 00       	jmp    c219 <sys_waitpid+0x2b8>
			// 如果子进程p处于僵死状态，则首先把它在用户态和内核态运行的时间分别累计到当前进程（父进程）中，然后取出子进程pid和退出码，
			// 把退出码放入返回状态位置stat_addr处并释放该子进程。最后返回子进程的退出码和pid。若定义了调试进程树符号，则调用进程树
			// 检测显示函数。
			case TASK_ZOMBIE:
				current->cutime += p->utime;
    c075:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c07b:	8b 00                	mov    (%eax),%eax
    c07d:	8b 88 e8 02 00 00    	mov    0x2e8(%eax),%ecx
    c083:	8b 44 24 08          	mov    0x8(%esp),%eax
    c087:	8b 90 e0 02 00 00    	mov    0x2e0(%eax),%edx
    c08d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c093:	8b 00                	mov    (%eax),%eax
    c095:	01 ca                	add    %ecx,%edx
    c097:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%eax)
				current->cstime += p->stime;
    c09d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c0a3:	8b 00                	mov    (%eax),%eax
    c0a5:	8b 88 ec 02 00 00    	mov    0x2ec(%eax),%ecx
    c0ab:	8b 44 24 08          	mov    0x8(%esp),%eax
    c0af:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    c0b5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c0bb:	8b 00                	mov    (%eax),%eax
    c0bd:	01 ca                	add    %ecx,%edx
    c0bf:	89 90 ec 02 00 00    	mov    %edx,0x2ec(%eax)
				flag = p->pid;
    c0c5:	8b 44 24 08          	mov    0x8(%esp),%eax
    c0c9:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    c0cf:	89 44 24 0c          	mov    %eax,0xc(%esp)
				Log(LOG_INFO_TYPE, "<<<<< sys_waitpid current_pid = %d, child_pid = %d, exit_code = %d >>>>>\n", current->pid, p->pid, p->exit_code);
    c0d3:	8b 44 24 08          	mov    0x8(%esp),%eax
    c0d7:	8b 88 14 02 00 00    	mov    0x214(%eax),%ecx
    c0dd:	8b 44 24 08          	mov    0x8(%esp),%eax
    c0e1:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    c0e7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c0ed:	8b 00                	mov    (%eax),%eax
    c0ef:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    c0f5:	83 ec 0c             	sub    $0xc,%esp
    c0f8:	51                   	push   %ecx
    c0f9:	52                   	push   %edx
    c0fa:	50                   	push   %eax
    c0fb:	8d 83 68 49 ff ff    	lea    -0xb698(%ebx),%eax
    c101:	50                   	push   %eax
    c102:	6a 00                	push   $0x0
    c104:	e8 96 9a 01 00       	call   25b9f <Log>
    c109:	83 c4 20             	add    $0x20,%esp
				put_fs_long(p->exit_code, stat_addr);
    c10c:	8b 44 24 08          	mov    0x8(%esp),%eax
    c110:	8b 80 14 02 00 00    	mov    0x214(%eax),%eax
    c116:	83 ec 08             	sub    $0x8,%esp
    c119:	ff 74 24 2c          	pushl  0x2c(%esp)
    c11d:	50                   	push   %eax
    c11e:	e8 cf ec ff ff       	call   adf2 <put_fs_long>
    c123:	83 c4 10             	add    $0x10,%esp
				release(p);
    c126:	83 ec 0c             	sub    $0xc,%esp
    c129:	ff 74 24 14          	pushl  0x14(%esp)
    c12d:	e8 d7 ec ff ff       	call   ae09 <release>
    c132:	83 c4 10             	add    $0x10,%esp
#ifdef DEBUG_PROC_TREE
				audit_ptree();
    c135:	e8 44 ee ff ff       	call   af7e <audit_ptree>
#endif
				return flag;
    c13a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c13e:	e9 d6 00 00 00       	jmp    c219 <sys_waitpid+0x2b8>
			// 如果这个子进程p的状态即是不停止也不是僵死，那么就置flag = 1。表示找到过一个符合要求的子进程，但是它处于运行态或睡眠态。
			default:
				flag = 1;
    c143:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    c14a:	00 
				continue;
    c14b:	eb 04                	jmp    c151 <sys_waitpid+0x1f0>
				continue;
    c14d:	90                   	nop
    c14e:	eb 01                	jmp    c151 <sys_waitpid+0x1f0>
					continue;
    c150:	90                   	nop
	for (p = current->p_cptr ; p ; p = p->p_osptr) {
    c151:	8b 44 24 08          	mov    0x8(%esp),%eax
    c155:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    c15b:	89 44 24 08          	mov    %eax,0x8(%esp)
    c15f:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    c164:	0f 85 36 fe ff ff    	jne    bfa0 <sys_waitpid+0x3f>
    }
	// 在上面对任务数组扫描结束后，如果flag被置位，说明了有符合等待要求的子进程并没有处于退出立刻或僵死状态。此时如果已设置
	// WNOHANG选项（表示若没有子进程处于退出或终止态就返回），就立刻返回0,退出。否则把当前进程置为可中断等待状态，保留并修改当前
	// 进程信号阻塞位图，允许其接收SIGCHLD信号。然后执行调度程序。当系统又开始执行本进程时，如果本进程收到除SIGCHLD以外的
	// 其他未屏蔽信号，则以退出码“重新启动系统调用”返回。否则跳转到函数开始处repeat标号处重重复处理。
	if (flag) {
    c16a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    c16f:	0f 84 9f 00 00 00    	je     c214 <sys_waitpid+0x2b3>
		if (options & WNOHANG)
    c175:	8b 44 24 28          	mov    0x28(%esp),%eax
    c179:	83 e0 01             	and    $0x1,%eax
    c17c:	85 c0                	test   %eax,%eax
    c17e:	74 0a                	je     c18a <sys_waitpid+0x229>
			return 0;
    c180:	b8 00 00 00 00       	mov    $0x0,%eax
    c185:	e9 8f 00 00 00       	jmp    c219 <sys_waitpid+0x2b8>
		current->state = TASK_INTERRUPTIBLE;
    c18a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c190:	8b 00                	mov    (%eax),%eax
    c192:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		oldblocked = current->blocked;
    c198:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c19e:	8b 00                	mov    (%eax),%eax
    c1a0:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
    c1a6:	89 44 24 04          	mov    %eax,0x4(%esp)
		current->blocked &= ~(1 << (SIGCHLD - 1));
    c1aa:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c1b0:	8b 00                	mov    (%eax),%eax
    c1b2:	8b 90 10 02 00 00    	mov    0x210(%eax),%edx
    c1b8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c1be:	8b 00                	mov    (%eax),%eax
    c1c0:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
    c1c6:	89 90 10 02 00 00    	mov    %edx,0x210(%eax)
		schedule();
    c1cc:	e8 7a ad ff ff       	call   6f4b <schedule>
		current->blocked = oldblocked;
    c1d1:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c1d7:	8b 00                	mov    (%eax),%eax
    c1d9:	8b 54 24 04          	mov    0x4(%esp),%edx
    c1dd:	89 90 10 02 00 00    	mov    %edx,0x210(%eax)
		if (current->signal & ~(current->blocked | (1 << (SIGCHLD - 1))))
    c1e3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c1e9:	8b 00                	mov    (%eax),%eax
    c1eb:	8b 50 0c             	mov    0xc(%eax),%edx
    c1ee:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c1f4:	8b 00                	mov    (%eax),%eax
    c1f6:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
    c1fc:	0d 00 00 01 00       	or     $0x10000,%eax
    c201:	f7 d0                	not    %eax
    c203:	21 d0                	and    %edx,%eax
    c205:	85 c0                	test   %eax,%eax
    c207:	0f 84 74 fd ff ff    	je     bf81 <sys_waitpid+0x20>
			return -ERESTARTSYS;
    c20d:	b8 00 fe ff ff       	mov    $0xfffffe00,%eax
    c212:	eb 05                	jmp    c219 <sys_waitpid+0x2b8>
		else
			goto repeat;
	}
	// 若flag = 0，表示没有找到符合要求的子进程，则返回出错码（子进程不存在）。
	return -ECHILD;
    c214:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
    c219:	83 c4 18             	add    $0x18,%esp
    c21c:	5b                   	pop    %ebx
    c21d:	c3                   	ret    

0000c21e <get_fs_byte>:
{
    c21e:	53                   	push   %ebx
    c21f:	e8 ce aa ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c224:	05 dc 5d 02 00       	add    $0x25ddc,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    c229:	8b 44 24 08          	mov    0x8(%esp),%eax
    c22d:	64 8a 00             	mov    %fs:(%eax),%al
    c230:	89 c3                	mov    %eax,%ebx
	return _v;
    c232:	89 d8                	mov    %ebx,%eax
}
    c234:	5b                   	pop    %ebx
    c235:	c3                   	ret    

0000c236 <put_fs_byte>:
{
    c236:	83 ec 04             	sub    $0x4,%esp
    c239:	e8 b4 aa ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c23e:	05 c2 5d 02 00       	add    $0x25dc2,%eax
    c243:	8b 44 24 08          	mov    0x8(%esp),%eax
    c247:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    c24a:	0f b6 04 24          	movzbl (%esp),%eax
    c24e:	8b 54 24 0c          	mov    0xc(%esp),%edx
    c252:	64 88 02             	mov    %al,%fs:(%edx)
}
    c255:	90                   	nop
    c256:	83 c4 04             	add    $0x4,%esp
    c259:	c3                   	ret    

0000c25a <put_fs_long>:
{
    c25a:	e8 93 aa ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c25f:	05 a1 5d 02 00       	add    $0x25da1,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    c264:	8b 44 24 04          	mov    0x4(%esp),%eax
    c268:	8b 54 24 08          	mov    0x8(%esp),%edx
    c26c:	64 89 02             	mov    %eax,%fs:(%edx)
}
    c26f:	90                   	nop
    c270:	c3                   	ret    

0000c271 <sys_sgetmask>:
#include <signal.h>
#include <errno.h>

// 获取当前任务信号屏蔽位图（屏蔽码或阻塞码）。sgetmask可分解为signal-get-mask。以下类似。
int sys_sgetmask()
{
    c271:	e8 7c aa ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c276:	05 8a 5d 02 00       	add    $0x25d8a,%eax
	return current->blocked;
    c27b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c281:	8b 00                	mov    (%eax),%eax
    c283:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
}
    c289:	c3                   	ret    

0000c28a <sys_ssetmask>:

// 设置新的信号屏蔽位图。信号SIGKILL和SIGSTOP不能被屏蔽。返回值是原信号屏蔽位图。
int sys_ssetmask(int newmask)
{
    c28a:	83 ec 10             	sub    $0x10,%esp
    c28d:	e8 60 aa ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c292:	05 6e 5d 02 00       	add    $0x25d6e,%eax
	int old = current->blocked;
    c297:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    c29d:	8b 12                	mov    (%edx),%edx
    c29f:	8b 92 10 02 00 00    	mov    0x210(%edx),%edx
    c2a5:	89 54 24 0c          	mov    %edx,0xc(%esp)

	current->blocked = newmask & ~(1 << (SIGKILL - 1)) & ~(1 << (SIGSTOP - 1));
    c2a9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c2af:	8b 00                	mov    (%eax),%eax
    c2b1:	8b 54 24 14          	mov    0x14(%esp),%edx
    c2b5:	81 e2 ff fe fb ff    	and    $0xfffbfeff,%edx
    c2bb:	89 90 10 02 00 00    	mov    %edx,0x210(%eax)
	return old;
    c2c1:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    c2c5:	83 c4 10             	add    $0x10,%esp
    c2c8:	c3                   	ret    

0000c2c9 <sys_sigpending>:

// 检测并取得进程收到的但被屏蔽（阻塞）的信号。还未处理信号的位图将被放入set中。
int sys_sigpending(sigset_t *set)
{
    c2c9:	53                   	push   %ebx
    c2ca:	83 ec 08             	sub    $0x8,%esp
    c2cd:	e8 28 aa ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    c2d2:	81 c3 2e 5d 02 00    	add    $0x25d2e,%ebx
    /* fill in "set" with signals pending but blocked. */
    /* 用还未处理并且被阻塞信号的位图填入set指针所指位置处 */
	// 首先验证进程提供的用户存储空间就有4个字节。然后把还未处理并且被阻塞信号的位图填入set指针所指位置处。
    verify_area(set, 4);
    c2d8:	83 ec 08             	sub    $0x8,%esp
    c2db:	6a 04                	push   $0x4
    c2dd:	ff 74 24 1c          	pushl  0x1c(%esp)
    c2e1:	e8 15 c6 ff ff       	call   88fb <verify_area>
    c2e6:	83 c4 10             	add    $0x10,%esp
    put_fs_long(current->blocked & current->signal, (unsigned long *)set);
    c2e9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c2ef:	8b 00                	mov    (%eax),%eax
    c2f1:	8b 90 10 02 00 00    	mov    0x210(%eax),%edx
    c2f7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c2fd:	8b 00                	mov    (%eax),%eax
    c2ff:	8b 40 0c             	mov    0xc(%eax),%eax
    c302:	21 d0                	and    %edx,%eax
    c304:	83 ec 08             	sub    $0x8,%esp
    c307:	ff 74 24 18          	pushl  0x18(%esp)
    c30b:	50                   	push   %eax
    c30c:	e8 49 ff ff ff       	call   c25a <put_fs_long>
    c311:	83 c4 10             	add    $0x10,%esp
    return 0;
    c314:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c319:	83 c4 08             	add    $0x8,%esp
    c31c:	5b                   	pop    %ebx
    c31d:	c3                   	ret    

0000c31e <sys_sigsuspend>:
// 该系统调用临时把进程信号屏蔽码替换成参数中给定的set，然后挂起进程，直到收到一个信号为止。
// restart是一个被中断的系统调用重新启动标志。当第1次调用该系统调用时，这是0.并且在该函数中会把进程原来的阻塞码
// blocked保存起来（old_mask），并设置restart为非0值。因此当进程第2次调用该系统调用时，它就会恢复进程原来保存在
// old_mask中的阻塞码。
int sys_sigsuspend(int restart, unsigned long old_mask, unsigned long set)
{
    c31e:	53                   	push   %ebx
    c31f:	83 ec 08             	sub    $0x8,%esp
    c322:	e8 cf a9 ff ff       	call   6cf6 <__x86.get_pc_thunk.dx>
    c327:	81 c2 d9 5c 02 00    	add    $0x25cd9,%edx
	// 相应的信号捕获函数。
    extern int sys_pause(void);

	// 如果restart标志不为0,表示重新让程序运行起来。于是恢复前面保存在old_mask中的原进程阻塞码。并返回码-EINTR（系统
	// 调用被信号中断）。
    if (restart) {
    c32d:	8b 44 24 10          	mov    0x10(%esp),%eax
    c331:	85 c0                	test   %eax,%eax
    c333:	74 1b                	je     c350 <sys_sigsuspend+0x32>
			/* we're restarting */  /* 我们正在重新启动系统调用 */
			current->blocked = old_mask;
    c335:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    c339:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c33f:	8b 00                	mov    (%eax),%eax
    c341:	89 ca                	mov    %ecx,%edx
    c343:	89 90 10 02 00 00    	mov    %edx,0x210(%eax)
			return -EINTR;
    c349:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    c34e:	eb 38                	jmp    c388 <sys_sigsuspend+0x6a>
	// 进程会去执行信号处理函数，然后本调用返回-ERESTARTNOINTR码退出。这个返回码说明在处理完信号后要求返回到本系统调用中继续
	// 运行，即本系统调用不会被中断。
    /* we're not restarting.  do the work */
    /* 我们不是重新运行，那么就干活吧 */
    //*(&restart) = 1;
	__asm__("movl $1, %0\n\t" \
    c350:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
    c357:	00 
			: \
			:"m"(restart));
    //*(&old_mask) = current->blocked;
	__asm__("movl %%eax, %0\n\t" \
			: \
			:"m"(old_mask), "a"(current->blocked));
    c358:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c35e:	8b 00                	mov    (%eax),%eax
    c360:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
	__asm__("movl %%eax, %0\n\t" \
    c366:	89 44 24 14          	mov    %eax,0x14(%esp)
    current->blocked = set;
    c36a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c370:	8b 00                	mov    (%eax),%eax
    c372:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    c376:	89 88 10 02 00 00    	mov    %ecx,0x210(%eax)
    (void) sys_pause();			/* return after a signal arrives */
    c37c:	89 d3                	mov    %edx,%ebx
    c37e:	e8 e4 ad ff ff       	call   7167 <sys_pause>
    return -ERESTARTNOINTR;		/* handle the signal, and come back */
    c383:	b8 ff fd ff ff       	mov    $0xfffffdff,%eax
}
    c388:	83 c4 08             	add    $0x8,%esp
    c38b:	5b                   	pop    %ebx
    c38c:	c3                   	ret    

0000c38d <save_old>:

// 复制sigaction数据到fs数据段to处。即从内核空间复制到用户（任务）数据段中。
static inline void save_old(char * from, char * to)
{
    c38d:	53                   	push   %ebx
    c38e:	83 ec 18             	sub    $0x18,%esp
    c391:	e8 5c a9 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c396:	05 6a 5c 02 00       	add    $0x25c6a,%eax
	int i;

	// 首先验证to处的内存空间是否足够大。然后把一个sigaction结构信息复制到fs段（用户）空间中。宏函数put_fs_byte()在
	// include/asm/segment.h中实现。
	verify_area(to, sizeof(struct sigaction));
    c39b:	83 ec 08             	sub    $0x8,%esp
    c39e:	6a 10                	push   $0x10
    c3a0:	ff 74 24 30          	pushl  0x30(%esp)
    c3a4:	89 c3                	mov    %eax,%ebx
    c3a6:	e8 50 c5 ff ff       	call   88fb <verify_area>
    c3ab:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < sizeof(struct sigaction) ; i++) {
    c3ae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c3b5:	00 
    c3b6:	eb 29                	jmp    c3e1 <save_old+0x54>
		put_fs_byte(*from, to);
    c3b8:	8b 44 24 20          	mov    0x20(%esp),%eax
    c3bc:	0f b6 00             	movzbl (%eax),%eax
    c3bf:	0f be c0             	movsbl %al,%eax
    c3c2:	83 ec 08             	sub    $0x8,%esp
    c3c5:	ff 74 24 2c          	pushl  0x2c(%esp)
    c3c9:	50                   	push   %eax
    c3ca:	e8 67 fe ff ff       	call   c236 <put_fs_byte>
    c3cf:	83 c4 10             	add    $0x10,%esp
		from++;
    c3d2:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
		to++;
    c3d7:	83 44 24 24 01       	addl   $0x1,0x24(%esp)
	for (i = 0 ; i < sizeof(struct sigaction) ; i++) {
    c3dc:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    c3e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3e5:	83 f8 0f             	cmp    $0xf,%eax
    c3e8:	76 ce                	jbe    c3b8 <save_old+0x2b>
	}
}
    c3ea:	90                   	nop
    c3eb:	83 c4 18             	add    $0x18,%esp
    c3ee:	5b                   	pop    %ebx
    c3ef:	c3                   	ret    

0000c3f0 <get_new>:

// 把sigaction数据从fs数据段from位置复制到to处。即从用户数据空间取到内核数据段中。
static inline void get_new(char * from, char * to)
{
    c3f0:	83 ec 10             	sub    $0x10,%esp
    c3f3:	e8 fa a8 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c3f8:	05 08 5c 02 00       	add    $0x25c08,%eax
	int i;

	for (i = 0 ; i < sizeof(struct sigaction) ; i++)
    c3fd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c404:	00 
    c405:	eb 2a                	jmp    c431 <get_new+0x41>
		*(to++) = get_fs_byte(from++);
    c407:	8b 44 24 14          	mov    0x14(%esp),%eax
    c40b:	8d 50 01             	lea    0x1(%eax),%edx
    c40e:	89 54 24 14          	mov    %edx,0x14(%esp)
    c412:	50                   	push   %eax
    c413:	e8 06 fe ff ff       	call   c21e <get_fs_byte>
    c418:	83 c4 04             	add    $0x4,%esp
    c41b:	89 c1                	mov    %eax,%ecx
    c41d:	8b 44 24 18          	mov    0x18(%esp),%eax
    c421:	8d 50 01             	lea    0x1(%eax),%edx
    c424:	89 54 24 18          	mov    %edx,0x18(%esp)
    c428:	89 ca                	mov    %ecx,%edx
    c42a:	88 10                	mov    %dl,(%eax)
	for (i = 0 ; i < sizeof(struct sigaction) ; i++)
    c42c:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    c431:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c435:	83 f8 0f             	cmp    $0xf,%eax
    c438:	76 cd                	jbe    c407 <get_new+0x17>
}
    c43a:	90                   	nop
    c43b:	83 c4 10             	add    $0x10,%esp
    c43e:	c3                   	ret    

0000c43f <sys_signal>:
// 信号句柄可以是用户指定的函数，也可以是SIG_DFL（默认句柄）或SIG_IGN（忽略）。
// 参数signum -- 指定的信号； handler -- 指定的句柄； restorer -- 恢复函数指针，该函数由Libc库提供。用于在信号
// 处理程序结束后恢复系统调用返回时几个寄存器的原有值以及系统调用的返回值，就好像系统调用没有执行过信号处理程序而直接
// 返回到用户程序一样。函数返回原信号句柄。
int sys_signal(int signum, long handler, long restorer)
{
    c43f:	83 ec 10             	sub    $0x10,%esp
    c442:	e8 ab a8 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c447:	05 b9 5b 02 00       	add    $0x25bb9,%eax
	struct sigaction tmp;

	// 首先验证信号值在有效范围（1--32）内，并且不得是信号SIGKILL和SIGSTOP。因为这两个信号不能被进程捕获。
	if (signum < 1 || signum > 32 || signum == SIGKILL || signum == SIGSTOP)
    c44c:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    c451:	7e 15                	jle    c468 <sys_signal+0x29>
    c453:	83 7c 24 14 20       	cmpl   $0x20,0x14(%esp)
    c458:	7f 0e                	jg     c468 <sys_signal+0x29>
    c45a:	83 7c 24 14 09       	cmpl   $0x9,0x14(%esp)
    c45f:	74 07                	je     c468 <sys_signal+0x29>
    c461:	83 7c 24 14 13       	cmpl   $0x13,0x14(%esp)
    c466:	75 07                	jne    c46f <sys_signal+0x30>
		return -EINVAL;
    c468:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    c46d:	eb 71                	jmp    c4e0 <sys_signal+0xa1>
	// 然后根据提供的参数组建sigaction结构内容。sa_handler是指定的信号处理句柄（函数）。sa_mask是执行信号处理句柄时的
	// 信号屏蔽码。sa_flags是执行时的一些标志组合。这里设定该信号处理句柄只使用1次后就恢复到默认值，并允许信号在自己的处理
	// 句柄中收到。
	tmp.sa_handler = (void (*)(int)) handler;
    c46f:	8b 54 24 18          	mov    0x18(%esp),%edx
    c473:	89 14 24             	mov    %edx,(%esp)
	tmp.sa_mask = 0;
    c476:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    c47d:	00 
	tmp.sa_flags = SA_ONESHOT | SA_NOMASK;
    c47e:	c7 44 24 08 00 00 00 	movl   $0xc0000000,0x8(%esp)
    c485:	c0 
	tmp.sa_restorer = (void (*)(void)) restorer;    				// 保存恢复处理函数指针。
    c486:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    c48a:	89 54 24 0c          	mov    %edx,0xc(%esp)
	// 接着取该信号原来的处理句柄，并设置该信号的sigaction结构。最后返回原信号句柄。
	handler = (long) current->sigaction[signum - 1].sa_handler;
    c48e:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    c494:	8b 12                	mov    (%edx),%edx
    c496:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    c49a:	83 e9 01             	sub    $0x1,%ecx
    c49d:	83 c1 01             	add    $0x1,%ecx
    c4a0:	c1 e1 04             	shl    $0x4,%ecx
    c4a3:	01 ca                	add    %ecx,%edx
    c4a5:	8b 12                	mov    (%edx),%edx
    c4a7:	89 54 24 18          	mov    %edx,0x18(%esp)
	current->sigaction[signum - 1] = tmp;
    c4ab:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c4b1:	8b 00                	mov    (%eax),%eax
    c4b3:	8b 54 24 14          	mov    0x14(%esp),%edx
    c4b7:	83 ea 01             	sub    $0x1,%edx
    c4ba:	83 c2 01             	add    $0x1,%edx
    c4bd:	c1 e2 04             	shl    $0x4,%edx
    c4c0:	01 d0                	add    %edx,%eax
    c4c2:	8b 14 24             	mov    (%esp),%edx
    c4c5:	89 10                	mov    %edx,(%eax)
    c4c7:	8b 54 24 04          	mov    0x4(%esp),%edx
    c4cb:	89 50 04             	mov    %edx,0x4(%eax)
    c4ce:	8b 54 24 08          	mov    0x8(%esp),%edx
    c4d2:	89 50 08             	mov    %edx,0x8(%eax)
    c4d5:	8b 54 24 0c          	mov    0xc(%esp),%edx
    c4d9:	89 50 0c             	mov    %edx,0xc(%eax)
	return handler;
    c4dc:	8b 44 24 18          	mov    0x18(%esp),%eax
}
    c4e0:	83 c4 10             	add    $0x10,%esp
    c4e3:	c3                   	ret    

0000c4e4 <sys_sigaction>:

// sigaction()系统调用。改变进程在收到一个信号时的操作。signum是除了SIGKILL以外的任何信号。[如果新操作（action）不为空]
// 则新操作被安装。如果oldaction指针不为空，则原操作被保留到oldaction。成功则返回0,否则为-EINVAL。
int sys_sigaction(int signum, const struct sigaction * action,
	struct sigaction * oldaction)
{
    c4e4:	56                   	push   %esi
    c4e5:	53                   	push   %ebx
    c4e6:	83 ec 14             	sub    $0x14,%esp
    c4e9:	e8 0c a8 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    c4ee:	81 c3 12 5b 02 00    	add    $0x25b12,%ebx
	struct sigaction tmp;

	// 首先验证信号值在有效范围（1--32）内，并且不得是信号SIGKILL和SIGSTOP。因为这两个信号不能被进程捕获。
	if (signum < 1 || signum > 32 || signum == SIGKILL || signum == SIGSTOP)
    c4f4:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    c4f9:	7e 15                	jle    c510 <sys_sigaction+0x2c>
    c4fb:	83 7c 24 20 20       	cmpl   $0x20,0x20(%esp)
    c500:	7f 0e                	jg     c510 <sys_sigaction+0x2c>
    c502:	83 7c 24 20 09       	cmpl   $0x9,0x20(%esp)
    c507:	74 07                	je     c510 <sys_sigaction+0x2c>
    c509:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    c50e:	75 0a                	jne    c51a <sys_sigaction+0x36>
		return -EINVAL;
    c510:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    c515:	e9 0c 01 00 00       	jmp    c626 <sys_sigaction+0x142>
	// 在信号的sigaction结构中设置新的操作（动作）。如果oldaction指针不为空的话，则将原操作指针保存到oldaction所指的位置。
	tmp = current->sigaction[signum - 1];
    c51a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c520:	8b 00                	mov    (%eax),%eax
    c522:	8b 54 24 20          	mov    0x20(%esp),%edx
    c526:	83 ea 01             	sub    $0x1,%edx
    c529:	83 c2 01             	add    $0x1,%edx
    c52c:	c1 e2 04             	shl    $0x4,%edx
    c52f:	01 d0                	add    %edx,%eax
    c531:	8b 10                	mov    (%eax),%edx
    c533:	89 14 24             	mov    %edx,(%esp)
    c536:	8b 50 04             	mov    0x4(%eax),%edx
    c539:	89 54 24 04          	mov    %edx,0x4(%esp)
    c53d:	8b 50 08             	mov    0x8(%eax),%edx
    c540:	89 54 24 08          	mov    %edx,0x8(%esp)
    c544:	8b 40 0c             	mov    0xc(%eax),%eax
    c547:	89 44 24 0c          	mov    %eax,0xc(%esp)
	get_new((char *) action,
		(char *) (signum - 1 + current->sigaction));
    c54b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c551:	8b 00                	mov    (%eax),%eax
    c553:	8d 50 10             	lea    0x10(%eax),%edx
    c556:	8b 44 24 20          	mov    0x20(%esp),%eax
	get_new((char *) action,
    c55a:	05 ff ff ff 0f       	add    $0xfffffff,%eax
    c55f:	c1 e0 04             	shl    $0x4,%eax
    c562:	01 d0                	add    %edx,%eax
    c564:	50                   	push   %eax
    c565:	ff 74 24 28          	pushl  0x28(%esp)
    c569:	e8 82 fe ff ff       	call   c3f0 <get_new>
    c56e:	83 c4 08             	add    $0x8,%esp
	if (oldaction)
    c571:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    c576:	74 14                	je     c58c <sys_sigaction+0xa8>
		save_old((char *) &tmp,(char *) oldaction);
    c578:	83 ec 08             	sub    $0x8,%esp
    c57b:	ff 74 24 30          	pushl  0x30(%esp)
    c57f:	8d 44 24 0c          	lea    0xc(%esp),%eax
    c583:	50                   	push   %eax
    c584:	e8 04 fe ff ff       	call   c38d <save_old>
    c589:	83 c4 10             	add    $0x10,%esp
	// 如果允许信号在自己的信号句柄中收到，则令屏蔽码为0,否则设置屏蔽本信号。
	if (current->sigaction[signum - 1].sa_flags & SA_NOMASK)
    c58c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c592:	8b 00                	mov    (%eax),%eax
    c594:	8b 54 24 20          	mov    0x20(%esp),%edx
    c598:	83 ea 01             	sub    $0x1,%edx
    c59b:	83 c2 01             	add    $0x1,%edx
    c59e:	c1 e2 04             	shl    $0x4,%edx
    c5a1:	01 d0                	add    %edx,%eax
    c5a3:	83 c0 08             	add    $0x8,%eax
    c5a6:	8b 00                	mov    (%eax),%eax
    c5a8:	25 00 00 00 40       	and    $0x40000000,%eax
    c5ad:	85 c0                	test   %eax,%eax
    c5af:	74 22                	je     c5d3 <sys_sigaction+0xef>
		current->sigaction[signum - 1].sa_mask = 0;
    c5b1:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c5b7:	8b 00                	mov    (%eax),%eax
    c5b9:	8b 54 24 20          	mov    0x20(%esp),%edx
    c5bd:	83 ea 01             	sub    $0x1,%edx
    c5c0:	83 c2 01             	add    $0x1,%edx
    c5c3:	c1 e2 04             	shl    $0x4,%edx
    c5c6:	01 d0                	add    %edx,%eax
    c5c8:	83 c0 04             	add    $0x4,%eax
    c5cb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    c5d1:	eb 4e                	jmp    c621 <sys_sigaction+0x13d>
	else
		current->sigaction[signum - 1].sa_mask |= (1 << (signum - 1));
    c5d3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c5d9:	8b 00                	mov    (%eax),%eax
    c5db:	8b 54 24 20          	mov    0x20(%esp),%edx
    c5df:	83 ea 01             	sub    $0x1,%edx
    c5e2:	83 c2 01             	add    $0x1,%edx
    c5e5:	c1 e2 04             	shl    $0x4,%edx
    c5e8:	01 d0                	add    %edx,%eax
    c5ea:	83 c0 04             	add    $0x4,%eax
    c5ed:	8b 10                	mov    (%eax),%edx
    c5ef:	8b 44 24 20          	mov    0x20(%esp),%eax
    c5f3:	83 e8 01             	sub    $0x1,%eax
    c5f6:	be 01 00 00 00       	mov    $0x1,%esi
    c5fb:	89 c1                	mov    %eax,%ecx
    c5fd:	d3 e6                	shl    %cl,%esi
    c5ff:	89 f0                	mov    %esi,%eax
    c601:	89 c6                	mov    %eax,%esi
    c603:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c609:	8b 00                	mov    (%eax),%eax
    c60b:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    c60f:	83 e9 01             	sub    $0x1,%ecx
    c612:	09 f2                	or     %esi,%edx
    c614:	83 c1 01             	add    $0x1,%ecx
    c617:	c1 e1 04             	shl    $0x4,%ecx
    c61a:	01 c8                	add    %ecx,%eax
    c61c:	83 c0 04             	add    $0x4,%eax
    c61f:	89 10                	mov    %edx,(%eax)
	return 0;
    c621:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c626:	83 c4 14             	add    $0x14,%esp
    c629:	5b                   	pop    %ebx
    c62a:	5e                   	pop    %esi
    c62b:	c3                   	ret    

0000c62c <core_dump>:
 */
/*
 * 在当前目录中产生core dump映像文件的子程序。目前还没有实现。
 */
int core_dump(long signr)
{
    c62c:	e8 c1 a6 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    c631:	05 cf 59 02 00       	add    $0x259cf,%eax
	return(0);	/* We didn't do a dump */
    c636:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c63b:	c3                   	ret    

0000c63c <do_signal>:
// 4、第124行压入栈中的当前处理的信号值（signr）。
int do_signal(long signr, long eax, long ebx, long ecx, long edx, long orig_eax,
	long fs, long es, long ds,
	long eip, long cs, long eflags,
	unsigned long * esp, long ss)
{
    c63c:	53                   	push   %ebx
    c63d:	83 ec 28             	sub    $0x28,%esp
    c640:	e8 b5 a6 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    c645:	81 c3 bb 59 02 00    	add    $0x259bb,%ebx
	unsigned long sa_handler;
	long old_eip = eip;
    c64b:	8b 44 24 54          	mov    0x54(%esp),%eax
    c64f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	struct sigaction * sa = current->sigaction + signr - 1;			// 得到对应信号的处理数据结构
    c653:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c659:	8b 00                	mov    (%eax),%eax
    c65b:	8d 50 10             	lea    0x10(%eax),%edx
    c65e:	8b 44 24 30          	mov    0x30(%esp),%eax
    c662:	05 ff ff ff 0f       	add    $0xfffffff,%eax
    c667:	c1 e0 04             	shl    $0x4,%eax
    c66a:	01 d0                	add    %edx,%eax
    c66c:	89 44 24 14          	mov    %eax,0x14(%esp)
	// 当前读数据但没有读到任何数据等情况下，进程收到了任何一个非阻塞的信号，则都会-ERESTARTSYS返回值返回。它表示进程可以被
	// 中断，但是在继续执行后会重新启动系统调用。返回码-ERESTARTNOINTR说明在处理完信号后要求返回到原系统调用中继续运行，即系统
	// 调用不会被中断。
	// 因此下面语句说明如果是在系统调用中调用的本函数，并且相应系统调用的返回码eax等于-ERESTARTSYS或-ERESTARTNOINTR时进行下面
	// 的处理（实际上还没有真正回到用户程序中）。
	if ((orig_eax != -1) &&
    c670:	83 7c 24 44 ff       	cmpl   $0xffffffff,0x44(%esp)
    c675:	74 5e                	je     c6d5 <do_signal+0x99>
	    ((eax == -ERESTARTSYS) || (eax == -ERESTARTNOINTR))) {
    c677:	8b 44 24 34          	mov    0x34(%esp),%eax
	if ((orig_eax != -1) &&
    c67b:	3d 00 fe ff ff       	cmp    $0xfffffe00,%eax
    c680:	74 0b                	je     c68d <do_signal+0x51>
	    ((eax == -ERESTARTSYS) || (eax == -ERESTARTNOINTR))) {
    c682:	8b 44 24 34          	mov    0x34(%esp),%eax
    c686:	3d ff fd ff ff       	cmp    $0xfffffdff,%eax
    c68b:	75 48                	jne    c6d5 <do_signal+0x99>
		// 如果系统调用返回码是-ERESTARTSYS（重新启动系统调用），并且sigaction中含有标志SA_INTERRUPT（系统调用被信号中断后不重新
		// 启动系统调用）或者信号值小于SIGCONT或者信号值大于SIGTTOU（即信号不是SIGCONT、SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU），
		// 则修改系统调用的返回值为eax = -EINTR，即被信号中断的系统调用。
		if ((eax == -ERESTARTSYS) && ((sa->sa_flags & SA_INTERRUPT) ||
    c68d:	8b 44 24 34          	mov    0x34(%esp),%eax
    c691:	3d 00 fe ff ff       	cmp    $0xfffffe00,%eax
    c696:	75 28                	jne    c6c0 <do_signal+0x84>
    c698:	8b 44 24 14          	mov    0x14(%esp),%eax
    c69c:	8b 40 08             	mov    0x8(%eax),%eax
    c69f:	25 00 00 00 20       	and    $0x20000000,%eax
    c6a4:	85 c0                	test   %eax,%eax
    c6a6:	75 0e                	jne    c6b6 <do_signal+0x7a>
    c6a8:	83 7c 24 30 11       	cmpl   $0x11,0x30(%esp)
    c6ad:	7e 07                	jle    c6b6 <do_signal+0x7a>
		    signr < SIGCONT || signr > SIGTTOU))
    c6af:	83 7c 24 30 16       	cmpl   $0x16,0x30(%esp)
    c6b4:	7e 0a                	jle    c6c0 <do_signal+0x84>
			*(&eax) = -EINTR;
    c6b6:	c7 44 24 34 fc ff ff 	movl   $0xfffffffc,0x34(%esp)
    c6bd:	ff 
    c6be:	eb 15                	jmp    c6d5 <do_signal+0x99>
		// 否则就恢复进程寄存器eax在调用系统调用之前的值，并且把源程序指令指针回调2个字节。即当返回用户程序时，让程序重新启动执行被信号
		// 中断的系统调用。
		else {
			*(&eax) = orig_eax;     				// orig_eax系统调用号
    c6c0:	8b 44 24 44          	mov    0x44(%esp),%eax
    c6c4:	89 44 24 34          	mov    %eax,0x34(%esp)
			//*(&eip) = old_eip -= 2;
			// 系统调用返回到用户态的时候再次执行本次系统调用
			old_eip -= 2;
    c6c8:	83 6c 24 1c 02       	subl   $0x2,0x1c(%esp)
			__asm__ ("movl %%eax, %0\n\t" \
    c6cd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    c6d1:	89 44 24 54          	mov    %eax,0x54(%esp)
					: \
					:"m"(eip), "a"(old_eip));
		}
	}
	// 如果信号句柄为SIG_IGN（1,默认忽略句柄）则不对信号进行处理而直接返回。
	sa_handler = (unsigned long) sa->sa_handler;
    c6d5:	8b 44 24 14          	mov    0x14(%esp),%eax
    c6d9:	8b 00                	mov    (%eax),%eax
    c6db:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (sa_handler == 1)
    c6df:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
    c6e4:	75 0a                	jne    c6f0 <do_signal+0xb4>
		return(1);   								/* Ignore, see if there are more signals... */
    c6e6:	b8 01 00 00 00       	mov    $0x1,%eax
    c6eb:	e9 66 02 00 00       	jmp    c956 <.L43+0x1a4>
	// 如果句柄为SIG_DFL（0,默认处理），则根据具体的信号进行分别处理。
	if (!sa_handler) {
    c6f0:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    c6f5:	0f 85 c6 00 00 00    	jne    c7c1 <.L43+0xf>
		switch (signr) {
    c6fb:	8b 44 24 30          	mov    0x30(%esp),%eax
    c6ff:	83 e8 03             	sub    $0x3,%eax
    c702:	83 f8 13             	cmp    $0x13,%eax
    c705:	0f 87 a7 00 00 00    	ja     c7b2 <.L43>
    c70b:	c1 e0 02             	shl    $0x2,%eax
    c70e:	8b 84 18 b4 49 ff ff 	mov    -0xb64c(%eax,%ebx,1),%eax
    c715:	01 d8                	add    %ebx,%eax
    c717:	ff e0                	jmp    *%eax

0000c719 <.L46>:
		// 如果信号是以下两个则也忽略之，并返回
		case SIGCONT:
		case SIGCHLD:
			return(1);  							/* Ignore, ... */
    c719:	b8 01 00 00 00       	mov    $0x1,%eax
    c71e:	e9 33 02 00 00       	jmp    c956 <.L43+0x1a4>

0000c723 <.L47>:
		// 信号。
		case SIGSTOP:
		case SIGTSTP:
		case SIGTTIN:
		case SIGTTOU:
			current->state = TASK_STOPPED;
    c723:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c729:	8b 00                	mov    (%eax),%eax
    c72b:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
			current->exit_code = signr;
    c731:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c737:	8b 00                	mov    (%eax),%eax
    c739:	8b 54 24 30          	mov    0x30(%esp),%edx
    c73d:	89 90 14 02 00 00    	mov    %edx,0x214(%eax)
			if (!(current->p_pptr->sigaction[SIGCHLD - 1].sa_flags &
    c743:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c749:	8b 00                	mov    (%eax),%eax
    c74b:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    c751:	8b 80 18 01 00 00    	mov    0x118(%eax),%eax
    c757:	83 e0 01             	and    $0x1,%eax
    c75a:	85 c0                	test   %eax,%eax
    c75c:	75 28                	jne    c786 <.L47+0x63>
					SA_NOCLDSTOP))
				current->p_pptr->signal |= (1 << (SIGCHLD - 1));
    c75e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c764:	8b 00                	mov    (%eax),%eax
    c766:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    c76c:	8b 50 0c             	mov    0xc(%eax),%edx
    c76f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c775:	8b 00                	mov    (%eax),%eax
    c777:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    c77d:	81 ca 00 00 01 00    	or     $0x10000,%edx
    c783:	89 50 0c             	mov    %edx,0xc(%eax)
			return(1);  							/* Reschedule another event */
    c786:	b8 01 00 00 00       	mov    $0x1,%eax
    c78b:	e9 c6 01 00 00       	jmp    c956 <.L43+0x1a4>

0000c790 <.L44>:
		case SIGILL:
		case SIGTRAP:
		case SIGIOT:
		case SIGFPE:
		case SIGSEGV:
			if (core_dump(signr))
    c790:	ff 74 24 30          	pushl  0x30(%esp)
    c794:	e8 93 fe ff ff       	call   c62c <core_dump>
    c799:	83 c4 04             	add    $0x4,%esp
    c79c:	85 c0                	test   %eax,%eax
    c79e:	74 12                	je     c7b2 <.L43>
				do_exit(signr | 0x80);
    c7a0:	8b 44 24 30          	mov    0x30(%esp),%eax
    c7a4:	0c 80                	or     $0x80,%al
    c7a6:	83 ec 0c             	sub    $0xc,%esp
    c7a9:	50                   	push   %eax
    c7aa:	e8 b5 f1 ff ff       	call   b964 <do_exit>
    c7af:	83 c4 10             	add    $0x10,%esp

0000c7b2 <.L43>:
			/* fall through */
		default:
			do_exit(signr);
    c7b2:	83 ec 0c             	sub    $0xc,%esp
    c7b5:	ff 74 24 3c          	pushl  0x3c(%esp)
    c7b9:	e8 a6 f1 ff ff       	call   b964 <do_exit>
    c7be:	83 c4 10             	add    $0x10,%esp
	// 如果该信号句柄只需被调用一次，则将该句柄置空。注意，该信号句柄前面已经保存在sa_handler指针中。
	// 在系统调用进程内核时，用户程序返回地址（eip、cs）被保存在内核态栈中。下面这段代码修改内核态堆栈上用户调用时
	// 的代码指针eip为指向信号处理句柄，同时也将sa_restorer、signr、进程屏蔽码（如果SA_NOMASK没置位）、eax、
	// ecx、edx作为参数以及原调用系统调用的程序返回指针及标志寄存器值压入用户堆栈。因此在本次系统调用中断返回用户
	// 程序时会首先执行用户信号句柄程序，然后继续执行用户程序。
	if (sa->sa_flags & SA_ONESHOT)
    c7c1:	8b 44 24 14          	mov    0x14(%esp),%eax
    c7c5:	8b 40 08             	mov    0x8(%eax),%eax
    c7c8:	85 c0                	test   %eax,%eax
    c7ca:	79 0a                	jns    c7d6 <.L43+0x24>
		sa->sa_handler = NULL;
    c7cc:	8b 44 24 14          	mov    0x14(%esp),%eax
    c7d0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	// 调用者丢弃。这里之所以可以使用这种方式，是因为该函数是从汇编程序中被调用的，并且在函数返回后汇编程序并没有把
	// 调用do_signal()时的所有参数都丢弃。eip等仍然在堆栈中。
	// sigaction结构的sa_mask字段给出了在当前信号句柄（信号描述符）程序执行期间应该被屏蔽的信号集。同时，引起本
	// 信号句柄执行的信号也会被屏蔽。不过若sa_flags中使用了SA_NOMASK标志，那么引起本信号句柄执行的信号将不会被屏蔽
	// 掉。如果允许信号自己的处理句柄程序收到信号自己，则也需要将进程的信号阻塞码压入堆栈。
	*(&eip) = sa_handler;
    c7d6:	8b 44 24 10          	mov    0x10(%esp),%eax
    c7da:	89 44 24 54          	mov    %eax,0x54(%esp)
	longs = (sa->sa_flags & SA_NOMASK)?7:8;
    c7de:	8b 44 24 14          	mov    0x14(%esp),%eax
    c7e2:	8b 40 08             	mov    0x8(%eax),%eax
    c7e5:	25 00 00 00 40       	and    $0x40000000,%eax
    c7ea:	85 c0                	test   %eax,%eax
    c7ec:	74 07                	je     c7f5 <.L43+0x43>
    c7ee:	b8 07 00 00 00       	mov    $0x7,%eax
    c7f3:	eb 05                	jmp    c7fa <.L43+0x48>
    c7f5:	b8 08 00 00 00       	mov    $0x8,%eax
    c7fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
	// 将原调用程序的用户堆栈指针向下扩展7（或8）个长字（用来存放调用信号句柄的参数等），并检查内存使用情况（如内存超
	// 界则分配新页等）。
	//*(&esp) -= longs;
	__asm__("subl %1, %0\n\t" \
			: \
			:"m"(esp), "a"(longs * 4));
    c7fe:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c802:	c1 e0 02             	shl    $0x2,%eax
	__asm__("subl %1, %0\n\t" \
    c805:	29 44 24 60          	sub    %eax,0x60(%esp)
	verify_area(esp, longs * 4);
    c809:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c80d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c814:	8b 44 24 60          	mov    0x60(%esp),%eax
    c818:	83 ec 08             	sub    $0x8,%esp
    c81b:	52                   	push   %edx
    c81c:	50                   	push   %eax
    c81d:	e8 d9 c0 ff ff       	call   88fb <verify_area>
    c822:	83 c4 10             	add    $0x10,%esp
	// 在用户堆栈中从下到上存放sa_restorer、信号signr、屏蔽码blocked（如果SA_NOMASK置位）、eax、ecx、edx、eflags
	// 和用户程序原代码指针。
	tmp_esp = esp;
    c825:	8b 44 24 60          	mov    0x60(%esp),%eax
    c829:	89 44 24 18          	mov    %eax,0x18(%esp)
	put_fs_long((long) sa->sa_restorer, tmp_esp++);
    c82d:	8b 44 24 18          	mov    0x18(%esp),%eax
    c831:	8d 50 04             	lea    0x4(%eax),%edx
    c834:	89 54 24 18          	mov    %edx,0x18(%esp)
    c838:	8b 54 24 14          	mov    0x14(%esp),%edx
    c83c:	8b 52 0c             	mov    0xc(%edx),%edx
    c83f:	83 ec 08             	sub    $0x8,%esp
    c842:	50                   	push   %eax
    c843:	52                   	push   %edx
    c844:	e8 11 fa ff ff       	call   c25a <put_fs_long>
    c849:	83 c4 10             	add    $0x10,%esp
	put_fs_long(signr, tmp_esp++);
    c84c:	8b 44 24 18          	mov    0x18(%esp),%eax
    c850:	8d 50 04             	lea    0x4(%eax),%edx
    c853:	89 54 24 18          	mov    %edx,0x18(%esp)
    c857:	8b 54 24 30          	mov    0x30(%esp),%edx
    c85b:	83 ec 08             	sub    $0x8,%esp
    c85e:	50                   	push   %eax
    c85f:	52                   	push   %edx
    c860:	e8 f5 f9 ff ff       	call   c25a <put_fs_long>
    c865:	83 c4 10             	add    $0x10,%esp
	if (!(sa->sa_flags & SA_NOMASK))
    c868:	8b 44 24 14          	mov    0x14(%esp),%eax
    c86c:	8b 40 08             	mov    0x8(%eax),%eax
    c86f:	25 00 00 00 40       	and    $0x40000000,%eax
    c874:	85 c0                	test   %eax,%eax
    c876:	75 26                	jne    c89e <.L43+0xec>
		put_fs_long(current->blocked, tmp_esp++);
    c878:	8b 44 24 18          	mov    0x18(%esp),%eax
    c87c:	8d 50 04             	lea    0x4(%eax),%edx
    c87f:	89 54 24 18          	mov    %edx,0x18(%esp)
    c883:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    c889:	8b 12                	mov    (%edx),%edx
    c88b:	8b 92 10 02 00 00    	mov    0x210(%edx),%edx
    c891:	83 ec 08             	sub    $0x8,%esp
    c894:	50                   	push   %eax
    c895:	52                   	push   %edx
    c896:	e8 bf f9 ff ff       	call   c25a <put_fs_long>
    c89b:	83 c4 10             	add    $0x10,%esp
	put_fs_long(eax, tmp_esp++);
    c89e:	8b 44 24 18          	mov    0x18(%esp),%eax
    c8a2:	8d 50 04             	lea    0x4(%eax),%edx
    c8a5:	89 54 24 18          	mov    %edx,0x18(%esp)
    c8a9:	8b 54 24 34          	mov    0x34(%esp),%edx
    c8ad:	83 ec 08             	sub    $0x8,%esp
    c8b0:	50                   	push   %eax
    c8b1:	52                   	push   %edx
    c8b2:	e8 a3 f9 ff ff       	call   c25a <put_fs_long>
    c8b7:	83 c4 10             	add    $0x10,%esp
	put_fs_long(ecx, tmp_esp++);
    c8ba:	8b 44 24 18          	mov    0x18(%esp),%eax
    c8be:	8d 50 04             	lea    0x4(%eax),%edx
    c8c1:	89 54 24 18          	mov    %edx,0x18(%esp)
    c8c5:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    c8c9:	83 ec 08             	sub    $0x8,%esp
    c8cc:	50                   	push   %eax
    c8cd:	52                   	push   %edx
    c8ce:	e8 87 f9 ff ff       	call   c25a <put_fs_long>
    c8d3:	83 c4 10             	add    $0x10,%esp
	put_fs_long(edx, tmp_esp++);
    c8d6:	8b 44 24 18          	mov    0x18(%esp),%eax
    c8da:	8d 50 04             	lea    0x4(%eax),%edx
    c8dd:	89 54 24 18          	mov    %edx,0x18(%esp)
    c8e1:	8b 54 24 40          	mov    0x40(%esp),%edx
    c8e5:	83 ec 08             	sub    $0x8,%esp
    c8e8:	50                   	push   %eax
    c8e9:	52                   	push   %edx
    c8ea:	e8 6b f9 ff ff       	call   c25a <put_fs_long>
    c8ef:	83 c4 10             	add    $0x10,%esp
	put_fs_long(eflags, tmp_esp++);
    c8f2:	8b 44 24 18          	mov    0x18(%esp),%eax
    c8f6:	8d 50 04             	lea    0x4(%eax),%edx
    c8f9:	89 54 24 18          	mov    %edx,0x18(%esp)
    c8fd:	8b 54 24 5c          	mov    0x5c(%esp),%edx
    c901:	83 ec 08             	sub    $0x8,%esp
    c904:	50                   	push   %eax
    c905:	52                   	push   %edx
    c906:	e8 4f f9 ff ff       	call   c25a <put_fs_long>
    c90b:	83 c4 10             	add    $0x10,%esp
	put_fs_long(old_eip, tmp_esp++);
    c90e:	8b 44 24 18          	mov    0x18(%esp),%eax
    c912:	8d 50 04             	lea    0x4(%eax),%edx
    c915:	89 54 24 18          	mov    %edx,0x18(%esp)
    c919:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    c91d:	83 ec 08             	sub    $0x8,%esp
    c920:	50                   	push   %eax
    c921:	52                   	push   %edx
    c922:	e8 33 f9 ff ff       	call   c25a <put_fs_long>
    c927:	83 c4 10             	add    $0x10,%esp
	current->blocked |= sa->sa_mask;                // 进程阻塞码（屏蔽码）添上as_mask中的码。
    c92a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c930:	8b 00                	mov    (%eax),%eax
    c932:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
    c938:	89 c2                	mov    %eax,%edx
    c93a:	8b 44 24 14          	mov    0x14(%esp),%eax
    c93e:	8b 40 04             	mov    0x4(%eax),%eax
    c941:	09 c2                	or     %eax,%edx
    c943:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    c949:	8b 00                	mov    (%eax),%eax
    c94b:	89 90 10 02 00 00    	mov    %edx,0x210(%eax)
	return(0);										/* Continue, execute handler */
    c951:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c956:	83 c4 28             	add    $0x28,%esp
    c959:	5b                   	pop    %ebx
    c95a:	c3                   	ret    

0000c95b <kernel_mktime>:
};

// 该函数计算从1970年1月1日0时起到开机当日经过的秒数,作为开机时间.
// 参数tm中各字段已经在init/main.c中被赋值,信息取自CMOS.
long kernel_mktime(struct tm * tm)
{
    c95b:	53                   	push   %ebx
    c95c:	83 ec 10             	sub    $0x10,%esp
    c95f:	e8 92 a3 ff ff       	call   6cf6 <__x86.get_pc_thunk.dx>
    c964:	81 c2 9c 56 02 00    	add    $0x2569c,%edx
	// if(tm->tm_year<70) tm->tm_year += 100;由于UNIX计年份y是从1970年算起.到1972年就是一个闰年,因此过3年(71,72,73)
	// 就是第1个闰年,这样从1970年开始的闰年数计算方法就应该是1+(y-3)/4,即为(y+1)/4.res=这些年经过的秒数时间+每个闰年时多1天
	// 的秒数时间+当年到当月时的秒数.另外,month[]数组中已经在2月份的天数中包含进了闰年时的天数,即2月份天数多算了1天.因此,若
	// 当年不是闰年并且当前月份大于2月份的话,我们就要减去这天.因为人70开始算起,所以当年是闰年的判断方法是(y+2)能被4除尽.若不能
	// 除尽(有余数)就不是闰年.
	if(tm->tm_year < 70) tm->tm_year += 100;				//处理2000年问题
    c96a:	8b 44 24 18          	mov    0x18(%esp),%eax
    c96e:	8b 40 14             	mov    0x14(%eax),%eax
    c971:	83 f8 45             	cmp    $0x45,%eax
    c974:	7f 11                	jg     c987 <kernel_mktime+0x2c>
    c976:	8b 44 24 18          	mov    0x18(%esp),%eax
    c97a:	8b 40 14             	mov    0x14(%eax),%eax
    c97d:	8d 48 64             	lea    0x64(%eax),%ecx
    c980:	8b 44 24 18          	mov    0x18(%esp),%eax
    c984:	89 48 14             	mov    %ecx,0x14(%eax)
	year = tm->tm_year - 70;
    c987:	8b 44 24 18          	mov    0x18(%esp),%eax
    c98b:	8b 40 14             	mov    0x14(%eax),%eax
    c98e:	83 e8 46             	sub    $0x46,%eax
    c991:	89 44 24 08          	mov    %eax,0x8(%esp)
	/* magic offsets (y+1) needed to get leapyears right.*/
	/* 为了获得正确的闰年数,这里需要这样一个魔幻值(y+1) */
	res = YEAR * year + DAY * ((year + 1) / 4);
    c995:	8b 44 24 08          	mov    0x8(%esp),%eax
    c999:	69 c8 80 33 e1 01    	imul   $0x1e13380,%eax,%ecx
    c99f:	8b 44 24 08          	mov    0x8(%esp),%eax
    c9a3:	83 c0 01             	add    $0x1,%eax
    c9a6:	8d 58 03             	lea    0x3(%eax),%ebx
    c9a9:	85 c0                	test   %eax,%eax
    c9ab:	0f 48 c3             	cmovs  %ebx,%eax
    c9ae:	c1 f8 02             	sar    $0x2,%eax
    c9b1:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    c9b7:	01 c8                	add    %ecx,%eax
    c9b9:	89 44 24 0c          	mov    %eax,0xc(%esp)
	res += month[tm->tm_mon];
    c9bd:	8b 44 24 18          	mov    0x18(%esp),%eax
    c9c1:	8b 40 10             	mov    0x10(%eax),%eax
    c9c4:	8b 84 82 c0 00 00 00 	mov    0xc0(%edx,%eax,4),%eax
    c9cb:	01 44 24 0c          	add    %eax,0xc(%esp)
	/* and (y+2) here. If it wasn't a leap-year, we have to adjust */
	/* 以及(y+2).如果(y+2)不是闰年,那么我们就必须进行调整(减去一天的秒数时间). */
	if (tm->tm_mon > 1 && ((year + 2) % 4))
    c9cf:	8b 44 24 18          	mov    0x18(%esp),%eax
    c9d3:	8b 40 10             	mov    0x10(%eax),%eax
    c9d6:	83 f8 01             	cmp    $0x1,%eax
    c9d9:	7e 16                	jle    c9f1 <kernel_mktime+0x96>
    c9db:	8b 44 24 08          	mov    0x8(%esp),%eax
    c9df:	83 c0 02             	add    $0x2,%eax
    c9e2:	83 e0 03             	and    $0x3,%eax
    c9e5:	85 c0                	test   %eax,%eax
    c9e7:	74 08                	je     c9f1 <kernel_mktime+0x96>
		res -= DAY;
    c9e9:	81 6c 24 0c 80 51 01 	subl   $0x15180,0xc(%esp)
    c9f0:	00 
	res += DAY * (tm->tm_mday - 1);							// 再加上本月过去的天数的秒数时间.
    c9f1:	8b 44 24 18          	mov    0x18(%esp),%eax
    c9f5:	8b 40 0c             	mov    0xc(%eax),%eax
    c9f8:	83 e8 01             	sub    $0x1,%eax
    c9fb:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    ca01:	01 44 24 0c          	add    %eax,0xc(%esp)
	res += HOUR * tm->tm_hour;								// 再加上当天过去的小时数的秒数时间.
    ca05:	8b 44 24 18          	mov    0x18(%esp),%eax
    ca09:	8b 40 08             	mov    0x8(%eax),%eax
    ca0c:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
    ca12:	01 44 24 0c          	add    %eax,0xc(%esp)
	res += MINUTE * tm->tm_min;								// 再加上1小时内过去的分钟数的秒数时间.
    ca16:	8b 44 24 18          	mov    0x18(%esp),%eax
    ca1a:	8b 40 04             	mov    0x4(%eax),%eax
    ca1d:	6b c0 3c             	imul   $0x3c,%eax,%eax
    ca20:	01 44 24 0c          	add    %eax,0xc(%esp)
	res += tm->tm_sec;										// 再加上1分钟内已过的秒数.
    ca24:	8b 44 24 18          	mov    0x18(%esp),%eax
    ca28:	8b 00                	mov    (%eax),%eax
    ca2a:	01 44 24 0c          	add    %eax,0xc(%esp)
	return res;												// 即等于从1970年以来经过的秒数时间.
    ca2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    ca32:	83 c4 10             	add    $0x10,%esp
    ca35:	5b                   	pop    %ebx
    ca36:	c3                   	ret    

0000ca37 <__x86.get_pc_thunk.cx>:
    ca37:	8b 0c 24             	mov    (%esp),%ecx
    ca3a:	c3                   	ret    

0000ca3b <oom>:
void swap_in(unsigned long *table_ptr);                                             // 把页表项是table_ptr的一页物理内存换出到交换空间

// 下面函数名前关键字volatile用于告诉编译器gcc该函数不会返回.这样可让gcc产生更好的代码,更重要的是使用这个关键字可以避免产生某些(未
//　初始化变量的)假警告信息.
static inline void oom(void)
{
    ca3b:	53                   	push   %ebx
    ca3c:	83 ec 08             	sub    $0x8,%esp
    ca3f:	e8 b6 a2 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    ca44:	81 c3 bc 55 02 00    	add    $0x255bc,%ebx
	printk("out of memory\n\r");
    ca4a:	83 ec 0c             	sub    $0xc,%esp
    ca4d:	8d 83 04 4a ff ff    	lea    -0xb5fc(%ebx),%eax
    ca53:	50                   	push   %eax
    ca54:	e8 d9 c8 ff ff       	call   9332 <printk>
    ca59:	83 c4 10             	add    $0x10,%esp
    //　do_exit()应该使用退出代码,这里用了信息值SIGSEGV(11).相同值的出错码含义是"资源暂不可用",正好同义.
	do_exit(SIGSEGV);
    ca5c:	83 ec 0c             	sub    $0xc,%esp
    ca5f:	6a 0b                	push   $0xb
    ca61:	e8 fe ee ff ff       	call   b964 <do_exit>
    ca66:	83 c4 10             	add    $0x10,%esp
}
    ca69:	90                   	nop
    ca6a:	83 c4 08             	add    $0x8,%esp
    ca6d:	5b                   	pop    %ebx
    ca6e:	c3                   	ret    

0000ca6f <free_page>:
 * 释放物理地址"addr"处的一页内存.用于函数free_page_tables().
 */
// 释放物理地址addr开始的1页面内存.
// 物理地址1MB以下的内存空间用于内核程序和缓冲,不作为分配页面的内存空间.因此参数addr需要大于1MB
void free_page(unsigned long addr)
{
    ca6f:	56                   	push   %esi
    ca70:	53                   	push   %ebx
    ca71:	83 ec 04             	sub    $0x4,%esp
    ca74:	e8 81 a2 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    ca79:	81 c3 87 55 02 00    	add    $0x25587,%ebx
	// 首先判断参数给定的物理地址addr的合理性.如果物理地址addr小于内存低端(1MB),则表示在内核程序或高速缓冲中,对此不予处理.如果物理地址
	// addr >=系统所含物理内存最高端,则显示出错信息并且内核停止工作.
	if (addr < LOW_MEM) return;
    ca7f:	81 7c 24 10 ff ff 0f 	cmpl   $0xfffff,0x10(%esp)
    ca86:	00 
    ca87:	76 72                	jbe    cafb <free_page+0x8c>
	if (addr >= HIGH_MEMORY)
    ca89:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
    ca8f:	39 44 24 10          	cmp    %eax,0x10(%esp)
    ca93:	72 12                	jb     caa7 <free_page+0x38>
		panic("trying to free nonexistent page");
    ca95:	83 ec 0c             	sub    $0xc,%esp
    ca98:	8d 83 14 4a ff ff    	lea    -0xb5ec(%ebx),%eax
    ca9e:	50                   	push   %eax
    ca9f:	e8 3a c8 ff ff       	call   92de <panic>
    caa4:	83 c4 10             	add    $0x10,%esp
	// 如果对参数addr验证通过,那么就根据这个物理地址换算出内存低端开始计起的内存页面号.页面号 = (addr - LOW_MEME)/4096.可见页面号从0号
	// 开始计起.此时addr中存放着页面号.如果该页面号对应的页面映射字节不等于0,则减1返回.此时该映射字节值应该为0,表示页面已释放.如果对应页面原本就
	// 是0,表示该物理页面本来就是空闲的,说明内核代码出问题.于是显示出错信息并停机.
	addr -= LOW_MEM;
    caa7:	81 6c 24 10 00 00 10 	subl   $0x100000,0x10(%esp)
    caae:	00 
	addr >>= 12;
    caaf:	c1 6c 24 10 0c       	shrl   $0xc,0x10(%esp)
	if (mem_map[addr]--) return;
    cab4:	8d 93 20 23 00 00    	lea    0x2320(%ebx),%edx
    caba:	8b 44 24 10          	mov    0x10(%esp),%eax
    cabe:	01 d0                	add    %edx,%eax
    cac0:	0f b6 00             	movzbl (%eax),%eax
    cac3:	8d 50 ff             	lea    -0x1(%eax),%edx
    cac6:	8d b3 20 23 00 00    	lea    0x2320(%ebx),%esi
    cacc:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    cad0:	01 f1                	add    %esi,%ecx
    cad2:	88 11                	mov    %dl,(%ecx)
    cad4:	84 c0                	test   %al,%al
    cad6:	75 26                	jne    cafe <free_page+0x8f>
	// 执行到此处表示要释放空闲的页面，则将该页面的引用次数重置为0
	mem_map[addr] = 0;
    cad8:	8d 93 20 23 00 00    	lea    0x2320(%ebx),%edx
    cade:	8b 44 24 10          	mov    0x10(%esp),%eax
    cae2:	01 d0                	add    %edx,%eax
    cae4:	c6 00 00             	movb   $0x0,(%eax)
	panic("trying to free free page");
    cae7:	83 ec 0c             	sub    $0xc,%esp
    caea:	8d 83 34 4a ff ff    	lea    -0xb5cc(%ebx),%eax
    caf0:	50                   	push   %eax
    caf1:	e8 e8 c7 ff ff       	call   92de <panic>
    caf6:	83 c4 10             	add    $0x10,%esp
    caf9:	eb 04                	jmp    caff <free_page+0x90>
	if (addr < LOW_MEM) return;
    cafb:	90                   	nop
    cafc:	eb 01                	jmp    caff <free_page+0x90>
	if (mem_map[addr]--) return;
    cafe:	90                   	nop
}
    caff:	83 c4 04             	add    $0x4,%esp
    cb02:	5b                   	pop    %ebx
    cb03:	5e                   	pop    %esi
    cb04:	c3                   	ret    

0000cb05 <free_page_tables>:
// 页目录位于物理地址0开始处,共1024项,每项4字节,共占4KB.每个目录项指定一个页表.内核页表物理地址0x1000处开始(紧接着目录空间),
// 共4个页表.每个页表有1024项,每项4B.因此也占4KB(1页)内存.各进程(除了在内核代码中的进程0和1)的页表所占据的页面在进程被创建时由
// 内核为其在主内存区申请得到.每个页表项对应1页物理内存,因此一个页表最多可映射4MB的物理内存.
// 参数:from - 起始线性基地址;size - 释放的字节长度.
int free_page_tables(unsigned long from, unsigned long size)
{
    cb05:	53                   	push   %ebx
    cb06:	83 ec 18             	sub    $0x18,%esp
    cb09:	e8 ec a1 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    cb0e:	81 c3 f2 54 02 00    	add    $0x254f2,%ebx
	unsigned long *pg_table;
	unsigned long * dir, nr;

	// 首先检测参数from给出的线性基地址是否在4MB的边界处.因为该函数只能处理这种情况.若from = 0,则出错.说明试图释放内核和缓冲所占空间.
	if (from & 0x3fffff)
    cb14:	8b 44 24 20          	mov    0x20(%esp),%eax
    cb18:	25 ff ff 3f 00       	and    $0x3fffff,%eax
    cb1d:	85 c0                	test   %eax,%eax
    cb1f:	74 12                	je     cb33 <free_page_tables+0x2e>
		panic("free_page_tables called with wrong alignment");
    cb21:	83 ec 0c             	sub    $0xc,%esp
    cb24:	8d 83 50 4a ff ff    	lea    -0xb5b0(%ebx),%eax
    cb2a:	50                   	push   %eax
    cb2b:	e8 ae c7 ff ff       	call   92de <panic>
    cb30:	83 c4 10             	add    $0x10,%esp
	if (!from)
    cb33:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    cb38:	75 12                	jne    cb4c <free_page_tables+0x47>
		panic("Trying to free up swapper memory space");
    cb3a:	83 ec 0c             	sub    $0xc,%esp
    cb3d:	8d 83 80 4a ff ff    	lea    -0xb580(%ebx),%eax
    cb43:	50                   	push   %eax
    cb44:	e8 95 c7 ff ff       	call   92de <panic>
    cb49:	83 c4 10             	add    $0x10,%esp
	// 然后计算参数size给出的长度所占的页目录数(4MB的进位整数倍),也即所占页表数.
	// 因为1个页表可管理4MB物理内存,所以这里用右移22位的方式把需要复制的内存长度值除以4MB.其中加上0x3fffff(即4MB-1)用于得到进位整数倍
	// 结果,即除操作若有余数则进1.例如,如果原size = 4.01MB,那么可得到结果size = 2.
	size = (size + 0x3fffff) >> 22;
    cb4c:	8b 44 24 24          	mov    0x24(%esp),%eax
    cb50:	05 ff ff 3f 00       	add    $0x3fffff,%eax
    cb55:	c1 e8 16             	shr    $0x16,%eax
    cb58:	89 44 24 24          	mov    %eax,0x24(%esp)
	// 接着计算给出的线性基地址对应的起始目录项, 对应的目录项号 = from >>22.因为每项点4字节,并且由于页目录表从物理地址0开始存放,
	// 因此实际目录项指针 = 目录项号<<2,也即(from >> 20),"与"上0xffc确保目录项指针范围有效.
	// dir表示起始的页目录项物理地址
	dir = (unsigned long *) ((from >> 20) & 0xffc); 			/* _pg_dir = 0 */
    cb5c:	8b 44 24 20          	mov    0x20(%esp),%eax
    cb60:	c1 e8 14             	shr    $0x14,%eax
    cb63:	25 fc 0f 00 00       	and    $0xffc,%eax
    cb68:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 此时size是释放的页表个数,即页目录项数,而dir是起始目录项指针.现在开始循环操作页目录项,依次释放每个页表中的页表项.如果当前目录项无效(
	// P位=0),表示该目录项没有使用(对应的页表不存在),则继续处理下一个页表项.否则从目录项中取出页表地址pg_table,并对该页表中的1024个表项
	// 进行处理,释放有效页表(P位=1)对应的物理内存页面,或者从交换设备中释放无效页表项(P位=0)对应的页面,即释放交换设备中对应的内存页面(因为
	// 页面可能已经交换出去).然后把该页表项清零,并继续处理下一页表项.当一个页表所有表项都处理完毕就释放该页表自身占据的内存页面,并继续处理下
	// 一页目录项.最后刷新页变换高速缓冲,并返回0.
	for ( ; size-- > 0 ; dir++) {
    cb6c:	e9 b5 00 00 00       	jmp    cc26 <free_page_tables+0x121>
		// 如果该目录项不存在页表项，则直接跳过该页表项
		if (!(1 & *dir))
    cb71:	8b 44 24 08          	mov    0x8(%esp),%eax
    cb75:	8b 00                	mov    (%eax),%eax
    cb77:	83 e0 01             	and    $0x1,%eax
    cb7a:	85 c0                	test   %eax,%eax
    cb7c:	0f 84 9e 00 00 00    	je     cc20 <free_page_tables+0x11b>
			continue;
		pg_table = (unsigned long *) (0xfffff000 & *dir);		// 取页表地址.
    cb82:	8b 44 24 08          	mov    0x8(%esp),%eax
    cb86:	8b 00                	mov    (%eax),%eax
    cb88:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    cb8d:	89 44 24 0c          	mov    %eax,0xc(%esp)
		for (nr = 0 ; nr < 1024 ; nr++) {
    cb91:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    cb98:	00 
    cb99:	eb 58                	jmp    cbf3 <free_page_tables+0xee>
			if (*pg_table) {									// 若所指页表项内容不为0,则若该项有效,则释放对应面.
    cb9b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cb9f:	8b 00                	mov    (%eax),%eax
    cba1:	85 c0                	test   %eax,%eax
    cba3:	74 44                	je     cbe9 <free_page_tables+0xe4>
				if (1 & *pg_table)
    cba5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cba9:	8b 00                	mov    (%eax),%eax
    cbab:	83 e0 01             	and    $0x1,%eax
    cbae:	85 c0                	test   %eax,%eax
    cbb0:	74 19                	je     cbcb <free_page_tables+0xc6>
					free_page(0xfffff000 & *pg_table);
    cbb2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cbb6:	8b 00                	mov    (%eax),%eax
    cbb8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    cbbd:	83 ec 0c             	sub    $0xc,%esp
    cbc0:	50                   	push   %eax
    cbc1:	e8 a9 fe ff ff       	call   ca6f <free_page>
    cbc6:	83 c4 10             	add    $0x10,%esp
    cbc9:	eb 14                	jmp    cbdf <free_page_tables+0xda>
				else											// 否则释放交换设备中对应页.
					swap_free(*pg_table >> 1);
    cbcb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cbcf:	8b 00                	mov    (%eax),%eax
    cbd1:	d1 e8                	shr    %eax
    cbd3:	83 ec 0c             	sub    $0xc,%esp
    cbd6:	50                   	push   %eax
    cbd7:	e8 5d 10 00 00       	call   dc39 <swap_free>
    cbdc:	83 c4 10             	add    $0x10,%esp
				*pg_table = 0;									// 该页表项内容清零.
    cbdf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cbe3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			}
			pg_table++;											//指向页表中下一项.
    cbe9:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)
		for (nr = 0 ; nr < 1024 ; nr++) {
    cbee:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
    cbf3:	81 7c 24 04 ff 03 00 	cmpl   $0x3ff,0x4(%esp)
    cbfa:	00 
    cbfb:	76 9e                	jbe    cb9b <free_page_tables+0x96>
		}
		free_page(0xfffff000 & *dir);							// 释放该页表所占内存页面.
    cbfd:	8b 44 24 08          	mov    0x8(%esp),%eax
    cc01:	8b 00                	mov    (%eax),%eax
    cc03:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    cc08:	83 ec 0c             	sub    $0xc,%esp
    cc0b:	50                   	push   %eax
    cc0c:	e8 5e fe ff ff       	call   ca6f <free_page>
    cc11:	83 c4 10             	add    $0x10,%esp
		*dir = 0;												// 对应页表的目录项清零.
    cc14:	8b 44 24 08          	mov    0x8(%esp),%eax
    cc18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    cc1e:	eb 01                	jmp    cc21 <free_page_tables+0x11c>
			continue;
    cc20:	90                   	nop
	for ( ; size-- > 0 ; dir++) {
    cc21:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
    cc26:	8b 44 24 24          	mov    0x24(%esp),%eax
    cc2a:	8d 50 ff             	lea    -0x1(%eax),%edx
    cc2d:	89 54 24 24          	mov    %edx,0x24(%esp)
    cc31:	85 c0                	test   %eax,%eax
    cc33:	0f 85 38 ff ff ff    	jne    cb71 <free_page_tables+0x6c>
	}
	invalidate();												// 刷新CPU页变换高速缓冲.
    cc39:	b8 00 00 00 00       	mov    $0x0,%eax
    cc3e:	0f 22 d8             	mov    %eax,%cr3
	return 0;
    cc41:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cc46:	83 c4 18             	add    $0x18,%esp
    cc49:	5b                   	pop    %ebx
    cc4a:	c3                   	ret    

0000cc4b <copy_page_tables>:
// 复制指定线性地址和长度内存对应的页目录项和页表项,从而被复制的页目录和页表对应的原物理内存页面区被两套页表映射而共享使用.复制时,需申请
// 新页面来存放新页表,原物理内存区将被共享.此后两个进程(父进程和其子进程)将共享内存区,直到有一个进程执行写操作时,内核才会为写操作进程分配
// 新的内存页(写时复制机制).
// 参数from,to是线性地址,size是需要复制(共享)的内存长度,单位是字节.
int copy_page_tables(unsigned long from, unsigned long to, long size)
{
    cc4b:	53                   	push   %ebx
    cc4c:	83 ec 28             	sub    $0x28,%esp
    cc4f:	e8 a6 a0 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    cc54:	81 c3 ac 53 02 00    	add    $0x253ac,%ebx
	unsigned long nr;

	// 首先检测参数给出的源地址from和目的地址to的有效性.源地址和目的地址都需要在4MB内存边界地址上.否则出错死机.作这样的要求是因为一个页表的
	// 1024项可管理4MB内存.源地址from和目的地址to只有满足这个要求才能保证从一个页表的第1项开始复制页表项,并且新页表最初所有项都是有效的.然后
	// 取得源地址和目的地址的起始目录项指针(from_dir和do_dir).再根据参数给出的长度size计算要复制的内存块占用的页表数(即目录项数)
	if ((from & 0x3fffff) || (to & 0x3fffff))
    cc5a:	8b 44 24 30          	mov    0x30(%esp),%eax
    cc5e:	25 ff ff 3f 00       	and    $0x3fffff,%eax
    cc63:	85 c0                	test   %eax,%eax
    cc65:	75 0d                	jne    cc74 <copy_page_tables+0x29>
    cc67:	8b 44 24 34          	mov    0x34(%esp),%eax
    cc6b:	25 ff ff 3f 00       	and    $0x3fffff,%eax
    cc70:	85 c0                	test   %eax,%eax
    cc72:	74 12                	je     cc86 <copy_page_tables+0x3b>
		panic("copy_page_tables called with wrong alignment");
    cc74:	83 ec 0c             	sub    $0xc,%esp
    cc77:	8d 83 a8 4a ff ff    	lea    -0xb558(%ebx),%eax
    cc7d:	50                   	push   %eax
    cc7e:	e8 5b c6 ff ff       	call   92de <panic>
    cc83:	83 c4 10             	add    $0x10,%esp
	from_dir = (unsigned long *) ((from >> 20) & 0xffc); 				/* _pg_dir = 0 */
    cc86:	8b 44 24 30          	mov    0x30(%esp),%eax
    cc8a:	c1 e8 14             	shr    $0x14,%eax
    cc8d:	25 fc 0f 00 00       	and    $0xffc,%eax
    cc92:	89 44 24 14          	mov    %eax,0x14(%esp)
	to_dir = (unsigned long *) ((to >> 20) & 0xffc);
    cc96:	8b 44 24 34          	mov    0x34(%esp),%eax
    cc9a:	c1 e8 14             	shr    $0x14,%eax
    cc9d:	25 fc 0f 00 00       	and    $0xffc,%eax
    cca2:	89 44 24 10          	mov    %eax,0x10(%esp)
	size = ((unsigned) (size + 0x3fffff)) >> 22;
    cca6:	8b 44 24 38          	mov    0x38(%esp),%eax
    ccaa:	05 ff ff 3f 00       	add    $0x3fffff,%eax
    ccaf:	c1 e8 16             	shr    $0x16,%eax
    ccb2:	89 44 24 38          	mov    %eax,0x38(%esp)
	// 在得到了源起始目录项指针from_dir和目的起始目录项指针to_dir以及需要复制的页表个数size后,下面开始对每个页目录项依次申请1页内存来保存对应的面表,
	// 并且开始页表项复制操作.如果目的目录项指定的页表已经存在(P=1),则出错死机.如果源目录项无效,即指定的页表不存在(P=0),则继续循环处理下一个页目录项.
	for( ; size-- > 0 ; from_dir++, to_dir++) {
    ccb6:	e9 77 01 00 00       	jmp    ce32 <copy_page_tables+0x1e7>
		if (1 & *to_dir)
    ccbb:	8b 44 24 10          	mov    0x10(%esp),%eax
    ccbf:	8b 00                	mov    (%eax),%eax
    ccc1:	83 e0 01             	and    $0x1,%eax
    ccc4:	85 c0                	test   %eax,%eax
    ccc6:	74 12                	je     ccda <copy_page_tables+0x8f>
			panic("copy_page_tables: already exist");
    ccc8:	83 ec 0c             	sub    $0xc,%esp
    cccb:	8d 83 d8 4a ff ff    	lea    -0xb528(%ebx),%eax
    ccd1:	50                   	push   %eax
    ccd2:	e8 07 c6 ff ff       	call   92de <panic>
    ccd7:	83 c4 10             	add    $0x10,%esp
		if (!(1 & *from_dir))
    ccda:	8b 44 24 14          	mov    0x14(%esp),%eax
    ccde:	8b 00                	mov    (%eax),%eax
    cce0:	83 e0 01             	and    $0x1,%eax
    cce3:	85 c0                	test   %eax,%eax
    cce5:	0f 84 3c 01 00 00    	je     ce27 <copy_page_tables+0x1dc>
			continue;
		// 在验证了当前源目录项和目的项正常之后,取源目录项中页表地址from_page_table.为了保存目的目录项对应的页表,需要在主内存区中申请1页空闲内存页.如果取
		// 空闲页面函数get_free_page()返回0,则说明没有申请到空闲内存页面,可能是内存不够.于是返回-1值退出.
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
    cceb:	8b 44 24 14          	mov    0x14(%esp),%eax
    ccef:	8b 00                	mov    (%eax),%eax
    ccf1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    ccf6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if (!(to_page_table = (unsigned long *) get_free_page()))
    ccfa:	e8 ed 12 00 00       	call   dfec <get_free_page>
    ccff:	89 44 24 18          	mov    %eax,0x18(%esp)
    cd03:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    cd08:	75 0a                	jne    cd14 <copy_page_tables+0xc9>
			return -1;													/* Out of memory, see freeing */
    cd0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    cd0f:	e9 3e 01 00 00       	jmp    ce52 <copy_page_tables+0x207>
		// 否则我们设置目的目录项信息,把最后3位置位,即当前目的目录项"或"上7,表示对应页表映射的内存页面是用户级的,并且可读写,存在(User,R/W,Present).(如果
		// U/S位是0,则R/W就没有作用.如果U/S是1,而R/W是0,那么运行在用户层的代码就只能读页面.如果U/S和R/W都置位,则就有读写的权限).
		*to_dir = ((unsigned long) to_page_table) | 7;
    cd14:	8b 44 24 18          	mov    0x18(%esp),%eax
    cd18:	83 c8 07             	or     $0x7,%eax
    cd1b:	89 c2                	mov    %eax,%edx
    cd1d:	8b 44 24 10          	mov    0x10(%esp),%eax
    cd21:	89 10                	mov    %edx,(%eax)
		// 然后针对当前处理的页目录项对应的页表,设置需要复制的页面项数.如果是在内核空间,则仅需复制头160页对应的页表项(nr = 160),
		// 对应于开始640KB物理内存.否则需要复制一个页表中的所有1024个页表项(nr= 1024),可映射4MB物理内存.
		nr = (from == 0) ? 0xA0 : 1024;
    cd23:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
    cd28:	75 07                	jne    cd31 <copy_page_tables+0xe6>
    cd2a:	b8 a0 00 00 00       	mov    $0xa0,%eax
    cd2f:	eb 05                	jmp    cd36 <copy_page_tables+0xeb>
    cd31:	b8 00 04 00 00       	mov    $0x400,%eax
    cd36:	89 44 24 0c          	mov    %eax,0xc(%esp)
		// 此时对于当前页表,开始循环复制指定的nr个内存页面表项.先取出源页表项内容,如果当前源页面没有使用(项内容为0),则不用复制该表项,继续处理下一项.
		for ( ; nr-- > 0 ; from_page_table++, to_page_table++) {
    cd3a:	e9 d3 00 00 00       	jmp    ce12 <copy_page_tables+0x1c7>
			this_page = *from_page_table;
    cd3f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cd43:	8b 00                	mov    (%eax),%eax
    cd45:	89 44 24 08          	mov    %eax,0x8(%esp)
			// 如果源页表不存在，则直接拷贝下一页表
			if (!this_page)
    cd49:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    cd4e:	0f 84 b3 00 00 00    	je     ce07 <copy_page_tables+0x1bc>
				continue;
			// 如果该表项有内容,但是其存在位P=0,则该表项对应的页面可能在交换设备中.于是先申请1页内存,并从交换设备中读入该页面(若交换设备中有的话).然后将该页表项复制到
			// 目的页表项中.并修改源页表项内容指向该新申请的内存页.
			if (!(1 & this_page)) {
    cd54:	8b 44 24 08          	mov    0x8(%esp),%eax
    cd58:	83 e0 01             	and    $0x1,%eax
    cd5b:	85 c0                	test   %eax,%eax
    cd5d:	75 56                	jne    cdb5 <copy_page_tables+0x16a>
				// 申请一页新的内存然后将交换设备中的数据读取到该页面中
				if (!(new_page = get_free_page()))
    cd5f:	e8 88 12 00 00       	call   dfec <get_free_page>
    cd64:	89 44 24 04          	mov    %eax,0x4(%esp)
    cd68:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    cd6d:	75 0a                	jne    cd79 <copy_page_tables+0x12e>
					return -1;
    cd6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    cd74:	e9 d9 00 00 00       	jmp    ce52 <copy_page_tables+0x207>
				// 从交换设备中将页面读取出来
				read_swap_page(this_page >> 1, (char *) new_page);
    cd79:	8b 54 24 04          	mov    0x4(%esp),%edx
    cd7d:	8b 44 24 08          	mov    0x8(%esp),%eax
    cd81:	d1 e8                	shr    %eax
    cd83:	89 c1                	mov    %eax,%ecx
    cd85:	c7 c0 20 52 03 00    	mov    $0x35220,%eax
    cd8b:	8b 00                	mov    (%eax),%eax
    cd8d:	52                   	push   %edx
    cd8e:	51                   	push   %ecx
    cd8f:	50                   	push   %eax
    cd90:	6a 00                	push   $0x0
    cd92:	e8 78 b5 00 00       	call   1830f <ll_rw_page>
    cd97:	83 c4 10             	add    $0x10,%esp
				// 目的页表项指向源页表项值
				*to_page_table = this_page;
    cd9a:	8b 44 24 18          	mov    0x18(%esp),%eax
    cd9e:	8b 54 24 08          	mov    0x8(%esp),%edx
    cda2:	89 10                	mov    %edx,(%eax)
				// 并修改源页表项内容指向该新申请的内存页,并设置表项标志为"页面脏"加上7
				*from_page_table = new_page | (PAGE_DIRTY | 7);
    cda4:	8b 44 24 04          	mov    0x4(%esp),%eax
    cda8:	83 c8 47             	or     $0x47,%eax
    cdab:	89 c2                	mov    %eax,%edx
    cdad:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cdb1:	89 10                	mov    %edx,(%eax)
				// 继续处理下一页表项
				continue;
    cdb3:	eb 53                	jmp    ce08 <copy_page_tables+0x1bd>
			}
			// 复位页表项中R/W标志(位1置0),即让页表项对应的内存页面只读,然后将该页表项复制到目的页表中
			this_page &= ~2;
    cdb5:	83 64 24 08 fd       	andl   $0xfffffffd,0x8(%esp)
			*to_page_table = this_page;
    cdba:	8b 44 24 18          	mov    0x18(%esp),%eax
    cdbe:	8b 54 24 08          	mov    0x8(%esp),%edx
    cdc2:	89 10                	mov    %edx,(%eax)
			// 的页面,说明是内核页面,因此不需要对mem_map[]进行设置.因为mem_map[]仅用于管理主内存区中的页面使用请问.因此对于内核移动到任务0中并且调用fork()创建任务1时
			// (用于运行init()),由于此时复制的页面还仍然都在内核代码区域,因此以下判断中的语句不会执行,任务0的页面仍然可以随时读写.只有当调用fork()的父进程代码处于主内存
			// (页面位置大于1MB)时才会执行.这种情况需要在进程调用execve(),并装载执行了新程序代码时才会出现.
			// 157行语句含义是令源页表项所指内存页也为只读.因为现在开始已有两个进程共用内存区了.若其中1个进程需要进行操作,则可以通过页异常写保护处理为执行写操作的进程分配
			// 1页新空闲页面,也即进行写时复制(copy_on_write)操作.
			if (this_page > LOW_MEM) {
    cdc4:	81 7c 24 08 00 00 10 	cmpl   $0x100000,0x8(%esp)
    cdcb:	00 
    cdcc:	76 3a                	jbe    ce08 <copy_page_tables+0x1bd>
				*from_page_table = this_page;		// 令源页表项也只读.
    cdce:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cdd2:	8b 54 24 08          	mov    0x8(%esp),%edx
    cdd6:	89 10                	mov    %edx,(%eax)
				this_page -= LOW_MEM;
    cdd8:	81 6c 24 08 00 00 10 	subl   $0x100000,0x8(%esp)
    cddf:	00 
				this_page >>= 12;
    cde0:	c1 6c 24 08 0c       	shrl   $0xc,0x8(%esp)
				mem_map[this_page]++;
    cde5:	8d 93 20 23 00 00    	lea    0x2320(%ebx),%edx
    cdeb:	8b 44 24 08          	mov    0x8(%esp),%eax
    cdef:	01 d0                	add    %edx,%eax
    cdf1:	0f b6 00             	movzbl (%eax),%eax
    cdf4:	8d 50 01             	lea    0x1(%eax),%edx
    cdf7:	8d 8b 20 23 00 00    	lea    0x2320(%ebx),%ecx
    cdfd:	8b 44 24 08          	mov    0x8(%esp),%eax
    ce01:	01 c8                	add    %ecx,%eax
    ce03:	88 10                	mov    %dl,(%eax)
    ce05:	eb 01                	jmp    ce08 <copy_page_tables+0x1bd>
				continue;
    ce07:	90                   	nop
		for ( ; nr-- > 0 ; from_page_table++, to_page_table++) {
    ce08:	83 44 24 1c 04       	addl   $0x4,0x1c(%esp)
    ce0d:	83 44 24 18 04       	addl   $0x4,0x18(%esp)
    ce12:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce16:	8d 50 ff             	lea    -0x1(%eax),%edx
    ce19:	89 54 24 0c          	mov    %edx,0xc(%esp)
    ce1d:	85 c0                	test   %eax,%eax
    ce1f:	0f 85 1a ff ff ff    	jne    cd3f <copy_page_tables+0xf4>
    ce25:	eb 01                	jmp    ce28 <copy_page_tables+0x1dd>
			continue;
    ce27:	90                   	nop
	for( ; size-- > 0 ; from_dir++, to_dir++) {
    ce28:	83 44 24 14 04       	addl   $0x4,0x14(%esp)
    ce2d:	83 44 24 10 04       	addl   $0x4,0x10(%esp)
    ce32:	8b 44 24 38          	mov    0x38(%esp),%eax
    ce36:	8d 50 ff             	lea    -0x1(%eax),%edx
    ce39:	89 54 24 38          	mov    %edx,0x38(%esp)
    ce3d:	85 c0                	test   %eax,%eax
    ce3f:	0f 8f 76 fe ff ff    	jg     ccbb <copy_page_tables+0x70>
			}
        }
    }
	invalidate();									// 刷新页变换高速缓冲.
    ce45:	b8 00 00 00 00       	mov    $0x0,%eax
    ce4a:	0f 22 d8             	mov    %eax,%cr3
	return 0;
    ce4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ce52:	83 c4 28             	add    $0x28,%esp
    ce55:	5b                   	pop    %ebx
    ce56:	c3                   	ret    

0000ce57 <put_page>:
// 或者说是把线性地址空间中指定地址address处的页面映射到主内存区页面page上.主要工作是在相关页目录项和页表项中设置指定页面的信息.若成功则返回物理页面地址.
// 在处理缺页异常的C函数do_no_page()中会调用此函数.对于缺页引起的异常,由于任何缺页缘故而对页表作修改时,并不需要刷新CPU的页变换缓冲(或称Translation Lookaside
// Buffer,TLB),即使页表项中标志P被从0修改成1.因为无效页项不会被缓冲,因此当修改了一个无效的页表项时不需要刷新.在此就表现为不用调用Invalidate()函数.
// 参数page是分配的主内存区中某一页面(页帧,页框)的指针;address是线性地址.
static unsigned long put_page(unsigned long page, unsigned long address)
{
    ce57:	53                   	push   %ebx
    ce58:	83 ec 18             	sub    $0x18,%esp
    ce5b:	e8 9a 9e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    ce60:	81 c3 a0 51 02 00    	add    $0x251a0,%ebx
	/* 注意!!!这里使用了页目录表基地址pg_dir=0的条件 */

	// 首先判断参数给定物理内存页面page的有效性.如果该页面位置低于LOW_MEM(1MB)或超出系统实际含有内存高端HIGH_MEMORY,则发出警告.LOW_MEM是主内存区可能有的
	// 最小起始位置.当系统后果内存小于或等于6MB时,主内存区始于LOW_MEM处.再查看一下该page页面是不已经申请的页面,即判断其在内存页面映射字节图mem_map[]中相应
	// 字节是否以置位.若没有则需发出警告.
	if (page < LOW_MEM || page >= HIGH_MEMORY)
    ce66:	81 7c 24 20 ff ff 0f 	cmpl   $0xfffff,0x20(%esp)
    ce6d:	00 
    ce6e:	76 0c                	jbe    ce7c <put_page+0x25>
    ce70:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
    ce76:	39 44 24 20          	cmp    %eax,0x20(%esp)
    ce7a:	72 1a                	jb     ce96 <put_page+0x3f>
		printk("Trying to put page %p at %p\n", page, address);
    ce7c:	83 ec 04             	sub    $0x4,%esp
    ce7f:	ff 74 24 28          	pushl  0x28(%esp)
    ce83:	ff 74 24 28          	pushl  0x28(%esp)
    ce87:	8d 83 f8 4a ff ff    	lea    -0xb508(%ebx),%eax
    ce8d:	50                   	push   %eax
    ce8e:	e8 9f c4 ff ff       	call   9332 <printk>
    ce93:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page - LOW_MEM) >> 12] != 1)
    ce96:	8b 44 24 20          	mov    0x20(%esp),%eax
    ce9a:	2d 00 00 10 00       	sub    $0x100000,%eax
    ce9f:	c1 e8 0c             	shr    $0xc,%eax
    cea2:	0f b6 84 03 20 23 00 	movzbl 0x2320(%ebx,%eax,1),%eax
    cea9:	00 
    ceaa:	3c 01                	cmp    $0x1,%al
    ceac:	74 1a                	je     cec8 <put_page+0x71>
		printk("mem_map disagrees with %p at %p\n", page, address);
    ceae:	83 ec 04             	sub    $0x4,%esp
    ceb1:	ff 74 24 28          	pushl  0x28(%esp)
    ceb5:	ff 74 24 28          	pushl  0x28(%esp)
    ceb9:	8d 83 18 4b ff ff    	lea    -0xb4e8(%ebx),%eax
    cebf:	50                   	push   %eax
    cec0:	e8 6d c4 ff ff       	call   9332 <printk>
    cec5:	83 c4 10             	add    $0x10,%esp
	// 然后根据参数指定的线性地址address计算其在页目录表中对应的目录项指针,并从中取得一级页表地址.如果该目录项有效(P=1),即指定的页表在内存中,则从中取得指定页表
	// 地址放到page_table变量中.否则申请一空闲页面给页表使用,并在对应目录项中置相应标志(7 - User,U/S,R/W).然后将该页表地址放到page_table变量中.
	page_table = (unsigned long *) ((address >> 20) & 0xffc);
    cec8:	8b 44 24 24          	mov    0x24(%esp),%eax
    cecc:	c1 e8 14             	shr    $0x14,%eax
    cecf:	25 fc 0f 00 00       	and    $0xffc,%eax
    ced4:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if ((*page_table) & 1)
    ced8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cedc:	8b 00                	mov    (%eax),%eax
    cede:	83 e0 01             	and    $0x1,%eax
    cee1:	85 c0                	test   %eax,%eax
    cee3:	74 11                	je     cef6 <put_page+0x9f>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    cee5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cee9:	8b 00                	mov    (%eax),%eax
    ceeb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    cef0:	89 44 24 0c          	mov    %eax,0xc(%esp)
    cef4:	eb 2e                	jmp    cf24 <put_page+0xcd>
	else {
		if (!(tmp = get_free_page()))
    cef6:	e8 f1 10 00 00       	call   dfec <get_free_page>
    cefb:	89 44 24 08          	mov    %eax,0x8(%esp)
    ceff:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    cf04:	75 07                	jne    cf0d <put_page+0xb6>
			return 0;
    cf06:	b8 00 00 00 00       	mov    $0x0,%eax
    cf0b:	eb 3d                	jmp    cf4a <put_page+0xf3>
		*page_table = tmp | 7;
    cf0d:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf11:	83 c8 07             	or     $0x7,%eax
    cf14:	89 c2                	mov    %eax,%edx
    cf16:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cf1a:	89 10                	mov    %edx,(%eax)
		page_table = (unsigned long *) tmp;
    cf1c:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf20:	89 44 24 0c          	mov    %eax,0xc(%esp)
	}
	// 最后在找到的页表page_table中设置相关页表项内容,即把物理页面page的地址填入表项同时置位3个标志(U/S,W/R,P).该页表项在页表中的索引值等于线性地址位21~位12
	// 组成的10位的值.每个页表共可有1024项(0~0x3ff).
	page_table[(address >> 12) & 0x3ff] = page | 7;
    cf24:	8b 44 24 24          	mov    0x24(%esp),%eax
    cf28:	c1 e8 0c             	shr    $0xc,%eax
    cf2b:	25 ff 03 00 00       	and    $0x3ff,%eax
    cf30:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cf37:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cf3b:	01 d0                	add    %edx,%eax
    cf3d:	8b 54 24 20          	mov    0x20(%esp),%edx
    cf41:	83 ca 07             	or     $0x7,%edx
    cf44:	89 10                	mov    %edx,(%eax)
	/* no need for invalidate */
	/* 不需要刷新页变换高速缓冲 */
	return page;					// 返回物理页面地址.
    cf46:	8b 44 24 20          	mov    0x20(%esp),%eax
}
    cf4a:	83 c4 18             	add    $0x18,%esp
    cf4d:	5b                   	pop    %ebx
    cf4e:	c3                   	ret    

0000cf4f <put_dirty_page>:
 * 已修改状态标志.因而下面就有了与上面相同的函数,但是该函数在放置页面时会把页面标志为已修改状态.
 */
// 把一内容已修改过的物理内存页面映射到线性地址空间指定处.
// 该函数与一个函数put_page()几乎完全一样,除了本函数在第223行设置页表项内容时,同时还设置了页面已修改标志(位6,PAGE_DIRTY).
unsigned long put_dirty_page(unsigned long page, unsigned long address)
{
    cf4f:	53                   	push   %ebx
    cf50:	83 ec 18             	sub    $0x18,%esp
    cf53:	e8 a2 9d ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    cf58:	81 c3 a8 50 02 00    	add    $0x250a8,%ebx
	/* NOTE !!! This uses the fact that _pg_dir=0 */

	// 首先判断参数给定物理内存页面page的有效性.如果该页面位置低于LOW_MEM(1MB)或超出系统实际含有内存高端HIGH_MEMORY,则发出警告.LOW_MEM是主内存区可能有的
	// 最小起始位置.当系统后果内存小于或等于6MB时,主内存区始于LOW_MEM处.再查看一下该page页面是不已经申请的页面,即判断其在内存页面映射字节图mem_map[]中相应
	// 字节是否以置位.若没有则需发出警告.
	if (page < LOW_MEM || page >= HIGH_MEMORY)
    cf5e:	81 7c 24 20 ff ff 0f 	cmpl   $0xfffff,0x20(%esp)
    cf65:	00 
    cf66:	76 0c                	jbe    cf74 <put_dirty_page+0x25>
    cf68:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
    cf6e:	39 44 24 20          	cmp    %eax,0x20(%esp)
    cf72:	72 1a                	jb     cf8e <put_dirty_page+0x3f>
		printk("Trying to put page %p at %p\n", page, address);
    cf74:	83 ec 04             	sub    $0x4,%esp
    cf77:	ff 74 24 28          	pushl  0x28(%esp)
    cf7b:	ff 74 24 28          	pushl  0x28(%esp)
    cf7f:	8d 83 f8 4a ff ff    	lea    -0xb508(%ebx),%eax
    cf85:	50                   	push   %eax
    cf86:	e8 a7 c3 ff ff       	call   9332 <printk>
    cf8b:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page-LOW_MEM)>>12] != 1)
    cf8e:	8b 44 24 20          	mov    0x20(%esp),%eax
    cf92:	2d 00 00 10 00       	sub    $0x100000,%eax
    cf97:	c1 e8 0c             	shr    $0xc,%eax
    cf9a:	0f b6 84 03 20 23 00 	movzbl 0x2320(%ebx,%eax,1),%eax
    cfa1:	00 
    cfa2:	3c 01                	cmp    $0x1,%al
    cfa4:	74 1a                	je     cfc0 <put_dirty_page+0x71>
		printk("mem_map disagrees with %p at %p\n", page, address);
    cfa6:	83 ec 04             	sub    $0x4,%esp
    cfa9:	ff 74 24 28          	pushl  0x28(%esp)
    cfad:	ff 74 24 28          	pushl  0x28(%esp)
    cfb1:	8d 83 18 4b ff ff    	lea    -0xb4e8(%ebx),%eax
    cfb7:	50                   	push   %eax
    cfb8:	e8 75 c3 ff ff       	call   9332 <printk>
    cfbd:	83 c4 10             	add    $0x10,%esp
	// 然后根据参数指定的线性地址address计算其在页目录表中对应的目录项指针,并从中取得一级页表地址.如果该目录项有效(P=1),即指定的页表在内存中,则从中取得指定页表
	// 地址放到page_table变量中.否则申请一空闲页面给页表使用,并在对应目录项中置相应标志(7 - User,U/S,R/W).然后将该页表地址放到page_table变量中.
	page_table = (unsigned long *) ((address >> 20) & 0xffc);
    cfc0:	8b 44 24 24          	mov    0x24(%esp),%eax
    cfc4:	c1 e8 14             	shr    $0x14,%eax
    cfc7:	25 fc 0f 00 00       	and    $0xffc,%eax
    cfcc:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if ((*page_table) & 1)
    cfd0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cfd4:	8b 00                	mov    (%eax),%eax
    cfd6:	83 e0 01             	and    $0x1,%eax
    cfd9:	85 c0                	test   %eax,%eax
    cfdb:	74 11                	je     cfee <put_dirty_page+0x9f>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    cfdd:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cfe1:	8b 00                	mov    (%eax),%eax
    cfe3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    cfe8:	89 44 24 0c          	mov    %eax,0xc(%esp)
    cfec:	eb 2e                	jmp    d01c <put_dirty_page+0xcd>
	else {
		if (!(tmp = get_free_page()))
    cfee:	e8 f9 0f 00 00       	call   dfec <get_free_page>
    cff3:	89 44 24 08          	mov    %eax,0x8(%esp)
    cff7:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    cffc:	75 07                	jne    d005 <put_dirty_page+0xb6>
			return 0;
    cffe:	b8 00 00 00 00       	mov    $0x0,%eax
    d003:	eb 3d                	jmp    d042 <put_dirty_page+0xf3>
		*page_table = tmp | 7;
    d005:	8b 44 24 08          	mov    0x8(%esp),%eax
    d009:	83 c8 07             	or     $0x7,%eax
    d00c:	89 c2                	mov    %eax,%edx
    d00e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d012:	89 10                	mov    %edx,(%eax)
		page_table = (unsigned long *) tmp;
    d014:	8b 44 24 08          	mov    0x8(%esp),%eax
    d018:	89 44 24 0c          	mov    %eax,0xc(%esp)
	}
	// 最后在找到的页表page_table中设置相关页表项内容,即把物理页面page的地址填入表项同时置位3个标志(U/S,W/R,P).该页表项在页表中的索引值等于线性地址位21~位12
	// 组成的10位的值.每个页表共可有1024项(0~0x3ff).
	page_table[(address >> 12) & 0x3ff] = page | (PAGE_DIRTY | 7);
    d01c:	8b 44 24 24          	mov    0x24(%esp),%eax
    d020:	c1 e8 0c             	shr    $0xc,%eax
    d023:	25 ff 03 00 00       	and    $0x3ff,%eax
    d028:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d02f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d033:	01 d0                	add    %edx,%eax
    d035:	8b 54 24 20          	mov    0x20(%esp),%edx
    d039:	83 ca 47             	or     $0x47,%edx
    d03c:	89 10                	mov    %edx,(%eax)
	/* no need for invalidate */
	/* 不需要刷新页变换高速缓冲 */
	return page;
    d03e:	8b 44 24 20          	mov    0x20(%esp),%eax
}
    d042:	83 c4 18             	add    $0x18,%esp
    d045:	5b                   	pop    %ebx
    d046:	c3                   	ret    

0000d047 <un_wp_page>:
// 用于页异常中断过程中写保护异常的处理(写时复制).在内核创建进程时,新进程与父进程被设置成共享代码和数据内存页面,并且所有这些页面均被设置成只读页面.而当新进程或原
// 进程需要向内存页面写数据时,CPU就会检测到这个情况并产生页面写保护异常.于是在这个函数中内核就会首先判断要写的页面是否被共享.若没有则把页面设置成可写然后退出.若页面
// 处于共享状态,则要重新申请一新页面并复制被写页面内容,以供写进程单独使用.共享被取消.
// 输入参数为页面表项指针,是物理地址.[un_wp_page -- Un-Write Protect Page]
void un_wp_page(unsigned long * table_entry)
{
    d047:	57                   	push   %edi
    d048:	56                   	push   %esi
    d049:	53                   	push   %ebx
    d04a:	83 ec 10             	sub    $0x10,%esp
    d04d:	e8 a8 9c ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    d052:	81 c3 ae 4f 02 00    	add    $0x24fae,%ebx
	unsigned long old_page, new_page;

	// 首先取参数指定的页表项中物理页面位置(地址)并判断该页面是不是共享页面.如果原页面地址大于内存低端LOW_MEM(表示在主内存区中),并且其在页面映射字节图数组中值为1(表示
	// 页面仅被引用1次,页面没有被共享),则在该页面的页表项中 R/W标志(可写),并刷新页变换高速缓冲,然后返回.即如果该内存页面此时只被一个进程使用,并且不是内核中的进程,就直接
	// 把属性改为可写即可,不必重新申请一个新页面.
	old_page = 0xfffff000 & *table_entry;				// 取指定页表项中物理页面地址.
    d058:	8b 44 24 20          	mov    0x20(%esp),%eax
    d05c:	8b 00                	mov    (%eax),%eax
    d05e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    d063:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)] == 1) {
    d067:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
    d06e:	00 
    d06f:	76 33                	jbe    d0a4 <un_wp_page+0x5d>
    d071:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d075:	2d 00 00 10 00       	sub    $0x100000,%eax
    d07a:	c1 e8 0c             	shr    $0xc,%eax
    d07d:	0f b6 84 03 20 23 00 	movzbl 0x2320(%ebx,%eax,1),%eax
    d084:	00 
    d085:	3c 01                	cmp    $0x1,%al
    d087:	75 1b                	jne    d0a4 <un_wp_page+0x5d>
		*table_entry |= 2;
    d089:	8b 44 24 20          	mov    0x20(%esp),%eax
    d08d:	8b 00                	mov    (%eax),%eax
    d08f:	83 c8 02             	or     $0x2,%eax
    d092:	89 c2                	mov    %eax,%edx
    d094:	8b 44 24 20          	mov    0x20(%esp),%eax
    d098:	89 10                	mov    %edx,(%eax)
		invalidate();
    d09a:	b8 00 00 00 00       	mov    $0x0,%eax
    d09f:	0f 22 d8             	mov    %eax,%cr3
		return;
    d0a2:	eb 6c                	jmp    d110 <un_wp_page+0xc9>
	}
	// 否则就需要在主内存区内申请一页空闲页面给执行写操作的进程单独使用,取消页面共享.如果原页面大于内存低端(则意味着mem_map[]>1,页面是共享的),则将原页面的页面映射字节数组
	// 值递减1.然后将指定页表项内容更新为新页面地址,并置可读写标志(U/S,R/W,P).在刷新页变换高速缓冲之后,最后将原页面内容复制到新页面.
	if (!(new_page = get_free_page()))
    d0a4:	e8 43 0f 00 00       	call   dfec <get_free_page>
    d0a9:	89 44 24 08          	mov    %eax,0x8(%esp)
    d0ad:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    d0b2:	75 05                	jne    d0b9 <un_wp_page+0x72>
		oom();											// 内存不够处理.
    d0b4:	e8 82 f9 ff ff       	call   ca3b <oom>
	if (old_page >= LOW_MEM)
    d0b9:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
    d0c0:	00 
    d0c1:	76 1e                	jbe    d0e1 <un_wp_page+0x9a>
		mem_map[MAP_NR(old_page)]--;
    d0c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d0c7:	2d 00 00 10 00       	sub    $0x100000,%eax
    d0cc:	c1 e8 0c             	shr    $0xc,%eax
    d0cf:	0f b6 94 03 20 23 00 	movzbl 0x2320(%ebx,%eax,1),%edx
    d0d6:	00 
    d0d7:	83 ea 01             	sub    $0x1,%edx
    d0da:	88 94 03 20 23 00 00 	mov    %dl,0x2320(%ebx,%eax,1)
	copy_page(old_page, new_page);
    d0e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d0e5:	8b 54 24 08          	mov    0x8(%esp),%edx
    d0e9:	b9 00 04 00 00       	mov    $0x400,%ecx
    d0ee:	89 c6                	mov    %eax,%esi
    d0f0:	89 d7                	mov    %edx,%edi
    d0f2:	57                   	push   %edi
    d0f3:	56                   	push   %esi
    d0f4:	fc                   	cld    
    d0f5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    d0f7:	5e                   	pop    %esi
    d0f8:	5f                   	pop    %edi
	// 将新的页面设置为可读可写且存在
	*table_entry = new_page | 7;
    d0f9:	8b 44 24 08          	mov    0x8(%esp),%eax
    d0fd:	83 c8 07             	or     $0x7,%eax
    d100:	89 c2                	mov    %eax,%edx
    d102:	8b 44 24 20          	mov    0x20(%esp),%eax
    d106:	89 10                	mov    %edx,(%eax)
	// 刷新高速缓冲
	invalidate();
    d108:	b8 00 00 00 00       	mov    $0x0,%eax
    d10d:	0f 22 d8             	mov    %eax,%cr3
}
    d110:	83 c4 10             	add    $0x10,%esp
    d113:	5b                   	pop    %ebx
    d114:	5e                   	pop    %esi
    d115:	5f                   	pop    %edi
    d116:	c3                   	ret    

0000d117 <do_wp_page>:
// 执行写保护页面处理.
// 是写共享页面处理函数.是页异常中断处理过程中调用的C函数.在page.s程序中被调用.
// 函数参数error_code和address是进程在写写保护页面时由CPU产生异常而自动生成的.error_code指出出错类型;address是产生异常的页面
// 线性地址.写共享页面时需复制页面(写时复制).
void do_wp_page(unsigned long error_code, unsigned long address)
{
    d117:	53                   	push   %ebx
    d118:	83 ec 08             	sub    $0x8,%esp
    d11b:	e8 da 9b ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    d120:	81 c3 e0 4e 02 00    	add    $0x24ee0,%ebx
	// 首先判断CPU控制寄存器CR2给出的引起页面异常的线性地址在什么范围中.如果address小于TASK_SIZE(0x4000000,即64MB),表示异常页面位置
	// 在内核或任务0和任务1所处的线性地址范围内,于是发出警告信息"内核范围内存被写保护";如果(address - 当前进程代码起始地址)大于一个进程的
	// 长度(64MB),表示address所指的线性地址不在引起异常的进程线性地址空间范围内,则在发出出错信息后退出.
	if (address < TASK_SIZE)
    d126:	81 7c 24 14 ff ff ff 	cmpl   $0x3ffffff,0x14(%esp)
    d12d:	03 
    d12e:	77 12                	ja     d142 <do_wp_page+0x2b>
		printk("\n\rBAD! KERNEL MEMORY WP-ERR!\n\r");
    d130:	83 ec 0c             	sub    $0xc,%esp
    d133:	8d 83 3c 4b ff ff    	lea    -0xb4c4(%ebx),%eax
    d139:	50                   	push   %eax
    d13a:	e8 f3 c1 ff ff       	call   9332 <printk>
    d13f:	83 c4 10             	add    $0x10,%esp
	if (address - current->start_code > TASK_SIZE) {
    d142:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d148:	8b 00                	mov    (%eax),%eax
    d14a:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    d150:	8b 54 24 14          	mov    0x14(%esp),%edx
    d154:	29 c2                	sub    %eax,%edx
    d156:	89 d0                	mov    %edx,%eax
    d158:	3d 00 00 00 04       	cmp    $0x4000000,%eax
    d15d:	76 1f                	jbe    d17e <do_wp_page+0x67>
		printk("Bad things happen: page error in do_wp_page\n\r");
    d15f:	83 ec 0c             	sub    $0xc,%esp
    d162:	8d 83 5c 4b ff ff    	lea    -0xb4a4(%ebx),%eax
    d168:	50                   	push   %eax
    d169:	e8 c4 c1 ff ff       	call   9332 <printk>
    d16e:	83 c4 10             	add    $0x10,%esp
		do_exit(SIGSEGV);
    d171:	83 ec 0c             	sub    $0xc,%esp
    d174:	6a 0b                	push   $0xb
    d176:	e8 e9 e7 ff ff       	call   b964 <do_exit>
    d17b:	83 c4 10             	add    $0x10,%esp
	// 目录项索引值中最后2位.因为只移动了20位,因此最后2位是页表索引的内容,应该屏蔽掉.而*((address>>20)&0xffc)则是取指定目录表项内容中对应页表
	// 的物理地址.最后与上0xffffff000用于屏蔽掉页目录项内容中的一些标志位(目录项低12位).直观表示为(0xffffff000 & *((unsigned long *) (((
	// address>>22) & 0x3ff)<<2))).3:由1中页表项在页表中偏移地址加上2中目录表项内容中对应页表的物理地址即可得到页表项的指针(物理地址).这里对
	// 共享的页面进行复制.
	un_wp_page((unsigned long *)
		(((address >> 10) & 0xffc) + (0xfffff000 &
    d17e:	8b 44 24 14          	mov    0x14(%esp),%eax
    d182:	c1 e8 0a             	shr    $0xa,%eax
    d185:	25 fc 0f 00 00       	and    $0xffc,%eax
    d18a:	89 c2                	mov    %eax,%edx
		*((unsigned long *) ((address >> 20) & 0xffc)))));
    d18c:	8b 44 24 14          	mov    0x14(%esp),%eax
    d190:	c1 e8 14             	shr    $0x14,%eax
    d193:	25 fc 0f 00 00       	and    $0xffc,%eax
    d198:	8b 00                	mov    (%eax),%eax
		(((address >> 10) & 0xffc) + (0xfffff000 &
    d19a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    d19f:	09 d0                	or     %edx,%eax
	un_wp_page((unsigned long *)
    d1a1:	83 ec 0c             	sub    $0xc,%esp
    d1a4:	50                   	push   %eax
    d1a5:	e8 9d fe ff ff       	call   d047 <un_wp_page>
    d1aa:	83 c4 10             	add    $0x10,%esp

}
    d1ad:	90                   	nop
    d1ae:	83 c4 08             	add    $0x8,%esp
    d1b1:	5b                   	pop    %ebx
    d1b2:	c3                   	ret    

0000d1b3 <write_verify>:

// 写页面验证.
// 若页面不可写,则复制页面.在fork.c中被内存验证通用函数verify_area()调用.
// 参数address是指定页面在4GB空间中的线性地址.
void write_verify(unsigned long address)
{
    d1b3:	83 ec 1c             	sub    $0x1c,%esp
    d1b6:	e8 37 9b ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    d1bb:	05 45 4e 02 00       	add    $0x24e45,%eax

	// 首先取指定线性地址对应的页目录项,根据目录项中的存在位(P)判断目录项对应的页表是否存在(存在位P=1?),若不存在(P=0)则返回.这样处理
	// 是因为对于不存在的页面没有共享和写时复制可言,并且若程序对此不存在的页面执行写操作时,系统就会因为缺页异常而去执行do_no_page(),
	// 并为这个地方使用put_page()函数映射一个物理页面.接着程序从目录项中取页表地址,加上指定页面在页表中的页表项偏移值,得对应地址的页表
	// 项指针.在该表项中包含着给定线性地址对应的物理页面.
	if (!( (page = *((unsigned long *) ((address >> 20) & 0xffc)) ) & 1))
    d1c0:	8b 44 24 20          	mov    0x20(%esp),%eax
    d1c4:	c1 e8 14             	shr    $0x14,%eax
    d1c7:	25 fc 0f 00 00       	and    $0xffc,%eax
    d1cc:	8b 00                	mov    (%eax),%eax
    d1ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d1d2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d1d6:	83 e0 01             	and    $0x1,%eax
    d1d9:	85 c0                	test   %eax,%eax
    d1db:	74 39                	je     d216 <write_verify+0x63>
		return;
	page &= 0xfffff000;
    d1dd:	81 64 24 0c 00 f0 ff 	andl   $0xfffff000,0xc(%esp)
    d1e4:	ff 
	// 得到页表项的物理地址
	page += ((address >> 10) & 0xffc);
    d1e5:	8b 44 24 20          	mov    0x20(%esp),%eax
    d1e9:	c1 e8 0a             	shr    $0xa,%eax
    d1ec:	25 fc 0f 00 00       	and    $0xffc,%eax
    d1f1:	01 44 24 0c          	add    %eax,0xc(%esp)
	// 然后判断该页表项中位1(P/W),位0(P)标志.如果该页面不可写(R/W=0)且存在,那么就执行共享检验和复制页面操作(写时复制).否则什么也不做,
	// 直接退出.
	if ((3 & *(unsigned long *) page) == 1)  /* non-writeable, present */
    d1f5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d1f9:	8b 00                	mov    (%eax),%eax
    d1fb:	83 e0 03             	and    $0x3,%eax
    d1fe:	83 f8 01             	cmp    $0x1,%eax
    d201:	75 16                	jne    d219 <write_verify+0x66>
		un_wp_page((unsigned long *) page);
    d203:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d207:	83 ec 0c             	sub    $0xc,%esp
    d20a:	50                   	push   %eax
    d20b:	e8 37 fe ff ff       	call   d047 <un_wp_page>
    d210:	83 c4 10             	add    $0x10,%esp
	return;
    d213:	90                   	nop
    d214:	eb 03                	jmp    d219 <write_verify+0x66>
		return;
    d216:	90                   	nop
    d217:	eb 01                	jmp    d21a <write_verify+0x67>
	return;
    d219:	90                   	nop
}
    d21a:	83 c4 1c             	add    $0x1c,%esp
    d21d:	c3                   	ret    

0000d21e <get_empty_page>:

// 取得一页空闲内存并映射到指定线性地址处.
// get_free_page()仅是申请取得了主内存区的一页物理内存.而本函数则不仅是获取到一页物理内存页面,还进一步调用put_page(),将物理页面映射到指定的线性地址处.
// 参数address是指定页面的线性地址.
void get_empty_page(unsigned long address)
{
    d21e:	53                   	push   %ebx
    d21f:	83 ec 18             	sub    $0x18,%esp
    d222:	e8 cb 9a ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    d227:	05 d9 4d 02 00       	add    $0x24dd9,%eax
	unsigned long tmp;

	// 若不能取得一空闲页面,或者不能将所取页面放置到指定地址处,则显示内存不够的信息.292行上英文注释的含义是:free_page()函数的参数tmp是0也没有关系,该函数会忽略它
	// 并能正常返回.
	if (!(tmp = get_free_page()) || !put_page(tmp, address)) {
    d22c:	89 c3                	mov    %eax,%ebx
    d22e:	e8 b9 0d 00 00       	call   dfec <get_free_page>
    d233:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d237:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    d23c:	74 17                	je     d255 <get_empty_page+0x37>
    d23e:	83 ec 08             	sub    $0x8,%esp
    d241:	ff 74 24 28          	pushl  0x28(%esp)
    d245:	ff 74 24 18          	pushl  0x18(%esp)
    d249:	e8 09 fc ff ff       	call   ce57 <put_page>
    d24e:	83 c4 10             	add    $0x10,%esp
    d251:	85 c0                	test   %eax,%eax
    d253:	75 14                	jne    d269 <get_empty_page+0x4b>
		free_page(tmp);		/* 0 is ok - ignored */
    d255:	83 ec 0c             	sub    $0xc,%esp
    d258:	ff 74 24 18          	pushl  0x18(%esp)
    d25c:	e8 0e f8 ff ff       	call   ca6f <free_page>
    d261:	83 c4 10             	add    $0x10,%esp
		oom();
    d264:	e8 d2 f7 ff ff       	call   ca3b <oom>
	}
}
    d269:	90                   	nop
    d26a:	83 c4 18             	add    $0x18,%esp
    d26d:	5b                   	pop    %ebx
    d26e:	c3                   	ret    

0000d26f <try_to_share>:
// 段内容作过修改那么数据段内容也应一样。参数address是进程中的逻辑地址，即是当前进程欲与p进程共享页面的逻辑页面地址。进程
// p是将被共享页面的进程。如果p进程address处的页面存在并且没有被修改过的话，就让当前进程与p进程共享之。同时还需要验证指定
// 的地址处是否已经申请了页面，若是则出错，死机。
// 返回：1 - 页面共享处理成功；0 - 失败。
static int try_to_share(unsigned long address, struct task_struct * p)
{
    d26f:	53                   	push   %ebx
    d270:	83 ec 28             	sub    $0x28,%esp
    d273:	e8 82 9a ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    d278:	81 c3 88 4d 02 00    	add    $0x24d88,%ebx

	// 首先分别求得指定进程p中和当前进程中逻辑地址address对应的页目录项。为了计算方便先求出指定逻辑地址address处的“逻辑”页
	// 目录号，即以进程空间（0 - 64MB）算出的页目录项号。该“逻辑”页目录项号加上进程p在CPU 4GB线性空间中起始地址对应的页目录
	// 项，即得到进程p中地址address处页面所对应的4GB线性空间中实际页目录项from_page。而“逻辑”页目录项号加上当前进程CPU 4GB
	// 线性空间中的实际页目录项to_page。
	from_page = to_page = ((address >> 20) & 0xffc);
    d27e:	8b 44 24 30          	mov    0x30(%esp),%eax
    d282:	c1 e8 14             	shr    $0x14,%eax
    d285:	25 fc 0f 00 00       	and    $0xffc,%eax
    d28a:	89 44 24 18          	mov    %eax,0x18(%esp)
    d28e:	8b 44 24 18          	mov    0x18(%esp),%eax
    d292:	89 44 24 14          	mov    %eax,0x14(%esp)
	from_page += ((p->start_code >> 20) & 0xffc);             		// p进程目录项。
    d296:	8b 44 24 34          	mov    0x34(%esp),%eax
    d29a:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    d2a0:	c1 e8 14             	shr    $0x14,%eax
    d2a3:	25 fc 0f 00 00       	and    $0xffc,%eax
    d2a8:	01 44 24 14          	add    %eax,0x14(%esp)
	to_page += ((current->start_code >> 20) & 0xffc);         		// 当前进程目录项。
    d2ac:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d2b2:	8b 00                	mov    (%eax),%eax
    d2b4:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    d2ba:	c1 e8 14             	shr    $0x14,%eax
    d2bd:	25 fc 0f 00 00       	and    $0xffc,%eax
    d2c2:	01 44 24 18          	add    %eax,0x18(%esp)
	// address对应的物理内在页面地址，并且该物理页面存在，而且干净（没有被修改过，不脏）。
	// 方法是先取目录项内容。如果该目录项元效（P=0），表示目录项对应的二级页表不存在，于是返回。否则取该目录项对应页表地址from，
	// 从而计算出逻辑地址address对应的页表项指针，并取出该面表项内容临时保存在phys_addr中。
	/* is there a page-directory at from? */
	/* 在from处是否存在页目录项？ */
	from = *(unsigned long *) from_page;                    		// p进程目录项内容。
    d2c6:	8b 44 24 14          	mov    0x14(%esp),%eax
    d2ca:	8b 00                	mov    (%eax),%eax
    d2cc:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!(from & 1))
    d2d0:	8b 44 24 10          	mov    0x10(%esp),%eax
    d2d4:	83 e0 01             	and    $0x1,%eax
    d2d7:	85 c0                	test   %eax,%eax
    d2d9:	75 0a                	jne    d2e5 <try_to_share+0x76>
		return 0;
    d2db:	b8 00 00 00 00       	mov    $0x0,%eax
    d2e0:	e9 35 01 00 00       	jmp    d41a <try_to_share+0x1ab>
	from &= 0xfffff000;                                     		// 页表地址。
    d2e5:	81 64 24 10 00 f0 ff 	andl   $0xfffff000,0x10(%esp)
    d2ec:	ff 
	from_page = from + ((address >> 10) & 0xffc);             		// 页表项指针。
    d2ed:	8b 44 24 30          	mov    0x30(%esp),%eax
    d2f1:	c1 e8 0a             	shr    $0xa,%eax
    d2f4:	25 fc 0f 00 00       	and    $0xffc,%eax
    d2f9:	89 c2                	mov    %eax,%edx
    d2fb:	8b 44 24 10          	mov    0x10(%esp),%eax
    d2ff:	01 d0                	add    %edx,%eax
    d301:	89 44 24 14          	mov    %eax,0x14(%esp)
	phys_addr = *(unsigned long *) from_page;               		// 页表项内容。
    d305:	8b 44 24 14          	mov    0x14(%esp),%eax
    d309:	8b 00                	mov    (%eax),%eax
    d30b:	89 44 24 0c          	mov    %eax,0xc(%esp)
	// 接着看看页表项映射的物理页面是否存在并且干净。0x41对应页表项中的D（Dirty）和P（present）标志。如果页面不干净或无效则返回。
	// 然后我们从该表项中取出物理页面地址再保存在phys_addr中。最后我们再检查一下这个物理页面地址的有效性，即它不应该超过机器最大
	// 物理地址值，也不应该小于内在低端（1MB）。
	/* is the page clean and present? */
	/* 物理页面干净并且存在吗？ */
	if ((phys_addr & 0x41) != 0x01)
    d30f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d313:	83 e0 41             	and    $0x41,%eax
    d316:	83 f8 01             	cmp    $0x1,%eax
    d319:	74 0a                	je     d325 <try_to_share+0xb6>
		return 0;
    d31b:	b8 00 00 00 00       	mov    $0x0,%eax
    d320:	e9 f5 00 00 00       	jmp    d41a <try_to_share+0x1ab>
	phys_addr &= 0xfffff000;                                		// 物理页面地址。
    d325:	81 64 24 0c 00 f0 ff 	andl   $0xfffff000,0xc(%esp)
    d32c:	ff 
	if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
    d32d:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
    d333:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    d337:	73 0a                	jae    d343 <try_to_share+0xd4>
    d339:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
    d340:	00 
    d341:	77 0a                	ja     d34d <try_to_share+0xde>
		return 0;
    d343:	b8 00 00 00 00       	mov    $0x0,%eax
    d348:	e9 cd 00 00 00       	jmp    d41a <try_to_share+0x1ab>
	// 下面首先对当前进程的表项进行操作。目标是取得当前进程中address对应的页表项地址，并且该页表项还没有映射物理页面，即其P=0。
	// 首先取当前进程页目录项内容->to。如果该目录项元效（P=0），即目录项对应的二级页表不存在，则申请一空闲页面来存放页表，并更新
	// 目录项to_page内容，让其指向该内存页面。
	to = *(unsigned long *) to_page;                        		// 当前进程目录项内容。
    d34d:	8b 44 24 18          	mov    0x18(%esp),%eax
    d351:	8b 00                	mov    (%eax),%eax
    d353:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!(to & 1))
    d357:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d35b:	83 e0 01             	and    $0x1,%eax
    d35e:	85 c0                	test   %eax,%eax
    d360:	75 24                	jne    d386 <try_to_share+0x117>
		if (to = get_free_page())
    d362:	e8 85 0c 00 00       	call   dfec <get_free_page>
    d367:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    d36b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    d370:	74 0f                	je     d381 <try_to_share+0x112>
			*(unsigned long *) to_page = to | 7;
    d372:	8b 44 24 18          	mov    0x18(%esp),%eax
    d376:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d37a:	83 ca 07             	or     $0x7,%edx
    d37d:	89 10                	mov    %edx,(%eax)
    d37f:	eb 05                	jmp    d386 <try_to_share+0x117>
		else
			oom();
    d381:	e8 b5 f6 ff ff       	call   ca3b <oom>
	// 否则取目录项中的页表地址->to，加上页表索引值<<2，即页表项在表中偏移地址，得到页表项地址->to_page。针对该页表项，如果
	// 此时我们检查出其对应的物理页面已经存在，即页表项的存在位P=1,则说明原本我们想共享进程p中对应的物理页面，但现在我们自己已经
	// 占有了（映射有）物理页面。于是说明内核出错，死机。
	to &= 0xfffff000;                                       		// 当前进程的页表地址。
    d386:	81 64 24 1c 00 f0 ff 	andl   $0xfffff000,0x1c(%esp)
    d38d:	ff 
	to_page = to + ((address >> 10) & 0xffc);                 		// 当前进程的页表项地址。
    d38e:	8b 44 24 30          	mov    0x30(%esp),%eax
    d392:	c1 e8 0a             	shr    $0xa,%eax
    d395:	25 fc 0f 00 00       	and    $0xffc,%eax
    d39a:	89 c2                	mov    %eax,%edx
    d39c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d3a0:	01 d0                	add    %edx,%eax
    d3a2:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (1 & *(unsigned long *) to_page)
    d3a6:	8b 44 24 18          	mov    0x18(%esp),%eax
    d3aa:	8b 00                	mov    (%eax),%eax
    d3ac:	83 e0 01             	and    $0x1,%eax
    d3af:	85 c0                	test   %eax,%eax
    d3b1:	74 12                	je     d3c5 <try_to_share+0x156>
		panic("try_to_share: to_page already exists");
    d3b3:	83 ec 0c             	sub    $0xc,%esp
    d3b6:	8d 83 8c 4b ff ff    	lea    -0xb474(%ebx),%eax
    d3bc:	50                   	push   %eax
    d3bd:	e8 1c bf ff ff       	call   92de <panic>
    d3c2:	83 c4 10             	add    $0x10,%esp
	/* share them: write-protect */
	/* 对它们进行共享处理：写保护区*/
	*(unsigned long *) from_page &= ~2;
    d3c5:	8b 44 24 14          	mov    0x14(%esp),%eax
    d3c9:	8b 10                	mov    (%eax),%edx
    d3cb:	8b 44 24 14          	mov    0x14(%esp),%eax
    d3cf:	83 e2 fd             	and    $0xfffffffd,%edx
    d3d2:	89 10                	mov    %edx,(%eax)
	*(unsigned long *) to_page = *(unsigned long *) from_page;
    d3d4:	8b 54 24 14          	mov    0x14(%esp),%edx
    d3d8:	8b 44 24 18          	mov    0x18(%esp),%eax
    d3dc:	8b 12                	mov    (%edx),%edx
    d3de:	89 10                	mov    %edx,(%eax)
	// 随后刷新页变换高速缓冲。计算所操作物理页面的页面号，并将对应页面映射字节数组项中的引用递增1.最后返回1,表示共享处理成功。
	invalidate();
    d3e0:	b8 00 00 00 00       	mov    $0x0,%eax
    d3e5:	0f 22 d8             	mov    %eax,%cr3
	phys_addr -= LOW_MEM;
    d3e8:	81 6c 24 0c 00 00 10 	subl   $0x100000,0xc(%esp)
    d3ef:	00 
	phys_addr >>= 12;                       						// 得页面号。
    d3f0:	c1 6c 24 0c 0c       	shrl   $0xc,0xc(%esp)
	mem_map[phys_addr]++;
    d3f5:	8d 93 20 23 00 00    	lea    0x2320(%ebx),%edx
    d3fb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d3ff:	01 d0                	add    %edx,%eax
    d401:	0f b6 00             	movzbl (%eax),%eax
    d404:	8d 50 01             	lea    0x1(%eax),%edx
    d407:	8d 8b 20 23 00 00    	lea    0x2320(%ebx),%ecx
    d40d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d411:	01 c8                	add    %ecx,%eax
    d413:	88 10                	mov    %dl,(%eax)
	return 1;
    d415:	b8 01 00 00 00       	mov    $0x1,%eax
}
    d41a:	83 c4 28             	add    $0x28,%esp
    d41d:	5b                   	pop    %ebx
    d41e:	c3                   	ret    

0000d41f <share_page>:
// 点.根据该i节点的引用次数i_count我们可以进行这种判断.若节点的i_count值大于1,则表明系统中有两个进程正在运行同一个执行文件(或库
// 文件),于是可以再对任务结构数组中所有任务比较是否有相同的executable字段(或library字段)来最后确定多个进程运行着相同执行文件的
// 情况.参数inode是欲进行共享页面进程执行文件的内存i节点.address是进程中的逻辑地址,即当前进程欲与p进程共享页面的逻辑页面地址.返
// 回1 - 共享操作成功,0 - 失败.
static int share_page(struct m_inode * inode, unsigned long address)
{
    d41f:	53                   	push   %ebx
    d420:	83 ec 18             	sub    $0x18,%esp
    d423:	e8 d2 98 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    d428:	81 c3 d8 4b 02 00    	add    $0x24bd8,%ebx
	struct task_struct ** p;

	// 首先检查一下参数指定的内存i节点引用计数值.如果该内存i节点的引用计数值等于1(executalbe->i_count=1)或者i节点指针空,表示当前系
	// 统中只有1个进程在运行该执行文件或者提供的i节点无效.因此无共享可言,直接退出函数.
	if (inode->i_count < 2 || !inode)
    d42e:	8b 44 24 20          	mov    0x20(%esp),%eax
    d432:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    d436:	66 83 f8 01          	cmp    $0x1,%ax
    d43a:	76 07                	jbe    d443 <share_page+0x24>
    d43c:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    d441:	75 0a                	jne    d44d <share_page+0x2e>
		return 0;
    d443:	b8 00 00 00 00       	mov    $0x0,%eax
    d448:	e9 a0 00 00 00       	jmp    d4ed <share_page+0xce>
	// 辑地址address小于进程库文件在逻辑地址空间的起始地址LIBRARY_OFFSET,则表明共享的页面在进程执行文件对应的逻辑地址空间范围内,于是
	// 检查一下指定i节点是否与进程的执行文件i节点(即进程executable相同,若不相同则继续寻找.若进程逻辑地址address大于等于进程库文件在
	// 逻辑地址空间的起始地址LIBRARY_OFFSET,则表明想要共享的页面在进程使用的库文件中,于是检查指定节点inode是否与进程的库文件i节点相同,
	// 若不相同则继续寻找.如果找到某个进程p,其executable或library与指定的节点inode相同,则调用页面试探函数try_to_share()尝试页面共
	// 享.若共享操作成功,则函数返回1.否则返回0,表示共享页面操作失败.
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    d44d:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    d453:	8d 80 fc 00 00 00    	lea    0xfc(%eax),%eax
    d459:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d45d:	eb 79                	jmp    d4d8 <share_page+0xb9>
		if (!*p)								// 如果该任务项空闲,则继续寻找.
    d45f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d463:	8b 00                	mov    (%eax),%eax
    d465:	85 c0                	test   %eax,%eax
    d467:	74 63                	je     d4cc <share_page+0xad>
			continue;
		if (current == *p)						// 如果是当前任务,也继续寻找.
    d469:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d46d:	8b 10                	mov    (%eax),%edx
    d46f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d475:	8b 00                	mov    (%eax),%eax
    d477:	39 c2                	cmp    %eax,%edx
    d479:	74 54                	je     d4cf <share_page+0xb0>
			continue;
		if (address < LIBRARY_OFFSET) {
    d47b:	81 7c 24 24 ff ff bf 	cmpl   $0x3bfffff,0x24(%esp)
    d482:	03 
    d483:	77 14                	ja     d499 <share_page+0x7a>
			if (inode != (*p)->executable)		// 进程执行文件i节点.
    d485:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d489:	8b 00                	mov    (%eax),%eax
    d48b:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
    d491:	39 44 24 20          	cmp    %eax,0x20(%esp)
    d495:	74 14                	je     d4ab <share_page+0x8c>
				continue;
    d497:	eb 3a                	jmp    d4d3 <share_page+0xb4>
		} else {
			if (inode != (*p)->library)			// 进程使用库文件i节点.
    d499:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d49d:	8b 00                	mov    (%eax),%eax
    d49f:	8b 80 40 03 00 00    	mov    0x340(%eax),%eax
    d4a5:	39 44 24 20          	cmp    %eax,0x20(%esp)
    d4a9:	75 27                	jne    d4d2 <share_page+0xb3>
				continue;
		}
		if (try_to_share(address, *p))			// 尝试共享页面.
    d4ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d4af:	8b 00                	mov    (%eax),%eax
    d4b1:	83 ec 08             	sub    $0x8,%esp
    d4b4:	50                   	push   %eax
    d4b5:	ff 74 24 30          	pushl  0x30(%esp)
    d4b9:	e8 b1 fd ff ff       	call   d26f <try_to_share>
    d4be:	83 c4 10             	add    $0x10,%esp
    d4c1:	85 c0                	test   %eax,%eax
    d4c3:	74 0e                	je     d4d3 <share_page+0xb4>
			return 1;
    d4c5:	b8 01 00 00 00       	mov    $0x1,%eax
    d4ca:	eb 21                	jmp    d4ed <share_page+0xce>
			continue;
    d4cc:	90                   	nop
    d4cd:	eb 04                	jmp    d4d3 <share_page+0xb4>
			continue;
    d4cf:	90                   	nop
    d4d0:	eb 01                	jmp    d4d3 <share_page+0xb4>
				continue;
    d4d2:	90                   	nop
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    d4d3:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    d4d8:	c7 c0 a0 32 03 00    	mov    $0x332a0,%eax
    d4de:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    d4e2:	0f 87 77 ff ff ff    	ja     d45f <share_page+0x40>
	}
	return 0;
    d4e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d4ed:	83 c4 18             	add    $0x18,%esp
    d4f0:	5b                   	pop    %ebx
    d4f1:	c3                   	ret    

0000d4f2 <do_no_page>:
// 是访问不存在页面处理函数.页异常中断处理过程中调用的函数.在page.s程序中被调用.函数参数error_code和address是进程在访问页面时由CPU因
// 缺页产生异常而自动生成.error_code指出出错类型;address产生异常的页面线性地址.
// 该函数首先查看所缺页是否在交换设备中,若是则交换进来.否则尝试与已加载的相同文件进行页面共享,或者只是由于进程动态申请内存页面而只需映射一页
// 物理内存页即可.若共享操作不成功,那么只能从相应文件中读入所缺的数据页面到指定线性地址处.
void do_no_page(unsigned long error_code, unsigned long address)
{
    d4f2:	53                   	push   %ebx
    d4f3:	83 ec 38             	sub    $0x38,%esp
    d4f6:	e8 ff 97 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    d4fb:	81 c3 05 4b 02 00    	add    $0x24b05,%ebx
	struct m_inode * inode;

	// 首先判断CPU控制寄存器CR2给出的引起页面异常的线性地址在什么范围中.如果address小于TASK_SIZE(0x4000000,即64MB),表示异常页面位置在内核
	// 或任务0和任务1所处的线性地址范围内,于是发出警告信息"内核范围内存被写保护";如果(address-当前进程代码起始地址)大于一个进程的长度(64MB),表示
	// address所指的线性地址不在引起异常的进程线性地址空间范围内,则在发出出错信息后退出
	if (address < TASK_SIZE)
    d501:	81 7c 24 44 ff ff ff 	cmpl   $0x3ffffff,0x44(%esp)
    d508:	03 
    d509:	77 12                	ja     d51d <do_no_page+0x2b>
		printk("\n\rBAD!! KERNEL PAGE MISSING\n\r");
    d50b:	83 ec 0c             	sub    $0xc,%esp
    d50e:	8d 83 b1 4b ff ff    	lea    -0xb44f(%ebx),%eax
    d514:	50                   	push   %eax
    d515:	e8 18 be ff ff       	call   9332 <printk>
    d51a:	83 c4 10             	add    $0x10,%esp
	if (address - current->start_code > TASK_SIZE) {
    d51d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d523:	8b 00                	mov    (%eax),%eax
    d525:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    d52b:	8b 54 24 44          	mov    0x44(%esp),%edx
    d52f:	29 c2                	sub    %eax,%edx
    d531:	89 d0                	mov    %edx,%eax
    d533:	3d 00 00 00 04       	cmp    $0x4000000,%eax
    d538:	76 1f                	jbe    d559 <do_no_page+0x67>
		printk("Bad things happen: nonexistent page error in do_no_page\n\r");
    d53a:	83 ec 0c             	sub    $0xc,%esp
    d53d:	8d 83 d0 4b ff ff    	lea    -0xb430(%ebx),%eax
    d543:	50                   	push   %eax
    d544:	e8 e9 bd ff ff       	call   9332 <printk>
    d549:	83 c4 10             	add    $0x10,%esp
		do_exit(SIGSEGV);
    d54c:	83 ec 0c             	sub    $0xc,%esp
    d54f:	6a 0b                	push   $0xb
    d551:	e8 0e e4 ff ff       	call   b964 <do_exit>
    d556:	83 c4 10             	add    $0x10,%esp
	}
	// 然后根据指定的线性地址address求出其对应的二级页表项指针,并根据该页表项内容判断address处的页面是否在交换设备中.若是则调入页面并退出.方法是首先
	// 取指定线性地址address对应的目录项内容.如果对应的二级页表存在,则取出该目录项中二级页表的地址,加上页表项偏移值即得到线性地址address处页面对应的
	// 页表项指针,从而获得页表项内容.若页表内容不为0并且页表项存在位P=0,则说明该页表项指定的物理页面应该在交换设备中.于是从交换设备中调入指定页面后退出函数.
	page = *(unsigned long *) ((address >> 20) & 0xffc);				// 取目录项内容.
    d559:	8b 44 24 44          	mov    0x44(%esp),%eax
    d55d:	c1 e8 14             	shr    $0x14,%eax
    d560:	25 fc 0f 00 00       	and    $0xffc,%eax
    d565:	8b 00                	mov    (%eax),%eax
    d567:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (page & 1) {
    d56b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d56f:	83 e0 01             	and    $0x1,%eax
    d572:	85 c0                	test   %eax,%eax
    d574:	74 49                	je     d5bf <do_no_page+0xcd>
		page &= 0xfffff000;												// 二级页表地址.
    d576:	81 64 24 1c 00 f0 ff 	andl   $0xfffff000,0x1c(%esp)
    d57d:	ff 
		page += (address >> 10) & 0xffc;								// 页表项指针.
    d57e:	8b 44 24 44          	mov    0x44(%esp),%eax
    d582:	c1 e8 0a             	shr    $0xa,%eax
    d585:	25 fc 0f 00 00       	and    $0xffc,%eax
    d58a:	01 44 24 1c          	add    %eax,0x1c(%esp)
		tmp = *(unsigned long *) page;									// 页表项内容.
    d58e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d592:	8b 00                	mov    (%eax),%eax
    d594:	89 44 24 2c          	mov    %eax,0x2c(%esp)
		if (tmp && !(1 & tmp)) {
    d598:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
    d59d:	74 20                	je     d5bf <do_no_page+0xcd>
    d59f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    d5a3:	83 e0 01             	and    $0x1,%eax
    d5a6:	85 c0                	test   %eax,%eax
    d5a8:	75 15                	jne    d5bf <do_no_page+0xcd>
			swap_in((unsigned long *) page);							// 从交换设备读页面.
    d5aa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d5ae:	83 ec 0c             	sub    $0xc,%esp
    d5b1:	50                   	push   %eax
    d5b2:	e8 e2 06 00 00       	call   dc99 <swap_in>
    d5b7:	83 c4 10             	add    $0x10,%esp
			return;
    d5ba:	e9 c8 01 00 00       	jmp    d787 <do_no_page+0x295>
		}
	}
	// 否则取线性空间中指定地址address处页面地址,并算出指定线性地址在进程空间中相对于进程基址的偏移长度值tmp,即对应的逻辑地址.从而可以算出缺页页面在执行文件映像
	// 中或在库文件中的具体起始数据块号.
	address &= 0xfffff000;												// address处缺页页面地址.
    d5bf:	81 64 24 44 00 f0 ff 	andl   $0xfffff000,0x44(%esp)
    d5c6:	ff 
	tmp = address - current->start_code;								// 缺页页面对应逻辑地址.
    d5c7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d5cd:	8b 00                	mov    (%eax),%eax
    d5cf:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    d5d5:	8b 54 24 44          	mov    0x44(%esp),%edx
    d5d9:	29 c2                	sub    %eax,%edx
    d5db:	89 d0                	mov    %edx,%eax
    d5dd:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	// 如果缺页对应的逻辑地址tmp大于库映像文件在进程逻辑空间中的起始位置,说明缺少的页面在库映像文件中.于是从当前进程任务数据结构中可以取得库映像文件的i节点library,
	// 并计算出该缺页在库文件中的起始数据块号block.
	// 因为设置上存放的执行文件映像第1块数据是程序头结构,因此在读取该文件时需要跳过第1块数据.所以需要首先计算缺页所在数据块号.因为每块数据长度为BLOCK_SIZE = 1KB,因此
	// 一页内存可存放4个数据块.进程逻辑地址tmp除以数据块大小再加1即可得出缺少的页面在执行映像文件中的起始块号block.
	if (tmp >= LIBRARY_OFFSET ) {
    d5e1:	81 7c 24 2c ff ff bf 	cmpl   $0x3bfffff,0x2c(%esp)
    d5e8:	03 
    d5e9:	76 27                	jbe    d612 <do_no_page+0x120>
		inode = current->library;										// 库文件i节点和缺页起始块号.
    d5eb:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d5f1:	8b 00                	mov    (%eax),%eax
    d5f3:	8b 80 40 03 00 00    	mov    0x340(%eax),%eax
    d5f9:	89 44 24 20          	mov    %eax,0x20(%esp)
		block = 1 + (tmp - LIBRARY_OFFSET) / BLOCK_SIZE;
    d5fd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    d601:	2d 00 00 c0 03       	sub    $0x3c00000,%eax
    d606:	c1 e8 0a             	shr    $0xa,%eax
    d609:	83 c0 01             	add    $0x1,%eax
    d60c:	89 44 24 28          	mov    %eax,0x28(%esp)
    d610:	eb 46                	jmp    d658 <do_no_page+0x166>
	// 如果缺页对应的逻辑地址tmp小于进程的执行映像文件在逻辑地址空间的末端位置,则说明缺少的页面在进程执行文件映像中,于是可
	// 以从当前进程任务数据机构中取得执行文件的i节点号executable,并计算出该缺页在执行文件映像中的起始数据块号block.若逻辑地址tmp既不在执行文件映像的地址范围内,
	} else if (tmp < current->end_data) {
    d612:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d618:	8b 00                	mov    (%eax),%eax
    d61a:	8b 80 20 02 00 00    	mov    0x220(%eax),%eax
    d620:	39 44 24 2c          	cmp    %eax,0x2c(%esp)
    d624:	73 22                	jae    d648 <do_no_page+0x156>
		inode = current->executable;									// 执行文件i节点和缺页起始块号.
    d626:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d62c:	8b 00                	mov    (%eax),%eax
    d62e:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
    d634:	89 44 24 20          	mov    %eax,0x20(%esp)
		block = 1 + tmp / BLOCK_SIZE;
    d638:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    d63c:	c1 e8 0a             	shr    $0xa,%eax
    d63f:	83 c0 01             	add    $0x1,%eax
    d642:	89 44 24 28          	mov    %eax,0x28(%esp)
    d646:	eb 10                	jmp    d658 <do_no_page+0x166>
	// 也不在库文件空间范围内,则说明缺页是进程访问动态申请的内存页面数据所致,因此没有对应i节点和数据块号(都置空).
	} else {
		inode = NULL;													// 是动态申请的数据或栈内存页面.
    d648:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    d64f:	00 
		block = 0;
    d650:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    d657:	00 
	}
	// 若是进程访问其动态申请的页面或为了存放栈信息而引起的缺页异常,则直接申请一页物理内存页面并映射到线性地址address处即可.
	if (!inode) {														// 是动态申请的数据内存页面.
    d658:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    d65d:	75 14                	jne    d673 <do_no_page+0x181>
		get_empty_page(address);
    d65f:	83 ec 0c             	sub    $0xc,%esp
    d662:	ff 74 24 50          	pushl  0x50(%esp)
    d666:	e8 b3 fb ff ff       	call   d21e <get_empty_page>
    d66b:	83 c4 10             	add    $0x10,%esp
		return;
    d66e:	e9 14 01 00 00       	jmp    d787 <do_no_page+0x295>
	}
	// 否则说明所缺页面进程执行文件或库文件范围内,于是就尝试共享页面操作,若成功则退出.
	if (share_page(inode, tmp))											// 尝试逻辑地址tmp处页面的共享.
    d673:	83 ec 08             	sub    $0x8,%esp
    d676:	ff 74 24 34          	pushl  0x34(%esp)
    d67a:	ff 74 24 2c          	pushl  0x2c(%esp)
    d67e:	e8 9c fd ff ff       	call   d41f <share_page>
    d683:	83 c4 10             	add    $0x10,%esp
    d686:	85 c0                	test   %eax,%eax
    d688:	0f 85 f5 00 00 00    	jne    d783 <do_no_page+0x291>
		return;
	// 如果共享不成功就只能申请一页物理内存页面page,然后从设备上读取执行文件中的相应页面并放置(映射)到进程页面逻辑地址tmp处.
	if (!(page = get_free_page()))										// 申请一页物理内存.
    d68e:	e8 59 09 00 00       	call   dfec <get_free_page>
    d693:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    d697:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    d69c:	75 05                	jne    d6a3 <do_no_page+0x1b1>
		oom();
    d69e:	e8 98 f3 ff ff       	call   ca3b <oom>
	/* remember that 1 block is used for header */
	/* 记住,(程序)头要使用1个数据块 */
	// 根据这个块号和执行文件的i节点,我们就可以从映射位图中找到对应块设备中对应的设备逻辑块号(保存在nr[]数组中).利用break_page()
	// 即可把这4个逻辑块读入到物理页面page中.
	for (i = 0 ; i < 4 ; block++, i++)
    d6a3:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
    d6aa:	00 
    d6ab:	eb 27                	jmp    d6d4 <do_no_page+0x1e2>
		nr[i] = bmap(inode, block);
    d6ad:	83 ec 08             	sub    $0x8,%esp
    d6b0:	ff 74 24 30          	pushl  0x30(%esp)
    d6b4:	ff 74 24 2c          	pushl  0x2c(%esp)
    d6b8:	e8 99 21 00 00       	call   f856 <bmap>
    d6bd:	83 c4 10             	add    $0x10,%esp
    d6c0:	89 c2                	mov    %eax,%edx
    d6c2:	8b 44 24 24          	mov    0x24(%esp),%eax
    d6c6:	89 54 84 0c          	mov    %edx,0xc(%esp,%eax,4)
	for (i = 0 ; i < 4 ; block++, i++)
    d6ca:	83 44 24 28 01       	addl   $0x1,0x28(%esp)
    d6cf:	83 44 24 24 01       	addl   $0x1,0x24(%esp)
    d6d4:	83 7c 24 24 03       	cmpl   $0x3,0x24(%esp)
    d6d9:	7e d2                	jle    d6ad <do_no_page+0x1bb>
	bread_page(page, inode->i_dev, nr);
    d6db:	8b 44 24 20          	mov    0x20(%esp),%eax
    d6df:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    d6e3:	0f b7 c0             	movzwl %ax,%eax
    d6e6:	83 ec 04             	sub    $0x4,%esp
    d6e9:	8d 54 24 10          	lea    0x10(%esp),%edx
    d6ed:	52                   	push   %edx
    d6ee:	50                   	push   %eax
    d6ef:	ff 74 24 28          	pushl  0x28(%esp)
    d6f3:	e8 76 33 00 00       	call   10a6e <bread_page>
    d6f8:	83 c4 10             	add    $0x10,%esp
	// 在读设备逻辑块操作时,可能会出现这样一种情况,即在执行文件中的读取页面位置可能离文件尾不到1个页面的长度.因此就可能读入一些无用
	// 的信息.下面的操作就是把这部分超出执行文件end_data以后的部分进行清零处理.当然,若该页面离末端超过1页,说明不是从执行文件映像中
	// 读取的页面,而是从库文件中读取的,因此不用执行清零操作.
	i = tmp + 4096 - current->end_data;									// 超出的字节长度值.
    d6fb:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    d701:	8b 00                	mov    (%eax),%eax
    d703:	8b 80 20 02 00 00    	mov    0x220(%eax),%eax
    d709:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    d70d:	29 c2                	sub    %eax,%edx
    d70f:	89 d0                	mov    %edx,%eax
    d711:	05 00 10 00 00       	add    $0x1000,%eax
    d716:	89 44 24 24          	mov    %eax,0x24(%esp)
	if (i > 4095)														// 离末端超过1页则不用清零.
    d71a:	81 7c 24 24 ff 0f 00 	cmpl   $0xfff,0x24(%esp)
    d721:	00 
    d722:	7e 08                	jle    d72c <do_no_page+0x23a>
		i = 0;
    d724:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
    d72b:	00 
	tmp = page + 4096;
    d72c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d730:	05 00 10 00 00       	add    $0x1000,%eax
    d735:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	while (i-- > 0) {
    d739:	eb 0c                	jmp    d747 <do_no_page+0x255>
		tmp--;															// tmp指向页面末端.
    d73b:	83 6c 24 2c 01       	subl   $0x1,0x2c(%esp)
		*(char *)tmp = 0;       										// 页面末端i字节清零.
    d740:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    d744:	c6 00 00             	movb   $0x0,(%eax)
	while (i-- > 0) {
    d747:	8b 44 24 24          	mov    0x24(%esp),%eax
    d74b:	8d 50 ff             	lea    -0x1(%eax),%edx
    d74e:	89 54 24 24          	mov    %edx,0x24(%esp)
    d752:	85 c0                	test   %eax,%eax
    d754:	7f e5                	jg     d73b <do_no_page+0x249>
	}
	// 最后把引起缺页异常的一页物理页面映射到指定线性地址address处.若操作成功就返回.否则就释放内存页,显示内存不够.
	if (put_page(page, address))
    d756:	83 ec 08             	sub    $0x8,%esp
    d759:	ff 74 24 4c          	pushl  0x4c(%esp)
    d75d:	ff 74 24 28          	pushl  0x28(%esp)
    d761:	e8 f1 f6 ff ff       	call   ce57 <put_page>
    d766:	83 c4 10             	add    $0x10,%esp
    d769:	85 c0                	test   %eax,%eax
    d76b:	75 19                	jne    d786 <do_no_page+0x294>
		return;
	free_page(page);
    d76d:	83 ec 0c             	sub    $0xc,%esp
    d770:	ff 74 24 28          	pushl  0x28(%esp)
    d774:	e8 f6 f2 ff ff       	call   ca6f <free_page>
    d779:	83 c4 10             	add    $0x10,%esp
	oom();
    d77c:	e8 ba f2 ff ff       	call   ca3b <oom>
    d781:	eb 04                	jmp    d787 <do_no_page+0x295>
		return;
    d783:	90                   	nop
    d784:	eb 01                	jmp    d787 <do_no_page+0x295>
		return;
    d786:	90                   	nop
}
    d787:	83 c4 38             	add    $0x38,%esp
    d78a:	5b                   	pop    %ebx
    d78b:	c3                   	ret    

0000d78c <mem_init>:
// 不用.对于具有16MB内存的PC系统,在没有设置虚拟盘RAMDISK的情况下,共有3072个物理页面可供分配.而范围0~1MB内存空间用于内核系统(其实内核
// 只使用0~640KB,剩下的部分被部分高速缓冲和设备内存占用).
// 参数start_mem是可用作页面分配的主内存区起始地址(已去除RAMDISK所占内存空间).end_mem是实际物理内存最大地址.而地址范围start_mem到
// end_mem是主内存区.
void mem_init(long start_mem, long end_mem)
{
    d78c:	83 ec 10             	sub    $0x10,%esp
    d78f:	e8 5e 95 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    d794:	05 6c 48 02 00       	add    $0x2486c,%eax
	int i;

	// 首先将1MB到16MB范围内所有内存页面对应的内存映射字节数组项置为已占用状态,即各项字节值全部设置成USED(100).PAGING_PAGES被定义为(
	// PAGING_MEMORY>>12),即1MB以上所有物理内存分页后的内存页面数(15MB/4KB = 3840).
	HIGH_MEMORY = end_mem;									// 设置内存最高端(16MB).
    d799:	8b 54 24 18          	mov    0x18(%esp),%edx
    d79d:	89 90 00 23 00 00    	mov    %edx,0x2300(%eax)
	for (i = 0; i < PAGING_PAGES; i++)
    d7a3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    d7aa:	00 
    d7ab:	eb 14                	jmp    d7c1 <mem_init+0x35>
		mem_map[i] = USED;
    d7ad:	8d 88 20 23 00 00    	lea    0x2320(%eax),%ecx
    d7b3:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d7b7:	01 ca                	add    %ecx,%edx
    d7b9:	c6 02 64             	movb   $0x64,(%edx)
	for (i = 0; i < PAGING_PAGES; i++)
    d7bc:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    d7c1:	81 7c 24 0c ff 0e 00 	cmpl   $0xeff,0xc(%esp)
    d7c8:	00 
    d7c9:	7e e2                	jle    d7ad <mem_init+0x21>
	// 然后计算主内存区起始内存start_mem处页面对应内存映射字节数组中项号i和主内存区页面数.此时mem_map[]数组的第i项正对应主内存区中第1个页面.
	// 最后将主内存区中页面对应的数组项清零(表示空闲).对于具有16MB物理内存的系统,mem_map[]中对应4MB~16MB主内存区的项被清零.
	i = MAP_NR(start_mem);									// 主内存区起始位置处页面号.
    d7cb:	8b 54 24 14          	mov    0x14(%esp),%edx
    d7cf:	81 ea 00 00 10 00    	sub    $0x100000,%edx
    d7d5:	c1 fa 0c             	sar    $0xc,%edx
    d7d8:	89 54 24 0c          	mov    %edx,0xc(%esp)
	end_mem -= start_mem;
    d7dc:	8b 54 24 14          	mov    0x14(%esp),%edx
    d7e0:	29 54 24 18          	sub    %edx,0x18(%esp)
	// 得到主内存区的页面的数量
	end_mem >>= 12;											// 主内存区中的总页面数.
    d7e4:	c1 7c 24 18 0c       	sarl   $0xc,0x18(%esp)
	// 将主内存区对应的页面数的应用数置零
	while (end_mem-- > 0)
    d7e9:	eb 13                	jmp    d7fe <mem_init+0x72>
		mem_map[i++] = 0;									// 主内存区页面对应字节值清零.
    d7eb:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d7ef:	8d 4a 01             	lea    0x1(%edx),%ecx
    d7f2:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    d7f6:	c6 84 10 20 23 00 00 	movb   $0x0,0x2320(%eax,%edx,1)
    d7fd:	00 
	while (end_mem-- > 0)
    d7fe:	8b 54 24 18          	mov    0x18(%esp),%edx
    d802:	8d 4a ff             	lea    -0x1(%edx),%ecx
    d805:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    d809:	85 d2                	test   %edx,%edx
    d80b:	7f de                	jg     d7eb <mem_init+0x5f>
}
    d80d:	90                   	nop
    d80e:	83 c4 10             	add    $0x10,%esp
    d811:	c3                   	ret    

0000d812 <show_mem>:
// 显示系统内存信息.
// 根据内存映射字节数组mem_map[]中的信息以及页目录和页表内容统计系统中使用的内存页面数和主内存区中总物理内存页面数.该函数在chr_drv/keyboard.S程序
// 被调用.
// 即当按下"Shift + Scroll Lock"组合键时会显示系统内存统计信息.
void show_mem(void)
{
    d812:	53                   	push   %ebx
    d813:	83 ec 28             	sub    $0x28,%esp
    d816:	e8 df 94 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    d81b:	81 c3 e5 47 02 00    	add    $0x247e5,%ebx
	int i, j, k, free = 0, total = 0;
    d821:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    d828:	00 
    d829:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    d830:	00 
	int shared = 0;
    d831:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d838:	00 
	unsigned long * pg_tbl;

	// 根据内存映射字节数组mem_map[],统计系统主内存区页面总数total,以及其中空闲页面数free和被共享的页面数shared.并显示这些信息.
	printk("Mem-info:\n\r");
    d839:	83 ec 0c             	sub    $0xc,%esp
    d83c:	8d 83 0a 4c ff ff    	lea    -0xb3f6(%ebx),%eax
    d842:	50                   	push   %eax
    d843:	e8 ea ba ff ff       	call   9332 <printk>
    d848:	83 c4 10             	add    $0x10,%esp
	for(i = 0 ; i < PAGING_PAGES ; i++) {
    d84b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    d852:	00 
    d853:	eb 53                	jmp    d8a8 <show_mem+0x96>
		if (mem_map[i] == USED)								// 1MB以上内存系统占用的页面.
    d855:	8d 93 20 23 00 00    	lea    0x2320(%ebx),%edx
    d85b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d85f:	01 d0                	add    %edx,%eax
    d861:	0f b6 00             	movzbl (%eax),%eax
    d864:	3c 64                	cmp    $0x64,%al
    d866:	74 3a                	je     d8a2 <show_mem+0x90>
			continue;
		// 统计主内存中的页面数
		total++;
    d868:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
		if (!mem_map[i])
    d86d:	8d 93 20 23 00 00    	lea    0x2320(%ebx),%edx
    d873:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d877:	01 d0                	add    %edx,%eax
    d879:	0f b6 00             	movzbl (%eax),%eax
    d87c:	84 c0                	test   %al,%al
    d87e:	75 07                	jne    d887 <show_mem+0x75>
			// 统计未使用的主内存页面数
			free++;											// 主内存区空闲页面统计.
    d880:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
    d885:	eb 1c                	jmp    d8a3 <show_mem+0x91>
		else
			// 统计共享页面数
			shared += mem_map[i] - 1;						// 共享的页面数(字节值>1)
    d887:	8d 93 20 23 00 00    	lea    0x2320(%ebx),%edx
    d88d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d891:	01 d0                	add    %edx,%eax
    d893:	0f b6 00             	movzbl (%eax),%eax
    d896:	0f b6 c0             	movzbl %al,%eax
    d899:	83 e8 01             	sub    $0x1,%eax
    d89c:	01 44 24 08          	add    %eax,0x8(%esp)
    d8a0:	eb 01                	jmp    d8a3 <show_mem+0x91>
			continue;
    d8a2:	90                   	nop
	for(i = 0 ; i < PAGING_PAGES ; i++) {
    d8a3:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    d8a8:	81 7c 24 1c ff 0e 00 	cmpl   $0xeff,0x1c(%esp)
    d8af:	00 
    d8b0:	7e a3                	jle    d855 <show_mem+0x43>
	}
	printk("%d free pages of %d\n\r", free, total);
    d8b2:	83 ec 04             	sub    $0x4,%esp
    d8b5:	ff 74 24 10          	pushl  0x10(%esp)
    d8b9:	ff 74 24 18          	pushl  0x18(%esp)
    d8bd:	8d 83 16 4c ff ff    	lea    -0xb3ea(%ebx),%eax
    d8c3:	50                   	push   %eax
    d8c4:	e8 69 ba ff ff       	call   9332 <printk>
    d8c9:	83 c4 10             	add    $0x10,%esp
	printk("%d pages shared\n\r", shared);
    d8cc:	83 ec 08             	sub    $0x8,%esp
    d8cf:	ff 74 24 10          	pushl  0x10(%esp)
    d8d3:	8d 83 2c 4c ff ff    	lea    -0xb3d4(%ebx),%eax
    d8d9:	50                   	push   %eax
    d8da:	e8 53 ba ff ff       	call   9332 <printk>
    d8df:	83 c4 10             	add    $0x10,%esp
	// 统计处理器分页管理逻辑页面数.页目录表前4项供内核代码使用,不列为统计范围,因此扫描处理的页目录项从第5项开始.方法是循环处理所有页目录项
	// (除前4个项),若对应的二级页表存在,那么先统计二级页表本身占用的内存页面,然后对该页表中所有页表项对应页面情况进行统计.
	k = 0;													// 一个进程占用页面统计值.
    d8e2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    d8e9:	00 
	for(i = 4 ; i < 1024 ;) {
    d8ea:	c7 44 24 1c 04 00 00 	movl   $0x4,0x1c(%esp)
    d8f1:	00 
    d8f2:	e9 7e 01 00 00       	jmp    da75 <show_mem+0x263>
		if (1 & pg_dir[i]) {
    d8f7:	c7 c0 00 00 00 00    	mov    $0x0,%eax
    d8fd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d901:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d904:	83 e0 01             	and    $0x1,%eax
    d907:	85 c0                	test   %eax,%eax
    d909:	0f 84 1c 01 00 00    	je     da2b <show_mem+0x219>
			// (如果页目录项对应二级页表地址大于机器最高物理内存地址HIGH_MEMORY,说明该目录项有问题.于是显示该目录项信息并继续处理下一个目录项.
			if (pg_dir[i] > HIGH_MEMORY) {					// 目录项内容不正常.
    d90f:	c7 c0 00 00 00 00    	mov    $0x0,%eax
    d915:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d919:	8b 14 90             	mov    (%eax,%edx,4),%edx
    d91c:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
    d922:	39 c2                	cmp    %eax,%edx
    d924:	76 29                	jbe    d94f <show_mem+0x13d>
				printk("page directory[%d]: %08X\n\r",
    d926:	c7 c0 00 00 00 00    	mov    $0x0,%eax
    d92c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d930:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d933:	83 ec 04             	sub    $0x4,%esp
    d936:	50                   	push   %eax
    d937:	ff 74 24 24          	pushl  0x24(%esp)
    d93b:	8d 83 3e 4c ff ff    	lea    -0xb3c2(%ebx),%eax
    d941:	50                   	push   %eax
    d942:	e8 eb b9 ff ff       	call   9332 <printk>
    d947:	83 c4 10             	add    $0x10,%esp
					i, pg_dir[i]);
				continue;
    d94a:	e9 26 01 00 00       	jmp    da75 <show_mem+0x263>
			}
			// 如果页目录项对应二级页表的"地址"大于LOW_MEM(即1MB),则把一个进程占用的物理内存页统计值k增1,把系统占用的所有物理内存页统计值free增1.
			// 然后邓对应页表地址pg_tb1,并对该页表中所有页表项进行统计.如果当前页表项所指物理页面存在并且该物理页面"地址"大于LOW_MEME,那么就将页表项对应页面
			// 纳入统计值.
			if (pg_dir[i] > LOW_MEM)
    d94f:	c7 c0 00 00 00 00    	mov    $0x0,%eax
    d955:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d959:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d95c:	3d 00 00 10 00       	cmp    $0x100000,%eax
    d961:	76 0a                	jbe    d96d <show_mem+0x15b>
				free++, k++;								// 统计页表占用页面.
    d963:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
    d968:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
			pg_tbl = (unsigned long *) (0xfffff000 & pg_dir[i]);
    d96d:	c7 c0 00 00 00 00    	mov    $0x0,%eax
    d973:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d977:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d97a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    d97f:	89 44 24 04          	mov    %eax,0x4(%esp)
			for(j = 0 ; j < 1024 ; j++)
    d983:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    d98a:	00 
    d98b:	e9 8d 00 00 00       	jmp    da1d <show_mem+0x20b>
				if ((pg_tbl[j]&1) && pg_tbl[j] > LOW_MEM)
    d990:	8b 44 24 18          	mov    0x18(%esp),%eax
    d994:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d99b:	8b 44 24 04          	mov    0x4(%esp),%eax
    d99f:	01 d0                	add    %edx,%eax
    d9a1:	8b 00                	mov    (%eax),%eax
    d9a3:	83 e0 01             	and    $0x1,%eax
    d9a6:	85 c0                	test   %eax,%eax
    d9a8:	74 6e                	je     da18 <show_mem+0x206>
    d9aa:	8b 44 24 18          	mov    0x18(%esp),%eax
    d9ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d9b5:	8b 44 24 04          	mov    0x4(%esp),%eax
    d9b9:	01 d0                	add    %edx,%eax
    d9bb:	8b 00                	mov    (%eax),%eax
    d9bd:	3d 00 00 10 00       	cmp    $0x100000,%eax
    d9c2:	76 54                	jbe    da18 <show_mem+0x206>
					// (若该物理页面地址大于机器最高物理内存地址HIGH_MEMORY,则说明该页表项内容有问题,于是显示该页表项内容.否则将页表项对应页面纳入统计值.)
					if (pg_tbl[j] > HIGH_MEMORY)
    d9c4:	8b 44 24 18          	mov    0x18(%esp),%eax
    d9c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d9cf:	8b 44 24 04          	mov    0x4(%esp),%eax
    d9d3:	01 d0                	add    %edx,%eax
    d9d5:	8b 10                	mov    (%eax),%edx
    d9d7:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
    d9dd:	39 c2                	cmp    %eax,%edx
    d9df:	76 2d                	jbe    da0e <show_mem+0x1fc>
						printk("page_dir[%d][%d]: %08X\n\r",
							i, j, pg_tbl[j]);
    d9e1:	8b 44 24 18          	mov    0x18(%esp),%eax
    d9e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d9ec:	8b 44 24 04          	mov    0x4(%esp),%eax
    d9f0:	01 d0                	add    %edx,%eax
						printk("page_dir[%d][%d]: %08X\n\r",
    d9f2:	8b 00                	mov    (%eax),%eax
    d9f4:	50                   	push   %eax
    d9f5:	ff 74 24 1c          	pushl  0x1c(%esp)
    d9f9:	ff 74 24 24          	pushl  0x24(%esp)
    d9fd:	8d 83 59 4c ff ff    	lea    -0xb3a7(%ebx),%eax
    da03:	50                   	push   %eax
    da04:	e8 29 b9 ff ff       	call   9332 <printk>
    da09:	83 c4 10             	add    $0x10,%esp
    da0c:	eb 0a                	jmp    da18 <show_mem+0x206>
					else
						k++, free++;						// 统计责表项对应页面.
    da0e:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
    da13:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
			for(j = 0 ; j < 1024 ; j++)
    da18:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
    da1d:	81 7c 24 18 ff 03 00 	cmpl   $0x3ff,0x18(%esp)
    da24:	00 
    da25:	0f 8e 65 ff ff ff    	jle    d990 <show_mem+0x17e>
		}
		// 因每个任务线性空间长度是64MB,所以一个任务占用16个目录项.因此这每统计了16个目录项就把进程的任务结构占用的页表统计进来.若此时k=0则表示当前的16个页
		// 目录所对应的进程在系统中不存在(没有创建或者已经终止).在显示了对应进程号和其占用的物理内存页统计值k后,将k清零,以用于统计下一个进程占用的内存页面数.
		i++;
    da2b:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
		if (!(i & 15) && k) {
    da30:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    da34:	83 e0 0f             	and    $0xf,%eax
    da37:	85 c0                	test   %eax,%eax
    da39:	75 3a                	jne    da75 <show_mem+0x263>
    da3b:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    da40:	74 33                	je     da75 <show_mem+0x263>
			k++, free++;									/* one page/process for task_struct */
    da42:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
    da47:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
			printk("Process %d: %d pages\n\r", (i >> 4) - 1, k);
    da4c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    da50:	c1 f8 04             	sar    $0x4,%eax
    da53:	83 e8 01             	sub    $0x1,%eax
    da56:	83 ec 04             	sub    $0x4,%esp
    da59:	ff 74 24 18          	pushl  0x18(%esp)
    da5d:	50                   	push   %eax
    da5e:	8d 83 72 4c ff ff    	lea    -0xb38e(%ebx),%eax
    da64:	50                   	push   %eax
    da65:	e8 c8 b8 ff ff       	call   9332 <printk>
    da6a:	83 c4 10             	add    $0x10,%esp
			k = 0;
    da6d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    da74:	00 
	for(i = 4 ; i < 1024 ;) {
    da75:	81 7c 24 1c ff 03 00 	cmpl   $0x3ff,0x1c(%esp)
    da7c:	00 
    da7d:	0f 8e 74 fe ff ff    	jle    d8f7 <show_mem+0xe5>
		}
	}
	// 最后显示系统中正在使用的内存页面和主内存区中总的内存页面数.
	printk("Memory found: %d (%d)\n\r\n\r", free - shared, total);
    da83:	8b 44 24 10          	mov    0x10(%esp),%eax
    da87:	2b 44 24 08          	sub    0x8(%esp),%eax
    da8b:	83 ec 04             	sub    $0x4,%esp
    da8e:	ff 74 24 10          	pushl  0x10(%esp)
    da92:	50                   	push   %eax
    da93:	8d 83 89 4c ff ff    	lea    -0xb377(%ebx),%eax
    da99:	50                   	push   %eax
    da9a:	e8 93 b8 ff ff       	call   9332 <printk>
    da9f:	83 c4 10             	add    $0x10,%esp
}
    daa2:	90                   	nop
    daa3:	83 c4 28             	add    $0x28,%esp
    daa6:	5b                   	pop    %ebx
    daa7:	c3                   	ret    

0000daa8 <strncmp>:
// 字符串与字符串2的前count个字符进行比较.
// 参数:cs - 字符串1,ct - 字符串2,count - 比较的字符数.
// %0 - eax(__res)返回值,%1 - edi(cs)字符串1指针,%2 - esi(ct)字符串2指针,%3 - ecx(count).
// 返回:如果串1>串2,则返回1;串1=串2,则返回0;串1<串2,则返回-1.
static inline int strncmp(const char * cs, const char * ct, int count)
{
    daa8:	57                   	push   %edi
    daa9:	56                   	push   %esi
    daaa:	e8 43 92 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    daaf:	05 51 45 02 00       	add    $0x24551,%eax
register int __res __asm__("ax");							// __res是寄存器变量(eax).
__asm__(
    dab4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dab8:	8b 54 24 10          	mov    0x10(%esp),%edx
    dabc:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    dac0:	89 c7                	mov    %eax,%edi
    dac2:	89 d6                	mov    %edx,%esi
    dac4:	fc                   	cld    
    dac5:	49                   	dec    %ecx
    dac6:	78 08                	js     dad0 <strncmp+0x28>
    dac8:	ac                   	lods   %ds:(%esi),%al
    dac9:	ae                   	scas   %es:(%edi),%al
    daca:	75 08                	jne    dad4 <strncmp+0x2c>
    dacc:	84 c0                	test   %al,%al
    dace:	75 f5                	jne    dac5 <strncmp+0x1d>
    dad0:	31 c0                	xor    %eax,%eax
    dad2:	eb 09                	jmp    dadd <strncmp+0x35>
    dad4:	b8 01 00 00 00       	mov    $0x1,%eax
    dad9:	7c 02                	jl     dadd <strncmp+0x35>
    dadb:	f7 d8                	neg    %eax
	"jl 4f\n\t"												// 如果前面比较中串2字符<串1字符,则返回1结束.
	"negl %%eax\n"											// 否则eax=-eax,返回负值,结束.
	"4:"
	:"=a" (__res):"D" (cs), "S" (ct), "c" (count):);
return __res;												// 返回比较结果.
}
    dadd:	5e                   	pop    %esi
    dade:	5f                   	pop    %edi
    dadf:	c3                   	ret    

0000dae0 <memset>:

// 用字符填写指定长度内存块.
// 用字符c填写s指向的内存区域,共填count字节.
// %0 - eax(字符c),%1 - edi(内存地址),%2 - ecx(字节数count).
static inline void * memset(void * s, char c, int count)
{
    dae0:	57                   	push   %edi
    dae1:	83 ec 04             	sub    $0x4,%esp
    dae4:	e8 09 92 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    dae9:	05 17 45 02 00       	add    $0x24517,%eax
    daee:	8b 44 24 10          	mov    0x10(%esp),%eax
    daf2:	88 04 24             	mov    %al,(%esp)
__asm__(
    daf5:	0f b6 04 24          	movzbl (%esp),%eax
    daf9:	8b 54 24 0c          	mov    0xc(%esp),%edx
    dafd:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    db01:	89 d7                	mov    %edx,%edi
    db03:	fc                   	cld    
    db04:	57                   	push   %edi
    db05:	f3 aa                	rep stos %al,%es:(%edi)
    db07:	5f                   	pop    %edi
		"rep\n\t"											// 重复ecx指定的次数,执行.
		"stosb\n\t"											// 将al中字符存入es:[edi]中,并且edi++.
		"popl %%edi"
		::"a" (c), "D" (s), "c" (count)
		:);
return s;
    db08:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    db0c:	83 c4 04             	add    $0x4,%esp
    db0f:	5f                   	pop    %edi
    db10:	c3                   	ret    

0000db11 <oom>:
{
    db11:	53                   	push   %ebx
    db12:	83 ec 08             	sub    $0x8,%esp
    db15:	e8 e0 91 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    db1a:	81 c3 e6 44 02 00    	add    $0x244e6,%ebx
	printk("out of memory\n\r");
    db20:	83 ec 0c             	sub    $0xc,%esp
    db23:	8d 83 a4 4c ff ff    	lea    -0xb35c(%ebx),%eax
    db29:	50                   	push   %eax
    db2a:	e8 03 b8 ff ff       	call   9332 <printk>
    db2f:	83 c4 10             	add    $0x10,%esp
	do_exit(SIGSEGV);
    db32:	83 ec 0c             	sub    $0xc,%esp
    db35:	6a 0b                	push   $0xb
    db37:	e8 28 de ff ff       	call   b964 <do_exit>
    db3c:	83 c4 10             	add    $0x10,%esp
}
    db3f:	90                   	nop
    db40:	83 c4 08             	add    $0x8,%esp
    db43:	5b                   	pop    %ebx
    db44:	c3                   	ret    

0000db45 <bit>:
:"r" (nr),"m" (*(addr)),"0" (0)); \
return __res; \
}

// 这里根据不同的op字符定义3个内嵌函数.
bitop(bit, "")								// 定义内嵌函数bit(char * addr, unsigned int nr).
    db45:	83 ec 10             	sub    $0x10,%esp
    db48:	e8 a5 91 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    db4d:	05 b3 44 02 00       	add    $0x244b3,%eax
    db52:	8b 54 24 18          	mov    0x18(%esp),%edx
    db56:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    db5a:	b8 00 00 00 00       	mov    $0x0,%eax
    db5f:	b8 00 00 00 00       	mov    $0x0,%eax
    db64:	0f a3 11             	bt     %edx,(%ecx)
    db67:	83 d0 00             	adc    $0x0,%eax
    db6a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    db6e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    db72:	83 c4 10             	add    $0x10,%esp
    db75:	c3                   	ret    

0000db76 <setbit>:
bitop(setbit, "s")							// 定义内嵌函数setbit(char * addr, unsigned int nr).
    db76:	83 ec 10             	sub    $0x10,%esp
    db79:	e8 74 91 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    db7e:	05 82 44 02 00       	add    $0x24482,%eax
    db83:	8b 54 24 18          	mov    0x18(%esp),%edx
    db87:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    db8b:	b8 00 00 00 00       	mov    $0x0,%eax
    db90:	b8 00 00 00 00       	mov    $0x0,%eax
    db95:	0f ab 11             	bts    %edx,(%ecx)
    db98:	83 d0 00             	adc    $0x0,%eax
    db9b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    db9f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dba3:	83 c4 10             	add    $0x10,%esp
    dba6:	c3                   	ret    

0000dba7 <clrbit>:
bitop(clrbit, "r")							// 定义内嵌函数clrbit(char * addr, unsigned int nr).
    dba7:	83 ec 10             	sub    $0x10,%esp
    dbaa:	e8 43 91 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    dbaf:	05 51 44 02 00       	add    $0x24451,%eax
    dbb4:	8b 54 24 18          	mov    0x18(%esp),%edx
    dbb8:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    dbbc:	b8 00 00 00 00       	mov    $0x0,%eax
    dbc1:	b8 00 00 00 00       	mov    $0x0,%eax
    dbc6:	0f b3 11             	btr    %edx,(%ecx)
    dbc9:	83 d0 00             	adc    $0x0,%eax
    dbcc:	89 44 24 0c          	mov    %eax,0xc(%esp)
    dbd0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dbd4:	83 c4 10             	add    $0x10,%esp
    dbd7:	c3                   	ret    

0000dbd8 <get_swap_page>:
#define VM_PAGES (LAST_VM_PAGE - FIRST_VM_PAGE)					// = 1032192(从0开始计)(用总的页面数减去第0个任务的页面数)

// 申请1页交换页面.
// 扫描整个交换映射位图(除对应位图本身的位0以外),返回值为1的第一个比特位号,即目前空闲的交换页面号.若操作成功则返回交换页面号,否则返回0.
static int get_swap_page(void)
{
    dbd8:	53                   	push   %ebx
    dbd9:	83 ec 10             	sub    $0x10,%esp
    dbdc:	e8 19 91 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    dbe1:	81 c3 1f 44 02 00    	add    $0x2441f,%ebx
	int nr;

	if (!swap_bitmap)
    dbe7:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    dbed:	85 c0                	test   %eax,%eax
    dbef:	75 07                	jne    dbf8 <get_swap_page+0x20>
		return 0;
    dbf1:	b8 00 00 00 00       	mov    $0x0,%eax
    dbf6:	eb 3c                	jmp    dc34 <get_swap_page+0x5c>
	for (nr = 1; nr < 32768 ; nr++)
    dbf8:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    dbff:	00 
    dc00:	eb 23                	jmp    dc25 <get_swap_page+0x4d>
		if (clrbit(swap_bitmap, nr))
    dc02:	8b 54 24 0c          	mov    0xc(%esp),%edx
    dc06:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    dc0c:	52                   	push   %edx
    dc0d:	50                   	push   %eax
    dc0e:	e8 94 ff ff ff       	call   dba7 <clrbit>
    dc13:	83 c4 08             	add    $0x8,%esp
    dc16:	85 c0                	test   %eax,%eax
    dc18:	74 06                	je     dc20 <get_swap_page+0x48>
			return nr;					// 返回目前空闲的交换页面号.
    dc1a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dc1e:	eb 14                	jmp    dc34 <get_swap_page+0x5c>
	for (nr = 1; nr < 32768 ; nr++)
    dc20:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    dc25:	81 7c 24 0c ff 7f 00 	cmpl   $0x7fff,0xc(%esp)
    dc2c:	00 
    dc2d:	7e d3                	jle    dc02 <get_swap_page+0x2a>
	return 0;
    dc2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dc34:	83 c4 10             	add    $0x10,%esp
    dc37:	5b                   	pop    %ebx
    dc38:	c3                   	ret    

0000dc39 <swap_free>:

// 释放交换设备中指定的交换页面.
// 在交换位图中设置指定页面号对应的位(置1).若原来该位就等于1,则表示交换设备中原来该页面就没有被占用,或者位图出错.于是显示出错信息并返回.
// 参数指定交换页面号.
void swap_free(int swap_nr)
{
    dc39:	53                   	push   %ebx
    dc3a:	83 ec 08             	sub    $0x8,%esp
    dc3d:	e8 b8 90 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    dc42:	81 c3 be 43 02 00    	add    $0x243be,%ebx
	if (!swap_nr)
    dc48:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    dc4d:	74 41                	je     dc90 <swap_free+0x57>
		return;
	if (swap_bitmap && swap_nr < SWAP_BITS)
    dc4f:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    dc55:	85 c0                	test   %eax,%eax
    dc57:	74 22                	je     dc7b <swap_free+0x42>
    dc59:	81 7c 24 10 ff 7f 00 	cmpl   $0x7fff,0x10(%esp)
    dc60:	00 
    dc61:	7f 18                	jg     dc7b <swap_free+0x42>
		if (!setbit(swap_bitmap, swap_nr))
    dc63:	8b 54 24 10          	mov    0x10(%esp),%edx
    dc67:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    dc6d:	52                   	push   %edx
    dc6e:	50                   	push   %eax
    dc6f:	e8 02 ff ff ff       	call   db76 <setbit>
    dc74:	83 c4 08             	add    $0x8,%esp
    dc77:	85 c0                	test   %eax,%eax
    dc79:	74 18                	je     dc93 <swap_free+0x5a>
			return;
	printk("Swap-space bad (swap_free())\n\r");
    dc7b:	83 ec 0c             	sub    $0xc,%esp
    dc7e:	8d 83 b4 4c ff ff    	lea    -0xb34c(%ebx),%eax
    dc84:	50                   	push   %eax
    dc85:	e8 a8 b6 ff ff       	call   9332 <printk>
    dc8a:	83 c4 10             	add    $0x10,%esp
	return;
    dc8d:	90                   	nop
    dc8e:	eb 04                	jmp    dc94 <swap_free+0x5b>
		return;
    dc90:	90                   	nop
    dc91:	eb 01                	jmp    dc94 <swap_free+0x5b>
			return;
    dc93:	90                   	nop
}
    dc94:	83 c4 08             	add    $0x8,%esp
    dc97:	5b                   	pop    %ebx
    dc98:	c3                   	ret    

0000dc99 <swap_in>:

// 把指定页面交换进内存中
// 把指定页表项的对应页面从交换设备中读入到新申请的内存页面中.修改交换位图中对应位(置位),同时修改页表项内容,让它指向该内存页面,并设置相应标志.
void swap_in(unsigned long *table_ptr)
{
    dc99:	53                   	push   %ebx
    dc9a:	83 ec 18             	sub    $0x18,%esp
    dc9d:	e8 58 90 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    dca2:	81 c3 5e 43 02 00    	add    $0x2435e,%ebx
	int swap_nr;
	unsigned long page;

	// 首先检查交换位图和参数有效性.如果交换位图不存在,或者指定页表项对应的页面已存在于内存中,或者交换页面号为0,则显示警告信息并退出.对于已放到交换
	// 设备中去的内存页面,相应页表项中存放的应是交换页面号*2,即(swap_nr << 1).
	if (!swap_bitmap) {
    dca8:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    dcae:	85 c0                	test   %eax,%eax
    dcb0:	75 17                	jne    dcc9 <swap_in+0x30>
		printk("Trying to swap in without swap bit-map");
    dcb2:	83 ec 0c             	sub    $0xc,%esp
    dcb5:	8d 83 d4 4c ff ff    	lea    -0xb32c(%ebx),%eax
    dcbb:	50                   	push   %eax
    dcbc:	e8 71 b6 ff ff       	call   9332 <printk>
    dcc1:	83 c4 10             	add    $0x10,%esp
		return;
    dcc4:	e9 b6 00 00 00       	jmp    dd7f <swap_in+0xe6>
	}
	if (1 & *table_ptr) {
    dcc9:	8b 44 24 20          	mov    0x20(%esp),%eax
    dccd:	8b 00                	mov    (%eax),%eax
    dccf:	83 e0 01             	and    $0x1,%eax
    dcd2:	85 c0                	test   %eax,%eax
    dcd4:	74 17                	je     dced <swap_in+0x54>
		printk("trying to swap in present page\n\r");
    dcd6:	83 ec 0c             	sub    $0xc,%esp
    dcd9:	8d 83 fc 4c ff ff    	lea    -0xb304(%ebx),%eax
    dcdf:	50                   	push   %eax
    dce0:	e8 4d b6 ff ff       	call   9332 <printk>
    dce5:	83 c4 10             	add    $0x10,%esp
		return;
    dce8:	e9 92 00 00 00       	jmp    dd7f <swap_in+0xe6>
	}
	swap_nr = *table_ptr >> 1;
    dced:	8b 44 24 20          	mov    0x20(%esp),%eax
    dcf1:	8b 00                	mov    (%eax),%eax
    dcf3:	d1 e8                	shr    %eax
    dcf5:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!swap_nr) {
    dcf9:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    dcfe:	75 14                	jne    dd14 <swap_in+0x7b>
		printk("No swap page in swap_in\n\r");
    dd00:	83 ec 0c             	sub    $0xc,%esp
    dd03:	8d 83 1d 4d ff ff    	lea    -0xb2e3(%ebx),%eax
    dd09:	50                   	push   %eax
    dd0a:	e8 23 b6 ff ff       	call   9332 <printk>
    dd0f:	83 c4 10             	add    $0x10,%esp
		return;
    dd12:	eb 6b                	jmp    dd7f <swap_in+0xe6>
	}
	// 然后申请一页物理内存并从交换设备中读入页面号为swap_nr的页面.在把页面交换进来后,就把交换位图中对应比特位置位.如果其原本就是置位的,说明此次是再次
	// 从交换设备中读入相同的页面,于是显示一下警告信息.最后让页表指向该物理页面,并设置页面已修改,用户可读写和存在标志(Dirty,U/S,R/W,P).
	if (!(page = get_free_page()))
    dd14:	e8 d3 02 00 00       	call   dfec <get_free_page>
    dd19:	89 44 24 08          	mov    %eax,0x8(%esp)
    dd1d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    dd22:	75 05                	jne    dd29 <swap_in+0x90>
		oom();
    dd24:	e8 e8 fd ff ff       	call   db11 <oom>
	read_swap_page(swap_nr, (char *) page);
    dd29:	8b 54 24 08          	mov    0x8(%esp),%edx
    dd2d:	8b 83 20 32 00 00    	mov    0x3220(%ebx),%eax
    dd33:	52                   	push   %edx
    dd34:	ff 74 24 10          	pushl  0x10(%esp)
    dd38:	50                   	push   %eax
    dd39:	6a 00                	push   $0x0
    dd3b:	e8 cf a5 00 00       	call   1830f <ll_rw_page>
    dd40:	83 c4 10             	add    $0x10,%esp
	if (setbit(swap_bitmap, swap_nr))
    dd43:	8b 54 24 0c          	mov    0xc(%esp),%edx
    dd47:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    dd4d:	83 ec 08             	sub    $0x8,%esp
    dd50:	52                   	push   %edx
    dd51:	50                   	push   %eax
    dd52:	e8 1f fe ff ff       	call   db76 <setbit>
    dd57:	83 c4 10             	add    $0x10,%esp
    dd5a:	85 c0                	test   %eax,%eax
    dd5c:	74 12                	je     dd70 <swap_in+0xd7>
		printk("swapping in multiply from same page\n\r");
    dd5e:	83 ec 0c             	sub    $0xc,%esp
    dd61:	8d 83 38 4d ff ff    	lea    -0xb2c8(%ebx),%eax
    dd67:	50                   	push   %eax
    dd68:	e8 c5 b5 ff ff       	call   9332 <printk>
    dd6d:	83 c4 10             	add    $0x10,%esp
	*table_ptr = page | (PAGE_DIRTY | 7);
    dd70:	8b 44 24 08          	mov    0x8(%esp),%eax
    dd74:	83 c8 47             	or     $0x47,%eax
    dd77:	89 c2                	mov    %eax,%edx
    dd79:	8b 44 24 20          	mov    0x20(%esp),%eax
    dd7d:	89 10                	mov    %edx,(%eax)
}
    dd7f:	83 c4 18             	add    $0x18,%esp
    dd82:	5b                   	pop    %ebx
    dd83:	c3                   	ret    

0000dd84 <try_to_swap_out>:

// 尝试把页面交换出去.
// 若页面没有被修改过则不必保存在交换设备中,因为对应页面还可以再直接从相应映像文件中读入.于是可以直接释放掉相应物理页面了事.否则就申请一个交换页面号,然后
// 把页面交换出去.此时交换页面号要保存在对应页表项中,并且仍需要保持页表项存在位P=0.参数是页表项指针.页面换或释放成功返回1,否则返回0.
int try_to_swap_out(unsigned long * table_ptr)
{
    dd84:	53                   	push   %ebx
    dd85:	83 ec 18             	sub    $0x18,%esp
    dd88:	e8 6d 8f ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    dd8d:	81 c3 73 42 02 00    	add    $0x24273,%ebx
	unsigned long page;
	unsigned long swap_nr;

	// 首先判断参数的有效性.若需要交换出去的内存页面并不存在(或称无效),则即可退出.若页表项指定的物理页面地址大于分页管理的内存高端PAGING_MEMORY(15MB),
	// 也退出.
	page = *table_ptr;
    dd93:	8b 44 24 20          	mov    0x20(%esp),%eax
    dd97:	8b 00                	mov    (%eax),%eax
    dd99:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!(PAGE_PRESENT & page))
    dd9d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dda1:	83 e0 01             	and    $0x1,%eax
    dda4:	85 c0                	test   %eax,%eax
    dda6:	75 0a                	jne    ddb2 <try_to_swap_out+0x2e>
		return 0;
    dda8:	b8 00 00 00 00       	mov    $0x0,%eax
    ddad:	e9 da 00 00 00       	jmp    de8c <try_to_swap_out+0x108>
	if (page - LOW_MEM > PAGING_MEMORY)
    ddb2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ddb6:	2d 00 00 10 00       	sub    $0x100000,%eax
    ddbb:	3d 00 00 f0 00       	cmp    $0xf00000,%eax
    ddc0:	76 0a                	jbe    ddcc <try_to_swap_out+0x48>
		return 0;
    ddc2:	b8 00 00 00 00       	mov    $0x0,%eax
    ddc7:	e9 c0 00 00 00       	jmp    de8c <try_to_swap_out+0x108>
	// 若内存页面已被修改过,但是该页面是被共享的,那么为了提高运行效率,此类页面不宜被交换出去,于是直接退出,函数返回0.否则就申请一交换页面号,并把它保存在页表
	// 项中,然后把页面交换出去并释放对应物理内存页面.
	if (PAGE_DIRTY & page) {
    ddcc:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ddd0:	83 e0 40             	and    $0x40,%eax
    ddd3:	85 c0                	test   %eax,%eax
    ddd5:	0f 84 8b 00 00 00    	je     de66 <try_to_swap_out+0xe2>
		page &= 0xfffff000;									// 取物理页面地址.
    dddb:	81 64 24 0c 00 f0 ff 	andl   $0xfffff000,0xc(%esp)
    dde2:	ff 
		if (mem_map[MAP_NR(page)] != 1)
    dde3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dde7:	2d 00 00 10 00       	sub    $0x100000,%eax
    ddec:	c1 e8 0c             	shr    $0xc,%eax
    ddef:	89 c2                	mov    %eax,%edx
    ddf1:	c7 c0 20 43 03 00    	mov    $0x34320,%eax
    ddf7:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
    ddfb:	3c 01                	cmp    $0x1,%al
    ddfd:	74 0a                	je     de09 <try_to_swap_out+0x85>
			return 0;
    ddff:	b8 00 00 00 00       	mov    $0x0,%eax
    de04:	e9 83 00 00 00       	jmp    de8c <try_to_swap_out+0x108>
		if (!(swap_nr = get_swap_page()))					// 申请交换页面号.
    de09:	e8 ca fd ff ff       	call   dbd8 <get_swap_page>
    de0e:	89 44 24 08          	mov    %eax,0x8(%esp)
    de12:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    de17:	75 07                	jne    de20 <try_to_swap_out+0x9c>
			return 0;
    de19:	b8 00 00 00 00       	mov    $0x0,%eax
    de1e:	eb 6c                	jmp    de8c <try_to_swap_out+0x108>
		// 对于要交换设备中的页面,相应页表项中将存放的是(swap_nr << 1).乘2(左移1位)是为了空出原来页表项的存在位(P).只有存在位P=0并且页表项内容不为0的页面才会在
		// 交换设备中.Intel手册中明确指出,当一个表项的存在位P=0时(无效页表项),所有其他位(位31-1)可供随意使用.下面写交换页函数write_swap_page(nr,buffer)被
		// 定义为ll_rw_page(WRITE,SWAP_DEV,(nr),(buffer)).
		*table_ptr = swap_nr << 1;
    de20:	8b 44 24 08          	mov    0x8(%esp),%eax
    de24:	8d 14 00             	lea    (%eax,%eax,1),%edx
    de27:	8b 44 24 20          	mov    0x20(%esp),%eax
    de2b:	89 10                	mov    %edx,(%eax)
		invalidate();										// 刷新CPU页变换高速缓冲.
    de2d:	b8 00 00 00 00       	mov    $0x0,%eax
    de32:	0f 22 d8             	mov    %eax,%cr3
		write_swap_page(swap_nr, (char *) page);
    de35:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    de39:	8b 54 24 08          	mov    0x8(%esp),%edx
    de3d:	8b 83 20 32 00 00    	mov    0x3220(%ebx),%eax
    de43:	51                   	push   %ecx
    de44:	52                   	push   %edx
    de45:	50                   	push   %eax
    de46:	6a 01                	push   $0x1
    de48:	e8 c2 a4 00 00       	call   1830f <ll_rw_page>
    de4d:	83 c4 10             	add    $0x10,%esp
		free_page(page);
    de50:	83 ec 0c             	sub    $0xc,%esp
    de53:	ff 74 24 18          	pushl  0x18(%esp)
    de57:	e8 13 ec ff ff       	call   ca6f <free_page>
    de5c:	83 c4 10             	add    $0x10,%esp
		return 1;
    de5f:	b8 01 00 00 00       	mov    $0x1,%eax
    de64:	eb 26                	jmp    de8c <try_to_swap_out+0x108>
	}
	// 否则表明页面没有修改过.那么就不用交换出去,而直接释放即可.
	*table_ptr = 0;
    de66:	8b 44 24 20          	mov    0x20(%esp),%eax
    de6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	invalidate();
    de70:	b8 00 00 00 00       	mov    $0x0,%eax
    de75:	0f 22 d8             	mov    %eax,%cr3
	free_page(page);
    de78:	83 ec 0c             	sub    $0xc,%esp
    de7b:	ff 74 24 18          	pushl  0x18(%esp)
    de7f:	e8 eb eb ff ff       	call   ca6f <free_page>
    de84:	83 c4 10             	add    $0x10,%esp
	return 1;
    de87:	b8 01 00 00 00       	mov    $0x1,%eax
}
    de8c:	83 c4 18             	add    $0x18,%esp
    de8f:	5b                   	pop    %ebx
    de90:	c3                   	ret    

0000de91 <swap_out>:
 */
// 把内存页面放到交换设备中.
// 从线性地址64MB对应的目录项(FIRST_VM_PAGE>>10)开始,搜索整个4GB线性空间,对有效页目录二级页表指定的物理内存页面执行交换
// 到交换设备中去的尝试.一旦成功地交换出一个页面,就返回-1.否则返回0.该函数会在get_free_page()中被调用.
int swap_out(void)
{
    de91:	53                   	push   %ebx
    de92:	83 ec 18             	sub    $0x18,%esp
    de95:	e8 60 8e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    de9a:	81 c3 66 41 02 00    	add    $0x24166,%ebx
	static int dir_entry = FIRST_VM_PAGE >> 10;	// 即任务1的第1个目录项索引.
	static int page_entry = -1;
	int counter = VM_PAGES;						// 表示除去任务0以外的其他任务的所有页数目
    dea0:	c7 44 24 0c 00 c0 0f 	movl   $0xfc000,0xc(%esp)
    dea7:	00 
	int pg_table;

	// 首先搜索页目录表,查找二级页表存在的页目录项pg_table.找到则退出循环,否则高速页目录项数对应剩余二级页表项数counter,然后继续
	// 检测下一项目录项.若全部搜索完还没有找到适合的(存在的)页目录项,就重新搜索.
	while (counter > 0) {
    dea8:	eb 4c                	jmp    def6 <swap_out+0x65>
		pg_table = pg_dir[dir_entry];			// 页目录项内容.
    deaa:	8b 93 a0 13 00 00    	mov    0x13a0(%ebx),%edx
    deb0:	c7 c0 00 00 00 00    	mov    $0x0,%eax
    deb6:	8b 04 90             	mov    (%eax,%edx,4),%eax
    deb9:	89 44 24 08          	mov    %eax,0x8(%esp)
		if (pg_table & 1)
    debd:	8b 44 24 08          	mov    0x8(%esp),%eax
    dec1:	83 e0 01             	and    $0x1,%eax
    dec4:	85 c0                	test   %eax,%eax
    dec6:	75 37                	jne    deff <swap_out+0x6e>
			break;
		counter -= 1024;						// 1个页表对应1024个页帧
    dec8:	81 6c 24 0c 00 04 00 	subl   $0x400,0xc(%esp)
    decf:	00 
		dir_entry++;							// 下一目录项.
    ded0:	8b 83 a0 13 00 00    	mov    0x13a0(%ebx),%eax
    ded6:	83 c0 01             	add    $0x1,%eax
    ded9:	89 83 a0 13 00 00    	mov    %eax,0x13a0(%ebx)
		// 如果整个4GB的1024个页目录项检查完了则又回到第1个任务重新开始检查
		if (dir_entry >= 1024)
    dedf:	8b 83 a0 13 00 00    	mov    0x13a0(%ebx),%eax
    dee5:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    deea:	7e 0a                	jle    def6 <swap_out+0x65>
			dir_entry = FIRST_VM_PAGE >> 10;
    deec:	c7 83 a0 13 00 00 10 	movl   $0x10,0x13a0(%ebx)
    def3:	00 00 00 
	while (counter > 0) {
    def6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    defb:	7f ad                	jg     deaa <swap_out+0x19>
    defd:	eb 01                	jmp    df00 <swap_out+0x6f>
			break;
    deff:	90                   	nop
	}
	// 在取得当前目录项的页表指针后,针对该页表中的所有1024个页面,逐一调用交换函数try_to_swap_out()尝试交换出去.一旦某个页面成功交换到交换设备
	// 中就返回1.若对所有目录项的所有页表都已尝试失败,则显示"交换内存用完"的警告,并返回0.
	pg_table &= 0xfffff000;						// 页表指针(地址)(页对齐)
    df00:	81 64 24 08 00 f0 ff 	andl   $0xfffff000,0x8(%esp)
    df07:	ff 
	while (counter-- > 0) {
    df08:	e9 ad 00 00 00       	jmp    dfba <swap_out+0x129>
		page_entry++;
    df0d:	8b 83 a4 13 00 00    	mov    0x13a4(%ebx),%eax
    df13:	83 c0 01             	add    $0x1,%eax
    df16:	89 83 a4 13 00 00    	mov    %eax,0x13a4(%ebx)
		// 如果已经尝试处理完当前页表所有项还没有能够成功地交换出一个页面,即此时页表项索引大于等于1024,则如同前面第135-143行执行相同的处理来选出一个
		// 二级页表存在的页目录项,并取得相应二级页表指针.
		if (page_entry >= 1024) {
    df1c:	8b 83 a4 13 00 00    	mov    0x13a4(%ebx),%eax
    df22:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    df27:	7e 67                	jle    df90 <swap_out+0xff>
			page_entry = 0;
    df29:	c7 83 a4 13 00 00 00 	movl   $0x0,0x13a4(%ebx)
    df30:	00 00 00 
		repeat:
			dir_entry++;
    df33:	8b 83 a0 13 00 00    	mov    0x13a0(%ebx),%eax
    df39:	83 c0 01             	add    $0x1,%eax
    df3c:	89 83 a0 13 00 00    	mov    %eax,0x13a0(%ebx)
			if (dir_entry >= 1024)
    df42:	8b 83 a0 13 00 00    	mov    0x13a0(%ebx),%eax
    df48:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    df4d:	7e 0a                	jle    df59 <swap_out+0xc8>
				dir_entry = FIRST_VM_PAGE >> 10;
    df4f:	c7 83 a0 13 00 00 10 	movl   $0x10,0x13a0(%ebx)
    df56:	00 00 00 
			pg_table = pg_dir[dir_entry];		// 页目录项内容.
    df59:	8b 93 a0 13 00 00    	mov    0x13a0(%ebx),%edx
    df5f:	c7 c0 00 00 00 00    	mov    $0x0,%eax
    df65:	8b 04 90             	mov    (%eax,%edx,4),%eax
    df68:	89 44 24 08          	mov    %eax,0x8(%esp)
			if (!(pg_table & 1))
    df6c:	8b 44 24 08          	mov    0x8(%esp),%eax
    df70:	83 e0 01             	and    $0x1,%eax
    df73:	85 c0                	test   %eax,%eax
    df75:	75 11                	jne    df88 <swap_out+0xf7>
				if ((counter -= 1024) > 0)
    df77:	81 6c 24 0c 00 04 00 	subl   $0x400,0xc(%esp)
    df7e:	00 
    df7f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    df84:	7e 49                	jle    dfcf <swap_out+0x13e>
					goto repeat;
    df86:	eb ab                	jmp    df33 <swap_out+0xa2>
				else
					break;
			pg_table &= 0xfffff000;				// 页表指针.
    df88:	81 64 24 08 00 f0 ff 	andl   $0xfffff000,0x8(%esp)
    df8f:	ff 
		}
		if (try_to_swap_out(page_entry + (unsigned long *) pg_table))
    df90:	8b 83 a4 13 00 00    	mov    0x13a4(%ebx),%eax
    df96:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    df9d:	8b 44 24 08          	mov    0x8(%esp),%eax
    dfa1:	01 d0                	add    %edx,%eax
    dfa3:	83 ec 0c             	sub    $0xc,%esp
    dfa6:	50                   	push   %eax
    dfa7:	e8 d8 fd ff ff       	call   dd84 <try_to_swap_out>
    dfac:	83 c4 10             	add    $0x10,%esp
    dfaf:	85 c0                	test   %eax,%eax
    dfb1:	74 07                	je     dfba <swap_out+0x129>
			return 1;
    dfb3:	b8 01 00 00 00       	mov    $0x1,%eax
    dfb8:	eb 2d                	jmp    dfe7 <swap_out+0x156>
	while (counter-- > 0) {
    dfba:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dfbe:	8d 50 ff             	lea    -0x1(%eax),%edx
    dfc1:	89 54 24 0c          	mov    %edx,0xc(%esp)
    dfc5:	85 c0                	test   %eax,%eax
    dfc7:	0f 8f 40 ff ff ff    	jg     df0d <swap_out+0x7c>
    dfcd:	eb 01                	jmp    dfd0 <swap_out+0x13f>
					break;
    dfcf:	90                   	nop
        }
	printk("Out of swap-memory\n\r");
    dfd0:	83 ec 0c             	sub    $0xc,%esp
    dfd3:	8d 83 5e 4d ff ff    	lea    -0xb2a2(%ebx),%eax
    dfd9:	50                   	push   %eax
    dfda:	e8 53 b3 ff ff       	call   9332 <printk>
    dfdf:	83 c4 10             	add    $0x10,%esp
	return 0;
    dfe2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dfe7:	83 c4 18             	add    $0x18,%esp
    dfea:	5b                   	pop    %ebx
    dfeb:	c3                   	ret    

0000dfec <get_free_page>:
// 上面%4寄存器实际指向mem_map[]内存字节位图的最后一个字节.本函数从位图末端开始向前扫描所有页面标志(页面总数为PAGING_AGES),若有页面空闲
// (内存位图字节为0)则返回页面地址.注意!本函数只是指出在主内存区的一页空闲物理页面,但并没有映射到某个进程的地址空间中去.后面的put_page()函数
// 即用于把指定页面映射到某个进程的地址空间中.当然对于内核使用本函数并不需要再使用put_page()进行映射,因为内核代码和数据空间(16MB)已经对等
// 地映射到物理地址空间.
unsigned long get_free_page(void)
{
    dfec:	57                   	push   %edi
    dfed:	56                   	push   %esi
    dfee:	53                   	push   %ebx
    dfef:	e8 12 03 00 00       	call   e306 <__x86.get_pc_thunk.si>
    dff4:	81 c6 0c 40 02 00    	add    $0x2400c,%esi
		"movl %%edx, %%eax							/* 将页面起始地址->eax(返回值). */\n\t"
		"1:\n\t"
		"cld"
		:"=a" (__res)
		:"0" (0), "i" (LOW_MEM), "c" (PAGING_PAGES),
		"D" (mem_map + PAGING_PAGES - 1)
    dffa:	c7 c0 20 43 03 00    	mov    $0x34320,%eax
    e000:	8d 98 ff 0e 00 00    	lea    0xeff(%eax),%ebx
	__asm__(
    e006:	b8 00 00 00 00       	mov    $0x0,%eax
    e00b:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    e010:	89 df                	mov    %ebx,%edi
    e012:	fd                   	std    
    e013:	f2 ae                	repnz scas %es:(%edi),%al
    e015:	75 1e                	jne    e035 <get_free_page+0x49>
    e017:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    e01b:	c1 e1 0c             	shl    $0xc,%ecx
    e01e:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    e024:	89 ca                	mov    %ecx,%edx
    e026:	b9 00 04 00 00       	mov    $0x400,%ecx
    e02b:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    e031:	f3 ab                	rep stos %eax,%es:(%edi)
    e033:	89 d0                	mov    %edx,%eax
    e035:	fc                   	cld    
    e036:	89 c3                	mov    %eax,%ebx
		:"dx");
	if (__res >= HIGH_MEMORY)						// 页面地址大于实际内存容量则重新寻找
    e038:	c7 c0 00 43 03 00    	mov    $0x34300,%eax
    e03e:	8b 00                	mov    (%eax),%eax
    e040:	39 c3                	cmp    %eax,%ebx
    e042:	72 02                	jb     e046 <get_free_page+0x5a>
		goto repeat;
    e044:	eb b4                	jmp    dffa <get_free_page+0xe>
	if (!__res && swap_out())						// 若没有得到空闲页面则执行交换处理,并重新查找.
    e046:	85 db                	test   %ebx,%ebx
    e048:	75 0b                	jne    e055 <get_free_page+0x69>
    e04a:	e8 42 fe ff ff       	call   de91 <swap_out>
    e04f:	85 c0                	test   %eax,%eax
    e051:	74 02                	je     e055 <get_free_page+0x69>
		goto repeat;
    e053:	eb a5                	jmp    dffa <get_free_page+0xe>
	return __res;									// 返回空闲物理页面地址.
    e055:	89 d8                	mov    %ebx,%eax
}
    e057:	5b                   	pop    %ebx
    e058:	5e                   	pop    %esi
    e059:	5f                   	pop    %edi
    e05a:	c3                   	ret    

0000e05b <init_swapping>:

// 内存交换初始化.
void init_swapping(void)
{
    e05b:	53                   	push   %ebx
    e05c:	83 ec 18             	sub    $0x18,%esp
    e05f:	e8 96 8c ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    e064:	81 c3 9c 3f 02 00    	add    $0x23f9c,%ebx
	// blk_size[]指向指定主设备号的块设备块数数组.该块数数组每一项对应一个设备上所拥有的数据块总数(1块大小=1KB).
	extern int *blk_size[];							// blk_drv/ll_rw_blk.c
	int swap_size, i, j;

	// 如果没有定义交换设备则返回.如果交换设备没有设置块数数组,则显示并返回.
	if (!SWAP_DEV)
    e06a:	8b 83 20 32 00 00    	mov    0x3220(%ebx),%eax
    e070:	85 c0                	test   %eax,%eax
    e072:	0f 84 4e 02 00 00    	je     e2c6 <init_swapping+0x26b>
		return;
	if (!blk_size[MAJOR(SWAP_DEV)]) {
    e078:	8b 83 20 32 00 00    	mov    0x3220(%ebx),%eax
    e07e:	c1 e8 08             	shr    $0x8,%eax
    e081:	89 c2                	mov    %eax,%edx
    e083:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
    e089:	8b 04 90             	mov    (%eax,%edx,4),%eax
    e08c:	85 c0                	test   %eax,%eax
    e08e:	75 17                	jne    e0a7 <init_swapping+0x4c>
		printk("Unable to get size of swap device\n\r");
    e090:	83 ec 0c             	sub    $0xc,%esp
    e093:	8d 83 74 4d ff ff    	lea    -0xb28c(%ebx),%eax
    e099:	50                   	push   %eax
    e09a:	e8 93 b2 ff ff       	call   9332 <printk>
    e09f:	83 c4 10             	add    $0x10,%esp
		return;
    e0a2:	e9 23 02 00 00       	jmp    e2ca <init_swapping+0x26f>
	}
	// 取指定交换设备号的交换区数据块总数swap_size.若为0则返回,若总块数小于100块则显示信息"交换设备区太小",然后退出.
	swap_size = blk_size[MAJOR(SWAP_DEV)][MINOR(SWAP_DEV)];
    e0a7:	8b 83 20 32 00 00    	mov    0x3220(%ebx),%eax
    e0ad:	c1 e8 08             	shr    $0x8,%eax
    e0b0:	89 c2                	mov    %eax,%edx
    e0b2:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
    e0b8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    e0bb:	8b 93 20 32 00 00    	mov    0x3220(%ebx),%edx
    e0c1:	0f b6 d2             	movzbl %dl,%edx
    e0c4:	c1 e2 02             	shl    $0x2,%edx
    e0c7:	01 d0                	add    %edx,%eax
    e0c9:	8b 00                	mov    (%eax),%eax
    e0cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!swap_size)
    e0cf:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e0d4:	0f 84 ef 01 00 00    	je     e2c9 <init_swapping+0x26e>
		return;
	if (swap_size < 100) {
    e0da:	83 7c 24 0c 63       	cmpl   $0x63,0xc(%esp)
    e0df:	7f 1b                	jg     e0fc <init_swapping+0xa1>
		printk("Swap device too small (%d blocks)\n\r", swap_size);
    e0e1:	83 ec 08             	sub    $0x8,%esp
    e0e4:	ff 74 24 14          	pushl  0x14(%esp)
    e0e8:	8d 83 98 4d ff ff    	lea    -0xb268(%ebx),%eax
    e0ee:	50                   	push   %eax
    e0ef:	e8 3e b2 ff ff       	call   9332 <printk>
    e0f4:	83 c4 10             	add    $0x10,%esp
		return;
    e0f7:	e9 ce 01 00 00       	jmp    e2ca <init_swapping+0x26f>
	}
	// 每页4个数据块,所以swap_size >>= 2计算出交换页面总数.
	// 交换数据块总数转换成对应可交换页面总数.该值不能大于SWAP_BITS所能表示的页面数.即交换页面总数不得大于32768.
	swap_size >>= 2;
    e0fc:	c1 7c 24 0c 02       	sarl   $0x2,0xc(%esp)
	if (swap_size > SWAP_BITS)
    e101:	81 7c 24 0c 00 80 00 	cmpl   $0x8000,0xc(%esp)
    e108:	00 
    e109:	7e 08                	jle    e113 <init_swapping+0xb8>
		swap_size = SWAP_BITS;
    e10b:	c7 44 24 0c 00 80 00 	movl   $0x8000,0xc(%esp)
    e112:	00 
	// 然后申请一页物理内存来存放交换页面映射数组swap_bitmap,其中每1比特代表1页交换页面
	swap_bitmap = (char *) get_free_page();
    e113:	e8 d4 fe ff ff       	call   dfec <get_free_page>
    e118:	89 83 24 32 00 00    	mov    %eax,0x3224(%ebx)
	if (!swap_bitmap) {
    e11e:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e124:	85 c0                	test   %eax,%eax
    e126:	75 17                	jne    e13f <init_swapping+0xe4>
		printk("Unable to start swapping: out of memory :-)\n\r");
    e128:	83 ec 0c             	sub    $0xc,%esp
    e12b:	8d 83 bc 4d ff ff    	lea    -0xb244(%ebx),%eax
    e131:	50                   	push   %eax
    e132:	e8 fb b1 ff ff       	call   9332 <printk>
    e137:	83 c4 10             	add    $0x10,%esp
		return;
    e13a:	e9 8b 01 00 00       	jmp    e2ca <init_swapping+0x26f>
	}
	// read_swap_page(nr,buffer)被定义为ll_rw_page(READ,SWAP_DEV,(nr),(buffer)).这里把交换设备上的页面０读到swap_bitmap页面中.该页面
	//　是交换区管理页面.其中第4086字节开始处含有１０个字符的交换设备特征字符串"SWAP-SPACE".若没有找到该特征字符串,则说明不是一个有效的交换设备.
	// 于是显示信息,释放刚申请的物理页面并退出函数.否则将特征字符串字节清零.
	read_swap_page(0, swap_bitmap);
    e13f:	8b 93 24 32 00 00    	mov    0x3224(%ebx),%edx
    e145:	8b 83 20 32 00 00    	mov    0x3220(%ebx),%eax
    e14b:	52                   	push   %edx
    e14c:	6a 00                	push   $0x0
    e14e:	50                   	push   %eax
    e14f:	6a 00                	push   $0x0
    e151:	e8 b9 a1 00 00       	call   1830f <ll_rw_page>
    e156:	83 c4 10             	add    $0x10,%esp
	if (strncmp("SWAP-SPACE", swap_bitmap + 4086, 10)) {
    e159:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e15f:	05 f6 0f 00 00       	add    $0xff6,%eax
    e164:	83 ec 04             	sub    $0x4,%esp
    e167:	6a 0a                	push   $0xa
    e169:	50                   	push   %eax
    e16a:	8d 83 ea 4d ff ff    	lea    -0xb216(%ebx),%eax
    e170:	50                   	push   %eax
    e171:	e8 32 f9 ff ff       	call   daa8 <strncmp>
    e176:	83 c4 10             	add    $0x10,%esp
    e179:	85 c0                	test   %eax,%eax
    e17b:	74 33                	je     e1b0 <init_swapping+0x155>
		printk("Unable to find swap-space signature\n\r");
    e17d:	83 ec 0c             	sub    $0xc,%esp
    e180:	8d 83 f8 4d ff ff    	lea    -0xb208(%ebx),%eax
    e186:	50                   	push   %eax
    e187:	e8 a6 b1 ff ff       	call   9332 <printk>
    e18c:	83 c4 10             	add    $0x10,%esp
		free_page((long) swap_bitmap);
    e18f:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e195:	83 ec 0c             	sub    $0xc,%esp
    e198:	50                   	push   %eax
    e199:	e8 d1 e8 ff ff       	call   ca6f <free_page>
    e19e:	83 c4 10             	add    $0x10,%esp
		swap_bitmap = NULL;
    e1a1:	c7 83 24 32 00 00 00 	movl   $0x0,0x3224(%ebx)
    e1a8:	00 00 00 
		return;
    e1ab:	e9 1a 01 00 00       	jmp    e2ca <init_swapping+0x26f>
	}
	// 将交换设备的标志字符串"SWAP-SPACE"字符串清空
	memset(swap_bitmap + 4086, 0, 10);
    e1b0:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e1b6:	05 f6 0f 00 00       	add    $0xff6,%eax
    e1bb:	83 ec 04             	sub    $0x4,%esp
    e1be:	6a 0a                	push   $0xa
    e1c0:	6a 00                	push   $0x0
    e1c2:	50                   	push   %eax
    e1c3:	e8 18 f9 ff ff       	call   dae0 <memset>
    e1c8:	83 c4 10             	add    $0x10,%esp
	// 然后检查读入的交换位映射图.应该32768个位全为0,若位图中有置位的位0,则表示位图有问题,于是显示出错信息,释放位图占用的页面并退出函数.为了加快检查速度,
	// 这里首先仅挑选查看位图0和最后一个交换页面对应的位,即swap_size交换页面对应的位,以及随后到SWAP_BITS(32768)位.
	for (i = 0 ; i < SWAP_BITS ; i++) {
    e1cb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    e1d2:	00 
    e1d3:	eb 62                	jmp    e237 <init_swapping+0x1dc>
		if (i == 1)
    e1d5:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
    e1da:	75 08                	jne    e1e4 <init_swapping+0x189>
			i = swap_size;
    e1dc:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e1e0:	89 44 24 08          	mov    %eax,0x8(%esp)
		if (bit(swap_bitmap, i)) {
    e1e4:	8b 54 24 08          	mov    0x8(%esp),%edx
    e1e8:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e1ee:	83 ec 08             	sub    $0x8,%esp
    e1f1:	52                   	push   %edx
    e1f2:	50                   	push   %eax
    e1f3:	e8 4d f9 ff ff       	call   db45 <bit>
    e1f8:	83 c4 10             	add    $0x10,%esp
    e1fb:	85 c0                	test   %eax,%eax
    e1fd:	74 33                	je     e232 <init_swapping+0x1d7>
			printk("Bad swap-space bit-map\n\r");
    e1ff:	83 ec 0c             	sub    $0xc,%esp
    e202:	8d 83 1e 4e ff ff    	lea    -0xb1e2(%ebx),%eax
    e208:	50                   	push   %eax
    e209:	e8 24 b1 ff ff       	call   9332 <printk>
    e20e:	83 c4 10             	add    $0x10,%esp
			free_page((long) swap_bitmap);
    e211:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e217:	83 ec 0c             	sub    $0xc,%esp
    e21a:	50                   	push   %eax
    e21b:	e8 4f e8 ff ff       	call   ca6f <free_page>
    e220:	83 c4 10             	add    $0x10,%esp
			swap_bitmap = NULL;
    e223:	c7 83 24 32 00 00 00 	movl   $0x0,0x3224(%ebx)
    e22a:	00 00 00 
			return;
    e22d:	e9 98 00 00 00       	jmp    e2ca <init_swapping+0x26f>
	for (i = 0 ; i < SWAP_BITS ; i++) {
    e232:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    e237:	81 7c 24 08 ff 7f 00 	cmpl   $0x7fff,0x8(%esp)
    e23e:	00 
    e23f:	7e 94                	jle    e1d5 <init_swapping+0x17a>
		}
	}
	// 然后再仔细地检测位1到位swap_size所有位是否为0.若存在不是0的位,则表示位图有问题,于是释放位图占用的页面并退出函数.否则显示交换设备工作正常以及交换页面
	// 和交换空间总字节数.
	j = 0;
    e241:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    e248:	00 
	for (i = 1 ; i < swap_size ; i++)
    e249:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    e250:	00 
    e251:	eb 25                	jmp    e278 <init_swapping+0x21d>
		if (bit(swap_bitmap, i))
    e253:	8b 54 24 08          	mov    0x8(%esp),%edx
    e257:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e25d:	83 ec 08             	sub    $0x8,%esp
    e260:	52                   	push   %edx
    e261:	50                   	push   %eax
    e262:	e8 de f8 ff ff       	call   db45 <bit>
    e267:	83 c4 10             	add    $0x10,%esp
    e26a:	85 c0                	test   %eax,%eax
    e26c:	74 05                	je     e273 <init_swapping+0x218>
			j++;
    e26e:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
	for (i = 1 ; i < swap_size ; i++)
    e273:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    e278:	8b 44 24 08          	mov    0x8(%esp),%eax
    e27c:	3b 44 24 0c          	cmp    0xc(%esp),%eax
    e280:	7c d1                	jl     e253 <init_swapping+0x1f8>
	if (!j) {
    e282:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    e287:	75 1e                	jne    e2a7 <init_swapping+0x24c>
		free_page((long) swap_bitmap);
    e289:	8b 83 24 32 00 00    	mov    0x3224(%ebx),%eax
    e28f:	83 ec 0c             	sub    $0xc,%esp
    e292:	50                   	push   %eax
    e293:	e8 d7 e7 ff ff       	call   ca6f <free_page>
    e298:	83 c4 10             	add    $0x10,%esp
		swap_bitmap = NULL;
    e29b:	c7 83 24 32 00 00 00 	movl   $0x0,0x3224(%ebx)
    e2a2:	00 00 00 
		return;
    e2a5:	eb 23                	jmp    e2ca <init_swapping+0x26f>
	}
	Log(LOG_INFO_TYPE, "<<<<< Swap device ok: %d pages (%d bytes) swap-space >>>>>\n\r", j, j * 4096);
    e2a7:	8b 44 24 04          	mov    0x4(%esp),%eax
    e2ab:	c1 e0 0c             	shl    $0xc,%eax
    e2ae:	50                   	push   %eax
    e2af:	ff 74 24 08          	pushl  0x8(%esp)
    e2b3:	8d 83 38 4e ff ff    	lea    -0xb1c8(%ebx),%eax
    e2b9:	50                   	push   %eax
    e2ba:	6a 00                	push   $0x0
    e2bc:	e8 de 78 01 00       	call   25b9f <Log>
    e2c1:	83 c4 10             	add    $0x10,%esp
    e2c4:	eb 04                	jmp    e2ca <init_swapping+0x26f>
		return;
    e2c6:	90                   	nop
    e2c7:	eb 01                	jmp    e2ca <init_swapping+0x26f>
		return;
    e2c9:	90                   	nop
}
    e2ca:	83 c4 18             	add    $0x18,%esp
    e2cd:	5b                   	pop    %ebx
    e2ce:	c3                   	ret    

0000e2cf <page_fault>:
    e2cf:	87 04 24             	xchg   %eax,(%esp)
    e2d2:	51                   	push   %ecx
    e2d3:	52                   	push   %edx
    e2d4:	1e                   	push   %ds
    e2d5:	06                   	push   %es
    e2d6:	0f a0                	push   %fs
    e2d8:	ba 10 00 00 00       	mov    $0x10,%edx
    e2dd:	8e da                	mov    %edx,%ds
    e2df:	8e c2                	mov    %edx,%es
    e2e1:	8e e2                	mov    %edx,%fs
    e2e3:	0f 20 d2             	mov    %cr2,%edx
    e2e6:	52                   	push   %edx
    e2e7:	50                   	push   %eax
    e2e8:	a9 01 00 00 00       	test   $0x1,%eax
    e2ed:	75 07                	jne    e2f6 <page_fault+0x27>
    e2ef:	e8 fe f1 ff ff       	call   d4f2 <do_no_page>
    e2f4:	eb 05                	jmp    e2fb <page_fault+0x2c>
    e2f6:	e8 1c ee ff ff       	call   d117 <do_wp_page>
    e2fb:	83 c4 08             	add    $0x8,%esp
    e2fe:	0f a1                	pop    %fs
    e300:	07                   	pop    %es
    e301:	1f                   	pop    %ds
    e302:	5a                   	pop    %edx
    e303:	59                   	pop    %ecx
    e304:	58                   	pop    %eax
    e305:	cf                   	iret   

0000e306 <__x86.get_pc_thunk.si>:
    e306:	8b 34 24             	mov    (%esp),%esi
    e309:	c3                   	ret    

0000e30a <get_fs_long>:
//// 读取fs段中指定地址处的长字(4字节).
// 参数:addr - 指定的内存地址.
// %0 - (返回的长字_v);%1 - (内存地址addr)
// 返回:返回内存fs:[addr]处的长字.
static inline unsigned long get_fs_long(const unsigned long *addr)
{
    e30a:	83 ec 10             	sub    $0x10,%esp
    e30d:	e8 e0 89 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    e312:	05 ee 3c 02 00       	add    $0x23cee,%eax
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    e317:	8b 44 24 14          	mov    0x14(%esp),%eax
    e31b:	64 8b 00             	mov    %fs:(%eax),%eax
    e31e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
    e322:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    e326:	83 c4 10             	add    $0x10,%esp
    e329:	c3                   	ret    

0000e32a <sys_ustat>:
// 取文件系统信息。
// 参数dev是含有用户已安装文件系统的设备号。ubuf是一个ustat结构缓冲区指针，用于存放系统返回的文件系统信息。该系统
// 调用用于返回已安装（mounted）文件系统的统计信息。成功时返回0，并且ubuf指向的ustate结构被添入文件系统总空闲块
// 和空闲i节点数。ustat结构定义在include/sys/types.h中。
int sys_ustat(int dev, struct ustat * ubuf)
{
    e32a:	e8 c3 89 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    e32f:	05 d1 3c 02 00       	add    $0x23cd1,%eax
	return -ENOSYS;         						// 出错码：功能还未实现。
    e334:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    e339:	c3                   	ret    

0000e33a <sys_utime>:
// 设置文件访问和修改时间。
// 参数filename是文件名，times是访问和修改时间结构指针。
// 如果times指针不为NULL，则取utimbuf结构中的时间信息来设置文件的访问和修改时间。
// 如果times指针是NULL，则取系统当前时间来设置指定文件的访问和修改时间域。
int sys_utime(char * filename, struct utimbuf * times)
{
    e33a:	53                   	push   %ebx
    e33b:	83 ec 18             	sub    $0x18,%esp
    e33e:	e8 b7 89 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    e343:	81 c3 bd 3c 02 00    	add    $0x23cbd,%ebx
	long actime, modtime;

	// 文件的时间信息保存在其i节点中。因此我们首先根据文件名取得对应i节点。如果没有找到，则返回出错码。如果提供的访问
	// 和修改时间结构指针times不为NULL，则从结构中读取用户设置的时间值。否则就用系统当前时间来设置文件的访问和修改时
	// 间。
	if (!(inode = namei(filename)))
    e349:	83 ec 0c             	sub    $0xc,%esp
    e34c:	ff 74 24 2c          	pushl  0x2c(%esp)
    e350:	e8 58 69 00 00       	call   14cad <namei>
    e355:	83 c4 10             	add    $0x10,%esp
    e358:	89 44 24 04          	mov    %eax,0x4(%esp)
    e35c:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    e361:	75 0a                	jne    e36d <sys_utime+0x33>
		return -ENOENT;
    e363:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    e368:	e9 98 00 00 00       	jmp    e405 <sys_utime+0xcb>
	if (times) {
    e36d:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    e372:	74 2d                	je     e3a1 <sys_utime+0x67>
		actime = get_fs_long((unsigned long *) &times->actime);
    e374:	8b 44 24 24          	mov    0x24(%esp),%eax
    e378:	83 ec 0c             	sub    $0xc,%esp
    e37b:	50                   	push   %eax
    e37c:	e8 89 ff ff ff       	call   e30a <get_fs_long>
    e381:	83 c4 10             	add    $0x10,%esp
    e384:	89 44 24 0c          	mov    %eax,0xc(%esp)
		modtime = get_fs_long((unsigned long *) &times->modtime);
    e388:	8b 44 24 24          	mov    0x24(%esp),%eax
    e38c:	83 c0 04             	add    $0x4,%eax
    e38f:	83 ec 0c             	sub    $0xc,%esp
    e392:	50                   	push   %eax
    e393:	e8 72 ff ff ff       	call   e30a <get_fs_long>
    e398:	83 c4 10             	add    $0x10,%esp
    e39b:	89 44 24 08          	mov    %eax,0x8(%esp)
    e39f:	eb 32                	jmp    e3d3 <sys_utime+0x99>
	} else
		actime = modtime = CURRENT_TIME;
    e3a1:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    e3a7:	8b 10                	mov    (%eax),%edx
    e3a9:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    e3af:	8b 00                	mov    (%eax),%eax
    e3b1:	01 d0                	add    %edx,%eax
    e3b3:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    e3b8:	f7 e2                	mul    %edx
    e3ba:	c1 ea 05             	shr    $0x5,%edx
    e3bd:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    e3c3:	8b 00                	mov    (%eax),%eax
    e3c5:	01 d0                	add    %edx,%eax
    e3c7:	89 44 24 08          	mov    %eax,0x8(%esp)
    e3cb:	8b 44 24 08          	mov    0x8(%esp),%eax
    e3cf:	89 44 24 0c          	mov    %eax,0xc(%esp)
	// 然后修改i节点中的访问时间字段和修改时间字段。再设置i节点已修改标志，放回该i节点，并返回0。
	inode->i_atime = actime;
    e3d3:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e3d7:	8b 44 24 04          	mov    0x4(%esp),%eax
    e3db:	89 50 28             	mov    %edx,0x28(%eax)
	inode->i_mtime = modtime;
    e3de:	8b 54 24 08          	mov    0x8(%esp),%edx
    e3e2:	8b 44 24 04          	mov    0x4(%esp),%eax
    e3e6:	89 50 08             	mov    %edx,0x8(%eax)
	inode->i_dirt = 1;
    e3e9:	8b 44 24 04          	mov    0x4(%esp),%eax
    e3ed:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	iput(inode);
    e3f1:	83 ec 0c             	sub    $0xc,%esp
    e3f4:	ff 74 24 10          	pushl  0x10(%esp)
    e3f8:	e8 a5 14 00 00       	call   f8a2 <iput>
    e3fd:	83 c4 10             	add    $0x10,%esp
	return 0;
    e400:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e405:	83 c4 18             	add    $0x18,%esp
    e408:	5b                   	pop    %ebx
    e409:	c3                   	ret    

0000e40a <sys_access>:
 */
// 检查文件的访问权限。
// 参数filename是文件名，mode是检查的访问属性，它有3个有效位组成：R_OK（值4）、W_OK（2）、X_OK（1）和F_OK（0）
// 组成，分别表示检测文件是否可读、可写、可执行和文件是否存在。如果访问允许的话，则返回0,否则返回出错码。
int sys_access(const char * filename, int mode)
{
    e40a:	53                   	push   %ebx
    e40b:	83 ec 18             	sub    $0x18,%esp
    e40e:	e8 e7 88 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    e413:	81 c3 ed 3b 02 00    	add    $0x23bed,%ebx
	int res, i_mode;

	// 文件的访问权限信息同样保存在文件的i节点结构中，因此我们要先取得对应文件名的i节点。检测的访问属性mode由低3位组成，
	// 因此需要与上八进制0007来清除所有高位。如果文件名对应的i节点不存在，则返回没有许可权限出错码。若i节点存在，则取i
	// 节点中文件属性码，并放回该i节点。另外，57行上语句“iput(inode);”最好放在61行之后。
	mode &= 0007;
    e419:	83 64 24 24 07       	andl   $0x7,0x24(%esp)
	if (!(inode = namei(filename)))
    e41e:	83 ec 0c             	sub    $0xc,%esp
    e421:	ff 74 24 2c          	pushl  0x2c(%esp)
    e425:	e8 83 68 00 00       	call   14cad <namei>
    e42a:	83 c4 10             	add    $0x10,%esp
    e42d:	89 44 24 08          	mov    %eax,0x8(%esp)
    e431:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    e436:	75 0a                	jne    e442 <sys_access+0x38>
		return -EACCES;                 				// 出错码：无访问权限。
    e438:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    e43d:	e9 bf 00 00 00       	jmp    e501 <sys_access+0xf7>
	i_mode = res = inode->i_mode & 0777;
    e442:	8b 44 24 08          	mov    0x8(%esp),%eax
    e446:	0f b7 00             	movzwl (%eax),%eax
    e449:	0f b7 c0             	movzwl %ax,%eax
    e44c:	25 ff 01 00 00       	and    $0x1ff,%eax
    e451:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e455:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e459:	89 44 24 04          	mov    %eax,0x4(%esp)
	iput(inode);
    e45d:	83 ec 0c             	sub    $0xc,%esp
    e460:	ff 74 24 14          	pushl  0x14(%esp)
    e464:	e8 39 14 00 00       	call   f8a2 <iput>
    e469:	83 c4 10             	add    $0x10,%esp
	// 如果当前进程用户是该文件的宿主，则取文件宿主属性。否则如果当前进程用户与该文件宿主同属一个级，则取文件组属性。否则
	// 此时res低3位是其他人访问该文件的许可属性。
	// [??这里应res >> 3 ??]
	if (current->uid == inode->i_uid)
    e46c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e472:	8b 00                	mov    (%eax),%eax
    e474:	0f b7 90 cc 02 00 00 	movzwl 0x2cc(%eax),%edx
    e47b:	8b 44 24 08          	mov    0x8(%esp),%eax
    e47f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    e483:	66 39 c2             	cmp    %ax,%dx
    e486:	75 07                	jne    e48f <sys_access+0x85>
		res >>= 6;
    e488:	c1 7c 24 0c 06       	sarl   $0x6,0xc(%esp)
    e48d:	eb 24                	jmp    e4b3 <sys_access+0xa9>
	else if (current->gid == inode->i_gid)
    e48f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e495:	8b 00                	mov    (%eax),%eax
    e497:	0f b7 90 d2 02 00 00 	movzwl 0x2d2(%eax),%edx
    e49e:	8b 44 24 08          	mov    0x8(%esp),%eax
    e4a2:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    e4a6:	0f b6 c0             	movzbl %al,%eax
    e4a9:	66 39 c2             	cmp    %ax,%dx
    e4ac:	75 05                	jne    e4b3 <sys_access+0xa9>
		res >>= 3;
    e4ae:	c1 7c 24 0c 03       	sarl   $0x3,0xc(%esp)
	// 此时res的最低3位是根据当前进程用户与文件的关系选择出来的访问属性位。现在我们来判断这3位。如果文件属性具有参数所查询
	// 的属性位mode，则访问许可，返回0。
	if ((res & 0007 & mode) == mode)
    e4b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e4b7:	83 e0 07             	and    $0x7,%eax
    e4ba:	23 44 24 24          	and    0x24(%esp),%eax
    e4be:	39 44 24 24          	cmp    %eax,0x24(%esp)
    e4c2:	75 07                	jne    e4cb <sys_access+0xc1>
		return 0;
    e4c4:	b8 00 00 00 00       	mov    $0x0,%eax
    e4c9:	eb 36                	jmp    e501 <sys_access+0xf7>
    /*
     * XXX我们最后才做下面的测试，因为我们实际上需要交换有效用户ID和真实用户ID（临时地），然后才调用suser()函数，
     * 如果我们确实要调用suser()函数，则需要最后才被调用。
     */
	// 如果当前用户ID为0（超级用户）并且屏蔽码执行位是0或者文件可以被任何人执行、搜索，则返回0。否则返回出错码。
	if ((!current->uid) &&
    e4cb:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e4d1:	8b 00                	mov    (%eax),%eax
    e4d3:	0f b7 80 cc 02 00 00 	movzwl 0x2cc(%eax),%eax
    e4da:	66 85 c0             	test   %ax,%ax
    e4dd:	75 1d                	jne    e4fc <sys_access+0xf2>
	    (!(mode & 1) || (i_mode & 0111)))
    e4df:	8b 44 24 24          	mov    0x24(%esp),%eax
    e4e3:	83 e0 01             	and    $0x1,%eax
	if ((!current->uid) &&
    e4e6:	85 c0                	test   %eax,%eax
    e4e8:	74 0b                	je     e4f5 <sys_access+0xeb>
	    (!(mode & 1) || (i_mode & 0111)))
    e4ea:	8b 44 24 04          	mov    0x4(%esp),%eax
    e4ee:	83 e0 49             	and    $0x49,%eax
    e4f1:	85 c0                	test   %eax,%eax
    e4f3:	74 07                	je     e4fc <sys_access+0xf2>
		return 0;
    e4f5:	b8 00 00 00 00       	mov    $0x0,%eax
    e4fa:	eb 05                	jmp    e501 <sys_access+0xf7>
	return -EACCES;         							// 出错码：无访问权限。
    e4fc:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
}
    e501:	83 c4 18             	add    $0x18,%esp
    e504:	5b                   	pop    %ebx
    e505:	c3                   	ret    

0000e506 <sys_chdir>:

// 改变当前工作目录系统调用。
// 参数filename是目录名。
// 操作成功则返回0,否则返回出错码。
int sys_chdir(const char * filename)
{
    e506:	53                   	push   %ebx
    e507:	83 ec 18             	sub    $0x18,%esp
    e50a:	e8 eb 87 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    e50f:	81 c3 f1 3a 02 00    	add    $0x23af1,%ebx
	struct m_inode * inode;

	// 改变当前工作目录就是要求把进程任务结构的当前工作目录字段指向给定目录名的i节点。因此我们首先取目录名的i节点。如果目录名对应
	// 的i节点不存在，则返回出错码。如果该i节点不是一个目录i节点，则放回该i节点，并返回出错码。
	if (!(inode = namei(filename)))
    e515:	83 ec 0c             	sub    $0xc,%esp
    e518:	ff 74 24 2c          	pushl  0x2c(%esp)
    e51c:	e8 8c 67 00 00       	call   14cad <namei>
    e521:	83 c4 10             	add    $0x10,%esp
    e524:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e528:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e52d:	75 07                	jne    e536 <sys_chdir+0x30>
		return -ENOENT;                 				// 出错码：文件或目录不存在。
    e52f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    e534:	eb 5d                	jmp    e593 <sys_chdir+0x8d>
	if (!S_ISDIR(inode->i_mode)) {
    e536:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e53a:	0f b7 00             	movzwl (%eax),%eax
    e53d:	0f b7 c0             	movzwl %ax,%eax
    e540:	25 00 f0 00 00       	and    $0xf000,%eax
    e545:	3d 00 40 00 00       	cmp    $0x4000,%eax
    e54a:	74 16                	je     e562 <sys_chdir+0x5c>
		iput(inode);
    e54c:	83 ec 0c             	sub    $0xc,%esp
    e54f:	ff 74 24 18          	pushl  0x18(%esp)
    e553:	e8 4a 13 00 00       	call   f8a2 <iput>
    e558:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;                				// 出错码：不是目录名。
    e55b:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
    e560:	eb 31                	jmp    e593 <sys_chdir+0x8d>
	}
	// 然后释放进程原工作目录i节点，并使其指向新设置的工作目录i节点。返回0.
	iput(current->pwd);
    e562:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e568:	8b 00                	mov    (%eax),%eax
    e56a:	8b 80 34 03 00 00    	mov    0x334(%eax),%eax
    e570:	83 ec 0c             	sub    $0xc,%esp
    e573:	50                   	push   %eax
    e574:	e8 29 13 00 00       	call   f8a2 <iput>
    e579:	83 c4 10             	add    $0x10,%esp
	current->pwd = inode;
    e57c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e582:	8b 00                	mov    (%eax),%eax
    e584:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e588:	89 90 34 03 00 00    	mov    %edx,0x334(%eax)
	return (0);
    e58e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e593:	83 c4 18             	add    $0x18,%esp
    e596:	5b                   	pop    %ebx
    e597:	c3                   	ret    

0000e598 <sys_chroot>:

// 改变根目录系统调用。
// 把指定的目录名设置成为当前进程的根目录“/”。
// 如果操作成功则返回0，否则返回出错码。
int sys_chroot(const char * filename)
{
    e598:	53                   	push   %ebx
    e599:	83 ec 18             	sub    $0x18,%esp
    e59c:	e8 59 87 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    e5a1:	81 c3 5f 3a 02 00    	add    $0x23a5f,%ebx
	struct m_inode * inode;

	// 该调用用于改变当前进程任务结构中的根目录字段root，让其指向参数给定目录名的i节点。如果目录名对应i节点不存在，则返回出错码。
	// 如果该i节点不是目录i节点，则放回该i节点，也返回出错码。
	if (!(inode = namei(filename)))
    e5a7:	83 ec 0c             	sub    $0xc,%esp
    e5aa:	ff 74 24 2c          	pushl  0x2c(%esp)
    e5ae:	e8 fa 66 00 00       	call   14cad <namei>
    e5b3:	83 c4 10             	add    $0x10,%esp
    e5b6:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e5ba:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e5bf:	75 07                	jne    e5c8 <sys_chroot+0x30>
		return -ENOENT;
    e5c1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    e5c6:	eb 5d                	jmp    e625 <sys_chroot+0x8d>
	if (!S_ISDIR(inode->i_mode)) {
    e5c8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e5cc:	0f b7 00             	movzwl (%eax),%eax
    e5cf:	0f b7 c0             	movzwl %ax,%eax
    e5d2:	25 00 f0 00 00       	and    $0xf000,%eax
    e5d7:	3d 00 40 00 00       	cmp    $0x4000,%eax
    e5dc:	74 16                	je     e5f4 <sys_chroot+0x5c>
		iput(inode);
    e5de:	83 ec 0c             	sub    $0xc,%esp
    e5e1:	ff 74 24 18          	pushl  0x18(%esp)
    e5e5:	e8 b8 12 00 00       	call   f8a2 <iput>
    e5ea:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
    e5ed:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
    e5f2:	eb 31                	jmp    e625 <sys_chroot+0x8d>
	}
	// 然后释放当前进程的根目录，并重新设置为指定目录名的i节点，返回0。
	iput(current->root);
    e5f4:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e5fa:	8b 00                	mov    (%eax),%eax
    e5fc:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
    e602:	83 ec 0c             	sub    $0xc,%esp
    e605:	50                   	push   %eax
    e606:	e8 97 12 00 00       	call   f8a2 <iput>
    e60b:	83 c4 10             	add    $0x10,%esp
	current->root = inode;
    e60e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e614:	8b 00                	mov    (%eax),%eax
    e616:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e61a:	89 90 38 03 00 00    	mov    %edx,0x338(%eax)
	return (0);
    e620:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e625:	83 c4 18             	add    $0x18,%esp
    e628:	5b                   	pop    %ebx
    e629:	c3                   	ret    

0000e62a <sys_chmod>:

// 修改文件属性系统调用。
// 参数filename是文件名，mode是新的文件属性。
int sys_chmod(const char * filename, int mode)
{
    e62a:	53                   	push   %ebx
    e62b:	83 ec 18             	sub    $0x18,%esp
    e62e:	e8 c7 86 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    e633:	81 c3 cd 39 02 00    	add    $0x239cd,%ebx
	struct m_inode * inode;

	// 该调用为指定文件设置新的访问属性mode。文件的访问属性在文件名对应的i节点中，因此我们首先取文件名对应的i节点。如果i节点不存
	// 在，则返回出错码（文件或目录不存在）。如果当前进程的有效用户名id与文件i节点的用户id不同，并且也不是超级用户，则放回该文件
	// i节点，返回出错码（没有访问权限）。
	if (!(inode = namei(filename)))
    e639:	83 ec 0c             	sub    $0xc,%esp
    e63c:	ff 74 24 2c          	pushl  0x2c(%esp)
    e640:	e8 68 66 00 00       	call   14cad <namei>
    e645:	83 c4 10             	add    $0x10,%esp
    e648:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e64c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e651:	75 0a                	jne    e65d <sys_chmod+0x33>
		return -ENOENT;
    e653:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    e658:	e9 82 00 00 00       	jmp    e6df <sys_chmod+0xb5>
	if ((current->euid != inode->i_uid) && !suser()) {
    e65d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e663:	8b 00                	mov    (%eax),%eax
    e665:	0f b7 90 ce 02 00 00 	movzwl 0x2ce(%eax),%edx
    e66c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e670:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    e674:	66 39 c2             	cmp    %ax,%dx
    e677:	74 2a                	je     e6a3 <sys_chmod+0x79>
    e679:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e67f:	8b 00                	mov    (%eax),%eax
    e681:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    e688:	66 85 c0             	test   %ax,%ax
    e68b:	74 16                	je     e6a3 <sys_chmod+0x79>
		iput(inode);
    e68d:	83 ec 0c             	sub    $0xc,%esp
    e690:	ff 74 24 18          	pushl  0x18(%esp)
    e694:	e8 09 12 00 00       	call   f8a2 <iput>
    e699:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    e69c:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    e6a1:	eb 3c                	jmp    e6df <sys_chmod+0xb5>
	}
	// 否则就重新设置该i节点的文件属性，并置该i节点已修改标志。放回该i节点，返回0。
	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
    e6a3:	8b 44 24 24          	mov    0x24(%esp),%eax
    e6a7:	66 25 ff 0f          	and    $0xfff,%ax
    e6ab:	89 c2                	mov    %eax,%edx
    e6ad:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e6b1:	0f b7 00             	movzwl (%eax),%eax
    e6b4:	66 25 00 f0          	and    $0xf000,%ax
    e6b8:	09 d0                	or     %edx,%eax
    e6ba:	89 c2                	mov    %eax,%edx
    e6bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e6c0:	66 89 10             	mov    %dx,(%eax)
	inode->i_dirt = 1;
    e6c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e6c7:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	iput(inode);
    e6cb:	83 ec 0c             	sub    $0xc,%esp
    e6ce:	ff 74 24 18          	pushl  0x18(%esp)
    e6d2:	e8 cb 11 00 00       	call   f8a2 <iput>
    e6d7:	83 c4 10             	add    $0x10,%esp
	return 0;
    e6da:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e6df:	83 c4 18             	add    $0x18,%esp
    e6e2:	5b                   	pop    %ebx
    e6e3:	c3                   	ret    

0000e6e4 <sys_chown>:

// 修改文件宿主系统调用。
// 参数filename是文件名，uid是用户标识符（用户ID），gid是组ID。
// 若操作成功则返回0，否则返回出错码。
int sys_chown(const char * filename, int uid, int gid)
{
    e6e4:	53                   	push   %ebx
    e6e5:	83 ec 18             	sub    $0x18,%esp
    e6e8:	e8 0d 86 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    e6ed:	81 c3 13 39 02 00    	add    $0x23913,%ebx
	struct m_inode * inode;

	// 该调用用于设置文件i节点中的用户和组ID，因此首先要取得给定文件名的i节点。如果文件名的i节点不存在，则返回出错码（文件
	// 或目录不存在）。如果当前进程不是超级用户，则放回该i节点，并返回出错码（没有访问权限）。
	if (!(inode = namei(filename)))
    e6f3:	83 ec 0c             	sub    $0xc,%esp
    e6f6:	ff 74 24 2c          	pushl  0x2c(%esp)
    e6fa:	e8 ae 65 00 00       	call   14cad <namei>
    e6ff:	83 c4 10             	add    $0x10,%esp
    e702:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e706:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e70b:	75 07                	jne    e714 <sys_chown+0x30>
		return -ENOENT;
    e70d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    e712:	eb 61                	jmp    e775 <sys_chown+0x91>
	if (!suser()) {
    e714:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    e71a:	8b 00                	mov    (%eax),%eax
    e71c:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
    e723:	66 85 c0             	test   %ax,%ax
    e726:	74 16                	je     e73e <sys_chown+0x5a>
		iput(inode);
    e728:	83 ec 0c             	sub    $0xc,%esp
    e72b:	ff 74 24 18          	pushl  0x18(%esp)
    e72f:	e8 6e 11 00 00       	call   f8a2 <iput>
    e734:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    e737:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    e73c:	eb 37                	jmp    e775 <sys_chown+0x91>
	}
	// 否则我们就用参数提供的值来设置文件i节点的用户ID和组ID，并置i节点已经修改标志，放回该i节点，返回0。
	inode->i_uid = uid;
    e73e:	8b 44 24 24          	mov    0x24(%esp),%eax
    e742:	89 c2                	mov    %eax,%edx
    e744:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e748:	66 89 50 02          	mov    %dx,0x2(%eax)
	inode->i_gid = gid;
    e74c:	8b 44 24 28          	mov    0x28(%esp),%eax
    e750:	89 c2                	mov    %eax,%edx
    e752:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e756:	88 50 0c             	mov    %dl,0xc(%eax)
	inode->i_dirt = 1;
    e759:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e75d:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	iput(inode);
    e761:	83 ec 0c             	sub    $0xc,%esp
    e764:	ff 74 24 18          	pushl  0x18(%esp)
    e768:	e8 35 11 00 00       	call   f8a2 <iput>
    e76d:	83 c4 10             	add    $0x10,%esp
	return 0;
    e770:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e775:	83 c4 18             	add    $0x18,%esp
    e778:	5b                   	pop    %ebx
    e779:	c3                   	ret    

0000e77a <check_char_dev>:

// 检查字符设备类型.
// 该函数仅用于下面文件打开系统调用sys_open(),用于检查若打开的文件是tty终端字符设备时,需要对当前进程的设置和对tty表的设置.
// 返回0检测处理成功,返回-1表示失败,对应字符设备不能打开.
static int check_char_dev(struct m_inode * inode, int dev, int flag)
{
    e77a:	83 ec 10             	sub    $0x10,%esp
    e77d:	e8 70 85 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    e782:	05 7e 38 02 00       	add    $0x2387e,%eax
	// 的同义名.即/dev/tty设备是一个虚拟设备,它对应到进程实际使用的/dev/ttyxx设备之一.对于一个进程来说,若其有控制终端,那么它的任务结构
	// 中的tty字段将是4号设备的某一个子设备号.
	// 如果打开操作的文件是/dev/tty(即MAJOR(dev) = 5),那么我们令min = 进程任务结构中的tty字段,即取4号设备的子设备号.否则如果打开的是
	// 某个4号设备,则直接取其子设备号.如果得到的4号设备子设备号小于0,那么说明进程没有控制终端,或者设备号错误,则返回-1,表示由于进程没有控制终端
	// 或者不能打开这个设备.
	if (MAJOR(dev) == 4 || MAJOR(dev) == 5) {
    e787:	8b 54 24 18          	mov    0x18(%esp),%edx
    e78b:	c1 ea 08             	shr    $0x8,%edx
    e78e:	83 fa 04             	cmp    $0x4,%edx
    e791:	74 10                	je     e7a3 <check_char_dev+0x29>
    e793:	8b 54 24 18          	mov    0x18(%esp),%edx
    e797:	c1 ea 08             	shr    $0x8,%edx
    e79a:	83 fa 05             	cmp    $0x5,%edx
    e79d:	0f 85 7e 02 00 00    	jne    ea21 <check_char_dev+0x2a7>
		if (MAJOR(dev) == 5)
    e7a3:	8b 54 24 18          	mov    0x18(%esp),%edx
    e7a7:	c1 ea 08             	shr    $0x8,%edx
    e7aa:	83 fa 05             	cmp    $0x5,%edx
    e7ad:	75 14                	jne    e7c3 <check_char_dev+0x49>
			min = current->tty;
    e7af:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    e7b5:	8b 12                	mov    (%edx),%edx
    e7b7:	8b 92 2c 03 00 00    	mov    0x32c(%edx),%edx
    e7bd:	89 54 24 0c          	mov    %edx,0xc(%esp)
    e7c1:	eb 0b                	jmp    e7ce <check_char_dev+0x54>
		else
			min = MINOR(dev);
    e7c3:	8b 54 24 18          	mov    0x18(%esp),%edx
    e7c7:	0f b6 d2             	movzbl %dl,%edx
    e7ca:	89 54 24 0c          	mov    %edx,0xc(%esp)
		if (min < 0)
    e7ce:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e7d3:	79 0a                	jns    e7df <check_char_dev+0x65>
			return -1;
    e7d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    e7da:	e9 47 02 00 00       	jmp    ea26 <check_char_dev+0x2ac>
		// 主伪终端设备文件只能被进程独占使用.如果子设备号表明是一个主伪终端,并且该打开文件i节点引用计数大于1,则说明该设备已被其他进程使用.因此不能再
		// 打开该字符设备文件,于是返回-1.否则,我们让tty结构指针tty指向tty表中对应结构项.若打开文件操作标志flag中不含无需控制终端标志O_NOCTTY,并且进程
		// 是进程组首领,并且当前进程没有控制终端,并且tty结构中session字段为0(表示该终端还不是任何进程组的控制终端),那么就允许为进程设置这个终端设备min
		// 为其控制终端.于是设置进程任务结构终端设备号字段tty值等于min,并且设置对应tty结构的会话号session和进程组号pgrp分别等于进程的会话号和进程组号.
		if ((IS_A_PTY_MASTER(min)) && (inode->i_count > 1))
    e7df:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e7e3:	81 e2 c0 00 00 00    	and    $0xc0,%edx
    e7e9:	81 fa 80 00 00 00    	cmp    $0x80,%edx
    e7ef:	75 18                	jne    e809 <check_char_dev+0x8f>
    e7f1:	8b 54 24 14          	mov    0x14(%esp),%edx
    e7f5:	0f b7 52 34          	movzwl 0x34(%edx),%edx
    e7f9:	66 83 fa 01          	cmp    $0x1,%dx
    e7fd:	76 0a                	jbe    e809 <check_char_dev+0x8f>
			return -1;
    e7ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    e804:	e9 1d 02 00 00       	jmp    ea26 <check_char_dev+0x2ac>
		tty = TTY_TABLE(min);
    e809:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e80e:	74 30                	je     e840 <check_char_dev+0xc6>
    e810:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    e815:	7f 16                	jg     e82d <check_char_dev+0xb3>
    e817:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e81b:	83 ea 01             	sub    $0x1,%edx
    e81e:	89 d1                	mov    %edx,%ecx
    e820:	c1 e1 06             	shl    $0x6,%ecx
    e823:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e829:	01 ca                	add    %ecx,%edx
    e82b:	eb 28                	jmp    e855 <check_char_dev+0xdb>
    e82d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e831:	89 d1                	mov    %edx,%ecx
    e833:	c1 e1 06             	shl    $0x6,%ecx
    e836:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e83c:	01 ca                	add    %ecx,%edx
    e83e:	eb 15                	jmp    e855 <check_char_dev+0xdb>
    e840:	c7 c2 00 63 03 00    	mov    $0x36300,%edx
    e846:	8b 12                	mov    (%edx),%edx
    e848:	89 d1                	mov    %edx,%ecx
    e84a:	c1 e1 06             	shl    $0x6,%ecx
    e84d:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e853:	01 ca                	add    %ecx,%edx
    e855:	89 54 24 08          	mov    %edx,0x8(%esp)
		// Log(LOG_INFO_TYPE, "<<<<< tty index = %d>>>>>\n", min);
		if (!(flag & O_NOCTTY) &&
    e859:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    e85d:	81 e2 00 01 00 00    	and    $0x100,%edx
    e863:	85 d2                	test   %edx,%edx
    e865:	75 6b                	jne    e8d2 <check_char_dev+0x158>
		    current->leader &&
    e867:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    e86d:	8b 12                	mov    (%edx),%edx
    e86f:	8b 92 38 02 00 00    	mov    0x238(%edx),%edx
		if (!(flag & O_NOCTTY) &&
    e875:	85 d2                	test   %edx,%edx
    e877:	74 59                	je     e8d2 <check_char_dev+0x158>
		    current->tty < 0 &&
    e879:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    e87f:	8b 12                	mov    (%edx),%edx
    e881:	8b 92 2c 03 00 00    	mov    0x32c(%edx),%edx
		    current->leader &&
    e887:	85 d2                	test   %edx,%edx
    e889:	79 47                	jns    e8d2 <check_char_dev+0x158>
		    tty->session == 0) {
    e88b:	8b 54 24 08          	mov    0x8(%esp),%edx
    e88f:	8b 52 28             	mov    0x28(%edx),%edx
		    current->tty < 0 &&
    e892:	85 d2                	test   %edx,%edx
    e894:	75 3c                	jne    e8d2 <check_char_dev+0x158>
			current->tty = min;
    e896:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    e89c:	8b 12                	mov    (%edx),%edx
    e89e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    e8a2:	89 8a 2c 03 00 00    	mov    %ecx,0x32c(%edx)
			tty->session = current->session;
    e8a8:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    e8ae:	8b 12                	mov    (%edx),%edx
    e8b0:	8b 8a 34 02 00 00    	mov    0x234(%edx),%ecx
    e8b6:	8b 54 24 08          	mov    0x8(%esp),%edx
    e8ba:	89 4a 28             	mov    %ecx,0x28(%edx)
			tty->pgrp = current->pgrp;
    e8bd:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    e8c3:	8b 12                	mov    (%edx),%edx
    e8c5:	8b 8a 30 02 00 00    	mov    0x230(%edx),%ecx
    e8cb:	8b 54 24 08          	mov    0x8(%esp),%edx
    e8cf:	89 4a 24             	mov    %ecx,0x24(%edx)
		}
		// 如果打开文件操作标志flag中含有O_NONBLOCK(非阻塞)标志,则我们需要对该字符终端设备进行相关设置,设置为满足读操作需要读取的最少字符数为0,设置超时
		// 定时值为0,并把终端设备设置成非规范模式.非阻塞方式只能工作于非规范模式.在此模式下当VMIN和VTIME均设置为0时,辅助队列中有多少支进程就读取多少字符,
		// 并立刻返回.
		if (flag & O_NONBLOCK) {
    e8d2:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    e8d6:	81 e2 00 08 00 00    	and    $0x800,%edx
    e8dc:	85 d2                	test   %edx,%edx
    e8de:	0f 84 3d 01 00 00    	je     ea21 <check_char_dev+0x2a7>
			TTY_TABLE(min)->termios.c_cc[VMIN] = 0;
    e8e4:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e8e9:	74 30                	je     e91b <check_char_dev+0x1a1>
    e8eb:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    e8f0:	7f 16                	jg     e908 <check_char_dev+0x18e>
    e8f2:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e8f6:	83 ea 01             	sub    $0x1,%edx
    e8f9:	89 d1                	mov    %edx,%ecx
    e8fb:	c1 e1 06             	shl    $0x6,%ecx
    e8fe:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e904:	01 ca                	add    %ecx,%edx
    e906:	eb 28                	jmp    e930 <check_char_dev+0x1b6>
    e908:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e90c:	89 d1                	mov    %edx,%ecx
    e90e:	c1 e1 06             	shl    $0x6,%ecx
    e911:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e917:	01 ca                	add    %ecx,%edx
    e919:	eb 15                	jmp    e930 <check_char_dev+0x1b6>
    e91b:	c7 c2 00 63 03 00    	mov    $0x36300,%edx
    e921:	8b 12                	mov    (%edx),%edx
    e923:	89 d1                	mov    %edx,%ecx
    e925:	c1 e1 06             	shl    $0x6,%ecx
    e928:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e92e:	01 ca                	add    %ecx,%edx
    e930:	c6 42 17 00          	movb   $0x0,0x17(%edx)
			TTY_TABLE(min)->termios.c_cc[VTIME] = 0;
    e934:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e939:	74 30                	je     e96b <check_char_dev+0x1f1>
    e93b:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    e940:	7f 16                	jg     e958 <check_char_dev+0x1de>
    e942:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e946:	83 ea 01             	sub    $0x1,%edx
    e949:	89 d1                	mov    %edx,%ecx
    e94b:	c1 e1 06             	shl    $0x6,%ecx
    e94e:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e954:	01 ca                	add    %ecx,%edx
    e956:	eb 28                	jmp    e980 <check_char_dev+0x206>
    e958:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e95c:	89 d1                	mov    %edx,%ecx
    e95e:	c1 e1 06             	shl    $0x6,%ecx
    e961:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e967:	01 ca                	add    %ecx,%edx
    e969:	eb 15                	jmp    e980 <check_char_dev+0x206>
    e96b:	c7 c2 00 63 03 00    	mov    $0x36300,%edx
    e971:	8b 12                	mov    (%edx),%edx
    e973:	89 d1                	mov    %edx,%ecx
    e975:	c1 e1 06             	shl    $0x6,%ecx
    e978:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e97e:	01 ca                	add    %ecx,%edx
    e980:	c6 42 16 00          	movb   $0x0,0x16(%edx)
			TTY_TABLE(min)->termios.c_lflag &= ~ICANON;
    e984:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e989:	74 30                	je     e9bb <check_char_dev+0x241>
    e98b:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    e990:	7f 16                	jg     e9a8 <check_char_dev+0x22e>
    e992:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e996:	83 ea 01             	sub    $0x1,%edx
    e999:	89 d1                	mov    %edx,%ecx
    e99b:	c1 e1 06             	shl    $0x6,%ecx
    e99e:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e9a4:	01 ca                	add    %ecx,%edx
    e9a6:	eb 28                	jmp    e9d0 <check_char_dev+0x256>
    e9a8:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e9ac:	89 d1                	mov    %edx,%ecx
    e9ae:	c1 e1 06             	shl    $0x6,%ecx
    e9b1:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e9b7:	01 ca                	add    %ecx,%edx
    e9b9:	eb 15                	jmp    e9d0 <check_char_dev+0x256>
    e9bb:	c7 c2 00 63 03 00    	mov    $0x36300,%edx
    e9c1:	8b 12                	mov    (%edx),%edx
    e9c3:	89 d1                	mov    %edx,%ecx
    e9c5:	c1 e1 06             	shl    $0x6,%ecx
    e9c8:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
    e9ce:	01 ca                	add    %ecx,%edx
    e9d0:	8b 4a 0c             	mov    0xc(%edx),%ecx
    e9d3:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e9d8:	74 2c                	je     ea06 <check_char_dev+0x28c>
    e9da:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    e9df:	7f 14                	jg     e9f5 <check_char_dev+0x27b>
    e9e1:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e9e5:	83 ea 01             	sub    $0x1,%edx
    e9e8:	c1 e2 06             	shl    $0x6,%edx
    e9eb:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
    e9f1:	01 d0                	add    %edx,%eax
    e9f3:	eb 24                	jmp    ea19 <check_char_dev+0x29f>
    e9f5:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e9f9:	c1 e2 06             	shl    $0x6,%edx
    e9fc:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
    ea02:	01 d0                	add    %edx,%eax
    ea04:	eb 13                	jmp    ea19 <check_char_dev+0x29f>
    ea06:	c7 c2 00 63 03 00    	mov    $0x36300,%edx
    ea0c:	8b 12                	mov    (%edx),%edx
    ea0e:	c1 e2 06             	shl    $0x6,%edx
    ea11:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
    ea17:	01 d0                	add    %edx,%eax
    ea19:	83 e1 fd             	and    $0xfffffffd,%ecx
    ea1c:	89 ca                	mov    %ecx,%edx
    ea1e:	89 50 0c             	mov    %edx,0xc(%eax)
		}
	}
	return 0;
    ea21:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ea26:	83 c4 10             	add    $0x10,%esp
    ea29:	c3                   	ret    

0000ea2a <sys_open>:
// O_EXCL(被创建文件必须不存在),O_APPEND(在文件尾添加数据)等其他一些标志的组合,如果本调用创建了一个新文件,则mode就用于指定
// 文件的许可属性.这些属性有S_IRWXU(文件宿主具有读,写和执行权限),S_IRUSR(用户具有读文件权限),S_IRWXG(组成员有读,写
// 执行)等等.对于新创建的文件,这些属性只应用于将来对文件的访问,创建了只读文件的打开调用也将返回一个读写的文件句柄.如果调用
// 操作成功,则返回文件句柄(文件描述符),否则返回出错码.参见sys/tat.h,fcntl.h.
int sys_open(const char * filename, int flag, int mode)
{
    ea2a:	56                   	push   %esi
    ea2b:	53                   	push   %ebx
    ea2c:	83 ec 14             	sub    $0x14,%esp
    ea2f:	e8 c6 82 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    ea34:	81 c3 cc 35 02 00    	add    $0x235cc,%ebx
	struct file * f;
	int i, fd;

	// 首先对参数进行处理.将用户设置的文件模式和进程模式屏蔽码相与,产适配器的文件模式.为了为打开文件建立一个文件句柄,需要搜索进程
	// 结构中文件结构指针数组,以查找一个空闲项.空闲项的索引号fd即是句柄值.若已经没有空闲项,则返回出错码(参数无效).
	mode &= 0777 & ~current->umask;
    ea3a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ea40:	8b 00                	mov    (%eax),%eax
    ea42:	0f b7 80 30 03 00 00 	movzwl 0x330(%eax),%eax
    ea49:	0f b7 c0             	movzwl %ax,%eax
    ea4c:	f7 d0                	not    %eax
    ea4e:	25 ff 01 00 00       	and    $0x1ff,%eax
    ea53:	21 44 24 28          	and    %eax,0x28(%esp)
	for(fd = 0 ; fd < NR_OPEN ; fd++)
    ea57:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    ea5e:	00 
    ea5f:	eb 1f                	jmp    ea80 <sys_open+0x56>
		if (!current->filp[fd])
    ea61:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ea67:	8b 00                	mov    (%eax),%eax
    ea69:	8b 54 24 04          	mov    0x4(%esp),%edx
    ea6d:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    ea73:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    ea77:	85 c0                	test   %eax,%eax
    ea79:	74 0e                	je     ea89 <sys_open+0x5f>
	for(fd = 0 ; fd < NR_OPEN ; fd++)
    ea7b:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
    ea80:	83 7c 24 04 13       	cmpl   $0x13,0x4(%esp)
    ea85:	7e da                	jle    ea61 <sys_open+0x37>
    ea87:	eb 01                	jmp    ea8a <sys_open+0x60>
			break;          						// 找到空闲项.
    ea89:	90                   	nop
	if (fd >= NR_OPEN)
    ea8a:	83 7c 24 04 13       	cmpl   $0x13,0x4(%esp)
    ea8f:	7e 0a                	jle    ea9b <sys_open+0x71>
		return -EINVAL;
    ea91:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ea96:	e9 d3 01 00 00       	jmp    ec6e <sys_open+0x244>
	// 该子进程中调用execve()函数加载执行另一个新程序.此时子进程中开始执行新程序.若一个文件句柄close_on_exec中的对应位被置位,那么在
	// 执行execve()时该对应文件句柄将被关闭,否则该文件句柄将始终处于打开状态.当打开一个文件时,默认情况下文件句柄在子进程中也处于打开
	// 状态.因此这里要复位对应位.然后为打开文件在文件表中寻找一个空闲结构项.我们令f指向文件表数组开始处.搜索空闲文件结构项(引用计数
	// 为0的项),若已经没有空闲文件表结构项,则返回出错码.另外,第184行上的指针赋值"0+file_table"等同于"file_table"和"&file_table[0]"
	// 不过这样写可能更能明了一些.
	current->close_on_exec &= ~(1 << fd);           // 复位对应文件打开位
    ea9b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    eaa1:	8b 00                	mov    (%eax),%eax
    eaa3:	8b 90 44 03 00 00    	mov    0x344(%eax),%edx
    eaa9:	8b 44 24 04          	mov    0x4(%esp),%eax
    eaad:	be 01 00 00 00       	mov    $0x1,%esi
    eab2:	89 c1                	mov    %eax,%ecx
    eab4:	d3 e6                	shl    %cl,%esi
    eab6:	89 f0                	mov    %esi,%eax
    eab8:	f7 d0                	not    %eax
    eaba:	89 c1                	mov    %eax,%ecx
    eabc:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    eac2:	8b 00                	mov    (%eax),%eax
    eac4:	21 ca                	and    %ecx,%edx
    eac6:	89 90 44 03 00 00    	mov    %edx,0x344(%eax)
	f = 0 + file_table;
    eacc:	c7 c0 00 60 04 00    	mov    $0x46000,%eax
    ead2:	89 44 24 0c          	mov    %eax,0xc(%esp)
	for (i = 0 ; i < NR_FILE ; i++, f++)
    ead6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    eadd:	00 
    eade:	eb 17                	jmp    eaf7 <sys_open+0xcd>
		if (!f->f_count) break;         			// 在文件表中找到空闲结构项。
    eae0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    eae4:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    eae8:	66 85 c0             	test   %ax,%ax
    eaeb:	74 13                	je     eb00 <sys_open+0xd6>
	for (i = 0 ; i < NR_FILE ; i++, f++)
    eaed:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    eaf2:	83 44 24 0c 10       	addl   $0x10,0xc(%esp)
    eaf7:	83 7c 24 08 3f       	cmpl   $0x3f,0x8(%esp)
    eafc:	7e e2                	jle    eae0 <sys_open+0xb6>
    eafe:	eb 01                	jmp    eb01 <sys_open+0xd7>
		if (!f->f_count) break;         			// 在文件表中找到空闲结构项。
    eb00:	90                   	nop
	if (i >= NR_FILE)
    eb01:	83 7c 24 08 3f       	cmpl   $0x3f,0x8(%esp)
    eb06:	7e 0a                	jle    eb12 <sys_open+0xe8>
		return -EINVAL;
    eb08:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    eb0d:	e9 5c 01 00 00       	jmp    ec6e <sys_open+0x244>
	// 此时我们让进程对应文件句柄fd的文件结构指针指向搜索到的文件结构,并令文件引用计数递增1.然后调用函数open_namei()执行打开操作,若返回
	// 值小于0,则说明出错,于是释放刚申请到的文件结构,返回出错码i.若文件打开操作成功,则inode是已打开文件的i节点指针.
	(current->filp[fd] = f)->f_count++;
    eb12:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    eb18:	8b 00                	mov    (%eax),%eax
    eb1a:	8b 54 24 04          	mov    0x4(%esp),%edx
    eb1e:	8d 8a d0 00 00 00    	lea    0xd0(%edx),%ecx
    eb24:	8b 54 24 0c          	mov    0xc(%esp),%edx
    eb28:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    eb2c:	8b 54 24 04          	mov    0x4(%esp),%edx
    eb30:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    eb36:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    eb3a:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    eb3e:	83 c2 01             	add    $0x1,%edx
    eb41:	66 89 50 04          	mov    %dx,0x4(%eax)
	// Log(LOG_INFO_TYPE, "<<<<< sys_open : fd = %d\n", fd);
	if ((i = open_namei(filename, flag, mode, &inode)) < 0) {
    eb45:	89 e0                	mov    %esp,%eax
    eb47:	50                   	push   %eax
    eb48:	ff 74 24 2c          	pushl  0x2c(%esp)
    eb4c:	ff 74 24 2c          	pushl  0x2c(%esp)
    eb50:	ff 74 24 2c          	pushl  0x2c(%esp)
    eb54:	e8 78 61 00 00       	call   14cd1 <open_namei>
    eb59:	83 c4 10             	add    $0x10,%esp
    eb5c:	89 44 24 08          	mov    %eax,0x8(%esp)
    eb60:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    eb65:	79 2d                	jns    eb94 <sys_open+0x16a>
		current->filp[fd] = NULL;
    eb67:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    eb6d:	8b 00                	mov    (%eax),%eax
    eb6f:	8b 54 24 04          	mov    0x4(%esp),%edx
    eb73:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    eb79:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    eb80:	00 
		f->f_count = 0;
    eb81:	8b 44 24 0c          	mov    0xc(%esp),%eax
    eb85:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		return i;
    eb8b:	8b 44 24 08          	mov    0x8(%esp),%eax
    eb8f:	e9 da 00 00 00       	jmp    ec6e <sys_open+0x244>
	}
	// 根据已打开文件i节点的属性字段,我们可以知道文件的类型.对于不同类型的文件,我们需要作一些特别处理.如果打开的是字符设备文件,那么我们就要调用
	// check_char_dev()函数来检查当前进程是否能打开这个字符设备文件.如果允许(函数返回0),那么在check_char_dev()中会根据具体文件打开标志为进程
	// 设置控制终端.如果不允许打开使用该字符设备文件,那么我们只能释放上面申请的文件项和句柄资源.返回出错码.
	/* ttys are somewhat special (ttyxx major==4, tty major==5) */
	if (S_ISCHR(inode->i_mode))
    eb94:	8b 04 24             	mov    (%esp),%eax
    eb97:	0f b7 00             	movzwl (%eax),%eax
    eb9a:	0f b7 c0             	movzwl %ax,%eax
    eb9d:	25 00 f0 00 00       	and    $0xf000,%eax
    eba2:	3d 00 20 00 00       	cmp    $0x2000,%eax
    eba7:	75 5c                	jne    ec05 <sys_open+0x1db>
		if (check_char_dev(inode, inode->i_zone[0], flag)) {
    eba9:	8b 04 24             	mov    (%esp),%eax
    ebac:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    ebb0:	0f b7 d0             	movzwl %ax,%edx
    ebb3:	8b 04 24             	mov    (%esp),%eax
    ebb6:	83 ec 04             	sub    $0x4,%esp
    ebb9:	ff 74 24 28          	pushl  0x28(%esp)
    ebbd:	52                   	push   %edx
    ebbe:	50                   	push   %eax
    ebbf:	e8 b6 fb ff ff       	call   e77a <check_char_dev>
    ebc4:	83 c4 10             	add    $0x10,%esp
    ebc7:	85 c0                	test   %eax,%eax
    ebc9:	74 3a                	je     ec05 <sys_open+0x1db>
			iput(inode);
    ebcb:	8b 04 24             	mov    (%esp),%eax
    ebce:	83 ec 0c             	sub    $0xc,%esp
    ebd1:	50                   	push   %eax
    ebd2:	e8 cb 0c 00 00       	call   f8a2 <iput>
    ebd7:	83 c4 10             	add    $0x10,%esp
			current->filp[fd] = NULL;
    ebda:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ebe0:	8b 00                	mov    (%eax),%eax
    ebe2:	8b 54 24 04          	mov    0x4(%esp),%edx
    ebe6:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    ebec:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    ebf3:	00 
			f->f_count = 0;
    ebf4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ebf8:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
			return -EAGAIN;         				// 出错号:资源暂不可用.
    ebfe:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    ec03:	eb 69                	jmp    ec6e <sys_open+0x244>
		}
	// 如果打开的是块设备文件,则检查盘片是否更换过.若更换过则需要让高速缓冲区中该设备的所有缓冲块失效.
	/* Likewise with block-devices: check for floppy_change */
	/* 同样对于块设备文件:需要检查盘片是否被更换 */
	if (S_ISBLK(inode->i_mode))
    ec05:	8b 04 24             	mov    (%esp),%eax
    ec08:	0f b7 00             	movzwl (%eax),%eax
    ec0b:	0f b7 c0             	movzwl %ax,%eax
    ec0e:	25 00 f0 00 00       	and    $0xf000,%eax
    ec13:	3d 00 60 00 00       	cmp    $0x6000,%eax
    ec18:	75 16                	jne    ec30 <sys_open+0x206>
		check_disk_change(inode->i_zone[0]);
    ec1a:	8b 04 24             	mov    (%esp),%eax
    ec1d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    ec21:	0f b7 c0             	movzwl %ax,%eax
    ec24:	83 ec 0c             	sub    $0xc,%esp
    ec27:	50                   	push   %eax
    ec28:	e8 7e 17 00 00       	call   103ab <check_disk_change>
    ec2d:	83 c4 10             	add    $0x10,%esp
	// 现在我们初始化打开文件的文件结构.设置文件结构属性和标志,置句柄引用计数为1,并设置i节点字段为打开文件的i节点,初始化文件读写指针为0.最后返回文件句柄号.
	f->f_mode = inode->i_mode;
    ec30:	8b 04 24             	mov    (%esp),%eax
    ec33:	0f b7 10             	movzwl (%eax),%edx
    ec36:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ec3a:	66 89 10             	mov    %dx,(%eax)
	f->f_flags = flag;
    ec3d:	8b 44 24 24          	mov    0x24(%esp),%eax
    ec41:	89 c2                	mov    %eax,%edx
    ec43:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ec47:	66 89 50 02          	mov    %dx,0x2(%eax)
	f->f_count = 1;
    ec4b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ec4f:	66 c7 40 04 01 00    	movw   $0x1,0x4(%eax)
	f->f_inode = inode;
    ec55:	8b 14 24             	mov    (%esp),%edx
    ec58:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ec5c:	89 50 08             	mov    %edx,0x8(%eax)
	f->f_pos = 0;
    ec5f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ec63:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return (fd);
    ec6a:	8b 44 24 04          	mov    0x4(%esp),%eax
}
    ec6e:	83 c4 14             	add    $0x14,%esp
    ec71:	5b                   	pop    %ebx
    ec72:	5e                   	pop    %esi
    ec73:	c3                   	ret    

0000ec74 <sys_creat>:

// 创建文件系统调用。
// 参数pathname是路径名，mode与上面的sys_open()函数相同。
// 成功则返回文件句柄，否则返回出错码。
int sys_creat(const char * pathname, int mode)
{
    ec74:	83 ec 0c             	sub    $0xc,%esp
    ec77:	e8 76 80 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    ec7c:	05 84 33 02 00       	add    $0x23384,%eax
	return sys_open(pathname, O_CREAT | O_TRUNC, mode);
    ec81:	83 ec 04             	sub    $0x4,%esp
    ec84:	ff 74 24 18          	pushl  0x18(%esp)
    ec88:	68 40 02 00 00       	push   $0x240
    ec8d:	ff 74 24 1c          	pushl  0x1c(%esp)
    ec91:	e8 94 fd ff ff       	call   ea2a <sys_open>
    ec96:	83 c4 10             	add    $0x10,%esp
}
    ec99:	83 c4 0c             	add    $0xc,%esp
    ec9c:	c3                   	ret    

0000ec9d <sys_close>:

// 关闭文件系统调用.
// 参数fd是文件句柄.
// 成功则返回0,否则返回出错码.
int sys_close(unsigned int fd)
{
    ec9d:	56                   	push   %esi
    ec9e:	53                   	push   %ebx
    ec9f:	83 ec 14             	sub    $0x14,%esp
    eca2:	e8 53 80 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    eca7:	81 c3 59 33 02 00    	add    $0x23359,%ebx
	struct file * filp;

	// 首先检查参数有效性.若给出的文件句柄值大于程序同时打开的文件数NR_OPEN,则返回出错码(参数无效).然后复位进程的执行时关闭文件句柄位图对应位.若该文件句柄对应的
	// 文件结构指针是NULL,则返回出错码.
	if (fd >= NR_OPEN)
    ecad:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    ecb2:	76 0a                	jbe    ecbe <sys_close+0x21>
		return -EINVAL;
    ecb4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ecb9:	e9 d1 00 00 00       	jmp    ed8f <sys_close+0xf2>
	current->close_on_exec &= ~(1 << fd);
    ecbe:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ecc4:	8b 00                	mov    (%eax),%eax
    ecc6:	8b 90 44 03 00 00    	mov    0x344(%eax),%edx
    eccc:	8b 44 24 20          	mov    0x20(%esp),%eax
    ecd0:	be 01 00 00 00       	mov    $0x1,%esi
    ecd5:	89 c1                	mov    %eax,%ecx
    ecd7:	d3 e6                	shl    %cl,%esi
    ecd9:	89 f0                	mov    %esi,%eax
    ecdb:	f7 d0                	not    %eax
    ecdd:	89 c1                	mov    %eax,%ecx
    ecdf:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ece5:	8b 00                	mov    (%eax),%eax
    ece7:	21 ca                	and    %ecx,%edx
    ece9:	89 90 44 03 00 00    	mov    %edx,0x344(%eax)
	if (!(filp = current->filp[fd]))
    ecef:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ecf5:	8b 00                	mov    (%eax),%eax
    ecf7:	8b 54 24 20          	mov    0x20(%esp),%edx
    ecfb:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    ed01:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    ed05:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ed09:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    ed0e:	75 07                	jne    ed17 <sys_close+0x7a>
		return -EINVAL;
    ed10:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ed15:	eb 78                	jmp    ed8f <sys_close+0xf2>
	// 现在置该文件句柄的文件结构指针为NULL.若在关闭文件之前,对应文件结构中的句柄引用计数已经为0,则说明内核出错,停机.否则将对应文件结构的引用计数减1.此时如果它还不
	// 为0,则说明有其他进程正在使用该文件,于是返回0(成功).如果引用计数已等于0,说明该文件已经没有进程引用,该文件结构已变为空闲.则释放该文件i节点,返回0.
	current->filp[fd] = NULL;
    ed17:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    ed1d:	8b 00                	mov    (%eax),%eax
    ed1f:	8b 54 24 20          	mov    0x20(%esp),%edx
    ed23:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    ed29:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    ed30:	00 
	if (filp->f_count == 0)
    ed31:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed35:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    ed39:	66 85 c0             	test   %ax,%ax
    ed3c:	75 12                	jne    ed50 <sys_close+0xb3>
		panic("Close: file count is 0");
    ed3e:	83 ec 0c             	sub    $0xc,%esp
    ed41:	8d 83 78 4e ff ff    	lea    -0xb188(%ebx),%eax
    ed47:	50                   	push   %eax
    ed48:	e8 91 a5 ff ff       	call   92de <panic>
    ed4d:	83 c4 10             	add    $0x10,%esp
	if (--filp->f_count)
    ed50:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed54:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    ed58:	8d 50 ff             	lea    -0x1(%eax),%edx
    ed5b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed5f:	66 89 50 04          	mov    %dx,0x4(%eax)
    ed63:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed67:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    ed6b:	66 85 c0             	test   %ax,%ax
    ed6e:	74 07                	je     ed77 <sys_close+0xda>
		return (0);
    ed70:	b8 00 00 00 00       	mov    $0x0,%eax
    ed75:	eb 18                	jmp    ed8f <sys_close+0xf2>
	iput(filp->f_inode);
    ed77:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed7b:	8b 40 08             	mov    0x8(%eax),%eax
    ed7e:	83 ec 0c             	sub    $0xc,%esp
    ed81:	50                   	push   %eax
    ed82:	e8 1b 0b 00 00       	call   f8a2 <iput>
    ed87:	83 c4 10             	add    $0x10,%esp
	return (0);
    ed8a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ed8f:	83 c4 14             	add    $0x14,%esp
    ed92:	5b                   	pop    %ebx
    ed93:	5e                   	pop    %esi
    ed94:	c3                   	ret    

0000ed95 <sys_lseek>:

// 重定位文件读写指针系统调用。
// 参数fd是文件句柄，offset是新的文件读写指针偏移值，origin是偏移的起始位置，可有三种选择：SEEK_SET（0,
// 从文件开始处）、SEEK_CUR（1,从当前读写位置）、SEEK_END（2,从文件尾处）。
int sys_lseek(unsigned int fd, off_t offset, int origin)
{
    ed95:	83 ec 10             	sub    $0x10,%esp
    ed98:	e8 55 7f ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    ed9d:	05 63 32 02 00       	add    $0x23263,%eax
	int tmp;

	// 首先判断函数提供的参数有效性。如果文件句柄大于程序最多打开文件数NR_OPEN（20），或者该句柄的文件结构指针为空，
	// 或者对应文件结构的i节点字段为空，或者指定设备文件指针是不可定位的，则返回出错码并退出。如果文件对应i节点是管道
	// 节点，则返回出错码退出。因为管道头尾指针不可随意移动！
	if (fd >= NR_OPEN || !(file = current->filp[fd]) || !(file->f_inode)
    eda2:	83 7c 24 14 13       	cmpl   $0x13,0x14(%esp)
    eda7:	77 55                	ja     edfe <sys_lseek+0x69>
    eda9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    edaf:	8b 00                	mov    (%eax),%eax
    edb1:	8b 54 24 14          	mov    0x14(%esp),%edx
    edb5:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    edbb:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    edbf:	89 44 24 0c          	mov    %eax,0xc(%esp)
    edc3:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    edc8:	74 34                	je     edfe <sys_lseek+0x69>
    edca:	8b 44 24 0c          	mov    0xc(%esp),%eax
    edce:	8b 40 08             	mov    0x8(%eax),%eax
    edd1:	85 c0                	test   %eax,%eax
    edd3:	74 29                	je     edfe <sys_lseek+0x69>
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
    edd5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    edd9:	8b 40 08             	mov    0x8(%eax),%eax
    eddc:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    ede0:	66 c1 e8 08          	shr    $0x8,%ax
    ede4:	66 85 c0             	test   %ax,%ax
    ede7:	74 15                	je     edfe <sys_lseek+0x69>
    ede9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    eded:	8b 40 08             	mov    0x8(%eax),%eax
    edf0:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    edf4:	66 c1 e8 08          	shr    $0x8,%ax
    edf8:	66 83 f8 03          	cmp    $0x3,%ax
    edfc:	76 0a                	jbe    ee08 <sys_lseek+0x73>
		return -EBADF;
    edfe:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    ee03:	e9 b1 00 00 00       	jmp    eeb9 <sys_lseek+0x124>
	if (file->f_inode->i_pipe)
    ee08:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ee0c:	8b 40 08             	mov    0x8(%eax),%eax
    ee0f:	0f b6 40 38          	movzbl 0x38(%eax),%eax
    ee13:	84 c0                	test   %al,%al
    ee15:	74 0a                	je     ee21 <sys_lseek+0x8c>
		return -ESPIPE;
    ee17:	b8 e3 ff ff ff       	mov    $0xffffffe3,%eax
    ee1c:	e9 98 00 00 00       	jmp    eeb9 <sys_lseek+0x124>
	// 然后根据设置的定位标志，分别重新定位文件读写指针。
	switch (origin) {
    ee21:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ee25:	83 f8 01             	cmp    $0x1,%eax
    ee28:	74 24                	je     ee4e <sys_lseek+0xb9>
    ee2a:	83 f8 02             	cmp    $0x2,%eax
    ee2d:	74 4d                	je     ee7c <sys_lseek+0xe7>
    ee2f:	85 c0                	test   %eax,%eax
    ee31:	75 78                	jne    eeab <sys_lseek+0x116>
		// origin = SEEK_SET，要求以文件起始处作为原点设置文件读写指针。若偏移值小于零，则出错返回错误码。否则设置文件
		// 读写指针等于offset。
		case 0:
			if (offset < 0) return -EINVAL;
    ee33:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    ee38:	79 07                	jns    ee41 <sys_lseek+0xac>
    ee3a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ee3f:	eb 78                	jmp    eeb9 <sys_lseek+0x124>
			file->f_pos = offset;
    ee41:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ee45:	8b 54 24 18          	mov    0x18(%esp),%edx
    ee49:	89 50 0c             	mov    %edx,0xc(%eax)
			break;
    ee4c:	eb 64                	jmp    eeb2 <sys_lseek+0x11d>
		// origin = SEEK_CUR，要求以文件当前读写指针处作为原点重定位读写指针。如果文件当前指针加上偏移值小于0,则返回
		// 出错码退出。否则在当前读写指针上加上偏移值。
		case 1:
			if (file->f_pos + offset < 0) return -EINVAL;
    ee4e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ee52:	8b 50 0c             	mov    0xc(%eax),%edx
    ee55:	8b 44 24 18          	mov    0x18(%esp),%eax
    ee59:	01 d0                	add    %edx,%eax
    ee5b:	85 c0                	test   %eax,%eax
    ee5d:	79 07                	jns    ee66 <sys_lseek+0xd1>
    ee5f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ee64:	eb 53                	jmp    eeb9 <sys_lseek+0x124>
			file->f_pos += offset;
    ee66:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ee6a:	8b 50 0c             	mov    0xc(%eax),%edx
    ee6d:	8b 44 24 18          	mov    0x18(%esp),%eax
    ee71:	01 c2                	add    %eax,%edx
    ee73:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ee77:	89 50 0c             	mov    %edx,0xc(%eax)
			break;
    ee7a:	eb 36                	jmp    eeb2 <sys_lseek+0x11d>
		// origin = SEEK_END，要求以文件末尾作为原点重定位读写指针。此时若文件大小加上偏移值小于零则返回出错码退出。否则
		// 重定位读写指针为文件长度加上偏移值。
		case 2:
			if ((tmp = file->f_inode->i_size + offset) < 0)
    ee7c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ee80:	8b 40 08             	mov    0x8(%eax),%eax
    ee83:	8b 50 04             	mov    0x4(%eax),%edx
    ee86:	8b 44 24 18          	mov    0x18(%esp),%eax
    ee8a:	01 d0                	add    %edx,%eax
    ee8c:	89 44 24 08          	mov    %eax,0x8(%esp)
    ee90:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    ee95:	79 07                	jns    ee9e <sys_lseek+0x109>
				return -EINVAL;
    ee97:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ee9c:	eb 1b                	jmp    eeb9 <sys_lseek+0x124>
			file->f_pos = tmp;
    ee9e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    eea2:	8b 54 24 08          	mov    0x8(%esp),%edx
    eea6:	89 50 0c             	mov    %edx,0xc(%eax)
			break;
    eea9:	eb 07                	jmp    eeb2 <sys_lseek+0x11d>
		// origin设置无效，返回出错码退出。
		default:
			return -EINVAL;
    eeab:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    eeb0:	eb 07                	jmp    eeb9 <sys_lseek+0x124>
	}
	return file->f_pos;             					// 最后返回重定位后的文件读写指针值。
    eeb2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    eeb6:	8b 40 0c             	mov    0xc(%eax),%eax
}
    eeb9:	83 c4 10             	add    $0x10,%esp
    eebc:	c3                   	ret    

0000eebd <sys_read>:

// 读文件系统调用。
// 参数fd是文件句柄，buf是缓冲区，count是欲读字节数。
int sys_read(unsigned int fd, char * buf, int count)
{
    eebd:	53                   	push   %ebx
    eebe:	83 ec 18             	sub    $0x18,%esp
    eec1:	e8 34 7e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    eec6:	81 c3 3a 31 02 00    	add    $0x2313a,%ebx
	struct file * file;
	struct m_inode * inode;

	// 同样地,我们首先判断函数参数的有效性.如果进程文件句柄值大于程序最多打开文件数NR_OPEN,或者需要写入的字节计数小于0,或者该句柄的文件结构指针为空,
	// 则返回出错码并退出.如果需读取的字节数count等于0,则返回0退出.
	if (fd >= NR_OPEN || count < 0 || !(file = current->filp[fd]))
    eecc:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    eed1:	77 28                	ja     eefb <sys_read+0x3e>
    eed3:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    eed8:	78 21                	js     eefb <sys_read+0x3e>
    eeda:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
    eee0:	8b 00                	mov    (%eax),%eax
    eee2:	8b 54 24 20          	mov    0x20(%esp),%edx
    eee6:	81 c2 d0 00 00 00    	add    $0xd0,%edx
    eeec:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    eef0:	89 44 24 0c          	mov    %eax,0xc(%esp)
    eef4:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    eef9:	75 0a                	jne    ef05 <sys_read+0x48>
		return -EINVAL;
    eefb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ef00:	e9 9b 01 00 00       	jmp    f0a0 <sys_read+0x1e3>
	if (!count)
    ef05:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    ef0a:	75 0a                	jne    ef16 <sys_read+0x59>
		return 0;
    ef0c:	b8 00 00 00 00       	mov    $0x0,%eax
    ef11:	e9 8a 01 00 00       	jmp    f0a0 <sys_read+0x1e3>
	// 然后验证存放数据的缓冲区内存限制。并取文件的i节点。用于根据该i节点的属性，分别调用相应的读操作函数。若是管道操作，并且是读管道文件模式，则进行读
	// 管道操作，若成功则返回读取的字节数，否则返回出错码，退出。如果是字符型文件，则进行读字符设备操作，并返回读取的字符数。如果是块设备文件，则执行
	// 块设备读操作，并返回读取的字节数。
	verify_area(buf, count);
    ef16:	83 ec 08             	sub    $0x8,%esp
    ef19:	ff 74 24 30          	pushl  0x30(%esp)
    ef1d:	ff 74 24 30          	pushl  0x30(%esp)
    ef21:	e8 d5 99 ff ff       	call   88fb <verify_area>
    ef26:	83 c4 10             	add    $0x10,%esp
	inode = file->f_inode;
    ef29:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ef2d:	8b 40 08             	mov    0x8(%eax),%eax
    ef30:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 管道文件的读操作
	if (inode->i_pipe)
    ef34:	8b 44 24 08          	mov    0x8(%esp),%eax
    ef38:	0f b6 40 38          	movzbl 0x38(%eax),%eax
    ef3c:	84 c0                	test   %al,%al
    ef3e:	74 37                	je     ef77 <sys_read+0xba>
		return (file->f_mode & 1) ? read_pipe(inode, buf, count) : -EIO;
    ef40:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ef44:	0f b7 00             	movzwl (%eax),%eax
    ef47:	0f b7 c0             	movzwl %ax,%eax
    ef4a:	83 e0 01             	and    $0x1,%eax
    ef4d:	85 c0                	test   %eax,%eax
    ef4f:	74 1c                	je     ef6d <sys_read+0xb0>
    ef51:	83 ec 04             	sub    $0x4,%esp
    ef54:	ff 74 24 2c          	pushl  0x2c(%esp)
    ef58:	ff 74 24 2c          	pushl  0x2c(%esp)
    ef5c:	ff 74 24 14          	pushl  0x14(%esp)
    ef60:	e8 b5 4b 00 00       	call   13b1a <read_pipe>
    ef65:	83 c4 10             	add    $0x10,%esp
    ef68:	e9 33 01 00 00       	jmp    f0a0 <sys_read+0x1e3>
    ef6d:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    ef72:	e9 29 01 00 00       	jmp    f0a0 <sys_read+0x1e3>
	// 字符设备的读操作
	if (S_ISCHR(inode->i_mode))
    ef77:	8b 44 24 08          	mov    0x8(%esp),%eax
    ef7b:	0f b7 00             	movzwl (%eax),%eax
    ef7e:	0f b7 c0             	movzwl %ax,%eax
    ef81:	25 00 f0 00 00       	and    $0xf000,%eax
    ef86:	3d 00 20 00 00       	cmp    $0x2000,%eax
    ef8b:	75 2e                	jne    efbb <sys_read+0xfe>
		return rw_char(READ, inode->i_zone[0], buf, count, &file->f_pos);
    ef8d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ef91:	8d 50 0c             	lea    0xc(%eax),%edx
    ef94:	8b 44 24 08          	mov    0x8(%esp),%eax
    ef98:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    ef9c:	0f b7 c0             	movzwl %ax,%eax
    ef9f:	83 ec 0c             	sub    $0xc,%esp
    efa2:	52                   	push   %edx
    efa3:	ff 74 24 38          	pushl  0x38(%esp)
    efa7:	ff 74 24 38          	pushl  0x38(%esp)
    efab:	50                   	push   %eax
    efac:	6a 00                	push   $0x0
    efae:	e8 96 2f 00 00       	call   11f49 <rw_char>
    efb3:	83 c4 20             	add    $0x20,%esp
    efb6:	e9 e5 00 00 00       	jmp    f0a0 <sys_read+0x1e3>
	// 块设备的读操作
	if (S_ISBLK(inode->i_mode))
    efbb:	8b 44 24 08          	mov    0x8(%esp),%eax
    efbf:	0f b7 00             	movzwl (%eax),%eax
    efc2:	0f b7 c0             	movzwl %ax,%eax
    efc5:	25 00 f0 00 00       	and    $0xf000,%eax
    efca:	3d 00 60 00 00       	cmp    $0x6000,%eax
    efcf:	75 29                	jne    effa <sys_read+0x13d>
		return block_read(inode->i_zone[0], &file->f_pos, buf, count);
    efd1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    efd5:	8d 50 0c             	lea    0xc(%eax),%edx
    efd8:	8b 44 24 08          	mov    0x8(%esp),%eax
    efdc:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    efe0:	0f b7 c0             	movzwl %ax,%eax
    efe3:	ff 74 24 28          	pushl  0x28(%esp)
    efe7:	ff 74 24 28          	pushl  0x28(%esp)
    efeb:	52                   	push   %edx
    efec:	50                   	push   %eax
    efed:	e8 60 2b 00 00       	call   11b52 <block_read>
    eff2:	83 c4 10             	add    $0x10,%esp
    eff5:	e9 a6 00 00 00       	jmp    f0a0 <sys_read+0x1e3>
	// 如果是目录文件或者是常规文件，则首先验证读取字节数count的有效性并进行调整（若读取字节数加上文件当前读写指针值大于文件长度，则重新设置读取字节
	// 数为文件长度-当前读写指针值，若读取数等于0,则返回0退出），然后执行文件读操作，返回读取的字节数并退出。
	if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {
    effa:	8b 44 24 08          	mov    0x8(%esp),%eax
    effe:	0f b7 00             	movzwl (%eax),%eax
    f001:	0f b7 c0             	movzwl %ax,%eax
    f004:	25 00 f0 00 00       	and    $0xf000,%eax
    f009:	3d 00 40 00 00       	cmp    $0x4000,%eax
    f00e:	74 16                	je     f026 <sys_read+0x169>
    f010:	8b 44 24 08          	mov    0x8(%esp),%eax
    f014:	0f b7 00             	movzwl (%eax),%eax
    f017:	0f b7 c0             	movzwl %ax,%eax
    f01a:	25 00 f0 00 00       	and    $0xf000,%eax
    f01f:	3d 00 80 00 00       	cmp    $0x8000,%eax
    f024:	75 58                	jne    f07e <sys_read+0x1c1>
		if (count + file->f_pos > inode->i_size)
    f026:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f02a:	8b 50 0c             	mov    0xc(%eax),%edx
    f02d:	8b 44 24 28          	mov    0x28(%esp),%eax
    f031:	01 d0                	add    %edx,%eax
    f033:	89 c2                	mov    %eax,%edx
    f035:	8b 44 24 08          	mov    0x8(%esp),%eax
    f039:	8b 40 04             	mov    0x4(%eax),%eax
    f03c:	39 c2                	cmp    %eax,%edx
    f03e:	76 16                	jbe    f056 <sys_read+0x199>
			count = inode->i_size - file->f_pos;
    f040:	8b 44 24 08          	mov    0x8(%esp),%eax
    f044:	8b 50 04             	mov    0x4(%eax),%edx
    f047:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f04b:	8b 40 0c             	mov    0xc(%eax),%eax
    f04e:	29 c2                	sub    %eax,%edx
    f050:	89 d0                	mov    %edx,%eax
    f052:	89 44 24 28          	mov    %eax,0x28(%esp)
		if (count <= 0)
    f056:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f05b:	7f 07                	jg     f064 <sys_read+0x1a7>
			return 0;
    f05d:	b8 00 00 00 00       	mov    $0x0,%eax
    f062:	eb 3c                	jmp    f0a0 <sys_read+0x1e3>
		return file_read(inode, file, buf, count);
    f064:	ff 74 24 28          	pushl  0x28(%esp)
    f068:	ff 74 24 28          	pushl  0x28(%esp)
    f06c:	ff 74 24 14          	pushl  0x14(%esp)
    f070:	ff 74 24 14          	pushl  0x14(%esp)
    f074:	e8 74 2f 00 00       	call   11fed <file_read>
    f079:	83 c4 10             	add    $0x10,%esp
    f07c:	eb 22                	jmp    f0a0 <sys_read+0x1e3>
	}
	// 执行到这里，说明我们无法判断文件的属性。则打印节点文件的属性，并返回出错码退出。
	printk("(Read)inode->i_mode=%06o\n\r", inode->i_mode);
    f07e:	8b 44 24 08          	mov    0x8(%esp),%eax
    f082:	0f b7 00             	movzwl (%eax),%eax
    f085:	0f b7 c0             	movzwl %ax,%eax
    f088:	83 ec 08             	sub    $0x8,%esp
    f08b:	50                   	push   %eax
    f08c:	8d 83 8f 4e ff ff    	lea    -0xb171(%ebx),%eax
    f092:	50                   	push   %eax
    f093:	e8 9a a2 ff ff       	call   9332 <printk>
    f098:	83 c4 10             	add    $0x10,%esp
	return -EINVAL;
    f09b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    f0a0:	83 c4 18             	add    $0x18,%esp
    f0a3:	5b                   	pop    %ebx
    f0a4:	c3                   	ret    

0000f0a5 <sys_write>:

// 写文件系统调用.
// 参数fd是文件句柄,buf是用户缓冲区,count是欲写字节数.
int sys_write(unsigned int fd, char * buf, int count)
{
    f0a5:	53                   	push   %ebx
    f0a6:	83 ec 18             	sub    $0x18,%esp
    f0a9:	e8 44 7c ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    f0ae:	05 52 2f 02 00       	add    $0x22f52,%eax
	struct file * file;
	struct m_inode * inode;

	// 同样地,我们首先判断函数参数的有效性.如果进程文件句柄值大于程序最多打开文件数NR_OPEN,或者需要写入的字节计数小于0,或者该句柄的文件结构指针为空,
	// 则返回出错码并退出.如果需读取的字节数count等于0,则返回0退出.
	if (fd >= NR_OPEN || count < 0 || !(file = current->filp[fd]))
    f0b3:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    f0b8:	77 28                	ja     f0e2 <sys_write+0x3d>
    f0ba:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f0bf:	78 21                	js     f0e2 <sys_write+0x3d>
    f0c1:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
    f0c7:	8b 12                	mov    (%edx),%edx
    f0c9:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    f0cd:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
    f0d3:	8b 54 8a 08          	mov    0x8(%edx,%ecx,4),%edx
    f0d7:	89 54 24 0c          	mov    %edx,0xc(%esp)
    f0db:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f0e0:	75 0a                	jne    f0ec <sys_write+0x47>
		return -EINVAL;
    f0e2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    f0e7:	e9 41 01 00 00       	jmp    f22d <sys_write+0x188>
	// Log(LOG_INFO_TYPE, "<<<<< sys_write : fd = %d>>>>>\n", fd);
	if (!count)
    f0ec:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f0f1:	75 0a                	jne    f0fd <sys_write+0x58>
		return 0;
    f0f3:	b8 00 00 00 00       	mov    $0x0,%eax
    f0f8:	e9 30 01 00 00       	jmp    f22d <sys_write+0x188>
	// 然后验证存放数据的缓冲区内存限制.并取文件的i节点.根据该i节点的属性,分别调用相应的写操作函数.若是管道文件,并且是写管道文件模式,则进行写管道操作,若成功则
	// 返回写入的字节数,否则返回出错码退出.如果是字符设备文件,则进行写字符设备操作,返回写入的字符数退出.如果是块设备文件,则进行块设备写操作,并返回写入的字节数
	// 退出.若是常规文件,则执行文件写操作,并返回写入的字节数.退出.
	inode = file->f_inode;
    f0fd:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f101:	8b 52 08             	mov    0x8(%edx),%edx
    f104:	89 54 24 08          	mov    %edx,0x8(%esp)
	// 管道的写操作
	if (inode->i_pipe)
    f108:	8b 54 24 08          	mov    0x8(%esp),%edx
    f10c:	0f b6 52 38          	movzbl 0x38(%edx),%edx
    f110:	84 d2                	test   %dl,%dl
    f112:	74 39                	je     f14d <sys_write+0xa8>
		return (file->f_mode & 2) ? write_pipe(inode, buf, count) : -EIO;
    f114:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f118:	0f b7 12             	movzwl (%edx),%edx
    f11b:	0f b7 d2             	movzwl %dx,%edx
    f11e:	83 e2 02             	and    $0x2,%edx
    f121:	85 d2                	test   %edx,%edx
    f123:	74 1e                	je     f143 <sys_write+0x9e>
    f125:	83 ec 04             	sub    $0x4,%esp
    f128:	ff 74 24 2c          	pushl  0x2c(%esp)
    f12c:	ff 74 24 2c          	pushl  0x2c(%esp)
    f130:	ff 74 24 14          	pushl  0x14(%esp)
    f134:	89 c3                	mov    %eax,%ebx
    f136:	e8 91 4b 00 00       	call   13ccc <write_pipe>
    f13b:	83 c4 10             	add    $0x10,%esp
    f13e:	e9 ea 00 00 00       	jmp    f22d <sys_write+0x188>
    f143:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f148:	e9 e0 00 00 00       	jmp    f22d <sys_write+0x188>
	// 字符设备的写操作
	if (S_ISCHR(inode->i_mode))
    f14d:	8b 54 24 08          	mov    0x8(%esp),%edx
    f151:	0f b7 12             	movzwl (%edx),%edx
    f154:	0f b7 d2             	movzwl %dx,%edx
    f157:	81 e2 00 f0 00 00    	and    $0xf000,%edx
    f15d:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
    f163:	75 30                	jne    f195 <sys_write+0xf0>
		return rw_char(WRITE, inode->i_zone[0], buf, count, &file->f_pos);
    f165:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f169:	8d 4a 0c             	lea    0xc(%edx),%ecx
    f16c:	8b 54 24 08          	mov    0x8(%esp),%edx
    f170:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
    f174:	0f b7 d2             	movzwl %dx,%edx
    f177:	83 ec 0c             	sub    $0xc,%esp
    f17a:	51                   	push   %ecx
    f17b:	ff 74 24 38          	pushl  0x38(%esp)
    f17f:	ff 74 24 38          	pushl  0x38(%esp)
    f183:	52                   	push   %edx
    f184:	6a 01                	push   $0x1
    f186:	89 c3                	mov    %eax,%ebx
    f188:	e8 bc 2d 00 00       	call   11f49 <rw_char>
    f18d:	83 c4 20             	add    $0x20,%esp
    f190:	e9 98 00 00 00       	jmp    f22d <sys_write+0x188>
	// 块设备的写操作
	if (S_ISBLK(inode->i_mode))
    f195:	8b 54 24 08          	mov    0x8(%esp),%edx
    f199:	0f b7 12             	movzwl (%edx),%edx
    f19c:	0f b7 d2             	movzwl %dx,%edx
    f19f:	81 e2 00 f0 00 00    	and    $0xf000,%edx
    f1a5:	81 fa 00 60 00 00    	cmp    $0x6000,%edx
    f1ab:	75 28                	jne    f1d5 <sys_write+0x130>
		return block_write(inode->i_zone[0], &file->f_pos, buf, count);
    f1ad:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f1b1:	8d 4a 0c             	lea    0xc(%edx),%ecx
    f1b4:	8b 54 24 08          	mov    0x8(%esp),%edx
    f1b8:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
    f1bc:	0f b7 d2             	movzwl %dx,%edx
    f1bf:	ff 74 24 28          	pushl  0x28(%esp)
    f1c3:	ff 74 24 28          	pushl  0x28(%esp)
    f1c7:	51                   	push   %ecx
    f1c8:	52                   	push   %edx
    f1c9:	89 c3                	mov    %eax,%ebx
    f1cb:	e8 b9 27 00 00       	call   11989 <block_write>
    f1d0:	83 c4 10             	add    $0x10,%esp
    f1d3:	eb 58                	jmp    f22d <sys_write+0x188>
	// 文件的写操作
	if (S_ISREG(inode->i_mode))
    f1d5:	8b 54 24 08          	mov    0x8(%esp),%edx
    f1d9:	0f b7 12             	movzwl (%edx),%edx
    f1dc:	0f b7 d2             	movzwl %dx,%edx
    f1df:	81 e2 00 f0 00 00    	and    $0xf000,%edx
    f1e5:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
    f1eb:	75 1c                	jne    f209 <sys_write+0x164>
		return file_write(inode, file, buf, count);
    f1ed:	ff 74 24 28          	pushl  0x28(%esp)
    f1f1:	ff 74 24 28          	pushl  0x28(%esp)
    f1f5:	ff 74 24 14          	pushl  0x14(%esp)
    f1f9:	ff 74 24 14          	pushl  0x14(%esp)
    f1fd:	89 c3                	mov    %eax,%ebx
    f1ff:	e8 a2 2f 00 00       	call   121a6 <file_write>
    f204:	83 c4 10             	add    $0x10,%esp
    f207:	eb 24                	jmp    f22d <sys_write+0x188>
	// 执行到这里,说明我们无法判断文件的属性.则打印节点文件属性,并返回出错码退出.
	printk("(Write)inode->i_mode=%06o\n\r", inode->i_mode);
    f209:	8b 54 24 08          	mov    0x8(%esp),%edx
    f20d:	0f b7 12             	movzwl (%edx),%edx
    f210:	0f b7 d2             	movzwl %dx,%edx
    f213:	83 ec 08             	sub    $0x8,%esp
    f216:	52                   	push   %edx
    f217:	8d 90 aa 4e ff ff    	lea    -0xb156(%eax),%edx
    f21d:	52                   	push   %edx
    f21e:	89 c3                	mov    %eax,%ebx
    f220:	e8 0d a1 ff ff       	call   9332 <printk>
    f225:	83 c4 10             	add    $0x10,%esp
	return -EINVAL;
    f228:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    f22d:	83 c4 18             	add    $0x18,%esp
    f230:	5b                   	pop    %ebx
    f231:	c3                   	ret    

0000f232 <memset>:

// 用字符填写指定长度内存块.
// 用字符c填写s指向的内存区域,共填count字节.
// %0 - eax(字符c),%1 - edi(内存地址),%2 - ecx(字节数count).
static inline void * memset(void * s, char c, int count)
{
    f232:	57                   	push   %edi
    f233:	83 ec 04             	sub    $0x4,%esp
    f236:	e8 b7 7a ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    f23b:	05 c5 2d 02 00       	add    $0x22dc5,%eax
    f240:	8b 44 24 10          	mov    0x10(%esp),%eax
    f244:	88 04 24             	mov    %al,(%esp)
__asm__(
    f247:	0f b6 04 24          	movzbl (%esp),%eax
    f24b:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f24f:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    f253:	89 d7                	mov    %edx,%edi
    f255:	fc                   	cld    
    f256:	57                   	push   %edi
    f257:	f3 aa                	rep stos %al,%es:(%edi)
    f259:	5f                   	pop    %edi
		"rep\n\t"											// 重复ecx指定的次数,执行.
		"stosb\n\t"											// 将al中字符存入es:[edi]中,并且edi++.
		"popl %%edi"
		::"a" (c), "D" (s), "c" (count)
		:);
return s;
    f25a:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    f25e:	83 c4 04             	add    $0x4,%esp
    f261:	5f                   	pop    %edi
    f262:	c3                   	ret    

0000f263 <wait_on_inode>:
static void write_inode(struct m_inode * inode);					// 写i节点信息到高速缓冲中.

// 等待指定的i节点可用.
// 如果i节点已被锁定,则将当前任务置为不可中断的等待状态,并添加到该i节点的等待队列i_wait中.直到该i节点解锁并明确地唤醒本任务.
static inline void wait_on_inode(struct m_inode * inode)
{
    f263:	53                   	push   %ebx
    f264:	83 ec 08             	sub    $0x8,%esp
    f267:	e8 8e 7a ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    f26c:	81 c3 94 2d 02 00    	add    $0x22d94,%ebx
	cli();
    f272:	fa                   	cli    
	while (inode->i_lock)
    f273:	eb 13                	jmp    f288 <wait_on_inode+0x25>
		sleep_on(&inode->i_wait);									// kernel/sched.c
    f275:	8b 44 24 10          	mov    0x10(%esp),%eax
    f279:	83 c0 20             	add    $0x20,%eax
    f27c:	83 ec 0c             	sub    $0xc,%esp
    f27f:	50                   	push   %eax
    f280:	e8 ff 7f ff ff       	call   7284 <sleep_on>
    f285:	83 c4 10             	add    $0x10,%esp
	while (inode->i_lock)
    f288:	8b 44 24 10          	mov    0x10(%esp),%eax
    f28c:	0f b6 40 36          	movzbl 0x36(%eax),%eax
    f290:	84 c0                	test   %al,%al
    f292:	75 e1                	jne    f275 <wait_on_inode+0x12>
	sti();
    f294:	fb                   	sti    
}
    f295:	90                   	nop
    f296:	83 c4 08             	add    $0x8,%esp
    f299:	5b                   	pop    %ebx
    f29a:	c3                   	ret    

0000f29b <lock_inode>:

// 对i节点上锁(锁定指定的i节点)
// 如果i节点已被锁定,则将当前任务置为不可中断的等待状态,并添加到该i节点的等待队列i_wait中.直到该i节点解锁并明确地唤醒本任务.然后
// 对其上锁.
static inline void lock_inode(struct m_inode * inode)
{
    f29b:	53                   	push   %ebx
    f29c:	83 ec 08             	sub    $0x8,%esp
    f29f:	e8 56 7a ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    f2a4:	81 c3 5c 2d 02 00    	add    $0x22d5c,%ebx
	cli();
    f2aa:	fa                   	cli    
	while (inode->i_lock)
    f2ab:	eb 13                	jmp    f2c0 <lock_inode+0x25>
		sleep_on(&inode->i_wait);
    f2ad:	8b 44 24 10          	mov    0x10(%esp),%eax
    f2b1:	83 c0 20             	add    $0x20,%eax
    f2b4:	83 ec 0c             	sub    $0xc,%esp
    f2b7:	50                   	push   %eax
    f2b8:	e8 c7 7f ff ff       	call   7284 <sleep_on>
    f2bd:	83 c4 10             	add    $0x10,%esp
	while (inode->i_lock)
    f2c0:	8b 44 24 10          	mov    0x10(%esp),%eax
    f2c4:	0f b6 40 36          	movzbl 0x36(%eax),%eax
    f2c8:	84 c0                	test   %al,%al
    f2ca:	75 e1                	jne    f2ad <lock_inode+0x12>
	inode->i_lock = 1;												// 置锁定标志.
    f2cc:	8b 44 24 10          	mov    0x10(%esp),%eax
    f2d0:	c6 40 36 01          	movb   $0x1,0x36(%eax)
	sti();
    f2d4:	fb                   	sti    
}
    f2d5:	90                   	nop
    f2d6:	83 c4 08             	add    $0x8,%esp
    f2d9:	5b                   	pop    %ebx
    f2da:	c3                   	ret    

0000f2db <unlock_inode>:

// 对指定的i节点解锁.
// 复位i节点的锁定标志,并明确地唤醒等待在此i节点等待队列i_wait上的所有进程.
static inline void unlock_inode(struct m_inode * inode)
{
    f2db:	53                   	push   %ebx
    f2dc:	83 ec 08             	sub    $0x8,%esp
    f2df:	e8 0e 7a ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    f2e4:	05 1c 2d 02 00       	add    $0x22d1c,%eax
	inode->i_lock = 0;
    f2e9:	8b 54 24 10          	mov    0x10(%esp),%edx
    f2ed:	c6 42 36 00          	movb   $0x0,0x36(%edx)
	wake_up(&inode->i_wait);										// kernel/sched.c
    f2f1:	8b 54 24 10          	mov    0x10(%esp),%edx
    f2f5:	83 c2 20             	add    $0x20,%edx
    f2f8:	83 ec 0c             	sub    $0xc,%esp
    f2fb:	52                   	push   %edx
    f2fc:	89 c3                	mov    %eax,%ebx
    f2fe:	e8 a4 7f ff ff       	call   72a7 <wake_up>
    f303:	83 c4 10             	add    $0x10,%esp
}
    f306:	90                   	nop
    f307:	83 c4 08             	add    $0x8,%esp
    f30a:	5b                   	pop    %ebx
    f30b:	c3                   	ret    

0000f30c <invalidate_inodes>:

// 释放设备dev在内存i节点表中的所有i节点。
// 扫描内存中的i节点表数组，如果是指定设备使用的i节点就释放之。
void invalidate_inodes(int dev)
{
    f30c:	53                   	push   %ebx
    f30d:	83 ec 18             	sub    $0x18,%esp
    f310:	e8 e5 79 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    f315:	81 c3 eb 2c 02 00    	add    $0x22ceb,%ebx

	// 首先让指针指向内存i节点表数组首项。然后扫描i节点表指针数组中的所有i节点。针对其中每个i节点，先等待该i节点
	// 解锁可用（若目前正被上锁的话），再判断是否属于指定设备的i节点。如果是指定设备的i节点，则看看它是否还被使用
	// 着，即其引用计数是否不为0。若是则显示警告信息。然后释放之，即把i节点的设备号字段i_dev置。第50行上的指针
	// 赋值"0+inode_table"等同于"inode_table"、"&inode_table[0]"。不过这样写可能更明了一些。
	inode = 0 + inode_table;                  						// 指向i节点表指针数组首项。
    f31b:	8d 83 40 32 00 00    	lea    0x3240(%ebx),%eax
    f321:	89 44 24 08          	mov    %eax,0x8(%esp)
	for(i = 0 ; i < NR_INODE ; i++, inode++) {
    f325:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    f32c:	00 
    f32d:	eb 5b                	jmp    f38a <invalidate_inodes+0x7e>
		wait_on_inode(inode);           							// 等待该i节点可用（解锁）。
    f32f:	83 ec 0c             	sub    $0xc,%esp
    f332:	ff 74 24 14          	pushl  0x14(%esp)
    f336:	e8 28 ff ff ff       	call   f263 <wait_on_inode>
    f33b:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dev == dev) {
    f33e:	8b 44 24 08          	mov    0x8(%esp),%eax
    f342:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f346:	0f b7 c0             	movzwl %ax,%eax
    f349:	39 44 24 20          	cmp    %eax,0x20(%esp)
    f34d:	75 31                	jne    f380 <invalidate_inodes+0x74>
			if (inode->i_count)     								// 若其引用数不为0,则显示出错警告。
    f34f:	8b 44 24 08          	mov    0x8(%esp),%eax
    f353:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    f357:	66 85 c0             	test   %ax,%ax
    f35a:	74 12                	je     f36e <invalidate_inodes+0x62>
				printk("inode in use on removed disk\n\r");
    f35c:	83 ec 0c             	sub    $0xc,%esp
    f35f:	8d 83 c8 4e ff ff    	lea    -0xb138(%ebx),%eax
    f365:	50                   	push   %eax
    f366:	e8 c7 9f ff ff       	call   9332 <printk>
    f36b:	83 c4 10             	add    $0x10,%esp
			inode->i_dev = inode->i_dirt = 0;       				// 释放i节点（置设备号为0）。
    f36e:	8b 44 24 08          	mov    0x8(%esp),%eax
    f372:	c6 40 37 00          	movb   $0x0,0x37(%eax)
    f376:	8b 44 24 08          	mov    0x8(%esp),%eax
    f37a:	66 c7 40 30 00 00    	movw   $0x0,0x30(%eax)
	for(i = 0 ; i < NR_INODE ; i++, inode++) {
    f380:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    f385:	83 44 24 08 3c       	addl   $0x3c,0x8(%esp)
    f38a:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    f38f:	7e 9e                	jle    f32f <invalidate_inodes+0x23>
		}
	}
}
    f391:	90                   	nop
    f392:	83 c4 18             	add    $0x18,%esp
    f395:	5b                   	pop    %ebx
    f396:	c3                   	ret    

0000f397 <sync_inodes>:

// 同步所有i节点。
// 把内存i节点表中所有i节点与设备上i节点作同步操作。
void sync_inodes(void)
{
    f397:	83 ec 1c             	sub    $0x1c,%esp
    f39a:	e8 53 79 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    f39f:	05 61 2c 02 00       	add    $0x22c61,%eax
	struct m_inode * inode;

	// 首先让内存i节点类型的指针指向i节点表首项，然后扫描整个i节点表中的节点。针对其中每个i节点，先等待该i节点解锁可用（若
	// 目前正被上锁的话），然后判断该i节点是否已被修改并且不是管道节点。若是这种情况则将该i节点写入高速缓冲区中，缓冲区管理
	// 程序buffer.c会在适当时机将它们写入盘中。
	inode = 0 + inode_table;                          				// 让指针首先指向i节点表指针数组首项。
    f3a4:	8d 80 40 32 00 00    	lea    0x3240(%eax),%eax
    f3aa:	89 44 24 08          	mov    %eax,0x8(%esp)
	for(i = 0 ; i < NR_INODE ; i++, inode++) {           			// 扫描i节点表指针数组。
    f3ae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    f3b5:	00 
    f3b6:	eb 40                	jmp    f3f8 <sync_inodes+0x61>
		wait_on_inode(inode);                   					// 等待该i节点可用（解锁）。
    f3b8:	83 ec 0c             	sub    $0xc,%esp
    f3bb:	ff 74 24 14          	pushl  0x14(%esp)
    f3bf:	e8 9f fe ff ff       	call   f263 <wait_on_inode>
    f3c4:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dirt && !inode->i_pipe)    					// 若i节点已修改且不是管道节点，
    f3c7:	8b 44 24 08          	mov    0x8(%esp),%eax
    f3cb:	0f b6 40 37          	movzbl 0x37(%eax),%eax
    f3cf:	84 c0                	test   %al,%al
    f3d1:	74 1b                	je     f3ee <sync_inodes+0x57>
    f3d3:	8b 44 24 08          	mov    0x8(%esp),%eax
    f3d7:	0f b6 40 38          	movzbl 0x38(%eax),%eax
    f3db:	84 c0                	test   %al,%al
    f3dd:	75 0f                	jne    f3ee <sync_inodes+0x57>
			write_inode(inode);             						// 则写盘（实际是写入缓冲区中）。
    f3df:	83 ec 0c             	sub    $0xc,%esp
    f3e2:	ff 74 24 14          	pushl  0x14(%esp)
    f3e6:	e8 0a 0c 00 00       	call   fff5 <write_inode>
    f3eb:	83 c4 10             	add    $0x10,%esp
	for(i = 0 ; i < NR_INODE ; i++, inode++) {           			// 扫描i节点表指针数组。
    f3ee:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    f3f3:	83 44 24 08 3c       	addl   $0x3c,0x8(%esp)
    f3f8:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    f3fd:	7e b9                	jle    f3b8 <sync_inodes+0x21>
	}
}
    f3ff:	90                   	nop
    f400:	83 c4 1c             	add    $0x1c,%esp
    f403:	c3                   	ret    

0000f404 <_bmap>:

// 文件数据块映射到盘块的处理操作.(block位图处理函数,bmap - block map)
// 参数:inode - 文件的i节点指针;block - 文件中的数据块号;create - 创建块标志.该函数把指定的文件数据块block对应到设备上逻辑块上,并返回逻辑块号.
// 如果创建标志置位,则在设备上对应逻辑块不存在时就申请新磁盘块,返回文件数据块block对应在设备上的逻辑块号(盘块号).
static int _bmap(struct m_inode * inode, int block, int create)
{
    f404:	53                   	push   %ebx
    f405:	83 ec 18             	sub    $0x18,%esp
    f408:	e8 ed 78 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    f40d:	81 c3 f3 2b 02 00    	add    $0x22bf3,%ebx
	struct buffer_head * bh;
	int i;

	// 首先判断参数文件数据块号block的有效性.如果块号小于0,则停机.如果块号大于直接块数 + 间接块数 + 二次间接块数,超出文件系统表示范围,则停机.
	if (block < 0)
    f413:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    f418:	79 12                	jns    f42c <_bmap+0x28>
		panic("_bmap: block<0");
    f41a:	83 ec 0c             	sub    $0xc,%esp
    f41d:	8d 83 e7 4e ff ff    	lea    -0xb119(%ebx),%eax
    f423:	50                   	push   %eax
    f424:	e8 b5 9e ff ff       	call   92de <panic>
    f429:	83 c4 10             	add    $0x10,%esp
	if (block >= 7 + 512 + 512 * 512)
    f42c:	81 7c 24 24 06 02 04 	cmpl   $0x40206,0x24(%esp)
    f433:	00 
    f434:	7e 12                	jle    f448 <_bmap+0x44>
		panic("_bmap: block>big");
    f436:	83 ec 0c             	sub    $0xc,%esp
    f439:	8d 83 f6 4e ff ff    	lea    -0xb10a(%ebx),%eax
    f43f:	50                   	push   %eax
    f440:	e8 99 9e ff ff       	call   92de <panic>
    f445:	83 c4 10             	add    $0x10,%esp
	// 然后根据文件块号的大小值和是否设置了创建标志分别进行处理.如果该块号小于7,则使用直接块表示.如果创建标志置位,并且i节点中对应该块的逻辑块(区段)字段为0,
	// 则向相应设备申请一磁盘块(逻辑块),并且将盘上逻辑块号(盘块号)填入逻辑块字段中.然后设置i节点改变时间,置i节点已修改标志.最后返回逻辑块号.函数new_block()
	// 定义在bitmap.c程序中.
	if (block < 7) {
    f448:	83 7c 24 24 06       	cmpl   $0x6,0x24(%esp)
    f44d:	0f 8f 9b 00 00 00    	jg     f4ee <_bmap+0xea>
		if (create && !inode->i_zone[block])
    f453:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f458:	74 7f                	je     f4d9 <_bmap+0xd5>
    f45a:	8b 44 24 20          	mov    0x20(%esp),%eax
    f45e:	8b 54 24 24          	mov    0x24(%esp),%edx
    f462:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
    f467:	66 85 c0             	test   %ax,%ax
    f46a:	75 6d                	jne    f4d9 <_bmap+0xd5>
			if (inode->i_zone[block] = new_block(inode->i_dev)) {
    f46c:	8b 44 24 20          	mov    0x20(%esp),%eax
    f470:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f474:	0f b7 c0             	movzwl %ax,%eax
    f477:	83 ec 0c             	sub    $0xc,%esp
    f47a:	50                   	push   %eax
    f47b:	e8 66 72 00 00       	call   166e6 <new_block>
    f480:	83 c4 10             	add    $0x10,%esp
    f483:	89 c1                	mov    %eax,%ecx
    f485:	8b 44 24 20          	mov    0x20(%esp),%eax
    f489:	8b 54 24 24          	mov    0x24(%esp),%edx
    f48d:	66 89 4c 50 0e       	mov    %cx,0xe(%eax,%edx,2)
    f492:	8b 44 24 20          	mov    0x20(%esp),%eax
    f496:	8b 54 24 24          	mov    0x24(%esp),%edx
    f49a:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
    f49f:	66 85 c0             	test   %ax,%ax
    f4a2:	74 35                	je     f4d9 <_bmap+0xd5>
				inode->i_ctime = CURRENT_TIME;
    f4a4:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    f4aa:	8b 10                	mov    (%eax),%edx
    f4ac:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    f4b2:	8b 00                	mov    (%eax),%eax
    f4b4:	01 d0                	add    %edx,%eax
    f4b6:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    f4bb:	f7 e2                	mul    %edx
    f4bd:	c1 ea 05             	shr    $0x5,%edx
    f4c0:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    f4c6:	8b 00                	mov    (%eax),%eax
    f4c8:	01 c2                	add    %eax,%edx
    f4ca:	8b 44 24 20          	mov    0x20(%esp),%eax
    f4ce:	89 50 2c             	mov    %edx,0x2c(%eax)
				inode->i_dirt = 1;
    f4d1:	8b 44 24 20          	mov    0x20(%esp),%eax
    f4d5:	c6 40 37 01          	movb   $0x1,0x37(%eax)
			}
		return inode->i_zone[block];
    f4d9:	8b 44 24 20          	mov    0x20(%esp),%eax
    f4dd:	8b 54 24 24          	mov    0x24(%esp),%edx
    f4e1:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
    f4e6:	0f b7 c0             	movzwl %ax,%eax
    f4e9:	e9 63 03 00 00       	jmp    f851 <_bmap+0x44d>
	}
	// 如果该块号>=7,且小于7+512,则说明使用的是一次间接块.下面对一次间接块进行处理.如果是创建,并且该i节点中对应间接块字段i_zone[7]是0,表明文件是首次使用间接块,
	// 则需申请一磁盘块用于存放间接块信息,并将此实际磁盘块号填入间接块字段中.然后设置i节点已修改标志和修改时间.如果创建时申请磁盘块失败,则此时i节点间接块字段i_zone[7]
	// 为0,则返回0.或者不是创建,但i_zone[7]原来就为0,表明i节点中没有间接块,于是映射磁盘块失败,返回0退出.
	block -= 7;
    f4ee:	83 6c 24 24 07       	subl   $0x7,0x24(%esp)
	if (block < 512) {
    f4f3:	81 7c 24 24 ff 01 00 	cmpl   $0x1ff,0x24(%esp)
    f4fa:	00 
    f4fb:	0f 8f 43 01 00 00    	jg     f644 <_bmap+0x240>
		// 如果创建标志置位，同时索引7这个位置没有绑定到对应的逻辑块,则申请一个逻辑块
		if (create && !inode->i_zone[7])
    f501:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f506:	74 70                	je     f578 <_bmap+0x174>
    f508:	8b 44 24 20          	mov    0x20(%esp),%eax
    f50c:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    f510:	66 85 c0             	test   %ax,%ax
    f513:	75 63                	jne    f578 <_bmap+0x174>
			if (inode->i_zone[7] = new_block(inode->i_dev)) {
    f515:	8b 44 24 20          	mov    0x20(%esp),%eax
    f519:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f51d:	0f b7 c0             	movzwl %ax,%eax
    f520:	83 ec 0c             	sub    $0xc,%esp
    f523:	50                   	push   %eax
    f524:	e8 bd 71 00 00       	call   166e6 <new_block>
    f529:	83 c4 10             	add    $0x10,%esp
    f52c:	89 c2                	mov    %eax,%edx
    f52e:	8b 44 24 20          	mov    0x20(%esp),%eax
    f532:	66 89 50 1c          	mov    %dx,0x1c(%eax)
    f536:	8b 44 24 20          	mov    0x20(%esp),%eax
    f53a:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    f53e:	66 85 c0             	test   %ax,%ax
    f541:	74 35                	je     f578 <_bmap+0x174>
				inode->i_dirt = 1;
    f543:	8b 44 24 20          	mov    0x20(%esp),%eax
    f547:	c6 40 37 01          	movb   $0x1,0x37(%eax)
				inode->i_ctime = CURRENT_TIME;
    f54b:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    f551:	8b 10                	mov    (%eax),%edx
    f553:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    f559:	8b 00                	mov    (%eax),%eax
    f55b:	01 d0                	add    %edx,%eax
    f55d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    f562:	f7 e2                	mul    %edx
    f564:	c1 ea 05             	shr    $0x5,%edx
    f567:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    f56d:	8b 00                	mov    (%eax),%eax
    f56f:	01 c2                	add    %eax,%edx
    f571:	8b 44 24 20          	mov    0x20(%esp),%eax
    f575:	89 50 2c             	mov    %edx,0x2c(%eax)
			}
		if (!inode->i_zone[7])
    f578:	8b 44 24 20          	mov    0x20(%esp),%eax
    f57c:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    f580:	66 85 c0             	test   %ax,%ax
    f583:	75 0a                	jne    f58f <_bmap+0x18b>
			return 0;
    f585:	b8 00 00 00 00       	mov    $0x0,%eax
    f58a:	e9 c2 02 00 00       	jmp    f851 <_bmap+0x44d>
		// 现在读取设备上该i节点的一次间接块.并取该间接块上第block项中的逻辑块号(盘块号)i.每一项占2个字节.如果是创建并且间接块的第block项中的逻辑块号为0的话,则申请一磁盘块,
		// 并让间接块中的第block项等于该新逻辑块块号.然后置位间接块的已修改标志.如果不是创建,则i就是需要映射(寻找)的逻辑块号.
		if (!(bh = bread(inode->i_dev, inode->i_zone[7])))
    f58f:	8b 44 24 20          	mov    0x20(%esp),%eax
    f593:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    f597:	0f b7 d0             	movzwl %ax,%edx
    f59a:	8b 44 24 20          	mov    0x20(%esp),%eax
    f59e:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f5a2:	0f b7 c0             	movzwl %ax,%eax
    f5a5:	83 ec 08             	sub    $0x8,%esp
    f5a8:	52                   	push   %edx
    f5a9:	50                   	push   %eax
    f5aa:	e8 23 14 00 00       	call   109d2 <bread>
    f5af:	83 c4 10             	add    $0x10,%esp
    f5b2:	89 44 24 08          	mov    %eax,0x8(%esp)
    f5b6:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    f5bb:	75 0a                	jne    f5c7 <_bmap+0x1c3>
			return 0;
    f5bd:	b8 00 00 00 00       	mov    $0x0,%eax
    f5c2:	e9 8a 02 00 00       	jmp    f851 <_bmap+0x44d>
		i = ((unsigned short *) (bh->b_data))[block];
    f5c7:	8b 44 24 08          	mov    0x8(%esp),%eax
    f5cb:	8b 00                	mov    (%eax),%eax
    f5cd:	8b 54 24 24          	mov    0x24(%esp),%edx
    f5d1:	01 d2                	add    %edx,%edx
    f5d3:	01 d0                	add    %edx,%eax
    f5d5:	0f b7 00             	movzwl (%eax),%eax
    f5d8:	0f b7 c0             	movzwl %ax,%eax
    f5db:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (create && !i)
    f5df:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f5e4:	74 46                	je     f62c <_bmap+0x228>
    f5e6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f5eb:	75 3f                	jne    f62c <_bmap+0x228>
			if (i = new_block(inode->i_dev)) {
    f5ed:	8b 44 24 20          	mov    0x20(%esp),%eax
    f5f1:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f5f5:	0f b7 c0             	movzwl %ax,%eax
    f5f8:	83 ec 0c             	sub    $0xc,%esp
    f5fb:	50                   	push   %eax
    f5fc:	e8 e5 70 00 00       	call   166e6 <new_block>
    f601:	83 c4 10             	add    $0x10,%esp
    f604:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f608:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f60d:	74 1d                	je     f62c <_bmap+0x228>
				((unsigned short *) (bh->b_data))[block] = i;
    f60f:	8b 44 24 08          	mov    0x8(%esp),%eax
    f613:	8b 00                	mov    (%eax),%eax
    f615:	8b 54 24 24          	mov    0x24(%esp),%edx
    f619:	01 d2                	add    %edx,%edx
    f61b:	01 d0                	add    %edx,%eax
    f61d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f621:	66 89 10             	mov    %dx,(%eax)
				bh->b_dirt = 1;
    f624:	8b 44 24 08          	mov    0x8(%esp),%eax
    f628:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
			}
		// 最后释放该间接块占用的缓冲块,并返回磁盘上新申请或原有的对应block的逻辑块块号.
		brelse(bh);
    f62c:	83 ec 0c             	sub    $0xc,%esp
    f62f:	ff 74 24 14          	pushl  0x14(%esp)
    f633:	e8 33 13 00 00       	call   1096b <brelse>
    f638:	83 c4 10             	add    $0x10,%esp
		return i;
    f63b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f63f:	e9 0d 02 00 00       	jmp    f851 <_bmap+0x44d>
	}
	// 若程序运行到此,则表明数据块属于二次间接块.其处理过程与一次间接块类似.下面是对二次间接块的处理.首先将block再减去间接块所容纳的块数(512).然后根据
	// 是否设置了创建标志进行创建或寻找处理.如果是新创建并且i节点的二次间接块字段为0,则需申请一磁盘块用于存放二次间接块的一级块信息,并将此实际磁盘块号填入
	// 二次间接块字段中.之后,置i节点已修改编制和修改时间.同样地,如果创建时申请磁盘块失败,则此时i节点二次间接块字段i_zone[8]为0,则返回0.或者不是创建,但
	// i_zone[8]原来变为0,表明i节点中没有间接块,于是映射磁盘块失败,返回0退出.
	block -= 512;
    f644:	81 6c 24 24 00 02 00 	subl   $0x200,0x24(%esp)
    f64b:	00 
	if (create && !inode->i_zone[8])
    f64c:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f651:	74 70                	je     f6c3 <_bmap+0x2bf>
    f653:	8b 44 24 20          	mov    0x20(%esp),%eax
    f657:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    f65b:	66 85 c0             	test   %ax,%ax
    f65e:	75 63                	jne    f6c3 <_bmap+0x2bf>
		if (inode->i_zone[8] = new_block(inode->i_dev)) {
    f660:	8b 44 24 20          	mov    0x20(%esp),%eax
    f664:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f668:	0f b7 c0             	movzwl %ax,%eax
    f66b:	83 ec 0c             	sub    $0xc,%esp
    f66e:	50                   	push   %eax
    f66f:	e8 72 70 00 00       	call   166e6 <new_block>
    f674:	83 c4 10             	add    $0x10,%esp
    f677:	89 c2                	mov    %eax,%edx
    f679:	8b 44 24 20          	mov    0x20(%esp),%eax
    f67d:	66 89 50 1e          	mov    %dx,0x1e(%eax)
    f681:	8b 44 24 20          	mov    0x20(%esp),%eax
    f685:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    f689:	66 85 c0             	test   %ax,%ax
    f68c:	74 35                	je     f6c3 <_bmap+0x2bf>
			inode->i_dirt = 1;
    f68e:	8b 44 24 20          	mov    0x20(%esp),%eax
    f692:	c6 40 37 01          	movb   $0x1,0x37(%eax)
			inode->i_ctime = CURRENT_TIME;
    f696:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
    f69c:	8b 10                	mov    (%eax),%edx
    f69e:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
    f6a4:	8b 00                	mov    (%eax),%eax
    f6a6:	01 d0                	add    %edx,%eax
    f6a8:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    f6ad:	f7 e2                	mul    %edx
    f6af:	c1 ea 05             	shr    $0x5,%edx
    f6b2:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
    f6b8:	8b 00                	mov    (%eax),%eax
    f6ba:	01 c2                	add    %eax,%edx
    f6bc:	8b 44 24 20          	mov    0x20(%esp),%eax
    f6c0:	89 50 2c             	mov    %edx,0x2c(%eax)
		}
	if (!inode->i_zone[8])
    f6c3:	8b 44 24 20          	mov    0x20(%esp),%eax
    f6c7:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    f6cb:	66 85 c0             	test   %ax,%ax
    f6ce:	75 0a                	jne    f6da <_bmap+0x2d6>
		return 0;
    f6d0:	b8 00 00 00 00       	mov    $0x0,%eax
    f6d5:	e9 77 01 00 00       	jmp    f851 <_bmap+0x44d>
	// 现在读取设备上该i节点的二次间接块.并取该二次间接块的一级块上第(block/512)项中的逻辑块号i.如果是创建并且二次间接块的一级块上第(block/512)项中的逻辑
	// 块号为0的话,则需申请一磁盘块(逻辑块)作为二次间接块的二级块i,并让二次间接块的一级块中第(block/512)项等于该二级块的块号i.然后置位二次间接块的一级块已
	// 修改标志.并释放二次间接块的一级块.如果不是创建,则i就是需要映射(寻找)的逻辑块号.
	if (!(bh = bread(inode->i_dev, inode->i_zone[8])))
    f6da:	8b 44 24 20          	mov    0x20(%esp),%eax
    f6de:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    f6e2:	0f b7 d0             	movzwl %ax,%edx
    f6e5:	8b 44 24 20          	mov    0x20(%esp),%eax
    f6e9:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f6ed:	0f b7 c0             	movzwl %ax,%eax
    f6f0:	83 ec 08             	sub    $0x8,%esp
    f6f3:	52                   	push   %edx
    f6f4:	50                   	push   %eax
    f6f5:	e8 d8 12 00 00       	call   109d2 <bread>
    f6fa:	83 c4 10             	add    $0x10,%esp
    f6fd:	89 44 24 08          	mov    %eax,0x8(%esp)
    f701:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    f706:	75 0a                	jne    f712 <_bmap+0x30e>
		return 0;
    f708:	b8 00 00 00 00       	mov    $0x0,%eax
    f70d:	e9 3f 01 00 00       	jmp    f851 <_bmap+0x44d>
	i = ((unsigned short *)bh->b_data)[block >> 9];
    f712:	8b 44 24 08          	mov    0x8(%esp),%eax
    f716:	8b 00                	mov    (%eax),%eax
    f718:	8b 54 24 24          	mov    0x24(%esp),%edx
    f71c:	c1 fa 09             	sar    $0x9,%edx
    f71f:	01 d2                	add    %edx,%edx
    f721:	01 d0                	add    %edx,%eax
    f723:	0f b7 00             	movzwl (%eax),%eax
    f726:	0f b7 c0             	movzwl %ax,%eax
    f729:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (create && !i)
    f72d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f732:	74 49                	je     f77d <_bmap+0x379>
    f734:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f739:	75 42                	jne    f77d <_bmap+0x379>
		if (i = new_block(inode->i_dev)) {
    f73b:	8b 44 24 20          	mov    0x20(%esp),%eax
    f73f:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f743:	0f b7 c0             	movzwl %ax,%eax
    f746:	83 ec 0c             	sub    $0xc,%esp
    f749:	50                   	push   %eax
    f74a:	e8 97 6f 00 00       	call   166e6 <new_block>
    f74f:	83 c4 10             	add    $0x10,%esp
    f752:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f756:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f75b:	74 20                	je     f77d <_bmap+0x379>
			((unsigned short *) (bh->b_data))[block >> 9] = i;
    f75d:	8b 44 24 08          	mov    0x8(%esp),%eax
    f761:	8b 00                	mov    (%eax),%eax
    f763:	8b 54 24 24          	mov    0x24(%esp),%edx
    f767:	c1 fa 09             	sar    $0x9,%edx
    f76a:	01 d2                	add    %edx,%edx
    f76c:	01 d0                	add    %edx,%eax
    f76e:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f772:	66 89 10             	mov    %dx,(%eax)
			bh->b_dirt=1;
    f775:	8b 44 24 08          	mov    0x8(%esp),%eax
    f779:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		}
	brelse(bh);
    f77d:	83 ec 0c             	sub    $0xc,%esp
    f780:	ff 74 24 14          	pushl  0x14(%esp)
    f784:	e8 e2 11 00 00       	call   1096b <brelse>
    f789:	83 c4 10             	add    $0x10,%esp
	// 如果二次间接块的二级块块号为0,表示申请磁盘失败或者原来对应块号就为0,则返回0退出.否则就从设备上读取二次间接块的二级块,并取该二级块上第block项中的逻辑块
	// 号(与上511是为了限定block值不超过511).
	if (!i)
    f78c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f791:	75 0a                	jne    f79d <_bmap+0x399>
		return 0;
    f793:	b8 00 00 00 00       	mov    $0x0,%eax
    f798:	e9 b4 00 00 00       	jmp    f851 <_bmap+0x44d>
	if (!(bh = bread(inode->i_dev, i)))
    f79d:	8b 44 24 20          	mov    0x20(%esp),%eax
    f7a1:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f7a5:	0f b7 c0             	movzwl %ax,%eax
    f7a8:	83 ec 08             	sub    $0x8,%esp
    f7ab:	ff 74 24 14          	pushl  0x14(%esp)
    f7af:	50                   	push   %eax
    f7b0:	e8 1d 12 00 00       	call   109d2 <bread>
    f7b5:	83 c4 10             	add    $0x10,%esp
    f7b8:	89 44 24 08          	mov    %eax,0x8(%esp)
    f7bc:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    f7c1:	75 0a                	jne    f7cd <_bmap+0x3c9>
		return 0;
    f7c3:	b8 00 00 00 00       	mov    $0x0,%eax
    f7c8:	e9 84 00 00 00       	jmp    f851 <_bmap+0x44d>
	i = ((unsigned short *)bh->b_data)[block & 511];
    f7cd:	8b 44 24 08          	mov    0x8(%esp),%eax
    f7d1:	8b 00                	mov    (%eax),%eax
    f7d3:	8b 54 24 24          	mov    0x24(%esp),%edx
    f7d7:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    f7dd:	01 d2                	add    %edx,%edx
    f7df:	01 d0                	add    %edx,%eax
    f7e1:	0f b7 00             	movzwl (%eax),%eax
    f7e4:	0f b7 c0             	movzwl %ax,%eax
    f7e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	// 如果是创建并且二级块的第block项中逻辑块号为0的话,则申请一磁盘块(逻辑块),作为最终存放数据信息的块.并让二级块中的第block项等于该新逻辑块块号(i).然后置位
	// 二级块的已修改标志.
	if (create && !i)
    f7eb:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f7f0:	74 4c                	je     f83e <_bmap+0x43a>
    f7f2:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f7f7:	75 45                	jne    f83e <_bmap+0x43a>
		if (i = new_block(inode->i_dev)) {
    f7f9:	8b 44 24 20          	mov    0x20(%esp),%eax
    f7fd:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f801:	0f b7 c0             	movzwl %ax,%eax
    f804:	83 ec 0c             	sub    $0xc,%esp
    f807:	50                   	push   %eax
    f808:	e8 d9 6e 00 00       	call   166e6 <new_block>
    f80d:	83 c4 10             	add    $0x10,%esp
    f810:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f814:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f819:	74 23                	je     f83e <_bmap+0x43a>
			((unsigned short *) (bh->b_data))[block & 511] = i;
    f81b:	8b 44 24 08          	mov    0x8(%esp),%eax
    f81f:	8b 00                	mov    (%eax),%eax
    f821:	8b 54 24 24          	mov    0x24(%esp),%edx
    f825:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    f82b:	01 d2                	add    %edx,%edx
    f82d:	01 d0                	add    %edx,%eax
    f82f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f833:	66 89 10             	mov    %dx,(%eax)
			bh->b_dirt = 1;
    f836:	8b 44 24 08          	mov    0x8(%esp),%eax
    f83a:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		}
	// 最后释放该二次间接块的二级块,返回磁盘上新申请的或原有的对应block的逻辑块块号.
	brelse(bh);
    f83e:	83 ec 0c             	sub    $0xc,%esp
    f841:	ff 74 24 14          	pushl  0x14(%esp)
    f845:	e8 21 11 00 00       	call   1096b <brelse>
    f84a:	83 c4 10             	add    $0x10,%esp
	return i;
    f84d:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    f851:	83 c4 18             	add    $0x18,%esp
    f854:	5b                   	pop    %ebx
    f855:	c3                   	ret    

0000f856 <bmap>:

// 取文件数据块block在设备上对应的逻辑块号.
// 参数:inode - 文件的内存i节点指针;block - 文件中的数据块号.
// 若操作成功则返回对应的逻辑块号,否则返回0.
int bmap(struct m_inode * inode, int block)
{
    f856:	83 ec 0c             	sub    $0xc,%esp
    f859:	e8 94 74 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    f85e:	05 a2 27 02 00       	add    $0x227a2,%eax
	return _bmap(inode, block, 0);
    f863:	83 ec 04             	sub    $0x4,%esp
    f866:	6a 00                	push   $0x0
    f868:	ff 74 24 1c          	pushl  0x1c(%esp)
    f86c:	ff 74 24 1c          	pushl  0x1c(%esp)
    f870:	e8 8f fb ff ff       	call   f404 <_bmap>
    f875:	83 c4 10             	add    $0x10,%esp
}
    f878:	83 c4 0c             	add    $0xc,%esp
    f87b:	c3                   	ret    

0000f87c <create_block>:

// 取文件数据块block在设备上对应的逻辑块号。如果对应的逻辑块不存在就创建一块。并返回设备上对应的逻辑块号。
// 参数：inode - 文件的内在i节点指针；block - 文件中的数据块号。
// 若操作成功则返回对应的逻辑块号，否则返回0.
int create_block(struct m_inode * inode, int block)
{
    f87c:	83 ec 0c             	sub    $0xc,%esp
    f87f:	e8 6e 74 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
    f884:	05 7c 27 02 00       	add    $0x2277c,%eax
	return _bmap(inode, block, 1);
    f889:	83 ec 04             	sub    $0x4,%esp
    f88c:	6a 01                	push   $0x1
    f88e:	ff 74 24 1c          	pushl  0x1c(%esp)
    f892:	ff 74 24 1c          	pushl  0x1c(%esp)
    f896:	e8 69 fb ff ff       	call   f404 <_bmap>
    f89b:	83 c4 10             	add    $0x10,%esp
}
    f89e:	83 c4 0c             	add    $0xc,%esp
    f8a1:	c3                   	ret    

0000f8a2 <iput>:

// 放回(放置)一个i节点(加写入设备).
// 该函数主要用于把i节点引用计数值递减1,并且若是管道i节点,则唤醒等待的进程.若是块设备文件i节点则刷新设备.并且若i节点的链接计数为0,则释放该
// i节点占用的所有磁盘逻辑块,并释放该i节点.
void iput(struct m_inode * inode)
{
    f8a2:	53                   	push   %ebx
    f8a3:	83 ec 08             	sub    $0x8,%esp
    f8a6:	e8 4f 74 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    f8ab:	81 c3 55 27 02 00    	add    $0x22755,%ebx
	// 首先判断参数给出的i节点的有效性,并等待inode节点解锁(如果已经上锁的话).如果i节点的引用计数为0,表示该i节点已经是空闲的.内核再要求对其进行
	// 放回操作,说明内核中其他代码有问题.于是显示错误信息并停机.
	if (!inode)
    f8b1:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    f8b6:	0f 84 ab 01 00 00    	je     fa67 <iput+0x1c5>
		return;
	wait_on_inode(inode);
    f8bc:	83 ec 0c             	sub    $0xc,%esp
    f8bf:	ff 74 24 1c          	pushl  0x1c(%esp)
    f8c3:	e8 9b f9 ff ff       	call   f263 <wait_on_inode>
    f8c8:	83 c4 10             	add    $0x10,%esp
	if (!inode->i_count)
    f8cb:	8b 44 24 10          	mov    0x10(%esp),%eax
    f8cf:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    f8d3:	66 85 c0             	test   %ax,%ax
    f8d6:	75 12                	jne    f8ea <iput+0x48>
		panic("iput: trying to free free inode");
    f8d8:	83 ec 0c             	sub    $0xc,%esp
    f8db:	8d 83 08 4f ff ff    	lea    -0xb0f8(%ebx),%eax
    f8e1:	50                   	push   %eax
    f8e2:	e8 f7 99 ff ff       	call   92de <panic>
    f8e7:	83 c4 10             	add    $0x10,%esp
	// 如果是管道i节点,则唤醒等待该管道的进程,引用次数减1,如果还有引用则返回.否则释放管道占用的内存页面,并复位该节点的引用计数值,已修改标志和管道
	// 标志,并返回.对于管道节点,inode->i_size存放着内存页地址.参见get_pipe_inode().
	if (inode->i_pipe) {
    f8ea:	8b 44 24 10          	mov    0x10(%esp),%eax
    f8ee:	0f b6 40 38          	movzbl 0x38(%eax),%eax
    f8f2:	84 c0                	test   %al,%al
    f8f4:	74 7c                	je     f972 <iput+0xd0>
		wake_up(&inode->i_wait);
    f8f6:	8b 44 24 10          	mov    0x10(%esp),%eax
    f8fa:	83 c0 20             	add    $0x20,%eax
    f8fd:	83 ec 0c             	sub    $0xc,%esp
    f900:	50                   	push   %eax
    f901:	e8 a1 79 ff ff       	call   72a7 <wake_up>
    f906:	83 c4 10             	add    $0x10,%esp
		wake_up(&inode->i_wait2);
    f909:	8b 44 24 10          	mov    0x10(%esp),%eax
    f90d:	83 c0 24             	add    $0x24,%eax
    f910:	83 ec 0c             	sub    $0xc,%esp
    f913:	50                   	push   %eax
    f914:	e8 8e 79 ff ff       	call   72a7 <wake_up>
    f919:	83 c4 10             	add    $0x10,%esp
		if (--inode->i_count)
    f91c:	8b 44 24 10          	mov    0x10(%esp),%eax
    f920:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    f924:	8d 50 ff             	lea    -0x1(%eax),%edx
    f927:	8b 44 24 10          	mov    0x10(%esp),%eax
    f92b:	66 89 50 34          	mov    %dx,0x34(%eax)
    f92f:	8b 44 24 10          	mov    0x10(%esp),%eax
    f933:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    f937:	66 85 c0             	test   %ax,%ax
    f93a:	0f 85 2a 01 00 00    	jne    fa6a <iput+0x1c8>
			return;
		free_page(inode->i_size);
    f940:	8b 44 24 10          	mov    0x10(%esp),%eax
    f944:	8b 40 04             	mov    0x4(%eax),%eax
    f947:	83 ec 0c             	sub    $0xc,%esp
    f94a:	50                   	push   %eax
    f94b:	e8 1f d1 ff ff       	call   ca6f <free_page>
    f950:	83 c4 10             	add    $0x10,%esp
		inode->i_count = 0;
    f953:	8b 44 24 10          	mov    0x10(%esp),%eax
    f957:	66 c7 40 34 00 00    	movw   $0x0,0x34(%eax)
		inode->i_dirt = 0;
    f95d:	8b 44 24 10          	mov    0x10(%esp),%eax
    f961:	c6 40 37 00          	movb   $0x0,0x37(%eax)
		inode->i_pipe = 0;
    f965:	8b 44 24 10          	mov    0x10(%esp),%eax
    f969:	c6 40 38 00          	movb   $0x0,0x38(%eax)
		return;
    f96d:	e9 f9 00 00 00       	jmp    fa6b <iput+0x1c9>
	}
	// 如果i节点对应的设备号 =0,则将此节点的引用计数递减1,返回.例如用于管道操作的i节点,其i节点的设备号为0.
	if (!inode->i_dev) {
    f972:	8b 44 24 10          	mov    0x10(%esp),%eax
    f976:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f97a:	66 85 c0             	test   %ax,%ax
    f97d:	75 18                	jne    f997 <iput+0xf5>
		inode->i_count--;
    f97f:	8b 44 24 10          	mov    0x10(%esp),%eax
    f983:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    f987:	8d 50 ff             	lea    -0x1(%eax),%edx
    f98a:	8b 44 24 10          	mov    0x10(%esp),%eax
    f98e:	66 89 50 34          	mov    %dx,0x34(%eax)
		return;
    f992:	e9 d4 00 00 00       	jmp    fa6b <iput+0x1c9>
	}
	// 如果是块设备文件的i节点,此时逻辑块字段0(i_zone[0])中是设备号,则刷新该设备.并等待i节点解锁.
	if (S_ISBLK(inode->i_mode)) {
    f997:	8b 44 24 10          	mov    0x10(%esp),%eax
    f99b:	0f b7 00             	movzwl (%eax),%eax
    f99e:	0f b7 c0             	movzwl %ax,%eax
    f9a1:	25 00 f0 00 00       	and    $0xf000,%eax
    f9a6:	3d 00 60 00 00       	cmp    $0x6000,%eax
    f9ab:	75 28                	jne    f9d5 <iput+0x133>
		sync_dev(inode->i_zone[0]);
    f9ad:	8b 44 24 10          	mov    0x10(%esp),%eax
    f9b1:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    f9b5:	0f b7 c0             	movzwl %ax,%eax
    f9b8:	83 ec 0c             	sub    $0xc,%esp
    f9bb:	50                   	push   %eax
    f9bc:	e8 4c 08 00 00       	call   1020d <sync_dev>
    f9c1:	83 c4 10             	add    $0x10,%esp
		wait_on_inode(inode);
    f9c4:	83 ec 0c             	sub    $0xc,%esp
    f9c7:	ff 74 24 1c          	pushl  0x1c(%esp)
    f9cb:	e8 93 f8 ff ff       	call   f263 <wait_on_inode>
    f9d0:	83 c4 10             	add    $0x10,%esp
    f9d3:	eb 01                	jmp    f9d6 <iput+0x134>
	}
	// 如果i节点引用计数大于1,则计数递减1后就直接返回(因为该i节点还有人在用,不能释放),否则就说明i节点的引用计数值为1(因为第157行已经判断过计数是否为零).
	// 如果i节点的链接数为0,则说明i节点对应文件被删除.于是释放该i节点的所有逻辑块,并释放该i节点.函数free_inode()用于实际释放i节点操作,即复位i节点
	// 对应的i节点位图,清空i节点结构内容.
repeat:
    f9d5:	90                   	nop
	if (inode->i_count > 1) {
    f9d6:	8b 44 24 10          	mov    0x10(%esp),%eax
    f9da:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    f9de:	66 83 f8 01          	cmp    $0x1,%ax
    f9e2:	76 15                	jbe    f9f9 <iput+0x157>
		inode->i_count--;
    f9e4:	8b 44 24 10          	mov    0x10(%esp),%eax
    f9e8:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    f9ec:	8d 50 ff             	lea    -0x1(%eax),%edx
    f9ef:	8b 44 24 10          	mov    0x10(%esp),%eax
    f9f3:	66 89 50 34          	mov    %dx,0x34(%eax)
		return;
    f9f7:	eb 72                	jmp    fa6b <iput+0x1c9>
	}
	if (!inode->i_nlinks) {
    f9f9:	8b 44 24 10          	mov    0x10(%esp),%eax
    f9fd:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    fa01:	84 c0                	test   %al,%al
    fa03:	75 20                	jne    fa25 <iput+0x183>
		// 释放该i节点对应的所有逻辑块
		truncate(inode);
    fa05:	83 ec 0c             	sub    $0xc,%esp
    fa08:	ff 74 24 1c          	pushl  0x1c(%esp)
    fa0c:	e8 da 77 00 00       	call   171eb <truncate>
    fa11:	83 c4 10             	add    $0x10,%esp
		// 从该设备的超级块中删除该i节点
		free_inode(inode);      								// bitmap.c
    fa14:	83 ec 0c             	sub    $0xc,%esp
    fa17:	ff 74 24 1c          	pushl  0x1c(%esp)
    fa1b:	e8 95 6e 00 00       	call   168b5 <free_inode>
    fa20:	83 c4 10             	add    $0x10,%esp
		return;
    fa23:	eb 46                	jmp    fa6b <iput+0x1c9>
	}
	// 如果该i节点已作过修改,则回写更新该i节点,并等待该i节点解锁.由于这里在写i节点时需要等待睡眠,此时其他进程有可能修改该i节点,因此在进程被唤醒后需要重复
	// 进行上述判断过程(repeat).
	if (inode->i_dirt) {
    fa25:	8b 44 24 10          	mov    0x10(%esp),%eax
    fa29:	0f b6 40 37          	movzbl 0x37(%eax),%eax
    fa2d:	84 c0                	test   %al,%al
    fa2f:	74 20                	je     fa51 <iput+0x1af>
		write_inode(inode);										/* we can sleep - so do again */
    fa31:	83 ec 0c             	sub    $0xc,%esp
    fa34:	ff 74 24 1c          	pushl  0x1c(%esp)
    fa38:	e8 b8 05 00 00       	call   fff5 <write_inode>
    fa3d:	83 c4 10             	add    $0x10,%esp
		wait_on_inode(inode);									/* 因为我们睡眠了,所以要重复判断 */
    fa40:	83 ec 0c             	sub    $0xc,%esp
    fa43:	ff 74 24 1c          	pushl  0x1c(%esp)
    fa47:	e8 17 f8 ff ff       	call   f263 <wait_on_inode>
    fa4c:	83 c4 10             	add    $0x10,%esp
		goto repeat;
    fa4f:	eb 85                	jmp    f9d6 <iput+0x134>
	}
	// 程序若能执行到此,说明该i节点的引用计数值i_count是1,链接数不为零,并且内容没有被修改过.因此此时只要把i节点引用计数递减1,返回.此时该i节点的i_count=0,
	// 表示已释放.
	inode->i_count--;
    fa51:	8b 44 24 10          	mov    0x10(%esp),%eax
    fa55:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    fa59:	8d 50 ff             	lea    -0x1(%eax),%edx
    fa5c:	8b 44 24 10          	mov    0x10(%esp),%eax
    fa60:	66 89 50 34          	mov    %dx,0x34(%eax)
	return;
    fa64:	90                   	nop
    fa65:	eb 04                	jmp    fa6b <iput+0x1c9>
		return;
    fa67:	90                   	nop
    fa68:	eb 01                	jmp    fa6b <iput+0x1c9>
			return;
    fa6a:	90                   	nop
}
    fa6b:	83 c4 08             	add    $0x8,%esp
    fa6e:	5b                   	pop    %ebx
    fa6f:	c3                   	ret    

0000fa70 <get_empty_inode>:

// 从i节点表(inode_table)中获取一个空闲i节点项.
// 寻找引用计数count为0的i节点,并将其写盘后清零,返回其指针.引用计数被置1.
struct m_inode * get_empty_inode(void)
{
    fa70:	53                   	push   %ebx
    fa71:	83 ec 18             	sub    $0x18,%esp
    fa74:	e8 81 72 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    fa79:	81 c3 87 25 02 00    	add    $0x22587,%ebx

	// 在初始化last_inode指针指向i节点表头一项后循环扫描整个i节点表,如果last_inode已经指向i节点表的最后1项之后,则让其重新指向i节点表开始处,
	// 以继续循环寻找空闲i节点项.如果last_inode所指向的i节点计数值为0,则说明可能找到空闲i节点项.让inode指向该i节点.如果该i节点的已修改标志和
	// 和锁定标志均为0,则我们可以使用该i节点,于是退出for循环.
	do {
		inode = NULL;
    fa7f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    fa86:	00 
		for (i = NR_INODE; i ; i--) {							// NR_INODE = 64.
    fa87:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
    fa8e:	00 
    fa8f:	eb 61                	jmp    faf2 <get_empty_inode+0x82>
			if (++last_inode >= inode_table + NR_INODE)
    fa91:	8b 83 c0 13 00 00    	mov    0x13c0(%ebx),%eax
    fa97:	83 c0 3c             	add    $0x3c,%eax
    fa9a:	89 83 c0 13 00 00    	mov    %eax,0x13c0(%ebx)
    faa0:	8b 93 c0 13 00 00    	mov    0x13c0(%ebx),%edx
    faa6:	8d 83 40 41 00 00    	lea    0x4140(%ebx),%eax
    faac:	39 c2                	cmp    %eax,%edx
    faae:	72 0c                	jb     fabc <get_empty_inode+0x4c>
				last_inode = inode_table;
    fab0:	8d 83 40 32 00 00    	lea    0x3240(%ebx),%eax
    fab6:	89 83 c0 13 00 00    	mov    %eax,0x13c0(%ebx)
			if (!last_inode->i_count) {
    fabc:	8b 83 c0 13 00 00    	mov    0x13c0(%ebx),%eax
    fac2:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    fac6:	66 85 c0             	test   %ax,%ax
    fac9:	75 22                	jne    faed <get_empty_inode+0x7d>
				inode = last_inode;
    facb:	8b 83 c0 13 00 00    	mov    0x13c0(%ebx),%eax
    fad1:	89 44 24 0c          	mov    %eax,0xc(%esp)
				if (!inode->i_dirt && !inode->i_lock)
    fad5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fad9:	0f b6 40 37          	movzbl 0x37(%eax),%eax
    fadd:	84 c0                	test   %al,%al
    fadf:	75 0c                	jne    faed <get_empty_inode+0x7d>
    fae1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fae5:	0f b6 40 36          	movzbl 0x36(%eax),%eax
    fae9:	84 c0                	test   %al,%al
    faeb:	74 0e                	je     fafb <get_empty_inode+0x8b>
		for (i = NR_INODE; i ; i--) {							// NR_INODE = 64.
    faed:	83 6c 24 08 01       	subl   $0x1,0x8(%esp)
    faf2:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    faf7:	75 98                	jne    fa91 <get_empty_inode+0x21>
    faf9:	eb 01                	jmp    fafc <get_empty_inode+0x8c>
					break;
    fafb:	90                   	nop
			}
		}
		// 如果没有找到空闲i节点(inode=NULL),则将i节点表打印出来供调试使用,并停机.
		if (!inode) {
    fafc:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    fb01:	75 6c                	jne    fb6f <get_empty_inode+0xff>
			for (i = 0 ; i < NR_INODE ; i++)
    fb03:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fb0a:	00 
    fb0b:	eb 49                	jmp    fb56 <get_empty_inode+0xe6>
				printk("%04x: %6d\t", inode_table[i].i_dev,
					inode_table[i].i_num);
    fb0d:	8b 54 24 08          	mov    0x8(%esp),%edx
    fb11:	8d 83 42 32 00 00    	lea    0x3242(%ebx),%eax
    fb17:	6b d2 3c             	imul   $0x3c,%edx,%edx
    fb1a:	01 d0                	add    %edx,%eax
    fb1c:	83 c0 30             	add    $0x30,%eax
    fb1f:	0f b7 00             	movzwl (%eax),%eax
				printk("%04x: %6d\t", inode_table[i].i_dev,
    fb22:	0f b7 d0             	movzwl %ax,%edx
    fb25:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    fb29:	8d 83 40 32 00 00    	lea    0x3240(%ebx),%eax
    fb2f:	6b c9 3c             	imul   $0x3c,%ecx,%ecx
    fb32:	01 c8                	add    %ecx,%eax
    fb34:	83 c0 30             	add    $0x30,%eax
    fb37:	0f b7 00             	movzwl (%eax),%eax
    fb3a:	0f b7 c0             	movzwl %ax,%eax
    fb3d:	83 ec 04             	sub    $0x4,%esp
    fb40:	52                   	push   %edx
    fb41:	50                   	push   %eax
    fb42:	8d 83 28 4f ff ff    	lea    -0xb0d8(%ebx),%eax
    fb48:	50                   	push   %eax
    fb49:	e8 e4 97 ff ff       	call   9332 <printk>
    fb4e:	83 c4 10             	add    $0x10,%esp
			for (i = 0 ; i < NR_INODE ; i++)
    fb51:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    fb56:	83 7c 24 08 3f       	cmpl   $0x3f,0x8(%esp)
    fb5b:	7e b0                	jle    fb0d <get_empty_inode+0x9d>
			panic("No free inodes in mem");
    fb5d:	83 ec 0c             	sub    $0xc,%esp
    fb60:	8d 83 33 4f ff ff    	lea    -0xb0cd(%ebx),%eax
    fb66:	50                   	push   %eax
    fb67:	e8 72 97 ff ff       	call   92de <panic>
    fb6c:	83 c4 10             	add    $0x10,%esp
		}
		// 等待该i节点解锁(如果又被上锁的话).如果该i节点已修改标志被置位的话,则将该i节点刷新(同步).因为刷新时可能会睡眠,因此需要再次循环等待i节点解锁.
		wait_on_inode(inode);
    fb6f:	83 ec 0c             	sub    $0xc,%esp
    fb72:	ff 74 24 18          	pushl  0x18(%esp)
    fb76:	e8 e8 f6 ff ff       	call   f263 <wait_on_inode>
    fb7b:	83 c4 10             	add    $0x10,%esp
		while (inode->i_dirt) {
    fb7e:	eb 1e                	jmp    fb9e <get_empty_inode+0x12e>
			write_inode(inode);
    fb80:	83 ec 0c             	sub    $0xc,%esp
    fb83:	ff 74 24 18          	pushl  0x18(%esp)
    fb87:	e8 69 04 00 00       	call   fff5 <write_inode>
    fb8c:	83 c4 10             	add    $0x10,%esp
			wait_on_inode(inode);
    fb8f:	83 ec 0c             	sub    $0xc,%esp
    fb92:	ff 74 24 18          	pushl  0x18(%esp)
    fb96:	e8 c8 f6 ff ff       	call   f263 <wait_on_inode>
    fb9b:	83 c4 10             	add    $0x10,%esp
		while (inode->i_dirt) {
    fb9e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fba2:	0f b6 40 37          	movzbl 0x37(%eax),%eax
    fba6:	84 c0                	test   %al,%al
    fba8:	75 d6                	jne    fb80 <get_empty_inode+0x110>
		}
	} while (inode->i_count);
    fbaa:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fbae:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    fbb2:	66 85 c0             	test   %ax,%ax
    fbb5:	0f 85 c4 fe ff ff    	jne    fa7f <get_empty_inode+0xf>
	// 如果i节点又被其他占用的话(i节点的计数值不为0了),则重新寻找空闲i节点.否则说明已找到符合要求的空闲i节点项.则将该i节点项内容清零,并置引用计数为1,返回该
	// i节点指针.
	memset(inode, 0, sizeof(*inode));
    fbbb:	83 ec 04             	sub    $0x4,%esp
    fbbe:	6a 3c                	push   $0x3c
    fbc0:	6a 00                	push   $0x0
    fbc2:	ff 74 24 18          	pushl  0x18(%esp)
    fbc6:	e8 67 f6 ff ff       	call   f232 <memset>
    fbcb:	83 c4 10             	add    $0x10,%esp
	inode->i_count = 1;
    fbce:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fbd2:	66 c7 40 34 01 00    	movw   $0x1,0x34(%eax)
	return inode;
    fbd8:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    fbdc:	83 c4 18             	add    $0x18,%esp
    fbdf:	5b                   	pop    %ebx
    fbe0:	c3                   	ret    

0000fbe1 <get_pipe_inode>:

// 获取管道节点。
// 首先扫描i节点表，寻找一个空闲i节点项，然后取得一页空闲内存供管道使用。然后将得到的i节点的引用计数置为2（读者
// 和写者），初始化管道头和尾，置i节点的管道类型标志。返回i节点指针，如果失败则返回NULL。
struct m_inode * get_pipe_inode(void)
{
    fbe1:	53                   	push   %ebx
    fbe2:	83 ec 18             	sub    $0x18,%esp
    fbe5:	e8 10 71 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    fbea:	81 c3 16 24 02 00    	add    $0x22416,%ebx
	struct m_inode * inode;

	// 首先从内存i节点表中取得一个空闲i节点。如果找不到空闲i节点则返回NULL。然后为该i节点申请一页内存，并让节点的
	// i_size字段指向该页面。如果已没有空闲内存，则释放该i节点，并返回NULL。
	if (!(inode = get_empty_inode()))
    fbf0:	e8 7b fe ff ff       	call   fa70 <get_empty_inode>
    fbf5:	89 44 24 0c          	mov    %eax,0xc(%esp)
    fbf9:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    fbfe:	75 07                	jne    fc07 <get_pipe_inode+0x26>
		return NULL;
    fc00:	b8 00 00 00 00       	mov    $0x0,%eax
    fc05:	eb 5a                	jmp    fc61 <get_pipe_inode+0x80>
	if (!(inode->i_size = get_free_page())) {         			// 节点的i_size字段指向缓冲区。
    fc07:	e8 e0 e3 ff ff       	call   dfec <get_free_page>
    fc0c:	89 c2                	mov    %eax,%edx
    fc0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc12:	89 50 04             	mov    %edx,0x4(%eax)
    fc15:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc19:	8b 40 04             	mov    0x4(%eax),%eax
    fc1c:	85 c0                	test   %eax,%eax
    fc1e:	75 11                	jne    fc31 <get_pipe_inode+0x50>
		inode->i_count = 0;
    fc20:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc24:	66 c7 40 34 00 00    	movw   $0x0,0x34(%eax)
		return NULL;
    fc2a:	b8 00 00 00 00       	mov    $0x0,%eax
    fc2f:	eb 30                	jmp    fc61 <get_pipe_inode+0x80>
	}
	// 然后设置该i节点的引用计数为2,并复位管道头尾指针。i节点逻辑块号数组i_zone[]的i_zone[0]和i_zone[1]中分别用
	// 来存放管道头和管道尾指针。最后设置i节点是管道i节点标志并返回该i节点号。
	inode->i_count = 2;											/* sum of readers/writers */    /* 读/写两者总计 */
    fc31:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc35:	66 c7 40 34 02 00    	movw   $0x2,0x34(%eax)
	PIPE_HEAD(*inode) = PIPE_TAIL(*inode) = 0;      			// 复位管道头尾指针。
    fc3b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc3f:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    fc45:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc49:	0f b7 50 10          	movzwl 0x10(%eax),%edx
    fc4d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc51:	66 89 50 0e          	mov    %dx,0xe(%eax)
	inode->i_pipe = 1;                              			// 置节点为管道使用标志。
    fc55:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc59:	c6 40 38 01          	movb   $0x1,0x38(%eax)
	return inode;
    fc5d:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    fc61:	83 c4 18             	add    $0x18,%esp
    fc64:	5b                   	pop    %ebx
    fc65:	c3                   	ret    

0000fc66 <iget>:
// 取得一个i节点.
// 参数:dev - 设备号;nr - i节点号.
// 从设备上读取指定节点号的i节点结构内容到内存i节点表中,并且返回该i节点指针.首先在位于高速缓冲区中的i节点表中搜寻,若找到指定节点号的i节点则在经过一些
// 判断处理后返回该i节点指针.否则从设备dev上读取指定i节点号的i节点信息放入i节点表中,并返回该i节点指针.
struct m_inode * iget(int dev, int nr)
{
    fc66:	53                   	push   %ebx
    fc67:	83 ec 18             	sub    $0x18,%esp
    fc6a:	e8 8b 70 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    fc6f:	81 c3 91 23 02 00    	add    $0x22391,%ebx
	struct m_inode * inode, * empty;

	// 首先判断参数有效性.若设备号是0,则表明内核代码问题,显示出错信息并停机.然后预先从i节点表中取一个空闲i节点备用.
	if (!dev)
    fc75:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    fc7a:	75 12                	jne    fc8e <iget+0x28>
		panic("iget with dev==0");
    fc7c:	83 ec 0c             	sub    $0xc,%esp
    fc7f:	8d 83 49 4f ff ff    	lea    -0xb0b7(%ebx),%eax
    fc85:	50                   	push   %eax
    fc86:	e8 53 96 ff ff       	call   92de <panic>
    fc8b:	83 c4 10             	add    $0x10,%esp
	empty = get_empty_inode();
    fc8e:	e8 dd fd ff ff       	call   fa70 <get_empty_inode>
    fc93:	89 44 24 04          	mov    %eax,0x4(%esp)
	// 接着扫描i节点表.寻找参数指定节点号nr的i节点.并递增该节点的引用次数.如果当前扫描i节点的设备号不等于指定的设备号或者节点号不等于指定的节点号,则继续扫描.
	inode = inode_table;
    fc97:	8d 83 40 32 00 00    	lea    0x3240(%ebx),%eax
    fc9d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (inode < NR_INODE + inode_table) {
    fca1:	e9 55 01 00 00       	jmp    fdfb <iget+0x195>
		if (inode->i_dev != dev || inode->i_num != nr) {
    fca6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fcaa:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    fcae:	0f b7 c0             	movzwl %ax,%eax
    fcb1:	39 44 24 20          	cmp    %eax,0x20(%esp)
    fcb5:	75 11                	jne    fcc8 <iget+0x62>
    fcb7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fcbb:	0f b7 40 32          	movzwl 0x32(%eax),%eax
    fcbf:	0f b7 c0             	movzwl %ax,%eax
    fcc2:	39 44 24 24          	cmp    %eax,0x24(%esp)
    fcc6:	74 0a                	je     fcd2 <iget+0x6c>
			inode++;
    fcc8:	83 44 24 0c 3c       	addl   $0x3c,0xc(%esp)
			continue;
    fccd:	e9 29 01 00 00       	jmp    fdfb <iget+0x195>
		}
		// 如果找到指定设备号dev和节点号nr的i节点,则等待该节点解锁(如果已上锁的话).在等待该节点解锁过程中,i节点可能会发生变化.所以再次进行上述相同判断.如果发生
		// 了变化,则重新扫描整个i节点表.
		wait_on_inode(inode);
    fcd2:	83 ec 0c             	sub    $0xc,%esp
    fcd5:	ff 74 24 18          	pushl  0x18(%esp)
    fcd9:	e8 85 f5 ff ff       	call   f263 <wait_on_inode>
    fcde:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dev != dev || inode->i_num != nr) {
    fce1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fce5:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    fce9:	0f b7 c0             	movzwl %ax,%eax
    fcec:	39 44 24 20          	cmp    %eax,0x20(%esp)
    fcf0:	75 11                	jne    fd03 <iget+0x9d>
    fcf2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fcf6:	0f b7 40 32          	movzwl 0x32(%eax),%eax
    fcfa:	0f b7 c0             	movzwl %ax,%eax
    fcfd:	39 44 24 24          	cmp    %eax,0x24(%esp)
    fd01:	74 0f                	je     fd12 <iget+0xac>
			inode = inode_table;
    fd03:	8d 83 40 32 00 00    	lea    0x3240(%ebx),%eax
    fd09:	89 44 24 0c          	mov    %eax,0xc(%esp)
			continue;
    fd0d:	e9 e9 00 00 00       	jmp    fdfb <iget+0x195>
		}
		// 到这里表示找到相应的i节点.于是将该i节点引用计数增1.然后再作进一步检查,看它是否是另一个文件系统的安装点.若是则寻找被安装文件系统根节点并返回.如果该i节点
		// 的确是其他文件系统的安装点,则在超级块表中搜寻安装在此i节点的超级块.如果没有找到,则显示出错信息,并放回本函数开始时获取的空闲节点empty,返回该i节点指针.
		inode->i_count++;
    fd12:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fd16:	0f b7 40 34          	movzwl 0x34(%eax),%eax
    fd1a:	8d 50 01             	lea    0x1(%eax),%edx
    fd1d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fd21:	66 89 50 34          	mov    %dx,0x34(%eax)
		if (inode->i_mount) {
    fd25:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fd29:	0f b6 40 39          	movzbl 0x39(%eax),%eax
    fd2d:	84 c0                	test   %al,%al
    fd2f:	0f 84 aa 00 00 00    	je     fddf <iget+0x179>
			int i;

			for (i = 0 ; i < NR_SUPER ; i++)
    fd35:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fd3c:	00 
    fd3d:	eb 1f                	jmp    fd5e <iget+0xf8>
				if (super_block[i].s_imount == inode)
    fd3f:	c7 c2 a0 5c 04 00    	mov    $0x45ca0,%edx
    fd45:	8b 44 24 08          	mov    0x8(%esp),%eax
    fd49:	6b c0 6c             	imul   $0x6c,%eax,%eax
    fd4c:	01 d0                	add    %edx,%eax
    fd4e:	83 c0 5c             	add    $0x5c,%eax
    fd51:	8b 00                	mov    (%eax),%eax
    fd53:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    fd57:	74 0e                	je     fd67 <iget+0x101>
			for (i = 0 ; i < NR_SUPER ; i++)
    fd59:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    fd5e:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    fd63:	7e da                	jle    fd3f <iget+0xd9>
    fd65:	eb 01                	jmp    fd68 <iget+0x102>
					break;
    fd67:	90                   	nop
			if (i >= NR_SUPER) {
    fd68:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    fd6d:	7e 31                	jle    fda0 <iget+0x13a>
				printk("Mounted inode hasn't got sb\n");
    fd6f:	83 ec 0c             	sub    $0xc,%esp
    fd72:	8d 83 5a 4f ff ff    	lea    -0xb0a6(%ebx),%eax
    fd78:	50                   	push   %eax
    fd79:	e8 b4 95 ff ff       	call   9332 <printk>
    fd7e:	83 c4 10             	add    $0x10,%esp
				if (empty)
    fd81:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    fd86:	74 0f                	je     fd97 <iget+0x131>
					iput(empty);
    fd88:	83 ec 0c             	sub    $0xc,%esp
    fd8b:	ff 74 24 10          	pushl  0x10(%esp)
    fd8f:	e8 0e fb ff ff       	call   f8a2 <iput>
    fd94:	83 c4 10             	add    $0x10,%esp
				return inode;
    fd97:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fd9b:	e9 b0 00 00 00       	jmp    fe50 <iget+0x1ea>
			}
			// 执行到这里表示已经找到安装到inode节点的文件系统超级块.于是将该i节点写盘放回,并从安装在此i节点上的文件系统超级块中取设备号,并令i节点号为ROOT_INO.然后
			// 重新扫描整个i节点表,以获取该被安装文件系统的根i节点信息.
			iput(inode);
    fda0:	83 ec 0c             	sub    $0xc,%esp
    fda3:	ff 74 24 18          	pushl  0x18(%esp)
    fda7:	e8 f6 fa ff ff       	call   f8a2 <iput>
    fdac:	83 c4 10             	add    $0x10,%esp
			dev = super_block[i].s_dev;
    fdaf:	c7 c2 a0 5c 04 00    	mov    $0x45ca0,%edx
    fdb5:	8b 44 24 08          	mov    0x8(%esp),%eax
    fdb9:	6b c0 6c             	imul   $0x6c,%eax,%eax
    fdbc:	01 d0                	add    %edx,%eax
    fdbe:	83 c0 54             	add    $0x54,%eax
    fdc1:	0f b7 00             	movzwl (%eax),%eax
    fdc4:	0f b7 c0             	movzwl %ax,%eax
    fdc7:	89 44 24 20          	mov    %eax,0x20(%esp)
			nr = ROOT_INO;
    fdcb:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
    fdd2:	00 
			inode = inode_table;
    fdd3:	8d 83 40 32 00 00    	lea    0x3240(%ebx),%eax
    fdd9:	89 44 24 0c          	mov    %eax,0xc(%esp)
			continue;
    fddd:	eb 1c                	jmp    fdfb <iget+0x195>
		}
		// 最终我们找到了相应的i节点.因此可以放弃本函数开始处临时 的空闲i节点,返回找到的i节点指针.
		if (empty)
    fddf:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    fde4:	74 0f                	je     fdf5 <iget+0x18f>
			iput(empty);
    fde6:	83 ec 0c             	sub    $0xc,%esp
    fde9:	ff 74 24 10          	pushl  0x10(%esp)
    fded:	e8 b0 fa ff ff       	call   f8a2 <iput>
    fdf2:	83 c4 10             	add    $0x10,%esp
		return inode;
    fdf5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fdf9:	eb 55                	jmp    fe50 <iget+0x1ea>
	while (inode < NR_INODE + inode_table) {
    fdfb:	8d 83 40 41 00 00    	lea    0x4140(%ebx),%eax
    fe01:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    fe05:	0f 82 9b fe ff ff    	jb     fca6 <iget+0x40>
    }
	// 如果我们在i节点表中没有找到指定的i节点,则利用前面申请的空闲i节点empty在i节点表中建立该i节点.并从相应设备上读取该i节点信息,返回该i节点指针.
	if (!empty)
    fe0b:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    fe10:	75 07                	jne    fe19 <iget+0x1b3>
		return (NULL);
    fe12:	b8 00 00 00 00       	mov    $0x0,%eax
    fe17:	eb 37                	jmp    fe50 <iget+0x1ea>
	inode = empty;
    fe19:	8b 44 24 04          	mov    0x4(%esp),%eax
    fe1d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	inode->i_dev = dev;									// 设置i节点的设备.
    fe21:	8b 44 24 20          	mov    0x20(%esp),%eax
    fe25:	89 c2                	mov    %eax,%edx
    fe27:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fe2b:	66 89 50 30          	mov    %dx,0x30(%eax)
	inode->i_num = nr;									// 设置i节点号.
    fe2f:	8b 44 24 24          	mov    0x24(%esp),%eax
    fe33:	89 c2                	mov    %eax,%edx
    fe35:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fe39:	66 89 50 32          	mov    %dx,0x32(%eax)
	read_inode(inode);      							// 读取i节点信息
    fe3d:	83 ec 0c             	sub    $0xc,%esp
    fe40:	ff 74 24 18          	pushl  0x18(%esp)
    fe44:	e8 0c 00 00 00       	call   fe55 <read_inode>
    fe49:	83 c4 10             	add    $0x10,%esp
	return inode;
    fe4c:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    fe50:	83 c4 18             	add    $0x18,%esp
    fe53:	5b                   	pop    %ebx
    fe54:	c3                   	ret    

0000fe55 <read_inode>:
// 读取指定i节点信息.
// 从设备上读取含有指定i节点信息的i节点盘块,然后复制到指定的i节点结构中.为了确定i节点所在设备逻辑块号(或缓冲块),必须首先读取相应设备上的超级块,以
// 获取用于计算逻辑块号的每块i节点数信息INODES_PER_BLOCK.在计算出i节点所在的逻辑块号后,就把该逻辑块读入一缓冲块中.然后把缓冲块中相应位置处的i节点
// 内容复制到指定的位置处.
static void read_inode(struct m_inode * inode)
{
    fe55:	53                   	push   %ebx
    fe56:	83 ec 18             	sub    $0x18,%esp
    fe59:	e8 9c 6e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    fe5e:	81 c3 a2 21 02 00    	add    $0x221a2,%ebx
	struct super_block * sb;
	struct buffer_head * bh;
	int block;

	// 首先锁定该i节点,并取该节点所在设备的超级块.
	lock_inode(inode);
    fe64:	83 ec 0c             	sub    $0xc,%esp
    fe67:	ff 74 24 2c          	pushl  0x2c(%esp)
    fe6b:	e8 2b f4 ff ff       	call   f29b <lock_inode>
    fe70:	83 c4 10             	add    $0x10,%esp
	if (!(sb = get_super(inode->i_dev)))
    fe73:	8b 44 24 20          	mov    0x20(%esp),%eax
    fe77:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    fe7b:	0f b7 c0             	movzwl %ax,%eax
    fe7e:	83 ec 0c             	sub    $0xc,%esp
    fe81:	50                   	push   %eax
    fe82:	e8 1f 10 00 00       	call   10ea6 <get_super>
    fe87:	83 c4 10             	add    $0x10,%esp
    fe8a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    fe8e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    fe93:	75 12                	jne    fea7 <read_inode+0x52>
		panic("trying to read inode without dev");
    fe95:	83 ec 0c             	sub    $0xc,%esp
    fe98:	8d 83 78 4f ff ff    	lea    -0xb088(%ebx),%eax
    fe9e:	50                   	push   %eax
    fe9f:	e8 3a 94 ff ff       	call   92de <panic>
    fea4:	83 c4 10             	add    $0x10,%esp
	// 该i节点所在设备逻辑块号 = (启动块 + 超级块) + i节点位图占用的块数 + 逻辑块位图的块数 + (i节点号-1)/每块含有的i节点数.虽然i节点号从0开始编号,
	// 但第1个0号i节点不用,并且磁盘上也不保存对应的0号i节点结构.因此存放i节点的盘块的第1块上保存的是i节点号是1--16的i节点结构而不是0--15的.因此在上面计算
	// i节点号对应的i节点结构所在盘块时需要减1,即:B = (i节点号-1)/每块含有i节点结构数.例如,节点号16的i节点结构应该在B=(16-1)/16 = 0的块上.这里我们从
	// 设备上读取该i节点所在逻辑块,并复制指定i节点内容到inode指针所指位置处.
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    fea7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    feab:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    feaf:	0f b7 c0             	movzwl %ax,%eax
    feb2:	8d 50 02             	lea    0x2(%eax),%edx
    feb5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    feb9:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    febd:	0f b7 c0             	movzwl %ax,%eax
    fec0:	01 d0                	add    %edx,%eax
    fec2:	89 c2                	mov    %eax,%edx
		(inode->i_num - 1) / INODES_PER_BLOCK;
    fec4:	8b 44 24 20          	mov    0x20(%esp),%eax
    fec8:	0f b7 40 32          	movzwl 0x32(%eax),%eax
    fecc:	0f b7 c0             	movzwl %ax,%eax
    fecf:	83 e8 01             	sub    $0x1,%eax
    fed2:	c1 e8 05             	shr    $0x5,%eax
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    fed5:	01 d0                	add    %edx,%eax
    fed7:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 将i节点信息的那个逻辑块读取到高速缓存中
	if (!(bh = bread(inode->i_dev, block)))
    fedb:	8b 44 24 20          	mov    0x20(%esp),%eax
    fedf:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    fee3:	0f b7 c0             	movzwl %ax,%eax
    fee6:	83 ec 08             	sub    $0x8,%esp
    fee9:	ff 74 24 10          	pushl  0x10(%esp)
    feed:	50                   	push   %eax
    feee:	e8 df 0a 00 00       	call   109d2 <bread>
    fef3:	83 c4 10             	add    $0x10,%esp
    fef6:	89 44 24 04          	mov    %eax,0x4(%esp)
    fefa:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    feff:	75 12                	jne    ff13 <read_inode+0xbe>
		panic("unable to read i-node block");
    ff01:	83 ec 0c             	sub    $0xc,%esp
    ff04:	8d 83 99 4f ff ff    	lea    -0xb067(%ebx),%eax
    ff0a:	50                   	push   %eax
    ff0b:	e8 ce 93 ff ff       	call   92de <panic>
    ff10:	83 c4 10             	add    $0x10,%esp
	*(struct d_inode *)inode =
		((struct d_inode *)bh->b_data)
    ff13:	8b 44 24 04          	mov    0x4(%esp),%eax
    ff17:	8b 10                	mov    (%eax),%edx
			[(inode->i_num - 1) % INODES_PER_BLOCK];
    ff19:	8b 44 24 20          	mov    0x20(%esp),%eax
    ff1d:	0f b7 40 32          	movzwl 0x32(%eax),%eax
    ff21:	0f b7 c0             	movzwl %ax,%eax
    ff24:	83 e8 01             	sub    $0x1,%eax
    ff27:	83 e0 1f             	and    $0x1f,%eax
    ff2a:	c1 e0 05             	shl    $0x5,%eax
    ff2d:	01 c2                	add    %eax,%edx
	*(struct d_inode *)inode =
    ff2f:	8b 44 24 20          	mov    0x20(%esp),%eax
    ff33:	8b 0a                	mov    (%edx),%ecx
    ff35:	89 08                	mov    %ecx,(%eax)
    ff37:	8b 4a 04             	mov    0x4(%edx),%ecx
    ff3a:	89 48 04             	mov    %ecx,0x4(%eax)
    ff3d:	8b 4a 08             	mov    0x8(%edx),%ecx
    ff40:	89 48 08             	mov    %ecx,0x8(%eax)
    ff43:	8b 4a 0c             	mov    0xc(%edx),%ecx
    ff46:	89 48 0c             	mov    %ecx,0xc(%eax)
    ff49:	8b 4a 10             	mov    0x10(%edx),%ecx
    ff4c:	89 48 10             	mov    %ecx,0x10(%eax)
    ff4f:	8b 4a 14             	mov    0x14(%edx),%ecx
    ff52:	89 48 14             	mov    %ecx,0x14(%eax)
    ff55:	8b 4a 18             	mov    0x18(%edx),%ecx
    ff58:	89 48 18             	mov    %ecx,0x18(%eax)
    ff5b:	8b 52 1c             	mov    0x1c(%edx),%edx
    ff5e:	89 50 1c             	mov    %edx,0x1c(%eax)
	// 最后释放读入的缓冲块,并解锁该i节点.对于块设备文件,还需要设置i节点的文件最大长度值.
	brelse(bh);
    ff61:	83 ec 0c             	sub    $0xc,%esp
    ff64:	ff 74 24 10          	pushl  0x10(%esp)
    ff68:	e8 fe 09 00 00       	call   1096b <brelse>
    ff6d:	83 c4 10             	add    $0x10,%esp
	if (S_ISBLK(inode->i_mode)) {
    ff70:	8b 44 24 20          	mov    0x20(%esp),%eax
    ff74:	0f b7 00             	movzwl (%eax),%eax
    ff77:	0f b7 c0             	movzwl %ax,%eax
    ff7a:	25 00 f0 00 00       	and    $0xf000,%eax
    ff7f:	3d 00 60 00 00       	cmp    $0x6000,%eax
    ff84:	75 5a                	jne    ffe0 <read_inode+0x18b>
		int i = inode->i_zone[0];							// 对于块设备文件,i_zone[0]中是设备号.
    ff86:	8b 44 24 20          	mov    0x20(%esp),%eax
    ff8a:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    ff8e:	0f b7 c0             	movzwl %ax,%eax
    ff91:	89 04 24             	mov    %eax,(%esp)
		if (blk_size[MAJOR(i)])
    ff94:	8b 04 24             	mov    (%esp),%eax
    ff97:	c1 e8 08             	shr    $0x8,%eax
    ff9a:	89 c2                	mov    %eax,%edx
    ff9c:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
    ffa2:	8b 04 90             	mov    (%eax,%edx,4),%eax
    ffa5:	85 c0                	test   %eax,%eax
    ffa7:	74 2c                	je     ffd5 <read_inode+0x180>
			inode->i_size = 1024 * blk_size[MAJOR(i)][MINOR(i)];
    ffa9:	8b 04 24             	mov    (%esp),%eax
    ffac:	c1 e8 08             	shr    $0x8,%eax
    ffaf:	89 c2                	mov    %eax,%edx
    ffb1:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
    ffb7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    ffba:	8b 14 24             	mov    (%esp),%edx
    ffbd:	0f b6 d2             	movzbl %dl,%edx
    ffc0:	c1 e2 02             	shl    $0x2,%edx
    ffc3:	01 d0                	add    %edx,%eax
    ffc5:	8b 00                	mov    (%eax),%eax
    ffc7:	c1 e0 0a             	shl    $0xa,%eax
    ffca:	89 c2                	mov    %eax,%edx
    ffcc:	8b 44 24 20          	mov    0x20(%esp),%eax
    ffd0:	89 50 04             	mov    %edx,0x4(%eax)
    ffd3:	eb 0b                	jmp    ffe0 <read_inode+0x18b>
		else
			inode->i_size = 0x7fffffff;
    ffd5:	8b 44 24 20          	mov    0x20(%esp),%eax
    ffd9:	c7 40 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%eax)
	}
	unlock_inode(inode);
    ffe0:	83 ec 0c             	sub    $0xc,%esp
    ffe3:	ff 74 24 2c          	pushl  0x2c(%esp)
    ffe7:	e8 ef f2 ff ff       	call   f2db <unlock_inode>
    ffec:	83 c4 10             	add    $0x10,%esp
}
    ffef:	90                   	nop
    fff0:	83 c4 18             	add    $0x18,%esp
    fff3:	5b                   	pop    %ebx
    fff4:	c3                   	ret    

0000fff5 <write_inode>:
// 将i节点信息写入缓冲区中.
// 该函数把参数指定的i节点写入缓冲区相应的缓冲块中,待缓冲区刷新时会写入盘中.为了确定i节点所在的设备逻辑块号(或缓冲块),必须首先读取相应设备上的超级块,
// 以获取用于计算逻辑块号的每块i节点数信息INODES_PER_BLOCK.在计算出i节点所在的逻辑块号后,就把该逻辑块读入一缓冲块中.然后把i节点内容复制到缓冲块的
// 相应位置处.
static void write_inode(struct m_inode * inode)
{
    fff5:	53                   	push   %ebx
    fff6:	83 ec 18             	sub    $0x18,%esp
    fff9:	e8 fc 6c ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
    fffe:	81 c3 02 20 02 00    	add    $0x22002,%ebx
	struct buffer_head * bh;
	int block;

	// 首先锁定该i节点,如果该i节点没有被修改过或者该i节点的设备号等于零,则解锁该i节点,并退出.对于没有被修改过的i节点,其内容与缓冲区中或设备中的相同.然后获取
	// 该i节点的超级块.
	lock_inode(inode);
   10004:	83 ec 0c             	sub    $0xc,%esp
   10007:	ff 74 24 2c          	pushl  0x2c(%esp)
   1000b:	e8 8b f2 ff ff       	call   f29b <lock_inode>
   10010:	83 c4 10             	add    $0x10,%esp
	if (!inode->i_dirt || !inode->i_dev) {
   10013:	8b 44 24 20          	mov    0x20(%esp),%eax
   10017:	0f b6 40 37          	movzbl 0x37(%eax),%eax
   1001b:	84 c0                	test   %al,%al
   1001d:	74 0d                	je     1002c <write_inode+0x37>
   1001f:	8b 44 24 20          	mov    0x20(%esp),%eax
   10023:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   10027:	66 85 c0             	test   %ax,%ax
   1002a:	75 14                	jne    10040 <write_inode+0x4b>
		unlock_inode(inode);
   1002c:	83 ec 0c             	sub    $0xc,%esp
   1002f:	ff 74 24 2c          	pushl  0x2c(%esp)
   10033:	e8 a3 f2 ff ff       	call   f2db <unlock_inode>
   10038:	83 c4 10             	add    $0x10,%esp
		return;
   1003b:	e9 1c 01 00 00       	jmp    1015c <write_inode+0x167>
	}
	if (!(sb = get_super(inode->i_dev)))
   10040:	8b 44 24 20          	mov    0x20(%esp),%eax
   10044:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   10048:	0f b7 c0             	movzwl %ax,%eax
   1004b:	83 ec 0c             	sub    $0xc,%esp
   1004e:	50                   	push   %eax
   1004f:	e8 52 0e 00 00       	call   10ea6 <get_super>
   10054:	83 c4 10             	add    $0x10,%esp
   10057:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1005b:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   10060:	75 12                	jne    10074 <write_inode+0x7f>
		panic("trying to write inode without device");
   10062:	83 ec 0c             	sub    $0xc,%esp
   10065:	8d 83 b8 4f ff ff    	lea    -0xb048(%ebx),%eax
   1006b:	50                   	push   %eax
   1006c:	e8 6d 92 ff ff       	call   92de <panic>
   10071:	83 c4 10             	add    $0x10,%esp
	// 该i节点所在的设备逻辑号 = (启动块 + 超级块) + i节点位图占用的块数 + 逻辑块位图占用的块数 + (i节点号-1)/每块含有的i节点数.我们从设备上读取该i节点所
	// 在的逻辑块,并将该i节点信息复制到逻辑块对应该i节点的项位置处.
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
   10074:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10078:	0f b7 40 04          	movzwl 0x4(%eax),%eax
   1007c:	0f b7 c0             	movzwl %ax,%eax
   1007f:	8d 50 02             	lea    0x2(%eax),%edx
   10082:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10086:	0f b7 40 06          	movzwl 0x6(%eax),%eax
   1008a:	0f b7 c0             	movzwl %ax,%eax
   1008d:	01 d0                	add    %edx,%eax
   1008f:	89 c2                	mov    %eax,%edx
		(inode->i_num - 1) / INODES_PER_BLOCK;
   10091:	8b 44 24 20          	mov    0x20(%esp),%eax
   10095:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   10099:	0f b7 c0             	movzwl %ax,%eax
   1009c:	83 e8 01             	sub    $0x1,%eax
   1009f:	c1 e8 05             	shr    $0x5,%eax
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
   100a2:	01 d0                	add    %edx,%eax
   100a4:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!(bh = bread(inode->i_dev, block)))
   100a8:	8b 44 24 20          	mov    0x20(%esp),%eax
   100ac:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   100b0:	0f b7 c0             	movzwl %ax,%eax
   100b3:	83 ec 08             	sub    $0x8,%esp
   100b6:	ff 74 24 10          	pushl  0x10(%esp)
   100ba:	50                   	push   %eax
   100bb:	e8 12 09 00 00       	call   109d2 <bread>
   100c0:	83 c4 10             	add    $0x10,%esp
   100c3:	89 44 24 04          	mov    %eax,0x4(%esp)
   100c7:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   100cc:	75 12                	jne    100e0 <write_inode+0xeb>
		panic("unable to read i-node block");
   100ce:	83 ec 0c             	sub    $0xc,%esp
   100d1:	8d 83 99 4f ff ff    	lea    -0xb067(%ebx),%eax
   100d7:	50                   	push   %eax
   100d8:	e8 01 92 ff ff       	call   92de <panic>
   100dd:	83 c4 10             	add    $0x10,%esp
	((struct d_inode *)bh->b_data)
   100e0:	8b 44 24 04          	mov    0x4(%esp),%eax
   100e4:	8b 10                	mov    (%eax),%edx
		[(inode->i_num - 1) % INODES_PER_BLOCK] =
   100e6:	8b 44 24 20          	mov    0x20(%esp),%eax
   100ea:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   100ee:	0f b7 c0             	movzwl %ax,%eax
   100f1:	83 e8 01             	sub    $0x1,%eax
   100f4:	83 e0 1f             	and    $0x1f,%eax
   100f7:	c1 e0 05             	shl    $0x5,%eax
   100fa:	01 c2                	add    %eax,%edx
   100fc:	8b 44 24 20          	mov    0x20(%esp),%eax
   10100:	8b 08                	mov    (%eax),%ecx
   10102:	89 0a                	mov    %ecx,(%edx)
   10104:	8b 48 04             	mov    0x4(%eax),%ecx
   10107:	89 4a 04             	mov    %ecx,0x4(%edx)
   1010a:	8b 48 08             	mov    0x8(%eax),%ecx
   1010d:	89 4a 08             	mov    %ecx,0x8(%edx)
   10110:	8b 48 0c             	mov    0xc(%eax),%ecx
   10113:	89 4a 0c             	mov    %ecx,0xc(%edx)
   10116:	8b 48 10             	mov    0x10(%eax),%ecx
   10119:	89 4a 10             	mov    %ecx,0x10(%edx)
   1011c:	8b 48 14             	mov    0x14(%eax),%ecx
   1011f:	89 4a 14             	mov    %ecx,0x14(%edx)
   10122:	8b 48 18             	mov    0x18(%eax),%ecx
   10125:	89 4a 18             	mov    %ecx,0x18(%edx)
   10128:	8b 40 1c             	mov    0x1c(%eax),%eax
   1012b:	89 42 1c             	mov    %eax,0x1c(%edx)
			*(struct d_inode *)inode;
	// 然后置缓冲区已修改标志,而i节点内容已经与缓冲区中的一致,因此修改标志置零.然后释放该含有i节点的缓冲区,并解锁该i节点.
	bh->b_dirt = 1;
   1012e:	8b 44 24 04          	mov    0x4(%esp),%eax
   10132:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	inode->i_dirt = 0;
   10136:	8b 44 24 20          	mov    0x20(%esp),%eax
   1013a:	c6 40 37 00          	movb   $0x0,0x37(%eax)
	brelse(bh);
   1013e:	83 ec 0c             	sub    $0xc,%esp
   10141:	ff 74 24 10          	pushl  0x10(%esp)
   10145:	e8 21 08 00 00       	call   1096b <brelse>
   1014a:	83 c4 10             	add    $0x10,%esp
	unlock_inode(inode);
   1014d:	83 ec 0c             	sub    $0xc,%esp
   10150:	ff 74 24 2c          	pushl  0x2c(%esp)
   10154:	e8 82 f1 ff ff       	call   f2db <unlock_inode>
   10159:	83 c4 10             	add    $0x10,%esp
}
   1015c:	83 c4 18             	add    $0x18,%esp
   1015f:	5b                   	pop    %ebx
   10160:	c3                   	ret    

00010161 <wait_on_buffer>:
// 等待指定缓冲块解锁.
// 如果指定的缓冲块bh已经上锁就让进程不可中断地睡眠在该缓冲块的等待队列b_wait中.在缓冲块解锁时,其等待队列上的所有进程将被唤醒.虽然是在关闭
// 中断(cli)之后去睡眠的,但这样做并不会影响在其他进程上下文中响应中断.因为每个进程都在自己的TSS段中保存了标志寄存器EFLAGS的值,所在在进程
// 切换时CPU中当前EFLAGS的值也随之改变.使用sleep_on()进入睡眠状态的进程需要用wake_up()明确地唤醒.
static inline void wait_on_buffer(struct buffer_head * bh)
{
   10161:	53                   	push   %ebx
   10162:	83 ec 08             	sub    $0x8,%esp
   10165:	e8 90 6b ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1016a:	81 c3 96 1e 02 00    	add    $0x21e96,%ebx
	cli();							// 关中断
   10170:	fa                   	cli    
	while (bh->b_lock)				// 如果已被上锁则进程进入睡眠,等待其解锁.
   10171:	eb 13                	jmp    10186 <wait_on_buffer+0x25>
		sleep_on(&bh->b_wait);
   10173:	8b 44 24 10          	mov    0x10(%esp),%eax
   10177:	83 c0 10             	add    $0x10,%eax
   1017a:	83 ec 0c             	sub    $0xc,%esp
   1017d:	50                   	push   %eax
   1017e:	e8 01 71 ff ff       	call   7284 <sleep_on>
   10183:	83 c4 10             	add    $0x10,%esp
	while (bh->b_lock)				// 如果已被上锁则进程进入睡眠,等待其解锁.
   10186:	8b 44 24 10          	mov    0x10(%esp),%eax
   1018a:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1018e:	84 c0                	test   %al,%al
   10190:	75 e1                	jne    10173 <wait_on_buffer+0x12>
	sti();							// 开中断.
   10192:	fb                   	sti    
}
   10193:	90                   	nop
   10194:	83 c4 08             	add    $0x8,%esp
   10197:	5b                   	pop    %ebx
   10198:	c3                   	ret    

00010199 <sys_sync>:

// 设备数据同步。
// 同步设备和内存高速缓冲中数据。其中，sync_inodes()定义在inode.c。
int sys_sync(void)
{
   10199:	53                   	push   %ebx
   1019a:	83 ec 18             	sub    $0x18,%esp
   1019d:	e8 58 6b ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   101a2:	81 c3 5e 1e 02 00    	add    $0x21e5e,%ebx
	int i;
	struct buffer_head * bh;

	// 首先调用i节点同步函数，把内在i节点表中所有修改过的i节点写入高速缓冲中。然后扫描所有高速缓冲区，对已被修改的缓冲块
	// 产生写盘请求，将缓冲中数据写入盘中，做到高速缓冲中的数据与设备中的同步。
	sync_inodes();							/* write out inodes into buffers */
   101a8:	e8 ea f1 ff ff       	call   f397 <sync_inodes>
	bh = start_buffer;      				// bh指向缓冲开始处。
   101ad:	8b 83 00 14 00 00    	mov    0x1400(%ebx),%eax
   101b3:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   101b7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   101be:	00 
   101bf:	eb 36                	jmp    101f7 <sys_sync+0x5e>
		wait_on_buffer(bh);             	// 等待缓冲区解锁（如果已上锁的话）。
   101c1:	83 ec 0c             	sub    $0xc,%esp
   101c4:	ff 74 24 14          	pushl  0x14(%esp)
   101c8:	e8 94 ff ff ff       	call   10161 <wait_on_buffer>
   101cd:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dirt)
   101d0:	8b 44 24 08          	mov    0x8(%esp),%eax
   101d4:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   101d8:	84 c0                	test   %al,%al
   101da:	74 11                	je     101ed <sys_sync+0x54>
			ll_rw_block(WRITE, bh);  		// 产生写设备块请求。
   101dc:	83 ec 08             	sub    $0x8,%esp
   101df:	ff 74 24 10          	pushl  0x10(%esp)
   101e3:	6a 01                	push   $0x1
   101e5:	e8 85 82 00 00       	call   1846f <ll_rw_block>
   101ea:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   101ed:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   101f2:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
   101f7:	8b 83 40 41 00 00    	mov    0x4140(%ebx),%eax
   101fd:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   10201:	7c be                	jl     101c1 <sys_sync+0x28>
	}
	return 0;
   10203:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10208:	83 c4 18             	add    $0x18,%esp
   1020b:	5b                   	pop    %ebx
   1020c:	c3                   	ret    

0001020d <sync_dev>:

// 对指定设备进行高速缓冲数据与设备上数据的同步操作。
// 该函数首先搜索高速缓冲区中所有缓冲块。对于指定设备dev的缓冲块，若其数据已被修改过就写入盘中（同步操作）。然后
// 把内存中i节点数据写入高速缓冲中。之后再指定设备dev执行一次与上述相同的写盘操作。
int sync_dev(int dev)
{
   1020d:	53                   	push   %ebx
   1020e:	83 ec 18             	sub    $0x18,%esp
   10211:	e8 e4 6a ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10216:	81 c3 ea 1d 02 00    	add    $0x21dea,%ebx

	// 首先对参数指定的设备执行数据同步操作，让设备上的数据与高速缓冲区中的数据同步。方法是扫描高速缓冲区中所有缓冲块，
	// 对指定设备dev的缓冲块，先检测其是否已被上锁，若已被锁就睡眠等待其解锁。然后再判断一次该缓冲块是否还是指定设备的
	// 缓冲块并且已修改过（b_dirt标志置位），若是就对其执行写盘操作。因为在我们睡眠期间该缓冲块有可能已被释放或者被挪
	// 作它用，所以在继续执行前需要再次判断一下该缓冲块是否还是指定设备的缓冲块。
	bh = start_buffer;                      		// bf指向缓冲区开始处。
   1021c:	8b 83 00 14 00 00    	mov    0x1400(%ebx),%eax
   10222:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   10226:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1022d:	00 
   1022e:	eb 5b                	jmp    1028b <sync_dev+0x7e>
		if (bh->b_dev != dev)           			// 不是设备dev的缓冲块则继续。
   10230:	8b 44 24 08          	mov    0x8(%esp),%eax
   10234:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   10238:	0f b7 c0             	movzwl %ax,%eax
   1023b:	39 44 24 20          	cmp    %eax,0x20(%esp)
   1023f:	75 3f                	jne    10280 <sync_dev+0x73>
			continue;
		wait_on_buffer(bh);             			// 等待缓冲区解锁（如果已上锁的话）。
   10241:	83 ec 0c             	sub    $0xc,%esp
   10244:	ff 74 24 14          	pushl  0x14(%esp)
   10248:	e8 14 ff ff ff       	call   10161 <wait_on_buffer>
   1024d:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_dirt)
   10250:	8b 44 24 08          	mov    0x8(%esp),%eax
   10254:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   10258:	0f b7 c0             	movzwl %ax,%eax
   1025b:	39 44 24 20          	cmp    %eax,0x20(%esp)
   1025f:	75 20                	jne    10281 <sync_dev+0x74>
   10261:	8b 44 24 08          	mov    0x8(%esp),%eax
   10265:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   10269:	84 c0                	test   %al,%al
   1026b:	74 14                	je     10281 <sync_dev+0x74>
			ll_rw_block(WRITE, bh);
   1026d:	83 ec 08             	sub    $0x8,%esp
   10270:	ff 74 24 10          	pushl  0x10(%esp)
   10274:	6a 01                	push   $0x1
   10276:	e8 f4 81 00 00       	call   1846f <ll_rw_block>
   1027b:	83 c4 10             	add    $0x10,%esp
   1027e:	eb 01                	jmp    10281 <sync_dev+0x74>
			continue;
   10280:	90                   	nop
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   10281:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   10286:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
   1028b:	8b 83 40 41 00 00    	mov    0x4140(%ebx),%eax
   10291:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   10295:	7c 99                	jl     10230 <sync_dev+0x23>
	}
	// 再将i节点数据写入高速缓冲。让i节点表inode_table中的inode与缓冲中的信息同步。
	sync_inodes();
   10297:	e8 fb f0 ff ff       	call   f397 <sync_inodes>
	// 然后在高速缓冲中的数据更新之后，再把它们与设备中的数据同步。这里采用两遍同步操作是为了提高内核执行效率。第一遍缓
	// 冲区同步操作可以让内核中许多“脏块”变干净，使得i节点的同步操作能够高效执行。本次缓冲区同步操作则把那些由于i节点
	// 同步操作而又变脏的缓冲块与设备中数据同步。
	bh = start_buffer;
   1029c:	8b 83 00 14 00 00    	mov    0x1400(%ebx),%eax
   102a2:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   102a6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   102ad:	00 
   102ae:	eb 5b                	jmp    1030b <sync_dev+0xfe>
		if (bh->b_dev != dev)
   102b0:	8b 44 24 08          	mov    0x8(%esp),%eax
   102b4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   102b8:	0f b7 c0             	movzwl %ax,%eax
   102bb:	39 44 24 20          	cmp    %eax,0x20(%esp)
   102bf:	75 3f                	jne    10300 <sync_dev+0xf3>
			continue;
		wait_on_buffer(bh);
   102c1:	83 ec 0c             	sub    $0xc,%esp
   102c4:	ff 74 24 14          	pushl  0x14(%esp)
   102c8:	e8 94 fe ff ff       	call   10161 <wait_on_buffer>
   102cd:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_dirt)
   102d0:	8b 44 24 08          	mov    0x8(%esp),%eax
   102d4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   102d8:	0f b7 c0             	movzwl %ax,%eax
   102db:	39 44 24 20          	cmp    %eax,0x20(%esp)
   102df:	75 20                	jne    10301 <sync_dev+0xf4>
   102e1:	8b 44 24 08          	mov    0x8(%esp),%eax
   102e5:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   102e9:	84 c0                	test   %al,%al
   102eb:	74 14                	je     10301 <sync_dev+0xf4>
			ll_rw_block(WRITE, bh);
   102ed:	83 ec 08             	sub    $0x8,%esp
   102f0:	ff 74 24 10          	pushl  0x10(%esp)
   102f4:	6a 01                	push   $0x1
   102f6:	e8 74 81 00 00       	call   1846f <ll_rw_block>
   102fb:	83 c4 10             	add    $0x10,%esp
   102fe:	eb 01                	jmp    10301 <sync_dev+0xf4>
			continue;
   10300:	90                   	nop
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   10301:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   10306:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
   1030b:	8b 83 40 41 00 00    	mov    0x4140(%ebx),%eax
   10311:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   10315:	7c 99                	jl     102b0 <sync_dev+0xa3>
	}
	return 0;
   10317:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1031c:	83 c4 18             	add    $0x18,%esp
   1031f:	5b                   	pop    %ebx
   10320:	c3                   	ret    

00010321 <invalidate_buffers>:

// 使指定设备在高速缓冲区中的数据无效。
// 扫描高速缓冲中所有的缓冲块。对指定设备的缓冲块复位其有效（更新）标志和修改标志。
void invalidate_buffers(int dev)
{
   10321:	53                   	push   %ebx
   10322:	83 ec 18             	sub    $0x18,%esp
   10325:	e8 d0 69 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1032a:	81 c3 d6 1c 02 00    	add    $0x21cd6,%ebx
	int i;
	struct buffer_head * bh;

	bh = start_buffer;
   10330:	8b 83 00 14 00 00    	mov    0x1400(%ebx),%eax
   10336:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   1033a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   10341:	00 
   10342:	eb 55                	jmp    10399 <invalidate_buffers+0x78>
		if (bh->b_dev != dev)           // 如果不是指定设备的缓冲块，则继续扫描下一块。
   10344:	8b 44 24 08          	mov    0x8(%esp),%eax
   10348:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   1034c:	0f b7 c0             	movzwl %ax,%eax
   1034f:	39 44 24 20          	cmp    %eax,0x20(%esp)
   10353:	75 39                	jne    1038e <invalidate_buffers+0x6d>
			continue;
		wait_on_buffer(bh);             // 等待该缓冲区解锁（如果已被上锁）。
   10355:	83 ec 0c             	sub    $0xc,%esp
   10358:	ff 74 24 14          	pushl  0x14(%esp)
   1035c:	e8 00 fe ff ff       	call   10161 <wait_on_buffer>
   10361:	83 c4 10             	add    $0x10,%esp
		// 由于进程执行过睡眠等待，所以需要再判断一下缓冲区是否是指定设备的。
		if (bh->b_dev == dev)
   10364:	8b 44 24 08          	mov    0x8(%esp),%eax
   10368:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   1036c:	0f b7 c0             	movzwl %ax,%eax
   1036f:	39 44 24 20          	cmp    %eax,0x20(%esp)
   10373:	75 1a                	jne    1038f <invalidate_buffers+0x6e>
			bh->b_uptodate = bh->b_dirt = 0;
   10375:	8b 44 24 08          	mov    0x8(%esp),%eax
   10379:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
   1037d:	8b 44 24 08          	mov    0x8(%esp),%eax
   10381:	0f b6 50 0b          	movzbl 0xb(%eax),%edx
   10385:	8b 44 24 08          	mov    0x8(%esp),%eax
   10389:	88 50 0a             	mov    %dl,0xa(%eax)
   1038c:	eb 01                	jmp    1038f <invalidate_buffers+0x6e>
			continue;
   1038e:	90                   	nop
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
   1038f:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   10394:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
   10399:	8b 83 40 41 00 00    	mov    0x4140(%ebx),%eax
   1039f:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   103a3:	7c 9f                	jl     10344 <invalidate_buffers+0x23>
	}
}
   103a5:	90                   	nop
   103a6:	83 c4 18             	add    $0x18,%esp
   103a9:	5b                   	pop    %ebx
   103aa:	c3                   	ret    

000103ab <check_disk_change>:
 * 注意！尽管目前该子程序仅用于软盘，以后任何可移动介质的块设备都有将使用该程序，mount/open操作不需要知道
 * 是软盘还是其他什么特殊介质。
 */
// 检查磁盘是否更换，如果已更换就使用对应调整缓冲区无效。
void check_disk_change(int dev)
{
   103ab:	53                   	push   %ebx
   103ac:	83 ec 18             	sub    $0x18,%esp
   103af:	e8 46 69 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   103b4:	81 c3 4c 1c 02 00    	add    $0x21c4c,%ebx
	int i;

	// 首先检测一下是不是软盘设备。因为现在仅支持软盘可移动介质。如果不是则退出。然后测试软盘是否已更换，如果没有
	// 则退出。floppy_chang()在blk_drv/floppy.c。
	if (MAJOR(dev) != 2)
   103ba:	8b 44 24 20          	mov    0x20(%esp),%eax
   103be:	c1 e8 08             	shr    $0x8,%eax
   103c1:	83 f8 02             	cmp    $0x2,%eax
   103c4:	0f 85 8f 00 00 00    	jne    10459 <check_disk_change+0xae>
		return;
	if (!floppy_change(dev & 0x03))
   103ca:	8b 44 24 20          	mov    0x20(%esp),%eax
   103ce:	83 e0 03             	and    $0x3,%eax
   103d1:	83 ec 0c             	sub    $0xc,%esp
   103d4:	50                   	push   %eax
   103d5:	e8 07 83 00 00       	call   186e1 <floppy_change>
   103da:	83 c4 10             	add    $0x10,%esp
   103dd:	85 c0                	test   %eax,%eax
   103df:	74 7b                	je     1045c <check_disk_change+0xb1>
		return;
	// 软盘已更换，所以释放对应设备的i节点位图和逻辑位图所占的高速缓冲区；并使该设备的i节点和数据块信息所占据的高速缓冲
	// 块无效。
	for (i = 0 ; i < NR_SUPER ; i++)
   103e1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   103e8:	00 
   103e9:	eb 47                	jmp    10432 <check_disk_change+0x87>
		if (super_block[i].s_dev == dev)
   103eb:	c7 c2 a0 5c 04 00    	mov    $0x45ca0,%edx
   103f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   103f5:	6b c0 6c             	imul   $0x6c,%eax,%eax
   103f8:	01 d0                	add    %edx,%eax
   103fa:	83 c0 54             	add    $0x54,%eax
   103fd:	0f b7 00             	movzwl (%eax),%eax
   10400:	0f b7 c0             	movzwl %ax,%eax
   10403:	39 44 24 20          	cmp    %eax,0x20(%esp)
   10407:	75 24                	jne    1042d <check_disk_change+0x82>
			put_super(super_block[i].s_dev);
   10409:	c7 c2 a0 5c 04 00    	mov    $0x45ca0,%edx
   1040f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10413:	6b c0 6c             	imul   $0x6c,%eax,%eax
   10416:	01 d0                	add    %edx,%eax
   10418:	83 c0 54             	add    $0x54,%eax
   1041b:	0f b7 00             	movzwl (%eax),%eax
   1041e:	0f b7 c0             	movzwl %ax,%eax
   10421:	83 ec 0c             	sub    $0xc,%esp
   10424:	50                   	push   %eax
   10425:	e8 09 0b 00 00       	call   10f33 <put_super>
   1042a:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_SUPER ; i++)
   1042d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   10432:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
   10437:	7e b2                	jle    103eb <check_disk_change+0x40>
	invalidate_inodes(dev);         // 释放设备dev在内存i节点表中的所有i节点
   10439:	83 ec 0c             	sub    $0xc,%esp
   1043c:	ff 74 24 2c          	pushl  0x2c(%esp)
   10440:	e8 c7 ee ff ff       	call   f30c <invalidate_inodes>
   10445:	83 c4 10             	add    $0x10,%esp
	invalidate_buffers(dev);        //
   10448:	83 ec 0c             	sub    $0xc,%esp
   1044b:	ff 74 24 2c          	pushl  0x2c(%esp)
   1044f:	e8 cd fe ff ff       	call   10321 <invalidate_buffers>
   10454:	83 c4 10             	add    $0x10,%esp
   10457:	eb 04                	jmp    1045d <check_disk_change+0xb2>
		return;
   10459:	90                   	nop
   1045a:	eb 01                	jmp    1045d <check_disk_change+0xb2>
		return;
   1045c:	90                   	nop
}
   1045d:	83 c4 18             	add    $0x18,%esp
   10460:	5b                   	pop    %ebx
   10461:	c3                   	ret    

00010462 <remove_from_queues>:
#define hash(dev, block) hash_table[_hashfn(dev, block)]

// 从hash队列和空闲缓冲队列中移走缓冲块.
// hash队列是双向链表结构,空闲缓冲块队列是双向循环链表结构.
static inline void remove_from_queues(struct buffer_head * bh)
{
   10462:	53                   	push   %ebx
   10463:	83 ec 08             	sub    $0x8,%esp
   10466:	e8 8f 68 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1046b:	81 c3 95 1b 02 00    	add    $0x21b95,%ebx
	/* remove from hash-queue */
	/* 从hash队列中移除缓冲块 */
	if (bh->b_next)
   10471:	8b 44 24 10          	mov    0x10(%esp),%eax
   10475:	8b 40 18             	mov    0x18(%eax),%eax
   10478:	85 c0                	test   %eax,%eax
   1047a:	74 11                	je     1048d <remove_from_queues+0x2b>
		bh->b_next->b_prev = bh->b_prev;
   1047c:	8b 44 24 10          	mov    0x10(%esp),%eax
   10480:	8b 40 18             	mov    0x18(%eax),%eax
   10483:	8b 54 24 10          	mov    0x10(%esp),%edx
   10487:	8b 52 14             	mov    0x14(%edx),%edx
   1048a:	89 50 14             	mov    %edx,0x14(%eax)
	if (bh->b_prev)
   1048d:	8b 44 24 10          	mov    0x10(%esp),%eax
   10491:	8b 40 14             	mov    0x14(%eax),%eax
   10494:	85 c0                	test   %eax,%eax
   10496:	74 11                	je     104a9 <remove_from_queues+0x47>
		bh->b_prev->b_next = bh->b_next;
   10498:	8b 44 24 10          	mov    0x10(%esp),%eax
   1049c:	8b 40 14             	mov    0x14(%eax),%eax
   1049f:	8b 54 24 10          	mov    0x10(%esp),%edx
   104a3:	8b 52 18             	mov    0x18(%edx),%edx
   104a6:	89 50 18             	mov    %edx,0x18(%eax)
	// 如果该缓冲我是该队列的头一个块,则让hash表的对应项指向本队列中的下一个缓冲区.
	if (hash(bh->b_dev, bh->b_blocknr) == bh)
   104a9:	8b 44 24 10          	mov    0x10(%esp),%eax
   104ad:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   104b1:	0f b7 d0             	movzwl %ax,%edx
   104b4:	8b 44 24 10          	mov    0x10(%esp),%eax
   104b8:	8b 40 04             	mov    0x4(%eax),%eax
   104bb:	89 d1                	mov    %edx,%ecx
   104bd:	31 c1                	xor    %eax,%ecx
   104bf:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
   104c4:	89 c8                	mov    %ecx,%eax
   104c6:	f7 e2                	mul    %edx
   104c8:	89 d0                	mov    %edx,%eax
   104ca:	c1 e8 08             	shr    $0x8,%eax
   104cd:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
   104d3:	29 c1                	sub    %eax,%ecx
   104d5:	89 c8                	mov    %ecx,%eax
   104d7:	c7 c2 c0 57 04 00    	mov    $0x457c0,%edx
   104dd:	8b 04 82             	mov    (%edx,%eax,4),%eax
   104e0:	39 44 24 10          	cmp    %eax,0x10(%esp)
   104e4:	75 3e                	jne    10524 <remove_from_queues+0xc2>
		hash(bh->b_dev, bh->b_blocknr) = bh->b_next;
   104e6:	8b 44 24 10          	mov    0x10(%esp),%eax
   104ea:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   104ee:	0f b7 d0             	movzwl %ax,%edx
   104f1:	8b 44 24 10          	mov    0x10(%esp),%eax
   104f5:	8b 40 04             	mov    0x4(%eax),%eax
   104f8:	89 d1                	mov    %edx,%ecx
   104fa:	31 c1                	xor    %eax,%ecx
   104fc:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
   10501:	89 c8                	mov    %ecx,%eax
   10503:	f7 e2                	mul    %edx
   10505:	89 d0                	mov    %edx,%eax
   10507:	c1 e8 08             	shr    $0x8,%eax
   1050a:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
   10510:	29 c1                	sub    %eax,%ecx
   10512:	89 c8                	mov    %ecx,%eax
   10514:	8b 54 24 10          	mov    0x10(%esp),%edx
   10518:	8b 4a 18             	mov    0x18(%edx),%ecx
   1051b:	c7 c2 c0 57 04 00    	mov    $0x457c0,%edx
   10521:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
	/* remove from free list */
	/* 从空闲缓冲块表中移除缓冲块 */
	if (!(bh->b_prev_free) || !(bh->b_next_free))
   10524:	8b 44 24 10          	mov    0x10(%esp),%eax
   10528:	8b 40 1c             	mov    0x1c(%eax),%eax
   1052b:	85 c0                	test   %eax,%eax
   1052d:	74 0b                	je     1053a <remove_from_queues+0xd8>
   1052f:	8b 44 24 10          	mov    0x10(%esp),%eax
   10533:	8b 40 20             	mov    0x20(%eax),%eax
   10536:	85 c0                	test   %eax,%eax
   10538:	75 12                	jne    1054c <remove_from_queues+0xea>
		panic("Free block list corrupted");
   1053a:	83 ec 0c             	sub    $0xc,%esp
   1053d:	8d 83 dd 4f ff ff    	lea    -0xb023(%ebx),%eax
   10543:	50                   	push   %eax
   10544:	e8 95 8d ff ff       	call   92de <panic>
   10549:	83 c4 10             	add    $0x10,%esp
	bh->b_prev_free->b_next_free = bh->b_next_free;
   1054c:	8b 44 24 10          	mov    0x10(%esp),%eax
   10550:	8b 40 1c             	mov    0x1c(%eax),%eax
   10553:	8b 54 24 10          	mov    0x10(%esp),%edx
   10557:	8b 52 20             	mov    0x20(%edx),%edx
   1055a:	89 50 20             	mov    %edx,0x20(%eax)
	bh->b_next_free->b_prev_free = bh->b_prev_free;
   1055d:	8b 44 24 10          	mov    0x10(%esp),%eax
   10561:	8b 40 20             	mov    0x20(%eax),%eax
   10564:	8b 54 24 10          	mov    0x10(%esp),%edx
   10568:	8b 52 1c             	mov    0x1c(%edx),%edx
   1056b:	89 50 1c             	mov    %edx,0x1c(%eax)
	// 如果空闲链表头指向本缓冲区,则让其指向下一缓冲区.
	if (free_list == bh)
   1056e:	8b 83 44 41 00 00    	mov    0x4144(%ebx),%eax
   10574:	39 44 24 10          	cmp    %eax,0x10(%esp)
   10578:	75 0d                	jne    10587 <remove_from_queues+0x125>
		free_list = bh->b_next_free;
   1057a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1057e:	8b 40 20             	mov    0x20(%eax),%eax
   10581:	89 83 44 41 00 00    	mov    %eax,0x4144(%ebx)
}
   10587:	90                   	nop
   10588:	83 c4 08             	add    $0x8,%esp
   1058b:	5b                   	pop    %ebx
   1058c:	c3                   	ret    

0001058d <insert_into_queues>:

// 将缓冲块插入空闲链表尾部,同时放入hash队列中.
static inline void insert_into_queues(struct buffer_head * bh)
{
   1058d:	53                   	push   %ebx
   1058e:	e8 a4 c4 ff ff       	call   ca37 <__x86.get_pc_thunk.cx>
   10593:	81 c1 6d 1a 02 00    	add    $0x21a6d,%ecx
	/* put at end of free list */
	/* 放在空闲链表末尾处 */
	bh->b_next_free = free_list;
   10599:	8b 91 44 41 00 00    	mov    0x4144(%ecx),%edx
   1059f:	8b 44 24 08          	mov    0x8(%esp),%eax
   105a3:	89 50 20             	mov    %edx,0x20(%eax)
	bh->b_prev_free = free_list->b_prev_free;
   105a6:	8b 81 44 41 00 00    	mov    0x4144(%ecx),%eax
   105ac:	8b 50 1c             	mov    0x1c(%eax),%edx
   105af:	8b 44 24 08          	mov    0x8(%esp),%eax
   105b3:	89 50 1c             	mov    %edx,0x1c(%eax)
	free_list->b_prev_free->b_next_free = bh;
   105b6:	8b 81 44 41 00 00    	mov    0x4144(%ecx),%eax
   105bc:	8b 40 1c             	mov    0x1c(%eax),%eax
   105bf:	8b 54 24 08          	mov    0x8(%esp),%edx
   105c3:	89 50 20             	mov    %edx,0x20(%eax)
	free_list->b_prev_free = bh;
   105c6:	8b 81 44 41 00 00    	mov    0x4144(%ecx),%eax
   105cc:	8b 54 24 08          	mov    0x8(%esp),%edx
   105d0:	89 50 1c             	mov    %edx,0x1c(%eax)
	/* put the buffer in new hash-queue if it has a device */
	/* 如果该缓冲块对应一个设备,则将其插入新hash队列中 */
	bh->b_prev = NULL;
   105d3:	8b 44 24 08          	mov    0x8(%esp),%eax
   105d7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	bh->b_next = NULL;
   105de:	8b 44 24 08          	mov    0x8(%esp),%eax
   105e2:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	if (!bh->b_dev)
   105e9:	8b 44 24 08          	mov    0x8(%esp),%eax
   105ed:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   105f1:	66 85 c0             	test   %ax,%ax
   105f4:	0f 84 94 00 00 00    	je     1068e <insert_into_queues+0x101>
		return;
	bh->b_next = hash(bh->b_dev, bh->b_blocknr);
   105fa:	8b 44 24 08          	mov    0x8(%esp),%eax
   105fe:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   10602:	0f b7 d0             	movzwl %ax,%edx
   10605:	8b 44 24 08          	mov    0x8(%esp),%eax
   10609:	8b 40 04             	mov    0x4(%eax),%eax
   1060c:	89 d3                	mov    %edx,%ebx
   1060e:	31 c3                	xor    %eax,%ebx
   10610:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
   10615:	89 d8                	mov    %ebx,%eax
   10617:	f7 e2                	mul    %edx
   10619:	89 d0                	mov    %edx,%eax
   1061b:	c1 e8 08             	shr    $0x8,%eax
   1061e:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
   10624:	29 c3                	sub    %eax,%ebx
   10626:	89 d8                	mov    %ebx,%eax
   10628:	c7 c2 c0 57 04 00    	mov    $0x457c0,%edx
   1062e:	8b 14 82             	mov    (%edx,%eax,4),%edx
   10631:	8b 44 24 08          	mov    0x8(%esp),%eax
   10635:	89 50 18             	mov    %edx,0x18(%eax)
	hash(bh->b_dev, bh->b_blocknr) = bh;
   10638:	8b 44 24 08          	mov    0x8(%esp),%eax
   1063c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   10640:	0f b7 d0             	movzwl %ax,%edx
   10643:	8b 44 24 08          	mov    0x8(%esp),%eax
   10647:	8b 40 04             	mov    0x4(%eax),%eax
   1064a:	89 d3                	mov    %edx,%ebx
   1064c:	31 c3                	xor    %eax,%ebx
   1064e:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
   10653:	89 d8                	mov    %ebx,%eax
   10655:	f7 e2                	mul    %edx
   10657:	89 d0                	mov    %edx,%eax
   10659:	c1 e8 08             	shr    $0x8,%eax
   1065c:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
   10662:	29 c3                	sub    %eax,%ebx
   10664:	89 d8                	mov    %ebx,%eax
   10666:	c7 c2 c0 57 04 00    	mov    $0x457c0,%edx
   1066c:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   10670:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
	// 请注意当hash表某项第1次插入项时,hash()计算值肯定为NULL,因此此时hash(bh->b_dev,bh->b_blocknr)得到的bh->b_next肯定是NULL,
	// 所以bh->b_next->b_prev = bh应该在bh->b_next不为NULL时才能给b_pev赋bh值.即bh->b_next->b_prev = bh前应该增加判断"
	// if(bh->b_next)".该错误到0.96版后才被纠正.
	if(bh->b_next)
   10673:	8b 44 24 08          	mov    0x8(%esp),%eax
   10677:	8b 40 18             	mov    0x18(%eax),%eax
   1067a:	85 c0                	test   %eax,%eax
   1067c:	74 11                	je     1068f <insert_into_queues+0x102>
		bh->b_next->b_prev = bh;			// 此句前应添加"if(bh->b_next)"判断.
   1067e:	8b 44 24 08          	mov    0x8(%esp),%eax
   10682:	8b 40 18             	mov    0x18(%eax),%eax
   10685:	8b 54 24 08          	mov    0x8(%esp),%edx
   10689:	89 50 14             	mov    %edx,0x14(%eax)
   1068c:	eb 01                	jmp    1068f <insert_into_queues+0x102>
		return;
   1068e:	90                   	nop
}
   1068f:	5b                   	pop    %ebx
   10690:	c3                   	ret    

00010691 <find_buffer>:

// 利用hash表在高速缓冲中寻找给定设备和指定块号的缓冲区块.
// 如果找到则返回缓冲区块的指针,否则返回NULL.
static struct buffer_head * find_buffer(int dev, int block)
{
   10691:	53                   	push   %ebx
   10692:	83 ec 10             	sub    $0x10,%esp
   10695:	e8 9d c3 ff ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1069a:	81 c1 66 19 02 00    	add    $0x21966,%ecx
	struct buffer_head * tmp;

	// 搜索hash表,寻找指定设备与和块号的缓冲块.
	for (tmp = hash(dev, block) ; tmp != NULL ; tmp = tmp->b_next)
   106a0:	8b 44 24 18          	mov    0x18(%esp),%eax
   106a4:	33 44 24 1c          	xor    0x1c(%esp),%eax
   106a8:	89 c3                	mov    %eax,%ebx
   106aa:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
   106af:	89 d8                	mov    %ebx,%eax
   106b1:	f7 e2                	mul    %edx
   106b3:	89 d0                	mov    %edx,%eax
   106b5:	c1 e8 08             	shr    $0x8,%eax
   106b8:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
   106be:	29 c3                	sub    %eax,%ebx
   106c0:	89 d8                	mov    %ebx,%eax
   106c2:	c7 c2 c0 57 04 00    	mov    $0x457c0,%edx
   106c8:	8b 04 82             	mov    (%edx,%eax,4),%eax
   106cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
   106cf:	eb 31                	jmp    10702 <find_buffer+0x71>
		if (tmp->b_dev == dev && tmp->b_blocknr == block)
   106d1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   106d5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   106d9:	0f b7 c0             	movzwl %ax,%eax
   106dc:	39 44 24 18          	cmp    %eax,0x18(%esp)
   106e0:	75 15                	jne    106f7 <find_buffer+0x66>
   106e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   106e6:	8b 50 04             	mov    0x4(%eax),%edx
   106e9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   106ed:	39 c2                	cmp    %eax,%edx
   106ef:	75 06                	jne    106f7 <find_buffer+0x66>
			return tmp;
   106f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   106f5:	eb 17                	jmp    1070e <find_buffer+0x7d>
	for (tmp = hash(dev, block) ; tmp != NULL ; tmp = tmp->b_next)
   106f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   106fb:	8b 40 18             	mov    0x18(%eax),%eax
   106fe:	89 44 24 0c          	mov    %eax,0xc(%esp)
   10702:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   10707:	75 c8                	jne    106d1 <find_buffer+0x40>
	return NULL;
   10709:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1070e:	83 c4 10             	add    $0x10,%esp
   10711:	5b                   	pop    %ebx
   10712:	c3                   	ret    

00010713 <get_hash_table>:
 * 代码为什么会是这样子的?我听见你问......原因是竞争条件.由于我们没有对缓冲块上锁(除非我们正在读取它们的数据),那么当我们(进程)睡眠时缓冲块可能
 * 发生一些问题(例如一个读错误将导致该缓冲块出错).目前这种情况实际上是不会发生的,但处理的代码已经准备好了.
 */
// 利用hash表在高速缓冲区中寻找指定的缓冲块.若找到则对该缓冲块上锁并返回块头指针.
struct buffer_head * get_hash_table(int dev, int block)
{
   10713:	83 ec 1c             	sub    $0x1c,%esp
   10716:	e8 d7 65 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1071b:	05 e5 18 02 00       	add    $0x218e5,%eax
	struct buffer_head * bh;

	for (;;) {
		// 在高速缓冲中寻找给定设备和指定块的缓冲区块,如果没有找到则返回NULL,退出.
		if (!(bh = find_buffer(dev, block)))
   10720:	ff 74 24 24          	pushl  0x24(%esp)
   10724:	ff 74 24 24          	pushl  0x24(%esp)
   10728:	e8 64 ff ff ff       	call   10691 <find_buffer>
   1072d:	83 c4 08             	add    $0x8,%esp
   10730:	89 44 24 0c          	mov    %eax,0xc(%esp)
   10734:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   10739:	75 07                	jne    10742 <get_hash_table+0x2f>
			return NULL;
   1073b:	b8 00 00 00 00       	mov    $0x0,%eax
   10740:	eb 5b                	jmp    1079d <get_hash_table+0x8a>
		// 对该缓冲块增加引用计数,并等待该缓冲块解锁(如果已被上锁).由于经过了睡眠状态,因此有必要再验证该缓冲块的正确性,并返回缓冲块头指针.
		bh->b_count++;
   10742:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10746:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   1074a:	8d 50 01             	lea    0x1(%eax),%edx
   1074d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10751:	88 50 0c             	mov    %dl,0xc(%eax)
		wait_on_buffer(bh);
   10754:	83 ec 0c             	sub    $0xc,%esp
   10757:	ff 74 24 18          	pushl  0x18(%esp)
   1075b:	e8 01 fa ff ff       	call   10161 <wait_on_buffer>
   10760:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_blocknr == block)
   10763:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10767:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   1076b:	0f b7 c0             	movzwl %ax,%eax
   1076e:	39 44 24 20          	cmp    %eax,0x20(%esp)
   10772:	75 15                	jne    10789 <get_hash_table+0x76>
   10774:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10778:	8b 50 04             	mov    0x4(%eax),%edx
   1077b:	8b 44 24 24          	mov    0x24(%esp),%eax
   1077f:	39 c2                	cmp    %eax,%edx
   10781:	75 06                	jne    10789 <get_hash_table+0x76>
			return bh;
   10783:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10787:	eb 14                	jmp    1079d <get_hash_table+0x8a>
		// 如果在睡眠时该缓冲块所属的设备号或块号发生的改变,则撤消对它的用计数.重新寻找.
		bh->b_count--;
   10789:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1078d:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   10791:	8d 50 ff             	lea    -0x1(%eax),%edx
   10794:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10798:	88 50 0c             	mov    %dl,0xc(%eax)
		if (!(bh = find_buffer(dev, block)))
   1079b:	eb 83                	jmp    10720 <get_hash_table+0xd>
	}
}
   1079d:	83 c4 1c             	add    $0x1c,%esp
   107a0:	c3                   	ret    

000107a1 <getblk>:
#define BADNESS(bh) (((bh)->b_dirt << 1) + (bh)->b_lock)
// 取高速缓冲中指定的缓冲块.
// 检查指定(设备号和块号)的缓冲区是否已经在高速缓冲中.如果指定块已经在高速缓冲中,则返回对应缓冲区头指针退出;如果不在,就需要在高速中
// 中设置一个对应设备号和块号的新项.返回相应缓冲区头指针.
struct buffer_head * getblk(int dev, int block)
{
   107a1:	53                   	push   %ebx
   107a2:	83 ec 18             	sub    $0x18,%esp
   107a5:	e8 50 65 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   107aa:	81 c3 56 18 02 00    	add    $0x21856,%ebx
	struct buffer_head * tmp, * bh;

repeat:
	if (bh = get_hash_table(dev, block))
   107b0:	83 ec 08             	sub    $0x8,%esp
   107b3:	ff 74 24 2c          	pushl  0x2c(%esp)
   107b7:	ff 74 24 2c          	pushl  0x2c(%esp)
   107bb:	e8 53 ff ff ff       	call   10713 <get_hash_table>
   107c0:	83 c4 10             	add    $0x10,%esp
   107c3:	89 44 24 08          	mov    %eax,0x8(%esp)
   107c7:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   107cc:	74 09                	je     107d7 <getblk+0x36>
		return bh;
   107ce:	8b 44 24 08          	mov    0x8(%esp),%eax
   107d2:	e9 8f 01 00 00       	jmp    10966 <getblk+0x1c5>
	// 扫描空闲数据块链表,寻找空闲缓冲区.
	// 首先让tmp指向空闲链表的第一个空闲缓冲区头.
	tmp = free_list;
   107d7:	8b 83 44 41 00 00    	mov    0x4144(%ebx),%eax
   107dd:	89 44 24 0c          	mov    %eax,0xc(%esp)
	do {
		// 如果该缓冲区正在被使用(引用计数不等于0),则继续扫描下一项.对于b_count=0的块,即高速缓冲中当前没有引用的块不一定就是干净的(b_dirt=0)
		// 或没有锁定的(b_lock=0).因此,我们还是需要继续下面的判断和选择.例如当一个任务改写过一块内容后就释放了,于是该块b_count=0,但b_lock不等于0;
		// 当一个任务执行breada()预读几个块时,只要ll_rw_block()命令发出后,它就会递减b_count;但此时实际上硬盘访问操作可能还在进行,因此此时
		// b_lock=1,但b_count=0.
		if (tmp->b_count)
   107e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   107e5:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   107e9:	84 c0                	test   %al,%al
   107eb:	75 6a                	jne    10857 <getblk+0xb6>
			continue;
		// 如果缓冲头指针bh为空,或者tmp所指缓冲头的标志(修改,锁定)权重小于bh头标志的权重,则让bh指向tmp缓冲块头.如果该tmp缓冲块头表明缓冲
		// 块既没有修改也没有锁定标志置位,则说明已为指定设备上的块取得对应的高速缓冲块,则退出循环.否则我们就继续执行本循环,看看能否找到一个BADNESS()
		// 最小的缓冲块.
		if (!bh || BADNESS(tmp) < BADNESS(bh)) {
   107ed:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   107f2:	74 3a                	je     1082e <getblk+0x8d>
   107f4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   107f8:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   107fc:	0f b6 c0             	movzbl %al,%eax
   107ff:	8d 14 00             	lea    (%eax,%eax,1),%edx
   10802:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10806:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1080a:	0f b6 c0             	movzbl %al,%eax
   1080d:	01 c2                	add    %eax,%edx
   1080f:	8b 44 24 08          	mov    0x8(%esp),%eax
   10813:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   10817:	0f b6 c0             	movzbl %al,%eax
   1081a:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
   1081d:	8b 44 24 08          	mov    0x8(%esp),%eax
   10821:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   10825:	0f b6 c0             	movzbl %al,%eax
   10828:	01 c8                	add    %ecx,%eax
   1082a:	39 c2                	cmp    %eax,%edx
   1082c:	7d 2a                	jge    10858 <getblk+0xb7>
			bh = tmp;
   1082e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10832:	89 44 24 08          	mov    %eax,0x8(%esp)
			if (!BADNESS(tmp))
   10836:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1083a:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   1083e:	0f b6 c0             	movzbl %al,%eax
   10841:	8d 14 00             	lea    (%eax,%eax,1),%edx
   10844:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10848:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1084c:	0f b6 c0             	movzbl %al,%eax
   1084f:	01 d0                	add    %edx,%eax
   10851:	85 c0                	test   %eax,%eax
   10853:	74 20                	je     10875 <getblk+0xd4>
   10855:	eb 01                	jmp    10858 <getblk+0xb7>
			continue;
   10857:	90                   	nop
				break;
		}
	/* and repeat until we find something good */	/* 重复操作直到找到适合的缓冲块 */
	} while ((tmp = tmp->b_next_free) != free_list);
   10858:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1085c:	8b 40 20             	mov    0x20(%eax),%eax
   1085f:	89 44 24 0c          	mov    %eax,0xc(%esp)
   10863:	8b 83 44 41 00 00    	mov    0x4144(%ebx),%eax
   10869:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   1086d:	0f 85 6e ff ff ff    	jne    107e1 <getblk+0x40>
   10873:	eb 01                	jmp    10876 <getblk+0xd5>
				break;
   10875:	90                   	nop
	// 如果循环检查发现所有缓冲块都正在被使用(所有缓冲块的状况引用计数者>0)中,则睡眠等待有空闲缓冲区可用.当有空闲缓冲块可用时本各会被明确地唤醒.然后
	// 我们就跳转到函数开始处重新查找空闲缓冲块.
	if (!bh) {
   10876:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1087b:	75 17                	jne    10894 <getblk+0xf3>
		sleep_on(&buffer_wait);
   1087d:	83 ec 0c             	sub    $0xc,%esp
   10880:	8d 83 48 41 00 00    	lea    0x4148(%ebx),%eax
   10886:	50                   	push   %eax
   10887:	e8 f8 69 ff ff       	call   7284 <sleep_on>
   1088c:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   1088f:	e9 1c ff ff ff       	jmp    107b0 <getblk+0xf>
	}
	// 执行到这里,说明我们已经找到了一个比较适合的空闲缓冲块了.于是先等待该缓冲区解锁(如果已被上锁的话).如果在我们睡眠阶段该缓冲区又被其他任务使用的话,
	// 只好重复上述寻找过程.
	wait_on_buffer(bh);
   10894:	83 ec 0c             	sub    $0xc,%esp
   10897:	ff 74 24 14          	pushl  0x14(%esp)
   1089b:	e8 c1 f8 ff ff       	call   10161 <wait_on_buffer>
   108a0:	83 c4 10             	add    $0x10,%esp
	if (bh->b_count)	// 又被占用??
   108a3:	8b 44 24 08          	mov    0x8(%esp),%eax
   108a7:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   108ab:	84 c0                	test   %al,%al
   108ad:	74 3c                	je     108eb <getblk+0x14a>
		goto repeat;
   108af:	e9 fc fe ff ff       	jmp    107b0 <getblk+0xf>
	// 如果该缓冲区已被修改,则将数据写盘,并再次等待缓冲区解锁.同样地,若该缓冲区又被其他任务使用的话,只好再重复上述寻找过程.
	while (bh->b_dirt) {
		sync_dev(bh->b_dev);
   108b4:	8b 44 24 08          	mov    0x8(%esp),%eax
   108b8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   108bc:	0f b7 c0             	movzwl %ax,%eax
   108bf:	83 ec 0c             	sub    $0xc,%esp
   108c2:	50                   	push   %eax
   108c3:	e8 45 f9 ff ff       	call   1020d <sync_dev>
   108c8:	83 c4 10             	add    $0x10,%esp
		wait_on_buffer(bh);
   108cb:	83 ec 0c             	sub    $0xc,%esp
   108ce:	ff 74 24 14          	pushl  0x14(%esp)
   108d2:	e8 8a f8 ff ff       	call   10161 <wait_on_buffer>
   108d7:	83 c4 10             	add    $0x10,%esp
		if (bh->b_count)	// 又被占用??
   108da:	8b 44 24 08          	mov    0x8(%esp),%eax
   108de:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   108e2:	84 c0                	test   %al,%al
   108e4:	74 05                	je     108eb <getblk+0x14a>
			goto repeat;
   108e6:	e9 c5 fe ff ff       	jmp    107b0 <getblk+0xf>
	while (bh->b_dirt) {
   108eb:	8b 44 24 08          	mov    0x8(%esp),%eax
   108ef:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   108f3:	84 c0                	test   %al,%al
   108f5:	75 bd                	jne    108b4 <getblk+0x113>
	}
	/* NOTE!! While we slept waiting for this block, somebody else might */
	/* already have added "this" block to the cache. check it */
	/* 注意!!当进程为了等待该缓冲块而睡眠时,其他进程可能已经将该缓冲块加入进高速缓冲中,所以我们也要对此进行检查. */
	// 在高速缓冲hash表中检查指定设备和块的缓冲块是否乘我们睡眠之即已经被加入进去.如果是的话就再次重复上述寻找过程.
	if (find_buffer(dev, block))
   108f7:	83 ec 08             	sub    $0x8,%esp
   108fa:	ff 74 24 2c          	pushl  0x2c(%esp)
   108fe:	ff 74 24 2c          	pushl  0x2c(%esp)
   10902:	e8 8a fd ff ff       	call   10691 <find_buffer>
   10907:	83 c4 10             	add    $0x10,%esp
   1090a:	85 c0                	test   %eax,%eax
   1090c:	74 05                	je     10913 <getblk+0x172>
		goto repeat;
   1090e:	e9 9d fe ff ff       	jmp    107b0 <getblk+0xf>
	/* OK, FINALLY we know that this buffer is the only one of it's kind, */
	/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
	/* OK,最终我们知道该缓冲块是指定参数的唯一一块,而且目前还没有被占用 */
	/* (b_count=0),也未被上锁(b_lock=0),并且是干净的(未被修改的) */
	// 于是让我们占用此缓冲块.置引用计数为1,复位修改标志和有效(更新)标志.
	bh->b_count = 1;
   10913:	8b 44 24 08          	mov    0x8(%esp),%eax
   10917:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
	bh->b_dirt = 0;
   1091b:	8b 44 24 08          	mov    0x8(%esp),%eax
   1091f:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	bh->b_uptodate = 0;
   10923:	8b 44 24 08          	mov    0x8(%esp),%eax
   10927:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
	// 从hash队列和空闲块链表中移出该缓冲头,让该缓冲区用于指定设备和其上的指定块.然后根据此新设备号和块号重新插入空闲链表和hash队列新位置处.并最终返回缓冲
	// 头指针.
	remove_from_queues(bh);
   1092b:	83 ec 0c             	sub    $0xc,%esp
   1092e:	ff 74 24 14          	pushl  0x14(%esp)
   10932:	e8 2b fb ff ff       	call   10462 <remove_from_queues>
   10937:	83 c4 10             	add    $0x10,%esp
	bh->b_dev = dev;
   1093a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1093e:	89 c2                	mov    %eax,%edx
   10940:	8b 44 24 08          	mov    0x8(%esp),%eax
   10944:	66 89 50 08          	mov    %dx,0x8(%eax)
	bh->b_blocknr = block;
   10948:	8b 54 24 24          	mov    0x24(%esp),%edx
   1094c:	8b 44 24 08          	mov    0x8(%esp),%eax
   10950:	89 50 04             	mov    %edx,0x4(%eax)
	insert_into_queues(bh);
   10953:	83 ec 0c             	sub    $0xc,%esp
   10956:	ff 74 24 14          	pushl  0x14(%esp)
   1095a:	e8 2e fc ff ff       	call   1058d <insert_into_queues>
   1095f:	83 c4 10             	add    $0x10,%esp
	return bh;
   10962:	8b 44 24 08          	mov    0x8(%esp),%eax
}
   10966:	83 c4 18             	add    $0x18,%esp
   10969:	5b                   	pop    %ebx
   1096a:	c3                   	ret    

0001096b <brelse>:

// 释放指定缓冲块.
// 等待该缓冲块解锁.然后引用计数递减1,并明确地唤醒等待空闲缓冲块的进程.
void brelse(struct buffer_head * buf)
{
   1096b:	53                   	push   %ebx
   1096c:	83 ec 08             	sub    $0x8,%esp
   1096f:	e8 86 63 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10974:	81 c3 8c 16 02 00    	add    $0x2168c,%ebx
	if (!buf)						// 如果缓冲头指针无效则返回.
   1097a:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1097f:	74 4b                	je     109cc <brelse+0x61>
		return;
	wait_on_buffer(buf);
   10981:	83 ec 0c             	sub    $0xc,%esp
   10984:	ff 74 24 1c          	pushl  0x1c(%esp)
   10988:	e8 d4 f7 ff ff       	call   10161 <wait_on_buffer>
   1098d:	83 c4 10             	add    $0x10,%esp
	if (!(buf->b_count--))
   10990:	8b 44 24 10          	mov    0x10(%esp),%eax
   10994:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   10998:	8d 50 ff             	lea    -0x1(%eax),%edx
   1099b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1099f:	88 51 0c             	mov    %dl,0xc(%ecx)
   109a2:	84 c0                	test   %al,%al
   109a4:	75 12                	jne    109b8 <brelse+0x4d>
		panic("Trying to free free buffer");
   109a6:	83 ec 0c             	sub    $0xc,%esp
   109a9:	8d 83 f7 4f ff ff    	lea    -0xb009(%ebx),%eax
   109af:	50                   	push   %eax
   109b0:	e8 29 89 ff ff       	call   92de <panic>
   109b5:	83 c4 10             	add    $0x10,%esp
	wake_up(&buffer_wait);
   109b8:	83 ec 0c             	sub    $0xc,%esp
   109bb:	8d 83 48 41 00 00    	lea    0x4148(%ebx),%eax
   109c1:	50                   	push   %eax
   109c2:	e8 e0 68 ff ff       	call   72a7 <wake_up>
   109c7:	83 c4 10             	add    $0x10,%esp
   109ca:	eb 01                	jmp    109cd <brelse+0x62>
		return;
   109cc:	90                   	nop
}
   109cd:	83 c4 08             	add    $0x8,%esp
   109d0:	5b                   	pop    %ebx
   109d1:	c3                   	ret    

000109d2 <bread>:
 */
// 从设备上读取数据块.
// 该函数根据指定的设备号dev和数据块号block,首先在高速缓冲区中申请一块缓冲块.如果该缓冲块中经包含有有效的数据就直接返回该缓冲块指针,否则就从设备中
// 读取指定的数据块到该缓冲块中并返回缓冲块指针.
struct buffer_head * bread(int dev, int block)
{
   109d2:	53                   	push   %ebx
   109d3:	83 ec 18             	sub    $0x18,%esp
   109d6:	e8 1f 63 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   109db:	81 c3 25 16 02 00    	add    $0x21625,%ebx
	struct buffer_head * bh;

	// 从高速缓冲区中申请一块缓冲块.如果返回值是NULL,则表示内核出错,停机.否则我们判断其中是否已有可用数据.
	if (!(bh = getblk(dev, block)))
   109e1:	83 ec 08             	sub    $0x8,%esp
   109e4:	ff 74 24 2c          	pushl  0x2c(%esp)
   109e8:	ff 74 24 2c          	pushl  0x2c(%esp)
   109ec:	e8 b0 fd ff ff       	call   107a1 <getblk>
   109f1:	83 c4 10             	add    $0x10,%esp
   109f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
   109f8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   109fd:	75 12                	jne    10a11 <bread+0x3f>
		panic("bread: getblk returned NULL\n");
   109ff:	83 ec 0c             	sub    $0xc,%esp
   10a02:	8d 83 12 50 ff ff    	lea    -0xafee(%ebx),%eax
   10a08:	50                   	push   %eax
   10a09:	e8 d0 88 ff ff       	call   92de <panic>
   10a0e:	83 c4 10             	add    $0x10,%esp
	// 如果该缓冲块中数据是有效的(已更新的)可以直接使用,则返回.
	if (bh->b_uptodate)
   10a11:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10a15:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   10a19:	84 c0                	test   %al,%al
   10a1b:	74 06                	je     10a23 <bread+0x51>
		return bh;
   10a1d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10a21:	eb 46                	jmp    10a69 <bread+0x97>
	// 否则我们就调用底层块设备读写ll_rw_block()函数,产生读设备块请求.然后等待指定数据块被读入,并等待缓冲区解锁.在睡眠醒来之后,如果该缓冲区已更新,则返回
	// 缓冲区头指针,退出.否则表明读设备操作失败,于是释放该缓冲区,返回NULL,退出.
	ll_rw_block(READ, bh);
   10a23:	83 ec 08             	sub    $0x8,%esp
   10a26:	ff 74 24 14          	pushl  0x14(%esp)
   10a2a:	6a 00                	push   $0x0
   10a2c:	e8 3e 7a 00 00       	call   1846f <ll_rw_block>
   10a31:	83 c4 10             	add    $0x10,%esp
	wait_on_buffer(bh);
   10a34:	83 ec 0c             	sub    $0xc,%esp
   10a37:	ff 74 24 18          	pushl  0x18(%esp)
   10a3b:	e8 21 f7 ff ff       	call   10161 <wait_on_buffer>
   10a40:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
   10a43:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10a47:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   10a4b:	84 c0                	test   %al,%al
   10a4d:	74 06                	je     10a55 <bread+0x83>
		return bh;
   10a4f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10a53:	eb 14                	jmp    10a69 <bread+0x97>
	brelse(bh);
   10a55:	83 ec 0c             	sub    $0xc,%esp
   10a58:	ff 74 24 18          	pushl  0x18(%esp)
   10a5c:	e8 0a ff ff ff       	call   1096b <brelse>
   10a61:	83 c4 10             	add    $0x10,%esp
	return NULL;
   10a64:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10a69:	83 c4 18             	add    $0x18,%esp
   10a6c:	5b                   	pop    %ebx
   10a6d:	c3                   	ret    

00010a6e <bread_page>:
 */
// 读设备上一个页面(4个缓冲块)的内容到指定内存地址处.
// 参数address是保存页面数据的地址;dev是指定的设备号;b[4]是含有4个设备数据块号的数组.
// 该函数仅用于mm/memory.c文件的do_no_page()函数中.
void bread_page(unsigned long address, int dev, int b[4])
{
   10a6e:	57                   	push   %edi
   10a6f:	56                   	push   %esi
   10a70:	53                   	push   %ebx
   10a71:	83 ec 20             	sub    $0x20,%esp
   10a74:	e8 81 62 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10a79:	81 c3 87 15 02 00    	add    $0x21587,%ebx
	int i;

	// 该函数循环执行4次,根据放在数组b[]中的4个块号从设备dev中读取一页内容放到指定内存位置address处.对于参数b[i]给出的
	// 有效块号,函数首先从高速缓冲中取指定设备和块号的的缓冲块.如果缓冲块中数据无效(未更新)则产生读设备请求从设备上读取相
	// 应数据块.对于b[i]无效的块号则不用处理它了.因此本函数其实可以根据指定的b[]中的块号随意读取1-4个数据块.
	for (i = 0 ; i < 4 ; i++)
   10a7f:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   10a86:	00 
   10a87:	e9 89 00 00 00       	jmp    10b15 <bread_page+0xa7>
		if (b[i]) {
   10a8c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10a90:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a97:	8b 44 24 38          	mov    0x38(%esp),%eax
   10a9b:	01 d0                	add    %edx,%eax
   10a9d:	8b 00                	mov    (%eax),%eax
   10a9f:	85 c0                	test   %eax,%eax
   10aa1:	74 61                	je     10b04 <bread_page+0x96>
			// 先给该逻辑块号申请一个缓存块
			if (bh[i] = getblk(dev, b[i]))
   10aa3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10aa7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10aae:	8b 44 24 38          	mov    0x38(%esp),%eax
   10ab2:	01 d0                	add    %edx,%eax
   10ab4:	8b 00                	mov    (%eax),%eax
   10ab6:	83 ec 08             	sub    $0x8,%esp
   10ab9:	50                   	push   %eax
   10aba:	ff 74 24 40          	pushl  0x40(%esp)
   10abe:	e8 de fc ff ff       	call   107a1 <getblk>
   10ac3:	83 c4 10             	add    $0x10,%esp
   10ac6:	89 c2                	mov    %eax,%edx
   10ac8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10acc:	89 54 84 0c          	mov    %edx,0xc(%esp,%eax,4)
   10ad0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10ad4:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10ad8:	85 c0                	test   %eax,%eax
   10ada:	74 34                	je     10b10 <bread_page+0xa2>
				// 如果该缓冲块没有更新,则从块设备中读取出来
				if (!bh[i]->b_uptodate)
   10adc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10ae0:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10ae4:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   10ae8:	84 c0                	test   %al,%al
   10aea:	75 24                	jne    10b10 <bread_page+0xa2>
					ll_rw_block(READ, bh[i]);
   10aec:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10af0:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10af4:	83 ec 08             	sub    $0x8,%esp
   10af7:	50                   	push   %eax
   10af8:	6a 00                	push   $0x0
   10afa:	e8 70 79 00 00       	call   1846f <ll_rw_block>
   10aff:	83 c4 10             	add    $0x10,%esp
   10b02:	eb 0c                	jmp    10b10 <bread_page+0xa2>
		} else
			bh[i] = NULL;
   10b04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10b08:	c7 44 84 0c 00 00 00 	movl   $0x0,0xc(%esp,%eax,4)
   10b0f:	00 
	for (i = 0 ; i < 4 ; i++)
   10b10:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   10b15:	83 7c 24 1c 03       	cmpl   $0x3,0x1c(%esp)
   10b1a:	0f 8e 6c ff ff ff    	jle    10a8c <bread_page+0x1e>
	// 随后将4个缓冲块上的内容顺序复制到指定地址处.在进行复制(使用)缓冲块之前我们先要睡眠等待缓冲块解锁(若被上锁的话).另外,
	// 因为可能睡眠过了,所以我们还需要在复制之前再检查一下缓冲块中的数据是否是有效的.复制完后我们还需要释放缓冲块.
	for (i = 0 ; i < 4 ; i++, address += BLOCK_SIZE)
   10b20:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   10b27:	00 
   10b28:	eb 73                	jmp    10b9d <bread_page+0x12f>
		if (bh[i]) {
   10b2a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10b2e:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10b32:	85 c0                	test   %eax,%eax
   10b34:	74 5a                	je     10b90 <bread_page+0x122>
			wait_on_buffer(bh[i]);						// 等待缓冲块解锁(若被上锁的话).
   10b36:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10b3a:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10b3e:	83 ec 0c             	sub    $0xc,%esp
   10b41:	50                   	push   %eax
   10b42:	e8 1a f6 ff ff       	call   10161 <wait_on_buffer>
   10b47:	83 c4 10             	add    $0x10,%esp
			if (bh[i]->b_uptodate)						// 若缓冲块中数据有效的话则复制.
   10b4a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10b4e:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10b52:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   10b56:	84 c0                	test   %al,%al
   10b58:	74 22                	je     10b7c <bread_page+0x10e>
				COPYBLK((unsigned long) bh[i]->b_data, address);
   10b5a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10b5e:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10b62:	8b 00                	mov    (%eax),%eax
   10b64:	89 c3                	mov    %eax,%ebx
   10b66:	ba 00 01 00 00       	mov    $0x100,%edx
   10b6b:	8b 44 24 30          	mov    0x30(%esp),%eax
   10b6f:	89 d1                	mov    %edx,%ecx
   10b71:	89 de                	mov    %ebx,%esi
   10b73:	89 c7                	mov    %eax,%edi
   10b75:	fc                   	cld    
   10b76:	57                   	push   %edi
   10b77:	56                   	push   %esi
   10b78:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   10b7a:	5e                   	pop    %esi
   10b7b:	5f                   	pop    %edi
			brelse(bh[i]);								// 释放该缓冲区.
   10b7c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10b80:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   10b84:	83 ec 0c             	sub    $0xc,%esp
   10b87:	50                   	push   %eax
   10b88:	e8 de fd ff ff       	call   1096b <brelse>
   10b8d:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < 4 ; i++, address += BLOCK_SIZE)
   10b90:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   10b95:	81 44 24 30 00 04 00 	addl   $0x400,0x30(%esp)
   10b9c:	00 
   10b9d:	83 7c 24 1c 03       	cmpl   $0x3,0x1c(%esp)
   10ba2:	7e 86                	jle    10b2a <bread_page+0xbc>
		}
}
   10ba4:	90                   	nop
   10ba5:	83 c4 20             	add    $0x20,%esp
   10ba8:	5b                   	pop    %ebx
   10ba9:	5e                   	pop    %esi
   10baa:	5f                   	pop    %edi
   10bab:	c3                   	ret    

00010bac <breada>:
 * OK,breada可以象bread一样使用,但会另外预读一些块.该函数参数列表需要使用一个负数来表明参数列表的结束.
 */
// 从指定设备读取指定的一些块.
// 函数参数个数可变,是一系列指定的块号.成功时返回第1块的缓冲块头指针,否则返回NULL.
struct buffer_head * breada(int dev, int first, ...)
{
   10bac:	53                   	push   %ebx
   10bad:	83 ec 18             	sub    $0x18,%esp
   10bb0:	e8 45 61 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10bb5:	81 c3 4b 14 02 00    	add    $0x2144b,%ebx
	va_list args;
	struct buffer_head * bh, *tmp;

	// 首先取可变参数表中第1个参数(块号).接着从调整缓冲区中取指定设备和块号的缓冲块.如果该缓冲块数据无效(更新标志未置位),则
	// 发出读设备数据块请求.
	va_start(args, first);
   10bbb:	8d 44 24 24          	lea    0x24(%esp),%eax
   10bbf:	83 c0 04             	add    $0x4,%eax
   10bc2:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!(bh = getblk(dev, first)))
   10bc6:	8b 44 24 24          	mov    0x24(%esp),%eax
   10bca:	83 ec 08             	sub    $0x8,%esp
   10bcd:	50                   	push   %eax
   10bce:	ff 74 24 2c          	pushl  0x2c(%esp)
   10bd2:	e8 ca fb ff ff       	call   107a1 <getblk>
   10bd7:	83 c4 10             	add    $0x10,%esp
   10bda:	89 44 24 08          	mov    %eax,0x8(%esp)
   10bde:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   10be3:	75 12                	jne    10bf7 <breada+0x4b>
		panic("bread: getblk returned NULL\n");
   10be5:	83 ec 0c             	sub    $0xc,%esp
   10be8:	8d 83 12 50 ff ff    	lea    -0xafee(%ebx),%eax
   10bee:	50                   	push   %eax
   10bef:	e8 ea 86 ff ff       	call   92de <panic>
   10bf4:	83 c4 10             	add    $0x10,%esp
	if (!bh->b_uptodate)
   10bf7:	8b 44 24 08          	mov    0x8(%esp),%eax
   10bfb:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   10bff:	84 c0                	test   %al,%al
   10c01:	75 61                	jne    10c64 <breada+0xb8>
		ll_rw_block(READ, bh);
   10c03:	83 ec 08             	sub    $0x8,%esp
   10c06:	ff 74 24 10          	pushl  0x10(%esp)
   10c0a:	6a 00                	push   $0x0
   10c0c:	e8 5e 78 00 00       	call   1846f <ll_rw_block>
   10c11:	83 c4 10             	add    $0x10,%esp
	// 然后顺序取可变参数表中其他预读块号,并作与上面同样处理,但不引用.注意,336行上有一个bug.其中的bh应该是tmp.这个bug直到在0.96
	// 版的内核代码中才被纠正过来.另外,因为这里是预读随后的数据块,只需读进调整缓冲区但并不马上就使用,所以第337行语句需要将其引用计数
	// 递减释放掉该块(因为getblk()函数会增加缓冲块引用计数值).
	while ((first = va_arg(args, int)) >= 0) {
   10c14:	eb 4e                	jmp    10c64 <breada+0xb8>
		tmp = getblk(dev, first);
   10c16:	8b 44 24 24          	mov    0x24(%esp),%eax
   10c1a:	83 ec 08             	sub    $0x8,%esp
   10c1d:	50                   	push   %eax
   10c1e:	ff 74 24 2c          	pushl  0x2c(%esp)
   10c22:	e8 7a fb ff ff       	call   107a1 <getblk>
   10c27:	83 c4 10             	add    $0x10,%esp
   10c2a:	89 44 24 04          	mov    %eax,0x4(%esp)
		if (tmp) {
   10c2e:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   10c33:	74 2f                	je     10c64 <breada+0xb8>
			if (!tmp->b_uptodate)
   10c35:	8b 44 24 04          	mov    0x4(%esp),%eax
   10c39:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   10c3d:	84 c0                	test   %al,%al
   10c3f:	75 11                	jne    10c52 <breada+0xa6>
				ll_rw_block(READA, tmp);
   10c41:	83 ec 08             	sub    $0x8,%esp
   10c44:	ff 74 24 0c          	pushl  0xc(%esp)
   10c48:	6a 02                	push   $0x2
   10c4a:	e8 20 78 00 00       	call   1846f <ll_rw_block>
   10c4f:	83 c4 10             	add    $0x10,%esp
			tmp->b_count--;					// 暂时释放掉该预读块.
   10c52:	8b 44 24 04          	mov    0x4(%esp),%eax
   10c56:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   10c5a:	8d 50 ff             	lea    -0x1(%eax),%edx
   10c5d:	8b 44 24 04          	mov    0x4(%esp),%eax
   10c61:	88 50 0c             	mov    %dl,0xc(%eax)
	while ((first = va_arg(args, int)) >= 0) {
   10c64:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)
   10c69:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10c6d:	8b 40 fc             	mov    -0x4(%eax),%eax
   10c70:	89 44 24 24          	mov    %eax,0x24(%esp)
   10c74:	8b 44 24 24          	mov    0x24(%esp),%eax
   10c78:	85 c0                	test   %eax,%eax
   10c7a:	79 9a                	jns    10c16 <breada+0x6a>
		}
	}
	// 此时可变参数表中所有参数处理完毕.于是等待第1个缓冲区解锁(如果已被上锁).在等待退出之后如果缓冲区中数据仍然有效,则返回缓冲区头指针
	// 退出.否则释放该缓冲区返回NULL,退出.
	va_end(args);
	wait_on_buffer(bh);
   10c7c:	83 ec 0c             	sub    $0xc,%esp
   10c7f:	ff 74 24 14          	pushl  0x14(%esp)
   10c83:	e8 d9 f4 ff ff       	call   10161 <wait_on_buffer>
   10c88:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
   10c8b:	8b 44 24 08          	mov    0x8(%esp),%eax
   10c8f:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   10c93:	84 c0                	test   %al,%al
   10c95:	74 06                	je     10c9d <breada+0xf1>
		return bh;
   10c97:	8b 44 24 08          	mov    0x8(%esp),%eax
   10c9b:	eb 14                	jmp    10cb1 <breada+0x105>
	brelse(bh);
   10c9d:	83 ec 0c             	sub    $0xc,%esp
   10ca0:	ff 74 24 14          	pushl  0x14(%esp)
   10ca4:	e8 c2 fc ff ff       	call   1096b <brelse>
   10ca9:	83 c4 10             	add    $0x10,%esp
	return (NULL);
   10cac:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cb1:	83 c4 18             	add    $0x18,%esp
   10cb4:	5b                   	pop    %ebx
   10cb5:	c3                   	ret    

00010cb6 <buffer_init>:

// 缓冲区初始化函数
// 参数buffer_end是缓冲区内存末端.对于具有16M内存的系统,缓冲区末端被设置为4MB.对于有8MB内存的系统,缓冲区末端被设置2MB.该函数从缓冲区开始位置
// start_buffer处和缓冲区末端buffer_end处分别同时设置(初始化)缓冲块头结构和对应的数据块.直到缓冲区中所有内存被分配完毕.
void buffer_init(long buffer_end)
{
   10cb6:	83 ec 10             	sub    $0x10,%esp
   10cb9:	e8 34 60 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   10cbe:	05 42 13 02 00       	add    $0x21342,%eax
	struct buffer_head * h = start_buffer;
   10cc3:	8b 90 00 14 00 00    	mov    0x1400(%eax),%edx
   10cc9:	89 54 24 0c          	mov    %edx,0xc(%esp)
	void * b;
	int i;

	// 首先根据参数提供的缓冲区高端位置确定实际缓冲区高端位置b.如果缓冲区高端等于1MB,则因为从640KB-1MB被显示内存和BIOS占用,所以实际可用缓冲区内存
	// 高端位置应该是640KB.否则缓冲区内存高端一定大于1MB.
	if (buffer_end == 1 << 20)
   10ccd:	81 7c 24 14 00 00 10 	cmpl   $0x100000,0x14(%esp)
   10cd4:	00 
   10cd5:	75 0d                	jne    10ce4 <buffer_init+0x2e>
		b = (void *) (640 * 1024);
   10cd7:	c7 44 24 08 00 00 0a 	movl   $0xa0000,0x8(%esp)
   10cde:	00 
   10cdf:	e9 a4 00 00 00       	jmp    10d88 <buffer_init+0xd2>
	else
		b = (void *) buffer_end;
   10ce4:	8b 54 24 14          	mov    0x14(%esp),%edx
   10ce8:	89 54 24 08          	mov    %edx,0x8(%esp)
	// 这段代码用于初始化缓冲区,建立空闲缓冲块循环链表,并获取系统中缓冲块数目.操作的过程是从缓冲区高端开始划分1KB大小的缓冲块,与此同时在缓冲区低端建立
	// 描述该缓冲块的结构buffer_head,并将这些buffer_head组成双向链表.
	// h是指向缓冲头结构的指针,而h+1是指向内存地址连续的下一个缓冲头地址,也可以说是指向h缓冲有头的末端外.为了保证有足够长度的内存来存储一个缓冲头结构,
	// 需要b所指向的内存块地址>=h缓冲头的末端,即要求>=h+1.
	while ( (b -= BLOCK_SIZE) >= ((void *) (h + 1)) ) {
   10cec:	e9 97 00 00 00       	jmp    10d88 <buffer_init+0xd2>
		h->b_dev = 0;								// 使用该缓冲块的设备号.
   10cf1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10cf5:	66 c7 42 08 00 00    	movw   $0x0,0x8(%edx)
		h->b_dirt = 0;								// 脏标志,即缓冲块修改标志.
   10cfb:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10cff:	c6 42 0b 00          	movb   $0x0,0xb(%edx)
		h->b_count = 0;								// 缓冲块引用计数.
   10d03:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d07:	c6 42 0c 00          	movb   $0x0,0xc(%edx)
		h->b_lock = 0;								// 缓冲块锁定标志.
   10d0b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d0f:	c6 42 0d 00          	movb   $0x0,0xd(%edx)
		h->b_uptodate = 0;							// 缓冲块更新标志(或称数据有效标志).
   10d13:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d17:	c6 42 0a 00          	movb   $0x0,0xa(%edx)
		h->b_wait = NULL;							// 指向等待该缓冲块解锁的进程.
   10d1b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d1f:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
		h->b_next = NULL;							// 指向具有相同hash值的下一个缓冲头.
   10d26:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d2a:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
		h->b_prev = NULL;							// 指向具有相同hash值的前一个缓冲头.
   10d31:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d35:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
		h->b_data = (char *) b;						// 指向对应缓冲块数据块(1024字节).
   10d3c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d40:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   10d44:	89 0a                	mov    %ecx,(%edx)
		h->b_prev_free = h - 1;						// 指向链表中前一项.
   10d46:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d4a:	8d 4a dc             	lea    -0x24(%edx),%ecx
   10d4d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d51:	89 4a 1c             	mov    %ecx,0x1c(%edx)
		h->b_next_free = h + 1;						// 指向链表中下一项.
   10d54:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d58:	8d 4a 24             	lea    0x24(%edx),%ecx
   10d5b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d5f:	89 4a 20             	mov    %ecx,0x20(%edx)
		h++;										// h指向下一新缓冲头位置.
   10d62:	83 44 24 0c 24       	addl   $0x24,0xc(%esp)
		NR_BUFFERS++;								// 缓冲区块数累加.
   10d67:	8b 90 40 41 00 00    	mov    0x4140(%eax),%edx
   10d6d:	83 c2 01             	add    $0x1,%edx
   10d70:	89 90 40 41 00 00    	mov    %edx,0x4140(%eax)
		if (b == (void *) 0x100000)					// 若b递减到等于1MB,则跳过384KB
   10d76:	81 7c 24 08 00 00 10 	cmpl   $0x100000,0x8(%esp)
   10d7d:	00 
   10d7e:	75 08                	jne    10d88 <buffer_init+0xd2>
			b = (void *) 0xA0000;					// 让b指向地址0xA0000(640KB)处.
   10d80:	c7 44 24 08 00 00 0a 	movl   $0xa0000,0x8(%esp)
   10d87:	00 
	while ( (b -= BLOCK_SIZE) >= ((void *) (h + 1)) ) {
   10d88:	81 6c 24 08 00 04 00 	subl   $0x400,0x8(%esp)
   10d8f:	00 
   10d90:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10d94:	83 c2 24             	add    $0x24,%edx
   10d97:	39 54 24 08          	cmp    %edx,0x8(%esp)
   10d9b:	0f 83 50 ff ff ff    	jae    10cf1 <buffer_init+0x3b>
	}
	h--;											// 让h指向最后一个有效缓冲块头.
   10da1:	83 6c 24 0c 24       	subl   $0x24,0xc(%esp)
	free_list = start_buffer;						// 让空闲链表头指向头一个缓冲块.
   10da6:	8b 90 00 14 00 00    	mov    0x1400(%eax),%edx
   10dac:	89 90 44 41 00 00    	mov    %edx,0x4144(%eax)
	free_list->b_prev_free = h;     				// 链表头的b_prev_free指向前一项（即最后一项）。
   10db2:	8b 90 44 41 00 00    	mov    0x4144(%eax),%edx
   10db8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   10dbc:	89 4a 1c             	mov    %ecx,0x1c(%edx)
	h->b_next_free = free_list;     				// h的下一项指针指向第一项，形成一个环链。
   10dbf:	8b 88 44 41 00 00    	mov    0x4144(%eax),%ecx
   10dc5:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10dc9:	89 4a 20             	mov    %ecx,0x20(%edx)
	// 最后初始化hash表(哈希表、散列表),置表中所有指针为NULL。
	for (i = 0; i < NR_HASH; i++)
   10dcc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   10dd3:	00 
   10dd4:	eb 16                	jmp    10dec <buffer_init+0x136>
		hash_table[i] = NULL;
   10dd6:	c7 c2 c0 57 04 00    	mov    $0x457c0,%edx
   10ddc:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   10de0:	c7 04 8a 00 00 00 00 	movl   $0x0,(%edx,%ecx,4)
	for (i = 0; i < NR_HASH; i++)
   10de7:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
   10dec:	81 7c 24 04 32 01 00 	cmpl   $0x132,0x4(%esp)
   10df3:	00 
   10df4:	7e e0                	jle    10dd6 <buffer_init+0x120>
}
   10df6:	90                   	nop
   10df7:	83 c4 10             	add    $0x10,%esp
   10dfa:	c3                   	ret    

00010dfb <lock_super>:
//　以下３个函数(lock_super(),free_super()和wait_on_super())的作用与inode.c文件中头３个函数的作用相同,只是这里操作的对象
//　换成了超级块.
//　锁定超级块.
//　如果超级块已被锁定,则将当前任务置为不可中断的等待状态,并添加到该超级块等待队列s_wait中.直到该超级块解锁并明确地唤醒本任务.然后对其上锁.
static void lock_super(struct super_block * sb)
{
   10dfb:	53                   	push   %ebx
   10dfc:	83 ec 08             	sub    $0x8,%esp
   10dff:	e8 f6 5e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10e04:	81 c3 fc 11 02 00    	add    $0x211fc,%ebx
	cli();													//　关中断
   10e0a:	fa                   	cli    
	while (sb->s_lock)										//　如果该超级块已经上锁,则睡眠等待.
   10e0b:	eb 13                	jmp    10e20 <lock_super+0x25>
		sleep_on(&(sb->s_wait));
   10e0d:	8b 44 24 10          	mov    0x10(%esp),%eax
   10e11:	83 c0 64             	add    $0x64,%eax
   10e14:	83 ec 0c             	sub    $0xc,%esp
   10e17:	50                   	push   %eax
   10e18:	e8 67 64 ff ff       	call   7284 <sleep_on>
   10e1d:	83 c4 10             	add    $0x10,%esp
	while (sb->s_lock)										//　如果该超级块已经上锁,则睡眠等待.
   10e20:	8b 44 24 10          	mov    0x10(%esp),%eax
   10e24:	0f b6 40 68          	movzbl 0x68(%eax),%eax
   10e28:	84 c0                	test   %al,%al
   10e2a:	75 e1                	jne    10e0d <lock_super+0x12>
	sb->s_lock = 1;											//　给该超级块加锁(置锁定标志)
   10e2c:	8b 44 24 10          	mov    0x10(%esp),%eax
   10e30:	c6 40 68 01          	movb   $0x1,0x68(%eax)
	sti();													//　开中断.
   10e34:	fb                   	sti    
}
   10e35:	90                   	nop
   10e36:	83 c4 08             	add    $0x8,%esp
   10e39:	5b                   	pop    %ebx
   10e3a:	c3                   	ret    

00010e3b <free_super>:

//　对指定超级块解锁
//　复位超级块的锁定标志,并明确地唤醒等待此超级块等待队列s_wait上的所有进程.
//　如果使用unlock_super这个名称则可能更妥帖.
static void free_super(struct super_block * sb)
{
   10e3b:	53                   	push   %ebx
   10e3c:	83 ec 08             	sub    $0x8,%esp
   10e3f:	e8 ae 5e ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   10e44:	05 bc 11 02 00       	add    $0x211bc,%eax
	cli();
   10e49:	fa                   	cli    
	sb->s_lock = 0;											// 复位锁定标志.
   10e4a:	8b 54 24 10          	mov    0x10(%esp),%edx
   10e4e:	c6 42 68 00          	movb   $0x0,0x68(%edx)
	wake_up(&(sb->s_wait));									// 唤醒等待该超级块的进程.
   10e52:	8b 54 24 10          	mov    0x10(%esp),%edx
   10e56:	83 c2 64             	add    $0x64,%edx
   10e59:	83 ec 0c             	sub    $0xc,%esp
   10e5c:	52                   	push   %edx
   10e5d:	89 c3                	mov    %eax,%ebx
   10e5f:	e8 43 64 ff ff       	call   72a7 <wake_up>
   10e64:	83 c4 10             	add    $0x10,%esp
	sti();													// wake_up()在kernel/sched.c
   10e67:	fb                   	sti    
}
   10e68:	90                   	nop
   10e69:	83 c4 08             	add    $0x8,%esp
   10e6c:	5b                   	pop    %ebx
   10e6d:	c3                   	ret    

00010e6e <wait_on_super>:

// 睡眠等待超级块解锁.
// 如果超级块已被锁定,则将当前任务置为不可中断的等待状态,并添加到该超级块的等待队列s_wait中.直到该超级块解锁并明确地唤醒本任务.
static void wait_on_super(struct super_block * sb)
{
   10e6e:	53                   	push   %ebx
   10e6f:	83 ec 08             	sub    $0x8,%esp
   10e72:	e8 83 5e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10e77:	81 c3 89 11 02 00    	add    $0x21189,%ebx
	cli();
   10e7d:	fa                   	cli    
	while (sb->s_lock)										// 如果超级块已经上锁,则睡眠等待.
   10e7e:	eb 13                	jmp    10e93 <wait_on_super+0x25>
		sleep_on(&(sb->s_wait));
   10e80:	8b 44 24 10          	mov    0x10(%esp),%eax
   10e84:	83 c0 64             	add    $0x64,%eax
   10e87:	83 ec 0c             	sub    $0xc,%esp
   10e8a:	50                   	push   %eax
   10e8b:	e8 f4 63 ff ff       	call   7284 <sleep_on>
   10e90:	83 c4 10             	add    $0x10,%esp
	while (sb->s_lock)										// 如果超级块已经上锁,则睡眠等待.
   10e93:	8b 44 24 10          	mov    0x10(%esp),%eax
   10e97:	0f b6 40 68          	movzbl 0x68(%eax),%eax
   10e9b:	84 c0                	test   %al,%al
   10e9d:	75 e1                	jne    10e80 <wait_on_super+0x12>
	sti();
   10e9f:	fb                   	sti    
}
   10ea0:	90                   	nop
   10ea1:	83 c4 08             	add    $0x8,%esp
   10ea4:	5b                   	pop    %ebx
   10ea5:	c3                   	ret    

00010ea6 <get_super>:

// 取指定设备的超级块.
// 在超级块表(数组)中搜索指定设备dev的超级块结构信息.若找到则返回超级块的指针,否则返回空指针.
struct super_block * get_super(int dev)
{
   10ea6:	53                   	push   %ebx
   10ea7:	83 ec 18             	sub    $0x18,%esp
   10eaa:	e8 4b 5e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10eaf:	81 c3 51 11 02 00    	add    $0x21151,%ebx
	struct super_block * s;									// s是超级块数据结构指针.

	// 首先判断参数给出设备的有效性.若设备号为0则返回空指针.然后让s指向超级块数组起始处,开始搜索整个超级块数组,以寻找指定设备dev的超级块.
	// 第62行上的指针赋值语句"s = 0+super_block"等同于"s = super_block","s = &super_block[0]".
	if (!dev)
   10eb5:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   10eba:	75 07                	jne    10ec3 <get_super+0x1d>
		return NULL;
   10ebc:	b8 00 00 00 00       	mov    $0x0,%eax
   10ec1:	eb 6b                	jmp    10f2e <get_super+0x88>
	s = 0 + super_block;
   10ec3:	c7 c0 a0 5c 04 00    	mov    $0x45ca0,%eax
   10ec9:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (s < NR_SUPER + super_block)
   10ecd:	eb 48                	jmp    10f17 <get_super+0x71>
		// 如果当前搜索项是指定设备的超级块,即该超级块的设备号字段值与函数参数指定的相同,则先等待该超级块解锁(若已被其他进程上锁的话).在等待期间,
		// 该超级块项有可能被其他设备使用,因此等待返回之后需再判断一次是否是指定设备的超级块,如果是则返回该超级块的指针.否则就重新对超级块数组再
		// 搜索一遍,因此此时s需重又指向超级块数组开始处.
		if (s->s_dev == dev) {
   10ecf:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10ed3:	0f b7 40 54          	movzwl 0x54(%eax),%eax
   10ed7:	0f b7 c0             	movzwl %ax,%eax
   10eda:	39 44 24 20          	cmp    %eax,0x20(%esp)
   10ede:	75 32                	jne    10f12 <get_super+0x6c>
			wait_on_super(s);
   10ee0:	83 ec 0c             	sub    $0xc,%esp
   10ee3:	ff 74 24 18          	pushl  0x18(%esp)
   10ee7:	e8 82 ff ff ff       	call   10e6e <wait_on_super>
   10eec:	83 c4 10             	add    $0x10,%esp
			if (s->s_dev == dev)
   10eef:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10ef3:	0f b7 40 54          	movzwl 0x54(%eax),%eax
   10ef7:	0f b7 c0             	movzwl %ax,%eax
   10efa:	39 44 24 20          	cmp    %eax,0x20(%esp)
   10efe:	75 06                	jne    10f06 <get_super+0x60>
				return s;
   10f00:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10f04:	eb 28                	jmp    10f2e <get_super+0x88>
			s = 0 + super_block;
   10f06:	c7 c0 a0 5c 04 00    	mov    $0x45ca0,%eax
   10f0c:	89 44 24 0c          	mov    %eax,0xc(%esp)
   10f10:	eb 05                	jmp    10f17 <get_super+0x71>
		// 如果当前搜索项不是,则检查下一项.如果没有找到指定的超级块,则返回空指针.
		} else
			s++;
   10f12:	83 44 24 0c 6c       	addl   $0x6c,0xc(%esp)
	while (s < NR_SUPER + super_block)
   10f17:	c7 c0 a0 5c 04 00    	mov    $0x45ca0,%eax
   10f1d:	8d 80 60 03 00 00    	lea    0x360(%eax),%eax
   10f23:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   10f27:	72 a6                	jb     10ecf <get_super+0x29>
	return NULL;
   10f29:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10f2e:	83 c4 18             	add    $0x18,%esp
   10f31:	5b                   	pop    %ebx
   10f32:	c3                   	ret    

00010f33 <put_super>:

// 释放（放回）指定设备的超级块。
// 释放设备所使用的超级块数组项（置s_dev = 0），并释放该设备i节点位图和逻辑块位图所占用的高速缓冲块。如果超级块对应的
// 文件系统是根文件系统，或者其某个i节点上已经安装了其他的文件系统，则不能释放该超级块。
void put_super(int dev)
{
   10f33:	53                   	push   %ebx
   10f34:	83 ec 18             	sub    $0x18,%esp
   10f37:	e8 be 5d ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   10f3c:	81 c3 c4 10 02 00    	add    $0x210c4,%ebx

	// 首先判断参数的有效性和合法性。如果指定设备是根文件系统设备，则显示警告信息“根系统盘改变了，准备生死决战吧”，并返回。
	// 然后在超级块表中寻找指定设备号的文件系统超级块。如果找不到指定设备超级块，则返回。另外，如果该超级块指明该文件系统
	// 所安装到的i节点还没有被处理过，则显示警告信息并返回。在文件系统卸载（umount）操作中，s_imount会先被置成NULL以后
	// 才会调用本函数。
	if (dev == ROOT_DEV) {
   10f42:	8b 83 4c 41 00 00    	mov    0x414c(%ebx),%eax
   10f48:	39 44 24 20          	cmp    %eax,0x20(%esp)
   10f4c:	75 17                	jne    10f65 <put_super+0x32>
		printk("root diskette changed: prepare for armageddon\n\r");
   10f4e:	83 ec 0c             	sub    $0xc,%esp
   10f51:	8d 83 30 50 ff ff    	lea    -0xafd0(%ebx),%eax
   10f57:	50                   	push   %eax
   10f58:	e8 d5 83 ff ff       	call   9332 <printk>
   10f5d:	83 c4 10             	add    $0x10,%esp
		return;
   10f60:	e9 ce 00 00 00       	jmp    11033 <put_super+0x100>
	}
	if (!(sb = get_super(dev)))
   10f65:	83 ec 0c             	sub    $0xc,%esp
   10f68:	ff 74 24 2c          	pushl  0x2c(%esp)
   10f6c:	e8 35 ff ff ff       	call   10ea6 <get_super>
   10f71:	83 c4 10             	add    $0x10,%esp
   10f74:	89 44 24 08          	mov    %eax,0x8(%esp)
   10f78:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   10f7d:	0f 84 af 00 00 00    	je     11032 <put_super+0xff>
		return;
	if (sb->s_imount) {
   10f83:	8b 44 24 08          	mov    0x8(%esp),%eax
   10f87:	8b 40 5c             	mov    0x5c(%eax),%eax
   10f8a:	85 c0                	test   %eax,%eax
   10f8c:	74 17                	je     10fa5 <put_super+0x72>
		printk("Mounted disk changed - tssk, tssk\n\r");
   10f8e:	83 ec 0c             	sub    $0xc,%esp
   10f91:	8d 83 60 50 ff ff    	lea    -0xafa0(%ebx),%eax
   10f97:	50                   	push   %eax
   10f98:	e8 95 83 ff ff       	call   9332 <printk>
   10f9d:	83 c4 10             	add    $0x10,%esp
		return;
   10fa0:	e9 8e 00 00 00       	jmp    11033 <put_super+0x100>
	}
	// 然后在找到指定设备的超级块之后，我们先锁定该超级块，再置该超级块对应的设备号字段s_dev为0，也即释放该设备上的文件系统
	// 超级块。然后释放该超级块占用的其他内核资源，即释放该设备上文件系统i节点位图和逻辑位图在缓冲区中所占用的缓冲块。下面
	// 常数符号I_MAP_SLOTS和Z_MAP_SLOTS均等于8，用于分别指明i节点位图和逻辑块位图占用的磁盘逻辑块数。注意，若这些缓冲块
	// 内容被修改过，则需要作同步操作才能把缓冲块中的数据写入设备中。函数最后对该超级块，并返回。
	lock_super(sb);
   10fa5:	83 ec 0c             	sub    $0xc,%esp
   10fa8:	ff 74 24 14          	pushl  0x14(%esp)
   10fac:	e8 4a fe ff ff       	call   10dfb <lock_super>
   10fb1:	83 c4 10             	add    $0x10,%esp
	sb->s_dev = 0;                          		// 置超级块空闲。
   10fb4:	8b 44 24 08          	mov    0x8(%esp),%eax
   10fb8:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
	for(i = 0; i < I_MAP_SLOTS; i++)
   10fbe:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   10fc5:	00 
   10fc6:	eb 20                	jmp    10fe8 <put_super+0xb5>
		brelse(sb->s_imap[i]);
   10fc8:	8b 44 24 08          	mov    0x8(%esp),%eax
   10fcc:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10fd0:	83 c2 04             	add    $0x4,%edx
   10fd3:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   10fd7:	83 ec 0c             	sub    $0xc,%esp
   10fda:	50                   	push   %eax
   10fdb:	e8 8b f9 ff ff       	call   1096b <brelse>
   10fe0:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < I_MAP_SLOTS; i++)
   10fe3:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   10fe8:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
   10fed:	7e d9                	jle    10fc8 <put_super+0x95>
	for(i = 0; i < Z_MAP_SLOTS; i++)
   10fef:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   10ff6:	00 
   10ff7:	eb 20                	jmp    11019 <put_super+0xe6>
		brelse(sb->s_zmap[i]);
   10ff9:	8b 44 24 08          	mov    0x8(%esp),%eax
   10ffd:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11001:	83 c2 0c             	add    $0xc,%edx
   11004:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   11008:	83 ec 0c             	sub    $0xc,%esp
   1100b:	50                   	push   %eax
   1100c:	e8 5a f9 ff ff       	call   1096b <brelse>
   11011:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < Z_MAP_SLOTS; i++)
   11014:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   11019:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
   1101e:	7e d9                	jle    10ff9 <put_super+0xc6>
	free_super(sb);
   11020:	83 ec 0c             	sub    $0xc,%esp
   11023:	ff 74 24 14          	pushl  0x14(%esp)
   11027:	e8 0f fe ff ff       	call   10e3b <free_super>
   1102c:	83 c4 10             	add    $0x10,%esp
	return;
   1102f:	90                   	nop
   11030:	eb 01                	jmp    11033 <put_super+0x100>
		return;
   11032:	90                   	nop
}
   11033:	83 c4 18             	add    $0x18,%esp
   11036:	5b                   	pop    %ebx
   11037:	c3                   	ret    

00011038 <read_super>:

// 读取指定设备的超级块.
// 如果指定设备dev上的文件系统超级块已经在超级块表中,则直接返回该超级块项的指针.否则就从设备dev上读取超级块到缓冲块中,并复制到超级块表中.并
// 返回超级块指针.
static struct super_block * read_super(int dev)
{
   11038:	53                   	push   %ebx
   11039:	83 ec 18             	sub    $0x18,%esp
   1103c:	e8 b9 5c ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   11041:	81 c3 bf 0f 02 00    	add    $0x20fbf,%ebx
	struct buffer_head * bh;
	int i, block;

	// 首先判断参数的有效性.如果没有指明设备,则返回空指针.然后检查该设备是否可更换过盘片(也即是否是软盘设备).如果更换过盘,则高速缓冲区有关该设备的所有
	// 缓冲块均失效,需要进行失效处理,即释放原来加载的文件系统.
	if (!dev)
   11047:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   1104c:	75 0a                	jne    11058 <read_super+0x20>
		return NULL;
   1104e:	b8 00 00 00 00       	mov    $0x0,%eax
   11053:	e9 63 03 00 00       	jmp    113bb <read_super+0x383>
	check_disk_change(dev);
   11058:	83 ec 0c             	sub    $0xc,%esp
   1105b:	ff 74 24 2c          	pushl  0x2c(%esp)
   1105f:	e8 47 f3 ff ff       	call   103ab <check_disk_change>
   11064:	83 c4 10             	add    $0x10,%esp
	// 如果设备的超级块已经在超级块表中,则直接返回该超级块的指针.否则,首先在超级块数组中找出一个空项(也即字段s_dev=0的项).如果数组已经占满则返回空指针.
	if (s = get_super(dev))
   11067:	83 ec 0c             	sub    $0xc,%esp
   1106a:	ff 74 24 2c          	pushl  0x2c(%esp)
   1106e:	e8 33 fe ff ff       	call   10ea6 <get_super>
   11073:	83 c4 10             	add    $0x10,%esp
   11076:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1107a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1107f:	74 09                	je     1108a <read_super+0x52>
		return s;
   11081:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11085:	e9 31 03 00 00       	jmp    113bb <read_super+0x383>
	for (s = 0 + super_block ;; s++) {
   1108a:	c7 c0 a0 5c 04 00    	mov    $0x45ca0,%eax
   11090:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (s >= NR_SUPER + super_block)
   11094:	c7 c0 a0 5c 04 00    	mov    $0x45ca0,%eax
   1109a:	8d 80 60 03 00 00    	lea    0x360(%eax),%eax
   110a0:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   110a4:	72 0a                	jb     110b0 <read_super+0x78>
			return NULL;
   110a6:	b8 00 00 00 00       	mov    $0x0,%eax
   110ab:	e9 0b 03 00 00       	jmp    113bb <read_super+0x383>
		if (!s->s_dev)
   110b0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   110b4:	0f b7 40 54          	movzwl 0x54(%eax),%eax
   110b8:	66 85 c0             	test   %ax,%ax
   110bb:	74 07                	je     110c4 <read_super+0x8c>
	for (s = 0 + super_block ;; s++) {
   110bd:	83 44 24 0c 6c       	addl   $0x6c,0xc(%esp)
		if (s >= NR_SUPER + super_block)
   110c2:	eb d0                	jmp    11094 <read_super+0x5c>
			break;
   110c4:	90                   	nop
	}
	// 在超级块数组中找到空项之后,就将该超级块项用于指定设备dev上的文件系统.于是对该超级块结构中的内存字段进行部分初始化处理.
	s->s_dev = dev;										// 用于dev设备上的文件系统.
   110c5:	8b 44 24 20          	mov    0x20(%esp),%eax
   110c9:	89 c2                	mov    %eax,%edx
   110cb:	8b 44 24 0c          	mov    0xc(%esp),%eax
   110cf:	66 89 50 54          	mov    %dx,0x54(%eax)
	s->s_isup = NULL;
   110d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   110d7:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	s->s_imount = NULL;
   110de:	8b 44 24 0c          	mov    0xc(%esp),%eax
   110e2:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
	s->s_time = 0;
   110e9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   110ed:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	s->s_rd_only = 0;
   110f4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   110f8:	c6 40 69 00          	movb   $0x0,0x69(%eax)
	s->s_dirt = 0;
   110fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11100:	c6 40 6a 00          	movb   $0x0,0x6a(%eax)
	//　然后锁定该超级块,并从设备上读取超级块信息到bh指向的缓冲块中.超级块位于块设备的第２个逻辑块(１号块)中,(第１个是引导盘块).如果读超级块操作失败,则释放
	//　上面选定的超级块数组中的项(即置s_dev=0),并解锁该项,返回空指针退出.否则就将设备上读取的超级块信息从缓冲块数据区复制到超级块数组相应项结构中.并释放存放
	//　读取信息的高速缓冲块.
	lock_super(s);
   11104:	83 ec 0c             	sub    $0xc,%esp
   11107:	ff 74 24 18          	pushl  0x18(%esp)
   1110b:	e8 eb fc ff ff       	call   10dfb <lock_super>
   11110:	83 c4 10             	add    $0x10,%esp
	if (!(bh = bread(dev, 1))) {
   11113:	83 ec 08             	sub    $0x8,%esp
   11116:	6a 01                	push   $0x1
   11118:	ff 74 24 2c          	pushl  0x2c(%esp)
   1111c:	e8 b1 f8 ff ff       	call   109d2 <bread>
   11121:	83 c4 10             	add    $0x10,%esp
   11124:	89 04 24             	mov    %eax,(%esp)
   11127:	83 3c 24 00          	cmpl   $0x0,(%esp)
   1112b:	75 23                	jne    11150 <read_super+0x118>
		s->s_dev = 0;
   1112d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11131:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
   11137:	83 ec 0c             	sub    $0xc,%esp
   1113a:	ff 74 24 18          	pushl  0x18(%esp)
   1113e:	e8 f8 fc ff ff       	call   10e3b <free_super>
   11143:	83 c4 10             	add    $0x10,%esp
		return NULL;
   11146:	b8 00 00 00 00       	mov    $0x0,%eax
   1114b:	e9 6b 02 00 00       	jmp    113bb <read_super+0x383>
	}
	*((struct d_super_block *) s) =
		*((struct d_super_block *) bh->b_data);
   11150:	8b 04 24             	mov    (%esp),%eax
   11153:	8b 10                	mov    (%eax),%edx
	*((struct d_super_block *) s) =
   11155:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11159:	8b 0a                	mov    (%edx),%ecx
   1115b:	89 08                	mov    %ecx,(%eax)
   1115d:	8b 4a 04             	mov    0x4(%edx),%ecx
   11160:	89 48 04             	mov    %ecx,0x4(%eax)
   11163:	8b 4a 08             	mov    0x8(%edx),%ecx
   11166:	89 48 08             	mov    %ecx,0x8(%eax)
   11169:	8b 4a 0c             	mov    0xc(%edx),%ecx
   1116c:	89 48 0c             	mov    %ecx,0xc(%eax)
   1116f:	8b 52 10             	mov    0x10(%edx),%edx
   11172:	89 50 10             	mov    %edx,0x10(%eax)
	brelse(bh);
   11175:	83 ec 0c             	sub    $0xc,%esp
   11178:	ff 74 24 0c          	pushl  0xc(%esp)
   1117c:	e8 ea f7 ff ff       	call   1096b <brelse>
   11181:	83 c4 10             	add    $0x10,%esp
	// 现在我们从设备dev上得到了文件系统的超级块,于是开始检查这个超级块的有效性并从设备上读取i节点位图和逻辑块位图等信息.如果所读取的超级块的文件系统魔数字段不对,
	// 说明设备上不是正确的文件系统,因此向上面一样,释放上面选定的超级块数组中的项,并解锁该项,返回空指针退出.
	// 对于该版Linux内核,只支持MINIX文件系统1.0版本,其魔数是0x137f.
	if (s->s_magic != SUPER_MAGIC) {
   11184:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11188:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   1118c:	66 3d 7f 13          	cmp    $0x137f,%ax
   11190:	74 23                	je     111b5 <read_super+0x17d>
		s->s_dev = 0;
   11192:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11196:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
   1119c:	83 ec 0c             	sub    $0xc,%esp
   1119f:	ff 74 24 18          	pushl  0x18(%esp)
   111a3:	e8 93 fc ff ff       	call   10e3b <free_super>
   111a8:	83 c4 10             	add    $0x10,%esp
		return NULL;
   111ab:	b8 00 00 00 00       	mov    $0x0,%eax
   111b0:	e9 06 02 00 00       	jmp    113bb <read_super+0x383>
	}
	// 下面开始读取设备上i节点位图和逻辑块位图数据.首先初始化内存超级块结构中位图空间.然后从设备上读取i节点位图和逻辑块位图信息,并存放在超级块对应字段中.i节点位图
	// 保存在设备上2号块开始的逻辑块中,共占用s_imap_blocks个块.逻辑块位图在i节点位图所在块的后续块中,共占用s_zmap_blocks个块.
	for (i = 0; i < I_MAP_SLOTS; i++)					// 初始化操作.
   111b5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   111bc:	00 
   111bd:	eb 18                	jmp    111d7 <read_super+0x19f>
		s->s_imap[i] = NULL;
   111bf:	8b 44 24 0c          	mov    0xc(%esp),%eax
   111c3:	8b 54 24 08          	mov    0x8(%esp),%edx
   111c7:	83 c2 04             	add    $0x4,%edx
   111ca:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
   111d1:	00 
	for (i = 0; i < I_MAP_SLOTS; i++)					// 初始化操作.
   111d2:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   111d7:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
   111dc:	7e e1                	jle    111bf <read_super+0x187>
	for (i = 0; i < Z_MAP_SLOTS; i++)
   111de:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   111e5:	00 
   111e6:	eb 18                	jmp    11200 <read_super+0x1c8>
		s->s_zmap[i] = NULL;
   111e8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   111ec:	8b 54 24 08          	mov    0x8(%esp),%edx
   111f0:	83 c2 0c             	add    $0xc,%edx
   111f3:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
   111fa:	00 
	for (i = 0; i < Z_MAP_SLOTS; i++)
   111fb:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   11200:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
   11205:	7e e1                	jle    111e8 <read_super+0x1b0>
	block = 2;
   11207:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
   1120e:	00 
	// 从第二逻辑块号开始读取i节点位图
	for (i = 0 ; i < s->s_imap_blocks ; i++)			// 读取设备中i节点位图.
   1120f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   11216:	00 
   11217:	eb 41                	jmp    1125a <read_super+0x222>
		if (s->s_imap[i] = bread(dev, block))
   11219:	83 ec 08             	sub    $0x8,%esp
   1121c:	ff 74 24 0c          	pushl  0xc(%esp)
   11220:	ff 74 24 2c          	pushl  0x2c(%esp)
   11224:	e8 a9 f7 ff ff       	call   109d2 <bread>
   11229:	83 c4 10             	add    $0x10,%esp
   1122c:	89 c1                	mov    %eax,%ecx
   1122e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11232:	8b 54 24 08          	mov    0x8(%esp),%edx
   11236:	83 c2 04             	add    $0x4,%edx
   11239:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
   1123d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11241:	8b 54 24 08          	mov    0x8(%esp),%edx
   11245:	83 c2 04             	add    $0x4,%edx
   11248:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   1124c:	85 c0                	test   %eax,%eax
   1124e:	74 1d                	je     1126d <read_super+0x235>
			block++;
   11250:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
	for (i = 0 ; i < s->s_imap_blocks ; i++)			// 读取设备中i节点位图.
   11255:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   1125a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1125e:	0f b7 40 04          	movzwl 0x4(%eax),%eax
   11262:	0f b7 c0             	movzwl %ax,%eax
   11265:	39 44 24 08          	cmp    %eax,0x8(%esp)
   11269:	7c ae                	jl     11219 <read_super+0x1e1>
   1126b:	eb 01                	jmp    1126e <read_super+0x236>
		else
			break;
   1126d:	90                   	nop
	// 从i节点位图之后开始读取逻辑块位图
	for (i = 0 ; i < s->s_zmap_blocks ; i++)			// 读取设备中逻辑块位图.
   1126e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   11275:	00 
   11276:	eb 41                	jmp    112b9 <read_super+0x281>
		if (s->s_zmap[i] = bread(dev, block))
   11278:	83 ec 08             	sub    $0x8,%esp
   1127b:	ff 74 24 0c          	pushl  0xc(%esp)
   1127f:	ff 74 24 2c          	pushl  0x2c(%esp)
   11283:	e8 4a f7 ff ff       	call   109d2 <bread>
   11288:	83 c4 10             	add    $0x10,%esp
   1128b:	89 c1                	mov    %eax,%ecx
   1128d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11291:	8b 54 24 08          	mov    0x8(%esp),%edx
   11295:	83 c2 0c             	add    $0xc,%edx
   11298:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
   1129c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   112a0:	8b 54 24 08          	mov    0x8(%esp),%edx
   112a4:	83 c2 0c             	add    $0xc,%edx
   112a7:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   112ab:	85 c0                	test   %eax,%eax
   112ad:	74 1d                	je     112cc <read_super+0x294>
			block++;
   112af:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
	for (i = 0 ; i < s->s_zmap_blocks ; i++)			// 读取设备中逻辑块位图.
   112b4:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   112b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   112bd:	0f b7 40 06          	movzwl 0x6(%eax),%eax
   112c1:	0f b7 c0             	movzwl %ax,%eax
   112c4:	39 44 24 08          	cmp    %eax,0x8(%esp)
   112c8:	7c ae                	jl     11278 <read_super+0x240>
   112ca:	eb 01                	jmp    112cd <read_super+0x295>
		else
			break;
   112cc:	90                   	nop
	// 如果读出的位图个数不等于位图应该占有的逻辑块数,说明文件系统位图信息有问题,超级块初始化失败.因此只能释放前面申请并占用的所有资源,即释放i节点位图和逻辑块位图占用
	// 的高速缓冲块,释放上面选定的超级块数组项,解锁该超级块项,并返回空指针退出.
	if (block != 2 + s->s_imap_blocks + s->s_zmap_blocks) {
   112cd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   112d1:	0f b7 40 04          	movzwl 0x4(%eax),%eax
   112d5:	0f b7 c0             	movzwl %ax,%eax
   112d8:	8d 50 02             	lea    0x2(%eax),%edx
   112db:	8b 44 24 0c          	mov    0xc(%esp),%eax
   112df:	0f b7 40 06          	movzwl 0x6(%eax),%eax
   112e3:	0f b7 c0             	movzwl %ax,%eax
   112e6:	01 d0                	add    %edx,%eax
   112e8:	39 44 24 04          	cmp    %eax,0x4(%esp)
   112ec:	0f 84 82 00 00 00    	je     11374 <read_super+0x33c>
		for(i = 0; i < I_MAP_SLOTS; i++)				// 释放位图占用的高速缓冲块.
   112f2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   112f9:	00 
   112fa:	eb 20                	jmp    1131c <read_super+0x2e4>
			brelse(s->s_imap[i]);
   112fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11300:	8b 54 24 08          	mov    0x8(%esp),%edx
   11304:	83 c2 04             	add    $0x4,%edx
   11307:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   1130b:	83 ec 0c             	sub    $0xc,%esp
   1130e:	50                   	push   %eax
   1130f:	e8 57 f6 ff ff       	call   1096b <brelse>
   11314:	83 c4 10             	add    $0x10,%esp
		for(i = 0; i < I_MAP_SLOTS; i++)				// 释放位图占用的高速缓冲块.
   11317:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   1131c:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
   11321:	7e d9                	jle    112fc <read_super+0x2c4>
		for(i = 0; i < Z_MAP_SLOTS; i++)
   11323:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   1132a:	00 
   1132b:	eb 20                	jmp    1134d <read_super+0x315>
			brelse(s->s_zmap[i]);
   1132d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11331:	8b 54 24 08          	mov    0x8(%esp),%edx
   11335:	83 c2 0c             	add    $0xc,%edx
   11338:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   1133c:	83 ec 0c             	sub    $0xc,%esp
   1133f:	50                   	push   %eax
   11340:	e8 26 f6 ff ff       	call   1096b <brelse>
   11345:	83 c4 10             	add    $0x10,%esp
		for(i = 0; i < Z_MAP_SLOTS; i++)
   11348:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   1134d:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
   11352:	7e d9                	jle    1132d <read_super+0x2f5>
		s->s_dev = 0;									// 释放选定的超级块数组项.
   11354:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11358:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);									// 解锁该超级块项.
   1135e:	83 ec 0c             	sub    $0xc,%esp
   11361:	ff 74 24 18          	pushl  0x18(%esp)
   11365:	e8 d1 fa ff ff       	call   10e3b <free_super>
   1136a:	83 c4 10             	add    $0x10,%esp
		return NULL;
   1136d:	b8 00 00 00 00       	mov    $0x0,%eax
   11372:	eb 47                	jmp    113bb <read_super+0x383>
	}
	// 否则一切成功.另外,由于对于申请空闲i节点的函数来讲,如果设备所有的i节点已经全被使用,则查找函数会返回0值.因此0号i节点是不能用的,所以这里将位图中第1块的最低位设置为
	// 1,以防止文件系统分配0号i节点.同样的道理,也将逻辑块位图的最低位设置为1.最后函数解锁该超级块,并返回超级块指针.
	s->s_imap[0]->b_data[0] |= 1;
   11374:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11378:	8b 40 14             	mov    0x14(%eax),%eax
   1137b:	8b 00                	mov    (%eax),%eax
   1137d:	0f b6 10             	movzbl (%eax),%edx
   11380:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11384:	8b 40 14             	mov    0x14(%eax),%eax
   11387:	8b 00                	mov    (%eax),%eax
   11389:	83 ca 01             	or     $0x1,%edx
   1138c:	88 10                	mov    %dl,(%eax)
	s->s_zmap[0]->b_data[0] |= 1;
   1138e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11392:	8b 40 34             	mov    0x34(%eax),%eax
   11395:	8b 00                	mov    (%eax),%eax
   11397:	0f b6 10             	movzbl (%eax),%edx
   1139a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1139e:	8b 40 34             	mov    0x34(%eax),%eax
   113a1:	8b 00                	mov    (%eax),%eax
   113a3:	83 ca 01             	or     $0x1,%edx
   113a6:	88 10                	mov    %dl,(%eax)
	free_super(s);
   113a8:	83 ec 0c             	sub    $0xc,%esp
   113ab:	ff 74 24 18          	pushl  0x18(%esp)
   113af:	e8 87 fa ff ff       	call   10e3b <free_super>
   113b4:	83 c4 10             	add    $0x10,%esp
	return s;
   113b7:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   113bb:	83 c4 18             	add    $0x18,%esp
   113be:	5b                   	pop    %ebx
   113bf:	c3                   	ret    

000113c0 <sys_umount>:
// 卸载文件系统（系统调用）。
// 参数dev_name是文件系统所在设备的设备文件名。
// 该函数首先根据参数给出的块设备文件名获得设备号，然后复位文件系统超级块中的相应字段，释放超级块和位图占用的缓冲块，最后对该
// 设备执行高速缓冲与设备上数据的同步操作。若卸载操作成功则返回0，否则返回出错码。
int sys_umount(char * dev_name)
{
   113c0:	53                   	push   %ebx
   113c1:	83 ec 18             	sub    $0x18,%esp
   113c4:	e8 31 59 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   113c9:	81 c3 37 0c 02 00    	add    $0x20c37,%ebx
	int dev;

	// 首先根据设备文件名找到对应的i节点，并取其中的设备号。设备文件所定义设备号是保存在其i节点的i_zone[0]中的。参见后面namei.c
	// 程序中系统调用sys_mknod()的代码第445行。另外，由于文件系统需要存放在块设备上，因此如果不是块设备文件，则放回刚申请的i节点
	// dev_i，返回出错码。
	if (!(inode = namei(dev_name)))
   113cf:	83 ec 0c             	sub    $0xc,%esp
   113d2:	ff 74 24 2c          	pushl  0x2c(%esp)
   113d6:	e8 d2 38 00 00       	call   14cad <namei>
   113db:	83 c4 10             	add    $0x10,%esp
   113de:	89 44 24 0c          	mov    %eax,0xc(%esp)
   113e2:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   113e7:	75 0a                	jne    113f3 <sys_umount+0x33>
		return -ENOENT;
   113e9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   113ee:	e9 68 01 00 00       	jmp    1155b <sys_umount+0x19b>
	dev = inode->i_zone[0];
   113f3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   113f7:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   113fb:	0f b7 c0             	movzwl %ax,%eax
   113fe:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!S_ISBLK(inode->i_mode)) {
   11402:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11406:	0f b7 00             	movzwl (%eax),%eax
   11409:	0f b7 c0             	movzwl %ax,%eax
   1140c:	25 00 f0 00 00       	and    $0xf000,%eax
   11411:	3d 00 60 00 00       	cmp    $0x6000,%eax
   11416:	74 19                	je     11431 <sys_umount+0x71>
		iput(inode);                    				// fs/inode.c。
   11418:	83 ec 0c             	sub    $0xc,%esp
   1141b:	ff 74 24 18          	pushl  0x18(%esp)
   1141f:	e8 7e e4 ff ff       	call   f8a2 <iput>
   11424:	83 c4 10             	add    $0x10,%esp
		return -ENOTBLK;
   11427:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   1142c:	e9 2a 01 00 00       	jmp    1155b <sys_umount+0x19b>
	}
	// OK，现在上面为了得到设备号而取得的i节点已完成了它的使命，因此这里放回该设备文件的i节点。接着我们来检查一下卸载该文件系统的
	// 条件是否满足。如果设备上是根文件系统，则不能卸载，返回忙出错号。
	iput(inode);
   11431:	83 ec 0c             	sub    $0xc,%esp
   11434:	ff 74 24 18          	pushl  0x18(%esp)
   11438:	e8 65 e4 ff ff       	call   f8a2 <iput>
   1143d:	83 c4 10             	add    $0x10,%esp
	if (dev == ROOT_DEV)
   11440:	8b 83 4c 41 00 00    	mov    0x414c(%ebx),%eax
   11446:	39 44 24 08          	cmp    %eax,0x8(%esp)
   1144a:	75 0a                	jne    11456 <sys_umount+0x96>
		return -EBUSY;
   1144c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   11451:	e9 05 01 00 00       	jmp    1155b <sys_umount+0x19b>
	// 如果在超级块表中没有找到该设备上文件系统的超级块，或者已找到但是该设备上文件系统没有安装过，则返回出错码。如果超级块所指明
	// 被安装到的i节点并没有置位其安装标志i_mount，则显示警告信息。然后查找一下i节点表，看看是否有进程在使用该设备上的文件，如果
	// 有则返回忙出错码。
	if (!(sb = get_super(dev)) || !(sb->s_imount))
   11456:	83 ec 0c             	sub    $0xc,%esp
   11459:	ff 74 24 14          	pushl  0x14(%esp)
   1145d:	e8 44 fa ff ff       	call   10ea6 <get_super>
   11462:	83 c4 10             	add    $0x10,%esp
   11465:	89 44 24 04          	mov    %eax,0x4(%esp)
   11469:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   1146e:	74 0b                	je     1147b <sys_umount+0xbb>
   11470:	8b 44 24 04          	mov    0x4(%esp),%eax
   11474:	8b 40 5c             	mov    0x5c(%eax),%eax
   11477:	85 c0                	test   %eax,%eax
   11479:	75 0a                	jne    11485 <sys_umount+0xc5>
		return -ENOENT;
   1147b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   11480:	e9 d6 00 00 00       	jmp    1155b <sys_umount+0x19b>
	if (!sb->s_imount->i_mount)
   11485:	8b 44 24 04          	mov    0x4(%esp),%eax
   11489:	8b 40 5c             	mov    0x5c(%eax),%eax
   1148c:	0f b6 40 39          	movzbl 0x39(%eax),%eax
   11490:	84 c0                	test   %al,%al
   11492:	75 12                	jne    114a6 <sys_umount+0xe6>
		printk("Mounted inode has i_mount=0\n");
   11494:	83 ec 0c             	sub    $0xc,%esp
   11497:	8d 83 84 50 ff ff    	lea    -0xaf7c(%ebx),%eax
   1149d:	50                   	push   %eax
   1149e:	e8 8f 7e ff ff       	call   9332 <printk>
   114a3:	83 c4 10             	add    $0x10,%esp
	for (inode = inode_table + 0 ; inode < inode_table + NR_INODE ; inode++)
   114a6:	c7 c0 40 52 03 00    	mov    $0x35240,%eax
   114ac:	89 44 24 0c          	mov    %eax,0xc(%esp)
   114b0:	eb 2d                	jmp    114df <sys_umount+0x11f>
		if (inode->i_dev == dev && inode->i_count)
   114b2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   114b6:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   114ba:	0f b7 c0             	movzwl %ax,%eax
   114bd:	39 44 24 08          	cmp    %eax,0x8(%esp)
   114c1:	75 17                	jne    114da <sys_umount+0x11a>
   114c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   114c7:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   114cb:	66 85 c0             	test   %ax,%ax
   114ce:	74 0a                	je     114da <sys_umount+0x11a>
				return -EBUSY;
   114d0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   114d5:	e9 81 00 00 00       	jmp    1155b <sys_umount+0x19b>
	for (inode = inode_table + 0 ; inode < inode_table + NR_INODE ; inode++)
   114da:	83 44 24 0c 3c       	addl   $0x3c,0xc(%esp)
   114df:	c7 c0 40 52 03 00    	mov    $0x35240,%eax
   114e5:	8d 80 00 0f 00 00    	lea    0xf00(%eax),%eax
   114eb:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   114ef:	72 c1                	jb     114b2 <sys_umount+0xf2>
	// 现在该设备上文件系统的卸载条件均得到满足，因此我们可以开始实施真正的卸载操作了。首先复位被安装到的i节点的安装标志，释放该
	// i节点。然后置超级块中被安装i节点字段为空，并放回设备文件系统的根i节点，接着置超级块中被安装系统根i节点指针为空。
	sb->s_imount->i_mount = 0;
   114f1:	8b 44 24 04          	mov    0x4(%esp),%eax
   114f5:	8b 40 5c             	mov    0x5c(%eax),%eax
   114f8:	c6 40 39 00          	movb   $0x0,0x39(%eax)
	iput(sb->s_imount);
   114fc:	8b 44 24 04          	mov    0x4(%esp),%eax
   11500:	8b 40 5c             	mov    0x5c(%eax),%eax
   11503:	83 ec 0c             	sub    $0xc,%esp
   11506:	50                   	push   %eax
   11507:	e8 96 e3 ff ff       	call   f8a2 <iput>
   1150c:	83 c4 10             	add    $0x10,%esp
	sb->s_imount = NULL;
   1150f:	8b 44 24 04          	mov    0x4(%esp),%eax
   11513:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
	iput(sb->s_isup);
   1151a:	8b 44 24 04          	mov    0x4(%esp),%eax
   1151e:	8b 40 58             	mov    0x58(%eax),%eax
   11521:	83 ec 0c             	sub    $0xc,%esp
   11524:	50                   	push   %eax
   11525:	e8 78 e3 ff ff       	call   f8a2 <iput>
   1152a:	83 c4 10             	add    $0x10,%esp
	sb->s_isup = NULL;
   1152d:	8b 44 24 04          	mov    0x4(%esp),%eax
   11531:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	// 最后我们释放该设备上的超级块以及位图占用的高速缓冲块，并对该设备执行高速缓冲与设备上数据的同步操作。然后返回0（卸载成功）。
	put_super(dev);
   11538:	83 ec 0c             	sub    $0xc,%esp
   1153b:	ff 74 24 14          	pushl  0x14(%esp)
   1153f:	e8 ef f9 ff ff       	call   10f33 <put_super>
   11544:	83 c4 10             	add    $0x10,%esp
	sync_dev(dev);
   11547:	83 ec 0c             	sub    $0xc,%esp
   1154a:	ff 74 24 14          	pushl  0x14(%esp)
   1154e:	e8 ba ec ff ff       	call   1020d <sync_dev>
   11553:	83 c4 10             	add    $0x10,%esp
	return 0;
   11556:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1155b:	83 c4 18             	add    $0x18,%esp
   1155e:	5b                   	pop    %ebx
   1155f:	c3                   	ret    

00011560 <sys_mount>:

// 安装文件系统（系统调用）。
// 参数dev_name是设备文件名，dir_name是安装到的目录名，rw_flag被安装文件系统的可读写标志。将被加载的地方必须是一
// 个目录名，并且对应的i节点没有被其他程序占用。若操作成功则返回0,否则返回出错号。
int sys_mount(char * dev_name, char * dir_name, int rw_flag)
{
   11560:	53                   	push   %ebx
   11561:	83 ec 18             	sub    $0x18,%esp
   11564:	e8 91 57 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   11569:	81 c3 97 0a 02 00    	add    $0x20a97,%ebx
	struct super_block * sb;
	int dev;

	// 首先根据设备文件名找到对应的i节点，以取得其中的设备号。对于块特殊设备文件，设备号在其i节点的i_zone[0]中。另外，
	// 由于文件系统必须在块设备中，因此如果不是块设备文件，则放回刚得的i节点dev_i，返回出错码。
	if (!(dev_i = namei(dev_name)))
   1156f:	83 ec 0c             	sub    $0xc,%esp
   11572:	ff 74 24 2c          	pushl  0x2c(%esp)
   11576:	e8 32 37 00 00       	call   14cad <namei>
   1157b:	83 c4 10             	add    $0x10,%esp
   1157e:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11582:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11587:	75 0a                	jne    11593 <sys_mount+0x33>
		return -ENOENT;
   11589:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1158e:	e9 64 01 00 00       	jmp    116f7 <sys_mount+0x197>
	dev = dev_i->i_zone[0];
   11593:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11597:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1159b:	0f b7 c0             	movzwl %ax,%eax
   1159e:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!S_ISBLK(dev_i->i_mode)) {
   115a2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   115a6:	0f b7 00             	movzwl (%eax),%eax
   115a9:	0f b7 c0             	movzwl %ax,%eax
   115ac:	25 00 f0 00 00       	and    $0xf000,%eax
   115b1:	3d 00 60 00 00       	cmp    $0x6000,%eax
   115b6:	74 19                	je     115d1 <sys_mount+0x71>
		iput(dev_i);
   115b8:	83 ec 0c             	sub    $0xc,%esp
   115bb:	ff 74 24 18          	pushl  0x18(%esp)
   115bf:	e8 de e2 ff ff       	call   f8a2 <iput>
   115c4:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   115c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   115cc:	e9 26 01 00 00       	jmp    116f7 <sys_mount+0x197>
	}
	// OK，现在上面为了得到设备号而取得的i节点dev_i已经完成了它的使命，因此这里放回该设备文件的i节点。接着我们来检查一
	// 下文件系统安装到的目录名是否有效。于是根据给定的目录文件名找到对应的i节点dir_i。如果该i节点的引用计数不为1（仅在
	// 这里引用），或者该i节点的节点号是根文件系统的节点号1,则放回该i节点返回出错码。另外，如果该节点不是一个目录文件节点，
	// 则也放回该i节点，返回出错码。因为文件系统只能安装在一个目录名上。
	iput(dev_i);
   115d1:	83 ec 0c             	sub    $0xc,%esp
   115d4:	ff 74 24 18          	pushl  0x18(%esp)
   115d8:	e8 c5 e2 ff ff       	call   f8a2 <iput>
   115dd:	83 c4 10             	add    $0x10,%esp
	if (!(dir_i = namei(dir_name)))
   115e0:	83 ec 0c             	sub    $0xc,%esp
   115e3:	ff 74 24 30          	pushl  0x30(%esp)
   115e7:	e8 c1 36 00 00       	call   14cad <namei>
   115ec:	83 c4 10             	add    $0x10,%esp
   115ef:	89 44 24 04          	mov    %eax,0x4(%esp)
   115f3:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   115f8:	75 0a                	jne    11604 <sys_mount+0xa4>
		return -ENOENT;
   115fa:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   115ff:	e9 f3 00 00 00       	jmp    116f7 <sys_mount+0x197>
	if (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) {
   11604:	8b 44 24 04          	mov    0x4(%esp),%eax
   11608:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   1160c:	66 83 f8 01          	cmp    $0x1,%ax
   11610:	75 0e                	jne    11620 <sys_mount+0xc0>
   11612:	8b 44 24 04          	mov    0x4(%esp),%eax
   11616:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   1161a:	66 83 f8 01          	cmp    $0x1,%ax
   1161e:	75 19                	jne    11639 <sys_mount+0xd9>
		iput(dir_i);
   11620:	83 ec 0c             	sub    $0xc,%esp
   11623:	ff 74 24 10          	pushl  0x10(%esp)
   11627:	e8 76 e2 ff ff       	call   f8a2 <iput>
   1162c:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
   1162f:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   11634:	e9 be 00 00 00       	jmp    116f7 <sys_mount+0x197>
	}
	if (!S_ISDIR(dir_i->i_mode)) {          			// 安装点需要是一个目录名。
   11639:	8b 44 24 04          	mov    0x4(%esp),%eax
   1163d:	0f b7 00             	movzwl (%eax),%eax
   11640:	0f b7 c0             	movzwl %ax,%eax
   11643:	25 00 f0 00 00       	and    $0xf000,%eax
   11648:	3d 00 40 00 00       	cmp    $0x4000,%eax
   1164d:	74 19                	je     11668 <sys_mount+0x108>
		iput(dir_i);
   1164f:	83 ec 0c             	sub    $0xc,%esp
   11652:	ff 74 24 10          	pushl  0x10(%esp)
   11656:	e8 47 e2 ff ff       	call   f8a2 <iput>
   1165b:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   1165e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11663:	e9 8f 00 00 00       	jmp    116f7 <sys_mount+0x197>
	}
	// 现在安装点也检查完毕，我们开始读取要安装文件系统的超级块信息。如果读超级块操作失败，则放回该安装点i节点dir_i并返回
	// 出错码。一个文件系统的超级块会首先从超级块表中进行搜索，如果不在超级块表中就从设备上读取。
	if (!(sb = read_super(dev))) {
   11668:	83 ec 0c             	sub    $0xc,%esp
   1166b:	ff 74 24 14          	pushl  0x14(%esp)
   1166f:	e8 c4 f9 ff ff       	call   11038 <read_super>
   11674:	83 c4 10             	add    $0x10,%esp
   11677:	89 04 24             	mov    %eax,(%esp)
   1167a:	83 3c 24 00          	cmpl   $0x0,(%esp)
   1167e:	75 16                	jne    11696 <sys_mount+0x136>
		iput(dir_i);
   11680:	83 ec 0c             	sub    $0xc,%esp
   11683:	ff 74 24 10          	pushl  0x10(%esp)
   11687:	e8 16 e2 ff ff       	call   f8a2 <iput>
   1168c:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
   1168f:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   11694:	eb 61                	jmp    116f7 <sys_mount+0x197>
	}
	// 在等到了文件系统超级块之后，我们对它先进行检测一番。如果将要被安装的文件系统已经安装在其他地方，则放回该i节点，返回
	// 出错码。如果将要安装到的i节点已经安装了文件系统（安装标志已经置位），则放回该i节点，也返回出错码。
	if (sb->s_imount) {
   11696:	8b 04 24             	mov    (%esp),%eax
   11699:	8b 40 5c             	mov    0x5c(%eax),%eax
   1169c:	85 c0                	test   %eax,%eax
   1169e:	74 16                	je     116b6 <sys_mount+0x156>
		iput(dir_i);
   116a0:	83 ec 0c             	sub    $0xc,%esp
   116a3:	ff 74 24 10          	pushl  0x10(%esp)
   116a7:	e8 f6 e1 ff ff       	call   f8a2 <iput>
   116ac:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
   116af:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   116b4:	eb 41                	jmp    116f7 <sys_mount+0x197>
	}
	if (dir_i->i_mount) {
   116b6:	8b 44 24 04          	mov    0x4(%esp),%eax
   116ba:	0f b6 40 39          	movzbl 0x39(%eax),%eax
   116be:	84 c0                	test   %al,%al
   116c0:	74 16                	je     116d8 <sys_mount+0x178>
		iput(dir_i);
   116c2:	83 ec 0c             	sub    $0xc,%esp
   116c5:	ff 74 24 10          	pushl  0x10(%esp)
   116c9:	e8 d4 e1 ff ff       	call   f8a2 <iput>
   116ce:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   116d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   116d6:	eb 1f                	jmp    116f7 <sys_mount+0x197>
	}
	// 最后设置被安装文件系统超级块的“被安装到i节点”字段指向安装到的目录名的i节点。并设置安装位置i节点的安装标志和节点已修改
	// 标志。然后返回0（安装成功）。
	sb->s_imount = dir_i;
   116d8:	8b 04 24             	mov    (%esp),%eax
   116db:	8b 54 24 04          	mov    0x4(%esp),%edx
   116df:	89 50 5c             	mov    %edx,0x5c(%eax)
	dir_i->i_mount = 1;
   116e2:	8b 44 24 04          	mov    0x4(%esp),%eax
   116e6:	c6 40 39 01          	movb   $0x1,0x39(%eax)
	dir_i->i_dirt = 1;									/* NOTE! we don't iput(dir_i) */        /* 注意！这里没有用iput(dir_i) */
   116ea:	8b 44 24 04          	mov    0x4(%esp),%eax
   116ee:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	return 0;											/* we do that in umount */      /* 这将在umount内操作 */
   116f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   116f7:	83 c4 18             	add    $0x18,%esp
   116fa:	5b                   	pop    %ebx
   116fb:	c3                   	ret    

000116fc <mount_root>:

// 安装根文件系统.
// 该函数属于系统初始化操作的一部分.函数首先初始化文件表数组file_table[]和超级块表(数组),然后读取根文件系统超级块,并取得文件系统根i
// 节点.最后统计并显示出根文件系统上的可用资源(空闲块数和空闲i节点数0.该函数会在系统开机进行初始化设置时(sys_setup())调用(blk_drv/hd.c)>
void mount_root(void)
{
   116fc:	56                   	push   %esi
   116fd:	53                   	push   %ebx
   116fe:	83 ec 14             	sub    $0x14,%esp
   11701:	e8 f4 55 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   11706:	81 c3 fa 08 02 00    	add    $0x208fa,%ebx
	// 若磁盘i节点结构不是32字节,则出错停机.该判断用于防止修改代码时出现不一致情况.
	if (32 != sizeof (struct d_inode))
		panic("bad i-node size");
	// 首先初始化文件表数组(共64项,即系统同时只能打开64个文件)和超级块表.这里将所有文件结构中的引用计数设置为0(表示空闲),并把超级块表中各项结构
	// 的设备字段初始化为0(也表示空闲).如果根文件系统所在设备是软盘的话,就提示"插入根文件系统盘,并按回车键",并等待按键.
	for(i = 0; i < NR_FILE; i++)									// 初始化文件表.
   1170c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   11713:	00 
   11714:	eb 1c                	jmp    11732 <mount_root+0x36>
		file_table[i].f_count = 0;
   11716:	c7 c0 00 60 04 00    	mov    $0x46000,%eax
   1171c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11720:	c1 e2 04             	shl    $0x4,%edx
   11723:	01 d0                	add    %edx,%eax
   11725:	83 c0 04             	add    $0x4,%eax
   11728:	66 c7 00 00 00       	movw   $0x0,(%eax)
	for(i = 0; i < NR_FILE; i++)									// 初始化文件表.
   1172d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   11732:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
   11737:	7e dd                	jle    11716 <mount_root+0x1a>
	if (MAJOR(ROOT_DEV) == 2) {										// 提示插入根文件系统盘.
   11739:	8b 83 4c 41 00 00    	mov    0x414c(%ebx),%eax
   1173f:	c1 e8 08             	shr    $0x8,%eax
   11742:	83 f8 02             	cmp    $0x2,%eax
   11745:	75 17                	jne    1175e <mount_root+0x62>
		printk("Insert root floppy and press ENTER\r\n");
   11747:	83 ec 0c             	sub    $0xc,%esp
   1174a:	8d 83 a4 50 ff ff    	lea    -0xaf5c(%ebx),%eax
   11750:	50                   	push   %eax
   11751:	e8 dc 7b ff ff       	call   9332 <printk>
   11756:	83 c4 10             	add    $0x10,%esp
		wait_for_keypress();
   11759:	e8 99 94 00 00       	call   1abf7 <wait_for_keypress>
	}
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
   1175e:	c7 c0 a0 5c 04 00    	mov    $0x45ca0,%eax
   11764:	89 44 24 04          	mov    %eax,0x4(%esp)
   11768:	eb 22                	jmp    1178c <mount_root+0x90>
		p->s_dev = 0;												// 初始化超级块表
   1176a:	8b 44 24 04          	mov    0x4(%esp),%eax
   1176e:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		p->s_lock = 0;
   11774:	8b 44 24 04          	mov    0x4(%esp),%eax
   11778:	c6 40 68 00          	movb   $0x0,0x68(%eax)
		p->s_wait = NULL;
   1177c:	8b 44 24 04          	mov    0x4(%esp),%eax
   11780:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
   11787:	83 44 24 04 6c       	addl   $0x6c,0x4(%esp)
   1178c:	c7 c0 a0 5c 04 00    	mov    $0x45ca0,%eax
   11792:	8d 80 60 03 00 00    	lea    0x360(%eax),%eax
   11798:	39 44 24 04          	cmp    %eax,0x4(%esp)
   1179c:	72 cc                	jb     1176a <mount_root+0x6e>
	}
	// 做好以上"份外"的初始化工作之后,我们开始安装根文件系统.于是从根设备上读取文件系统超级块,并取得文件系统的根i节点(1号节点)在内存i节点表中的指针.
	// 如果读根设备上超级块失败或取根节点失败,则都显示信息并停机.
	if (!(p = read_super(ROOT_DEV)))
   1179e:	8b 83 4c 41 00 00    	mov    0x414c(%ebx),%eax
   117a4:	83 ec 0c             	sub    $0xc,%esp
   117a7:	50                   	push   %eax
   117a8:	e8 8b f8 ff ff       	call   11038 <read_super>
   117ad:	83 c4 10             	add    $0x10,%esp
   117b0:	89 44 24 04          	mov    %eax,0x4(%esp)
   117b4:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   117b9:	75 12                	jne    117cd <mount_root+0xd1>
		panic("Unable to mount root");
   117bb:	83 ec 0c             	sub    $0xc,%esp
   117be:	8d 83 c9 50 ff ff    	lea    -0xaf37(%ebx),%eax
   117c4:	50                   	push   %eax
   117c5:	e8 14 7b ff ff       	call   92de <panic>
   117ca:	83 c4 10             	add    $0x10,%esp
	if (!(mi = iget(ROOT_DEV, ROOT_INO)))							// 在fs.h中ROOT_INO定义为1.
   117cd:	8b 83 4c 41 00 00    	mov    0x414c(%ebx),%eax
   117d3:	83 ec 08             	sub    $0x8,%esp
   117d6:	6a 01                	push   $0x1
   117d8:	50                   	push   %eax
   117d9:	e8 88 e4 ff ff       	call   fc66 <iget>
   117de:	83 c4 10             	add    $0x10,%esp
   117e1:	89 04 24             	mov    %eax,(%esp)
   117e4:	83 3c 24 00          	cmpl   $0x0,(%esp)
   117e8:	75 12                	jne    117fc <mount_root+0x100>
		panic("Unable to read root i-node");
   117ea:	83 ec 0c             	sub    $0xc,%esp
   117ed:	8d 83 de 50 ff ff    	lea    -0xaf22(%ebx),%eax
   117f3:	50                   	push   %eax
   117f4:	e8 e5 7a ff ff       	call   92de <panic>
   117f9:	83 c4 10             	add    $0x10,%esp
	// 现在我们对超级块和根i节点进行设置.把根i节点引用次数递增3次.因为下面266行上也引用了该i节点.另外,iget()函数中i节点引用计数已被设置为1.然后置该
	// 超级块的被安装文件系统i节点和被安装到i节点字段为该i节点.再设置当前进程的当前工作目录和根目录i节点.此时当前进程是1号进程(init进程).
	mi->i_count += 3 ;												/* NOTE! it is logically used 4 times, not 1 */
   117fc:	8b 04 24             	mov    (%esp),%eax
   117ff:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   11803:	8d 50 03             	lea    0x3(%eax),%edx
   11806:	8b 04 24             	mov    (%esp),%eax
   11809:	66 89 50 34          	mov    %dx,0x34(%eax)
                                									/* 注意!从逻辑上讲,它已被引用了4次,而不是1次 */
	p->s_isup = p->s_imount = mi;
   1180d:	8b 44 24 04          	mov    0x4(%esp),%eax
   11811:	8b 14 24             	mov    (%esp),%edx
   11814:	89 50 5c             	mov    %edx,0x5c(%eax)
   11817:	8b 44 24 04          	mov    0x4(%esp),%eax
   1181b:	8b 50 5c             	mov    0x5c(%eax),%edx
   1181e:	8b 44 24 04          	mov    0x4(%esp),%eax
   11822:	89 50 58             	mov    %edx,0x58(%eax)
	current->pwd = mi;
   11825:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1182b:	8b 00                	mov    (%eax),%eax
   1182d:	8b 14 24             	mov    (%esp),%edx
   11830:	89 90 34 03 00 00    	mov    %edx,0x334(%eax)
	current->root = mi;
   11836:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1183c:	8b 00                	mov    (%eax),%eax
   1183e:	8b 14 24             	mov    (%esp),%edx
   11841:	89 90 38 03 00 00    	mov    %edx,0x338(%eax)
	// 然后我们对根文件系统上的资源作统计工作.统计该设备上空闲块数和空闲i节点数.首先令i等于超级块中表明的设备逻辑块总数.然后根据逻辑块位图中相应位的占用情况统计出空闲块数.
	// 这里宏函数set_bit()只是在测试位,而非设置位."i&8191"用于取得i节点号在当前位图块中对应的位偏移值."i>>13"是将i除以8192,也即除一个磁盘块包含的位数.
	free = 0;
   11847:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   1184e:	00 
	i = p->s_nzones;
   1184f:	8b 44 24 04          	mov    0x4(%esp),%eax
   11853:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   11857:	0f b7 c0             	movzwl %ax,%eax
   1185a:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (-- i >= 0)
   1185e:	eb 39                	jmp    11899 <mount_root+0x19d>
		if (!set_bit(i & 8191, p->s_zmap[i >> 13]->b_data))
   11860:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11864:	25 ff 1f 00 00       	and    $0x1fff,%eax
   11869:	89 c1                	mov    %eax,%ecx
   1186b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1186f:	c1 f8 0d             	sar    $0xd,%eax
   11872:	89 c2                	mov    %eax,%edx
   11874:	8b 44 24 04          	mov    0x4(%esp),%eax
   11878:	83 c2 0c             	add    $0xc,%edx
   1187b:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   1187f:	8b 10                	mov    (%eax),%edx
   11881:	b8 00 00 00 00       	mov    $0x0,%eax
   11886:	0f a3 0a             	bt     %ecx,(%edx)
   11889:	0f 92 c0             	setb   %al
   1188c:	89 c6                	mov    %eax,%esi
   1188e:	89 f0                	mov    %esi,%eax
   11890:	85 c0                	test   %eax,%eax
   11892:	75 05                	jne    11899 <mount_root+0x19d>
			free++;
   11894:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
	while (-- i >= 0)
   11899:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
   1189e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   118a3:	79 bb                	jns    11860 <mount_root+0x164>
	// 打印当前主设备上空闲和总的逻辑块数
	Log(LOG_INFO_TYPE, "<<<<< %d/%d free blocks >>>>>\n\r", free, p->s_nzones);
   118a5:	8b 44 24 04          	mov    0x4(%esp),%eax
   118a9:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   118ad:	0f b7 c0             	movzwl %ax,%eax
   118b0:	50                   	push   %eax
   118b1:	ff 74 24 0c          	pushl  0xc(%esp)
   118b5:	8d 83 fc 50 ff ff    	lea    -0xaf04(%ebx),%eax
   118bb:	50                   	push   %eax
   118bc:	6a 00                	push   $0x0
   118be:	e8 dc 42 01 00       	call   25b9f <Log>
   118c3:	83 c4 10             	add    $0x10,%esp
	// 在显示过设备上空闲逻辑块数/逻辑块总数之后.我们再统计设备上空闲i节点数.首先令i等于超级块中表明的设备上i中总数+1.加1是将0节点也统计进去.然后根据i节点位图中相应位的
	// 占用情况计算出空闲i节点数.最后再显示设备上可用空闲i节点数和i节点总数.
	free = 0;
   118c6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   118cd:	00 
	i = p->s_ninodes + 1;
   118ce:	8b 44 24 04          	mov    0x4(%esp),%eax
   118d2:	0f b7 00             	movzwl (%eax),%eax
   118d5:	0f b7 c0             	movzwl %ax,%eax
   118d8:	83 c0 01             	add    $0x1,%eax
   118db:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (-- i >= 0)
   118df:	eb 39                	jmp    1191a <mount_root+0x21e>
		if (!set_bit(i & 8191, p->s_imap[i >> 13]->b_data))
   118e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   118e5:	25 ff 1f 00 00       	and    $0x1fff,%eax
   118ea:	89 c1                	mov    %eax,%ecx
   118ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
   118f0:	c1 f8 0d             	sar    $0xd,%eax
   118f3:	89 c2                	mov    %eax,%edx
   118f5:	8b 44 24 04          	mov    0x4(%esp),%eax
   118f9:	83 c2 04             	add    $0x4,%edx
   118fc:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   11900:	8b 10                	mov    (%eax),%edx
   11902:	b8 00 00 00 00       	mov    $0x0,%eax
   11907:	0f a3 0a             	bt     %ecx,(%edx)
   1190a:	0f 92 c0             	setb   %al
   1190d:	89 c6                	mov    %eax,%esi
   1190f:	89 f0                	mov    %esi,%eax
   11911:	85 c0                	test   %eax,%eax
   11913:	75 05                	jne    1191a <mount_root+0x21e>
			free++;
   11915:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
	while (-- i >= 0)
   1191a:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
   1191f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11924:	79 bb                	jns    118e1 <mount_root+0x1e5>
	// 打印当前主设备上i节点空闲和总的数量
	Log(LOG_INFO_TYPE, "<<<<< %d/%d free inodes >>>>>\n\r", free, p->s_ninodes);
   11926:	8b 44 24 04          	mov    0x4(%esp),%eax
   1192a:	0f b7 00             	movzwl (%eax),%eax
   1192d:	0f b7 c0             	movzwl %ax,%eax
   11930:	50                   	push   %eax
   11931:	ff 74 24 0c          	pushl  0xc(%esp)
   11935:	8d 83 1c 51 ff ff    	lea    -0xaee4(%ebx),%eax
   1193b:	50                   	push   %eax
   1193c:	6a 00                	push   $0x0
   1193e:	e8 5c 42 01 00       	call   25b9f <Log>
   11943:	83 c4 10             	add    $0x10,%esp
}
   11946:	90                   	nop
   11947:	83 c4 14             	add    $0x14,%esp
   1194a:	5b                   	pop    %ebx
   1194b:	5e                   	pop    %esi
   1194c:	c3                   	ret    

0001194d <get_fs_byte>:
{
   1194d:	53                   	push   %ebx
   1194e:	e8 9f 53 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11953:	05 ad 06 02 00       	add    $0x206ad,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   11958:	8b 44 24 08          	mov    0x8(%esp),%eax
   1195c:	64 8a 00             	mov    %fs:(%eax),%al
   1195f:	89 c3                	mov    %eax,%ebx
	return _v;
   11961:	89 d8                	mov    %ebx,%eax
}
   11963:	5b                   	pop    %ebx
   11964:	c3                   	ret    

00011965 <put_fs_byte>:

//// 将一字节存放在fs段中指定内存地址处.
// 参数:val - 字节值;addr - 内存地址.
// %0 - 寄存器(字节值val);%1 - (内存地址addr).
static inline void put_fs_byte(char val,char *addr)
{
   11965:	83 ec 04             	sub    $0x4,%esp
   11968:	e8 85 53 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1196d:	05 93 06 02 00       	add    $0x20693,%eax
   11972:	8b 44 24 08          	mov    0x8(%esp),%eax
   11976:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   11979:	0f b6 04 24          	movzbl (%esp),%eax
   1197d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11981:	64 88 02             	mov    %al,%fs:(%edx)
}
   11984:	90                   	nop
   11985:	83 c4 04             	add    $0x4,%esp
   11988:	c3                   	ret    

00011989 <block_write>:
// 返回已写入字节数。若没有写入任何字节或出错，则返回出错号。
// 对于内核来说，写操作是向高速缓冲区中写入数据。什么时候数据最终写入设备是高速缓冲管理程序决定并处理的。另外，因为
// 块设备是以块为单位进行读写，因此对于写开始位置不处于块起始处时，需要先将开始字节所在整个块读出，然后将需要写的数据
// 从开始处填写满该块，再将完整的一块数据写盘（即交由高速缓冲程序去处理）。
int block_write(int dev, long * pos, char * buf, int count)
{
   11989:	56                   	push   %esi
   1198a:	53                   	push   %ebx
   1198b:	83 ec 24             	sub    $0x24,%esp
   1198e:	e8 67 53 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   11993:	81 c3 6d 06 02 00    	add    $0x2066d,%ebx
	// 首先由文件中位置pos换算成开始写盘块的块序号block，并求出需写第1字节在该块中的偏移位置offset。
	int block = *pos >> BLOCK_SIZE_BITS;            			// pos所在文件数据块号。
   11999:	8b 44 24 34          	mov    0x34(%esp),%eax
   1199d:	8b 00                	mov    (%eax),%eax
   1199f:	c1 f8 0a             	sar    $0xa,%eax
   119a2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	int offset = *pos & (BLOCK_SIZE - 1);             			// pos在数据块中偏移值。
   119a6:	8b 44 24 34          	mov    0x34(%esp),%eax
   119aa:	8b 00                	mov    (%eax),%eax
   119ac:	25 ff 03 00 00       	and    $0x3ff,%eax
   119b1:	89 44 24 18          	mov    %eax,0x18(%esp)
	int chars;
	int written = 0;
   119b5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   119bc:	00 
	register char * p;               	       					// 局部寄存器变量，被存放在寄存器中。

	// 在写一个块设备文件时，要求写的总数据块数当然不能超过指定设备上容许的最大数据块总数。因此这里首先取出指定
	// 设备的块总数size来比较和限制函数参数给定的读入数据长度。如果系统中没有对设备指定长度，就使用默认长度
	// 0x7fffffff（2GB个块）。
	if (blk_size[MAJOR(dev)])
   119bd:	8b 44 24 30          	mov    0x30(%esp),%eax
   119c1:	c1 e8 08             	shr    $0x8,%eax
   119c4:	89 c2                	mov    %eax,%edx
   119c6:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
   119cc:	8b 04 90             	mov    (%eax,%edx,4),%eax
   119cf:	85 c0                	test   %eax,%eax
   119d1:	74 29                	je     119fc <block_write+0x73>
		size = blk_size[MAJOR(dev)][MINOR(dev)];
   119d3:	8b 44 24 30          	mov    0x30(%esp),%eax
   119d7:	c1 e8 08             	shr    $0x8,%eax
   119da:	89 c2                	mov    %eax,%edx
   119dc:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
   119e2:	8b 04 90             	mov    (%eax,%edx,4),%eax
   119e5:	8b 54 24 30          	mov    0x30(%esp),%edx
   119e9:	0f b6 d2             	movzbl %dl,%edx
   119ec:	c1 e2 02             	shl    $0x2,%edx
   119ef:	01 d0                	add    %edx,%eax
   119f1:	8b 00                	mov    (%eax),%eax
   119f3:	89 44 24 0c          	mov    %eax,0xc(%esp)
   119f7:	e9 41 01 00 00       	jmp    11b3d <block_write+0x1b4>
	else
		size = 0x7fffffff;
   119fc:	c7 44 24 0c ff ff ff 	movl   $0x7fffffff,0xc(%esp)
   11a03:	7f 
	// 然后针对要写入的字节数count，循环执行以下操作，直到数据全部写入。在循环执行过程中，若当前写入数据的块号
	// 已经大于或等于指定设备的总块数，则返回已写字节数并退出。然后再计算在当前处理的数据块中可写入的字节数。如果
	// 需要写入的字节数填不满一块，那么就只需写count字节。如果正好写1块数据内容，则直接申请1块高速缓冲块，并把
	// 用户数据放入即可。否则就需要读入将被写入部分数据的数据块，并预读下两块数据。然后将块号递增1,为下次操作做好
	// 准备。如果缓冲块操作失败，则返回已写字节数，如果没有写入任何字节，则返回出错号（负数）。
	while (count > 0) {
   11a04:	e9 34 01 00 00       	jmp    11b3d <block_write+0x1b4>
		if (block >= size)
   11a09:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11a0d:	3b 44 24 0c          	cmp    0xc(%esp),%eax
   11a11:	7c 1a                	jl     11a2d <block_write+0xa4>
			return written ? written : -EIO;
   11a13:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   11a18:	74 09                	je     11a23 <block_write+0x9a>
   11a1a:	8b 44 24 10          	mov    0x10(%esp),%eax
   11a1e:	e9 29 01 00 00       	jmp    11b4c <block_write+0x1c3>
   11a23:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   11a28:	e9 1f 01 00 00       	jmp    11b4c <block_write+0x1c3>
		chars = BLOCK_SIZE - offset;
   11a2d:	b8 00 04 00 00       	mov    $0x400,%eax
   11a32:	2b 44 24 18          	sub    0x18(%esp),%eax
   11a36:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars > count)
   11a3a:	8b 44 24 14          	mov    0x14(%esp),%eax
   11a3e:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
   11a42:	7e 08                	jle    11a4c <block_write+0xc3>
			chars = count;
   11a44:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   11a48:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars == BLOCK_SIZE)
   11a4c:	81 7c 24 14 00 04 00 	cmpl   $0x400,0x14(%esp)
   11a53:	00 
   11a54:	75 19                	jne    11a6f <block_write+0xe6>
			bh = getblk(dev, block);
   11a56:	83 ec 08             	sub    $0x8,%esp
   11a59:	ff 74 24 24          	pushl  0x24(%esp)
   11a5d:	ff 74 24 3c          	pushl  0x3c(%esp)
   11a61:	e8 3b ed ff ff       	call   107a1 <getblk>
   11a66:	83 c4 10             	add    $0x10,%esp
   11a69:	89 44 24 08          	mov    %eax,0x8(%esp)
   11a6d:	eb 29                	jmp    11a98 <block_write+0x10f>
		else
			bh = breada(dev, block, block + 1, block + 2, -1);
   11a6f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11a73:	8d 50 02             	lea    0x2(%eax),%edx
   11a76:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11a7a:	83 c0 01             	add    $0x1,%eax
   11a7d:	83 ec 0c             	sub    $0xc,%esp
   11a80:	6a ff                	push   $0xffffffff
   11a82:	52                   	push   %edx
   11a83:	50                   	push   %eax
   11a84:	ff 74 24 34          	pushl  0x34(%esp)
   11a88:	ff 74 24 4c          	pushl  0x4c(%esp)
   11a8c:	e8 1b f1 ff ff       	call   10bac <breada>
   11a91:	83 c4 20             	add    $0x20,%esp
   11a94:	89 44 24 08          	mov    %eax,0x8(%esp)
		block++;
   11a98:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
		if (!bh)
   11a9d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   11aa2:	75 1a                	jne    11abe <block_write+0x135>
			return written ? written : -EIO;
   11aa4:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   11aa9:	74 09                	je     11ab4 <block_write+0x12b>
   11aab:	8b 44 24 10          	mov    0x10(%esp),%eax
   11aaf:	e9 98 00 00 00       	jmp    11b4c <block_write+0x1c3>
   11ab4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   11ab9:	e9 8e 00 00 00       	jmp    11b4c <block_write+0x1c3>
		// 接着先把指针p指向读出数据的缓冲块中开始写入数据的位置处。若最后一次循环写入的数据不足一块，则需要从块开始
		// 处填写（修改）所需的字节，因此这里需预先设置offset为零。此后将文件中偏移指针pos前移此次将要写的字节数chars
		// 并累加这些要写的字节数到统计值written中。再把还需要写的计数值count减去此次要写的字节数chars。然后我们从
		// 用户缓冲区复制chars个字节到p指向的高速缓冲块中开始写入的位置处。复制完后就设置该缓冲区块已修改标志，并释放
		// 该缓冲区（即该缓冲区引用计数递减1）。
		p = offset + bh->b_data;
   11abe:	8b 44 24 08          	mov    0x8(%esp),%eax
   11ac2:	8b 10                	mov    (%eax),%edx
   11ac4:	8b 44 24 18          	mov    0x18(%esp),%eax
   11ac8:	8d 34 02             	lea    (%edx,%eax,1),%esi
		offset = 0;
   11acb:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   11ad2:	00 
		*pos += chars;
   11ad3:	8b 44 24 34          	mov    0x34(%esp),%eax
   11ad7:	8b 10                	mov    (%eax),%edx
   11ad9:	8b 44 24 14          	mov    0x14(%esp),%eax
   11add:	01 c2                	add    %eax,%edx
   11adf:	8b 44 24 34          	mov    0x34(%esp),%eax
   11ae3:	89 10                	mov    %edx,(%eax)
		written += chars;               						// 累计写入字节数。
   11ae5:	8b 44 24 14          	mov    0x14(%esp),%eax
   11ae9:	01 44 24 10          	add    %eax,0x10(%esp)
		count -= chars;
   11aed:	8b 44 24 14          	mov    0x14(%esp),%eax
   11af1:	29 44 24 3c          	sub    %eax,0x3c(%esp)
		while (chars-- > 0)
   11af5:	eb 20                	jmp    11b17 <block_write+0x18e>
			*(p++) = get_fs_byte(buf++);
   11af7:	8b 44 24 38          	mov    0x38(%esp),%eax
   11afb:	8d 50 01             	lea    0x1(%eax),%edx
   11afe:	89 54 24 38          	mov    %edx,0x38(%esp)
   11b02:	83 ec 0c             	sub    $0xc,%esp
   11b05:	50                   	push   %eax
   11b06:	e8 42 fe ff ff       	call   1194d <get_fs_byte>
   11b0b:	83 c4 10             	add    $0x10,%esp
   11b0e:	89 c2                	mov    %eax,%edx
   11b10:	89 f0                	mov    %esi,%eax
   11b12:	8d 70 01             	lea    0x1(%eax),%esi
   11b15:	88 10                	mov    %dl,(%eax)
		while (chars-- > 0)
   11b17:	8b 44 24 14          	mov    0x14(%esp),%eax
   11b1b:	8d 50 ff             	lea    -0x1(%eax),%edx
   11b1e:	89 54 24 14          	mov    %edx,0x14(%esp)
   11b22:	85 c0                	test   %eax,%eax
   11b24:	7f d1                	jg     11af7 <block_write+0x16e>
		bh->b_dirt = 1;
   11b26:	8b 44 24 08          	mov    0x8(%esp),%eax
   11b2a:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
   11b2e:	83 ec 0c             	sub    $0xc,%esp
   11b31:	ff 74 24 14          	pushl  0x14(%esp)
   11b35:	e8 31 ee ff ff       	call   1096b <brelse>
   11b3a:	83 c4 10             	add    $0x10,%esp
	while (count > 0) {
   11b3d:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
   11b42:	0f 8f c1 fe ff ff    	jg     11a09 <block_write+0x80>
	}
	return written;                         					// 返回已写入的字节数，正常退出。
   11b48:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   11b4c:	83 c4 24             	add    $0x24,%esp
   11b4f:	5b                   	pop    %ebx
   11b50:	5e                   	pop    %esi
   11b51:	c3                   	ret    

00011b52 <block_read>:

// 数据块读函数 - 从指定设备和位置处读入指定长度数据到用户缓冲区中。
// 参数：dev - 设备号；pos - 设备文件中领衔量指针；buf - 用户空间中缓冲区地址；count - 要传送的字节数。
// 返回已读入字节数。若没有读入任何字节或出错，则返回出错号。
int block_read(int dev, unsigned long * pos, char * buf, int count)
{
   11b52:	56                   	push   %esi
   11b53:	53                   	push   %ebx
   11b54:	83 ec 24             	sub    $0x24,%esp
   11b57:	e8 9e 51 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   11b5c:	81 c3 a4 04 02 00    	add    $0x204a4,%ebx
	int block = *pos >> BLOCK_SIZE_BITS;
   11b62:	8b 44 24 34          	mov    0x34(%esp),%eax
   11b66:	8b 00                	mov    (%eax),%eax
   11b68:	c1 e8 0a             	shr    $0xa,%eax
   11b6b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	int offset = *pos & (BLOCK_SIZE - 1);
   11b6f:	8b 44 24 34          	mov    0x34(%esp),%eax
   11b73:	8b 00                	mov    (%eax),%eax
   11b75:	25 ff 03 00 00       	and    $0x3ff,%eax
   11b7a:	89 44 24 18          	mov    %eax,0x18(%esp)
	int chars;
	int size;
	int read = 0;
   11b7e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   11b85:	00 
	register char * p;              							// 局部寄存器变量，被存放在寄存器中。

	// 在读一个块设备文件时，要求读的总数据块数当然不能超过指定设备上容许的最大数据块总数。因此这里首先取出指定
	// 设备的块总数size来比较和限制函数参数给定的读入数据长度。如果系统中没有对设备指定长度，就使用默认长度
	// 0x7fffffff（2GB个块）。
	if (blk_size[MAJOR(dev)])
   11b86:	8b 44 24 30          	mov    0x30(%esp),%eax
   11b8a:	c1 e8 08             	shr    $0x8,%eax
   11b8d:	89 c2                	mov    %eax,%edx
   11b8f:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
   11b95:	8b 04 90             	mov    (%eax,%edx,4),%eax
   11b98:	85 c0                	test   %eax,%eax
   11b9a:	74 29                	je     11bc5 <block_read+0x73>
		size = blk_size[MAJOR(dev)][MINOR(dev)];
   11b9c:	8b 44 24 30          	mov    0x30(%esp),%eax
   11ba0:	c1 e8 08             	shr    $0x8,%eax
   11ba3:	89 c2                	mov    %eax,%edx
   11ba5:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
   11bab:	8b 04 90             	mov    (%eax,%edx,4),%eax
   11bae:	8b 54 24 30          	mov    0x30(%esp),%edx
   11bb2:	0f b6 d2             	movzbl %dl,%edx
   11bb5:	c1 e2 02             	shl    $0x2,%edx
   11bb8:	01 d0                	add    %edx,%eax
   11bba:	8b 00                	mov    (%eax),%eax
   11bbc:	89 44 24 10          	mov    %eax,0x10(%esp)
   11bc0:	e9 19 01 00 00       	jmp    11cde <block_read+0x18c>
	else
		size = 0x7fffffff;
   11bc5:	c7 44 24 10 ff ff ff 	movl   $0x7fffffff,0x10(%esp)
   11bcc:	7f 
	// 然后针对要读入的字节数count，循环执行以下操作，直到数据全部读入。在循环执行过程中，若当前读入数据的块号已经
	// 大于或等于指定设备的总块数，则返回已读字节数并退出。然后再计算在当前处理的数据块中需读入的字节数。如果需要读
	// 入的字节数还不满一块，那么就只需读count字节。然后调用读块函数breada()读入需要的数据块，并预读下两块数据，
	// 如果读操作出错，则返回已读字节数，如果没有读入任何字节，则返回出错号。然后将块号递增1。为下次操作做好准备。如
	// 果缓冲块担操失败，则返回已写字节数，如果没有读入任何字节，则返回出错号（负数）。
	while (count > 0) {
   11bcd:	e9 0c 01 00 00       	jmp    11cde <block_read+0x18c>
		if (block >= size)
   11bd2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11bd6:	3b 44 24 10          	cmp    0x10(%esp),%eax
   11bda:	7c 1a                	jl     11bf6 <block_read+0xa4>
			return read ? read : -EIO;
   11bdc:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11be1:	74 09                	je     11bec <block_read+0x9a>
   11be3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11be7:	e9 01 01 00 00       	jmp    11ced <block_read+0x19b>
   11bec:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   11bf1:	e9 f7 00 00 00       	jmp    11ced <block_read+0x19b>
		chars = BLOCK_SIZE - offset;
   11bf6:	b8 00 04 00 00       	mov    $0x400,%eax
   11bfb:	2b 44 24 18          	sub    0x18(%esp),%eax
   11bff:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars > count)
   11c03:	8b 44 24 14          	mov    0x14(%esp),%eax
   11c07:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
   11c0b:	7e 08                	jle    11c15 <block_read+0xc3>
			chars = count;
   11c0d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   11c11:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (!(bh = breada(dev, block, block + 1, block + 2, -1)))
   11c15:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11c19:	8d 50 02             	lea    0x2(%eax),%edx
   11c1c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11c20:	83 c0 01             	add    $0x1,%eax
   11c23:	83 ec 0c             	sub    $0xc,%esp
   11c26:	6a ff                	push   $0xffffffff
   11c28:	52                   	push   %edx
   11c29:	50                   	push   %eax
   11c2a:	ff 74 24 34          	pushl  0x34(%esp)
   11c2e:	ff 74 24 4c          	pushl  0x4c(%esp)
   11c32:	e8 75 ef ff ff       	call   10bac <breada>
   11c37:	83 c4 20             	add    $0x20,%esp
   11c3a:	89 44 24 08          	mov    %eax,0x8(%esp)
   11c3e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   11c43:	75 1a                	jne    11c5f <block_read+0x10d>
			return read ? read : -EIO;
   11c45:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11c4a:	74 09                	je     11c55 <block_read+0x103>
   11c4c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11c50:	e9 98 00 00 00       	jmp    11ced <block_read+0x19b>
   11c55:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   11c5a:	e9 8e 00 00 00       	jmp    11ced <block_read+0x19b>
		block++;
   11c5f:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
		// 接着先把指针p指向读出盘块中开始读入数据的位置处。若最后一次循环读操作的数据不足一块，则需从块起始处读取所需字
		// 节，因此这里需预先设置offset为零。此后将文件中偏移指针pos前移此次将要读的字节数chars，并且累加这些要读的字节
		// 数到统计值read中。再把还需要读的计数值count减去此次要读的字节数chars。然后我们从高速缓冲块中p指向的开始读的
		// 位置处复制chars个字节到用户缓冲区中，同时把用户缓冲区指针前移。本次复制完后就释放该缓冲块。
		p = offset + bh->b_data;
   11c64:	8b 44 24 08          	mov    0x8(%esp),%eax
   11c68:	8b 10                	mov    (%eax),%edx
   11c6a:	8b 44 24 18          	mov    0x18(%esp),%eax
   11c6e:	8d 34 02             	lea    (%edx,%eax,1),%esi
		offset = 0;
   11c71:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   11c78:	00 
		*pos += chars;
   11c79:	8b 44 24 34          	mov    0x34(%esp),%eax
   11c7d:	8b 10                	mov    (%eax),%edx
   11c7f:	8b 44 24 14          	mov    0x14(%esp),%eax
   11c83:	01 c2                	add    %eax,%edx
   11c85:	8b 44 24 34          	mov    0x34(%esp),%eax
   11c89:	89 10                	mov    %edx,(%eax)
		read += chars;                  						// 累计读入字节数。
   11c8b:	8b 44 24 14          	mov    0x14(%esp),%eax
   11c8f:	01 44 24 0c          	add    %eax,0xc(%esp)
		count -= chars;
   11c93:	8b 44 24 14          	mov    0x14(%esp),%eax
   11c97:	29 44 24 3c          	sub    %eax,0x3c(%esp)
		while (chars-- > 0)
   11c9b:	eb 23                	jmp    11cc0 <block_read+0x16e>
			put_fs_byte(*(p++), buf++);
   11c9d:	8b 44 24 38          	mov    0x38(%esp),%eax
   11ca1:	8d 50 01             	lea    0x1(%eax),%edx
   11ca4:	89 54 24 38          	mov    %edx,0x38(%esp)
   11ca8:	89 f2                	mov    %esi,%edx
   11caa:	8d 72 01             	lea    0x1(%edx),%esi
   11cad:	0f b6 12             	movzbl (%edx),%edx
   11cb0:	0f be d2             	movsbl %dl,%edx
   11cb3:	83 ec 08             	sub    $0x8,%esp
   11cb6:	50                   	push   %eax
   11cb7:	52                   	push   %edx
   11cb8:	e8 a8 fc ff ff       	call   11965 <put_fs_byte>
   11cbd:	83 c4 10             	add    $0x10,%esp
		while (chars-- > 0)
   11cc0:	8b 44 24 14          	mov    0x14(%esp),%eax
   11cc4:	8d 50 ff             	lea    -0x1(%eax),%edx
   11cc7:	89 54 24 14          	mov    %edx,0x14(%esp)
   11ccb:	85 c0                	test   %eax,%eax
   11ccd:	7f ce                	jg     11c9d <block_read+0x14b>
		brelse(bh);
   11ccf:	83 ec 0c             	sub    $0xc,%esp
   11cd2:	ff 74 24 14          	pushl  0x14(%esp)
   11cd6:	e8 90 ec ff ff       	call   1096b <brelse>
   11cdb:	83 c4 10             	add    $0x10,%esp
	while (count > 0) {
   11cde:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
   11ce3:	0f 8f e9 fe ff ff    	jg     11bd2 <block_read+0x80>
	}
	return read;                            					// 返回已读取的字节数，正常退出。
   11ce9:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   11ced:	83 c4 24             	add    $0x24,%esp
   11cf0:	5b                   	pop    %ebx
   11cf1:	5e                   	pop    %esi
   11cf2:	c3                   	ret    

00011cf3 <get_fs_byte>:
{
   11cf3:	53                   	push   %ebx
   11cf4:	e8 f9 4f ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11cf9:	05 07 03 02 00       	add    $0x20307,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   11cfe:	8b 44 24 08          	mov    0x8(%esp),%eax
   11d02:	64 8a 00             	mov    %fs:(%eax),%al
   11d05:	89 c3                	mov    %eax,%ebx
	return _v;
   11d07:	89 d8                	mov    %ebx,%eax
}
   11d09:	5b                   	pop    %ebx
   11d0a:	c3                   	ret    

00011d0b <put_fs_byte>:
{
   11d0b:	83 ec 04             	sub    $0x4,%esp
   11d0e:	e8 df 4f ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11d13:	05 ed 02 02 00       	add    $0x202ed,%eax
   11d18:	8b 44 24 08          	mov    0x8(%esp),%eax
   11d1c:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   11d1f:	0f b6 04 24          	movzbl (%esp),%eax
   11d23:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11d27:	64 88 02             	mov    %al,%fs:(%edx)
}
   11d2a:	90                   	nop
   11d2b:	83 c4 04             	add    $0x4,%esp
   11d2e:	c3                   	ret    

00011d2f <rw_ttyx>:

// 串口终端读写操作函数.
// 参数:rw - 读写命令;minor - 终端子设备号;buf - 缓冲区;count - 读写字节数;pos - 读写操作当前指针,对于终端操作,该指针无用.
// 返回:实际读写的字节数.若失败则返回出错码.
static int rw_ttyx(int rw, unsigned minor, char * buf, int count, off_t * pos)
{
   11d2f:	53                   	push   %ebx
   11d30:	83 ec 08             	sub    $0x8,%esp
   11d33:	e8 ba 4f ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11d38:	05 c8 02 02 00       	add    $0x202c8,%eax
	return ((rw == READ) ? tty_read(minor, buf, count): tty_write(minor, buf, count));
   11d3d:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   11d42:	75 1b                	jne    11d5f <rw_ttyx+0x30>
   11d44:	83 ec 04             	sub    $0x4,%esp
   11d47:	ff 74 24 20          	pushl  0x20(%esp)
   11d4b:	ff 74 24 20          	pushl  0x20(%esp)
   11d4f:	ff 74 24 20          	pushl  0x20(%esp)
   11d53:	89 c3                	mov    %eax,%ebx
   11d55:	e8 31 97 00 00       	call   1b48b <tty_read>
   11d5a:	83 c4 10             	add    $0x10,%esp
   11d5d:	eb 19                	jmp    11d78 <rw_ttyx+0x49>
   11d5f:	83 ec 04             	sub    $0x4,%esp
   11d62:	ff 74 24 20          	pushl  0x20(%esp)
   11d66:	ff 74 24 20          	pushl  0x20(%esp)
   11d6a:	ff 74 24 20          	pushl  0x20(%esp)
   11d6e:	89 c3                	mov    %eax,%ebx
   11d70:	e8 9f 9b 00 00       	call   1b914 <tty_write>
   11d75:	83 c4 10             	add    $0x10,%esp
}
   11d78:	83 c4 08             	add    $0x8,%esp
   11d7b:	5b                   	pop    %ebx
   11d7c:	c3                   	ret    

00011d7d <rw_tty>:

// 终端读写操作函数。
// 同rw_ttyx()类似，只是增加了对进程是否有控制终端的检测。
static int rw_tty(int rw, unsigned minor, char * buf, int count, off_t * pos)
{
   11d7d:	83 ec 0c             	sub    $0xc,%esp
   11d80:	e8 6d 4f ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11d85:	05 7b 02 02 00       	add    $0x2027b,%eax
	// 若进程没有对应的控制终端，则返回出错号。否则调用终端读写函数rw_ttyx()，并返回实际读写字节数。
	if (current->tty < 0)
   11d8a:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   11d90:	8b 12                	mov    (%edx),%edx
   11d92:	8b 92 2c 03 00 00    	mov    0x32c(%edx),%edx
   11d98:	85 d2                	test   %edx,%edx
   11d9a:	79 07                	jns    11da3 <rw_tty+0x26>
		return -EPERM;
   11d9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11da1:	eb 2a                	jmp    11dcd <rw_tty+0x50>
	return rw_ttyx(rw, current->tty, buf, count, pos);
   11da3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   11da9:	8b 00                	mov    (%eax),%eax
   11dab:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
   11db1:	83 ec 0c             	sub    $0xc,%esp
   11db4:	ff 74 24 2c          	pushl  0x2c(%esp)
   11db8:	ff 74 24 2c          	pushl  0x2c(%esp)
   11dbc:	ff 74 24 2c          	pushl  0x2c(%esp)
   11dc0:	50                   	push   %eax
   11dc1:	ff 74 24 2c          	pushl  0x2c(%esp)
   11dc5:	e8 65 ff ff ff       	call   11d2f <rw_ttyx>
   11dca:	83 c4 20             	add    $0x20,%esp
}
   11dcd:	83 c4 0c             	add    $0xc,%esp
   11dd0:	c3                   	ret    

00011dd1 <rw_ram>:

// 内在数据读写。未实现。
static int rw_ram(int rw,char * buf, int count, off_t *pos)
{
   11dd1:	e8 1c 4f ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11dd6:	05 2a 02 02 00       	add    $0x2022a,%eax
	return -EIO;
   11ddb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
   11de0:	c3                   	ret    

00011de1 <rw_mem>:

// 物理内存数据读写操作函数。未实现。
static int rw_mem(int rw,char * buf, int count, off_t * pos)
{
   11de1:	e8 0c 4f ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11de6:	05 1a 02 02 00       	add    $0x2021a,%eax
	return -EIO;
   11deb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
   11df0:	c3                   	ret    

00011df1 <rw_kmem>:

// 内核虚拟内存数据读写函数。未实现。
static int rw_kmem(int rw,char * buf, int count, off_t * pos)
{
   11df1:	e8 fc 4e ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11df6:	05 0a 02 02 00       	add    $0x2020a,%eax
	return -EIO;
   11dfb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
   11e00:	c3                   	ret    

00011e01 <rw_port>:

// 端口读写操作函数。
// 参数：rw - 读写命令；buf - 缓冲区；count - 读写字节数；post - 端口地址。
// 返回：实际读写的字节数。
static int rw_port(int rw,char * buf, int count, off_t * pos)
{
   11e01:	83 ec 10             	sub    $0x10,%esp
   11e04:	e8 e9 4e ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11e09:	05 f7 01 02 00       	add    $0x201f7,%eax
	int i = *pos;
   11e0e:	8b 44 24 20          	mov    0x20(%esp),%eax
   11e12:	8b 00                	mov    (%eax),%eax
   11e14:	89 44 24 0c          	mov    %eax,0xc(%esp)

	// 对于所要求读写的字节数，并且端口地址小于64k时，循环执行单个字节的读写操作。
	// 若是读命令，则从端口i中读取一字节内容并放到用户缓冲区中。若是写命令，则从用户数据缓冲区中取一字节输出到端口i。
	while (count-- > 0 && i < 65536) {
   11e18:	eb 4f                	jmp    11e69 <rw_port+0x68>
		if (rw == READ)
   11e1a:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   11e1f:	75 2a                	jne    11e4b <rw_port+0x4a>
			put_fs_byte(inb(i), buf++);
   11e21:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   11e25:	8d 41 01             	lea    0x1(%ecx),%eax
   11e28:	89 44 24 18          	mov    %eax,0x18(%esp)
   11e2c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11e30:	89 c2                	mov    %eax,%edx
   11e32:	ec                   	in     (%dx),%al
   11e33:	88 44 24 0b          	mov    %al,0xb(%esp)
   11e37:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   11e3c:	0f be c0             	movsbl %al,%eax
   11e3f:	51                   	push   %ecx
   11e40:	50                   	push   %eax
   11e41:	e8 c5 fe ff ff       	call   11d0b <put_fs_byte>
   11e46:	83 c4 08             	add    $0x8,%esp
   11e49:	eb 19                	jmp    11e64 <rw_port+0x63>
		else
			outb(get_fs_byte(buf++), i);
   11e4b:	8b 44 24 18          	mov    0x18(%esp),%eax
   11e4f:	8d 50 01             	lea    0x1(%eax),%edx
   11e52:	89 54 24 18          	mov    %edx,0x18(%esp)
   11e56:	50                   	push   %eax
   11e57:	e8 97 fe ff ff       	call   11cf3 <get_fs_byte>
   11e5c:	83 c4 04             	add    $0x4,%esp
   11e5f:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11e63:	ee                   	out    %al,(%dx)
		i++;            						// 前移一个端口。[好奇怪，端口地址为什么会变化？]
   11e64:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
	while (count-- > 0 && i < 65536) {
   11e69:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11e6d:	8d 50 ff             	lea    -0x1(%eax),%edx
   11e70:	89 54 24 1c          	mov    %edx,0x1c(%esp)
   11e74:	85 c0                	test   %eax,%eax
   11e76:	7e 0a                	jle    11e82 <rw_port+0x81>
   11e78:	81 7c 24 0c ff ff 00 	cmpl   $0xffff,0xc(%esp)
   11e7f:	00 
   11e80:	7e 98                	jle    11e1a <rw_port+0x19>
	}
	// 然后计算读/写的字节数，调整相应读写指针，并返回读/写的字节数。
	i -= *pos;
   11e82:	8b 44 24 20          	mov    0x20(%esp),%eax
   11e86:	8b 00                	mov    (%eax),%eax
   11e88:	29 44 24 0c          	sub    %eax,0xc(%esp)
	*pos += i;
   11e8c:	8b 44 24 20          	mov    0x20(%esp),%eax
   11e90:	8b 10                	mov    (%eax),%edx
   11e92:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11e96:	01 c2                	add    %eax,%edx
   11e98:	8b 44 24 20          	mov    0x20(%esp),%eax
   11e9c:	89 10                	mov    %edx,(%eax)
	return i;
   11e9e:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   11ea2:	83 c4 10             	add    $0x10,%esp
   11ea5:	c3                   	ret    

00011ea6 <rw_memory>:

// 内存读写操作函数。
static int rw_memory(int rw, unsigned minor, char * buf, int count, off_t * pos)
{
   11ea6:	e8 47 4e ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11eab:	05 55 01 02 00       	add    $0x20155,%eax
	// 根据内存设备子设备号，分别调用不同的内存读写函数。
	switch(minor) {
   11eb0:	83 7c 24 08 04       	cmpl   $0x4,0x8(%esp)
   11eb5:	0f 87 88 00 00 00    	ja     11f43 <.L31+0x19>
   11ebb:	8b 54 24 08          	mov    0x8(%esp),%edx
   11ebf:	c1 e2 02             	shl    $0x2,%edx
   11ec2:	8b 94 02 3c 51 ff ff 	mov    -0xaec4(%edx,%eax,1),%edx
   11ec9:	01 d0                	add    %edx,%eax
   11ecb:	ff e0                	jmp    *%eax

00011ecd <.L26>:
		case 0:
			return rw_ram(rw, buf, count, pos);
   11ecd:	ff 74 24 14          	pushl  0x14(%esp)
   11ed1:	ff 74 24 14          	pushl  0x14(%esp)
   11ed5:	ff 74 24 14          	pushl  0x14(%esp)
   11ed9:	ff 74 24 10          	pushl  0x10(%esp)
   11edd:	e8 ef fe ff ff       	call   11dd1 <rw_ram>
   11ee2:	83 c4 10             	add    $0x10,%esp
   11ee5:	c3                   	ret    

00011ee6 <.L28>:
		case 1:
			return rw_mem(rw, buf, count, pos);
   11ee6:	ff 74 24 14          	pushl  0x14(%esp)
   11eea:	ff 74 24 14          	pushl  0x14(%esp)
   11eee:	ff 74 24 14          	pushl  0x14(%esp)
   11ef2:	ff 74 24 10          	pushl  0x10(%esp)
   11ef6:	e8 e6 fe ff ff       	call   11de1 <rw_mem>
   11efb:	83 c4 10             	add    $0x10,%esp
   11efe:	c3                   	ret    

00011eff <.L29>:
		case 2:
			return rw_kmem(rw, buf, count, pos);
   11eff:	ff 74 24 14          	pushl  0x14(%esp)
   11f03:	ff 74 24 14          	pushl  0x14(%esp)
   11f07:	ff 74 24 14          	pushl  0x14(%esp)
   11f0b:	ff 74 24 10          	pushl  0x10(%esp)
   11f0f:	e8 dd fe ff ff       	call   11df1 <rw_kmem>
   11f14:	83 c4 10             	add    $0x10,%esp
   11f17:	c3                   	ret    

00011f18 <.L30>:
		case 3:
			return (rw == READ) ? 0 : count;					/* rw_null */
   11f18:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   11f1d:	74 05                	je     11f24 <.L30+0xc>
   11f1f:	8b 44 24 10          	mov    0x10(%esp),%eax
   11f23:	c3                   	ret    
   11f24:	b8 00 00 00 00       	mov    $0x0,%eax
   11f29:	c3                   	ret    

00011f2a <.L31>:
		case 4:
			return rw_port(rw, buf, count, pos);
   11f2a:	ff 74 24 14          	pushl  0x14(%esp)
   11f2e:	ff 74 24 14          	pushl  0x14(%esp)
   11f32:	ff 74 24 14          	pushl  0x14(%esp)
   11f36:	ff 74 24 10          	pushl  0x10(%esp)
   11f3a:	e8 c2 fe ff ff       	call   11e01 <rw_port>
   11f3f:	83 c4 10             	add    $0x10,%esp
   11f42:	c3                   	ret    
		default:
			return -EIO;
   11f43:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}
}
   11f48:	c3                   	ret    

00011f49 <rw_char>:

// 字符设备读写操作函数
// 参数:rw - 读写命令;dev - 设备号;buf - 缓冲区;count - 读写字节数;pos - 读写指针.
// 返回:实际读/写字节数.
int rw_char(int rw, int dev, char * buf, int count, off_t * pos)
{
   11f49:	83 ec 1c             	sub    $0x1c,%esp
   11f4c:	e8 a1 4d ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11f51:	05 af 00 02 00       	add    $0x200af,%eax
	crw_ptr call_addr;

	// 如果设备号超出系统设备数,则返回出错码.如果该设备没有对应的读/写函数,也返回出错码.否则调用对应设备的读写操作函数,并返回实际读/写的字节数.
	if (MAJOR(dev) >= NRDEVS)
   11f56:	8b 54 24 24          	mov    0x24(%esp),%edx
   11f5a:	c1 ea 08             	shr    $0x8,%edx
   11f5d:	83 fa 07             	cmp    $0x7,%edx
   11f60:	76 07                	jbe    11f69 <rw_char+0x20>
		return -ENODEV;
   11f62:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   11f67:	eb 44                	jmp    11fad <rw_char+0x64>
	if (!(call_addr = crw_table[MAJOR(dev)]))
   11f69:	8b 54 24 24          	mov    0x24(%esp),%edx
   11f6d:	c1 ea 08             	shr    $0x8,%edx
   11f70:	8b 84 90 e0 13 00 00 	mov    0x13e0(%eax,%edx,4),%eax
   11f77:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11f7b:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11f80:	75 07                	jne    11f89 <rw_char+0x40>
		return -ENODEV;
   11f82:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   11f87:	eb 24                	jmp    11fad <rw_char+0x64>
	return call_addr(rw, MINOR(dev), buf, count, pos);
   11f89:	8b 44 24 24          	mov    0x24(%esp),%eax
   11f8d:	0f b6 c0             	movzbl %al,%eax
   11f90:	83 ec 0c             	sub    $0xc,%esp
   11f93:	ff 74 24 3c          	pushl  0x3c(%esp)
   11f97:	ff 74 24 3c          	pushl  0x3c(%esp)
   11f9b:	ff 74 24 3c          	pushl  0x3c(%esp)
   11f9f:	50                   	push   %eax
   11fa0:	ff 74 24 3c          	pushl  0x3c(%esp)
   11fa4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   11fa8:	ff d0                	call   *%eax
   11faa:	83 c4 20             	add    $0x20,%esp
}
   11fad:	83 c4 1c             	add    $0x1c,%esp
   11fb0:	c3                   	ret    

00011fb1 <get_fs_byte>:
{
   11fb1:	53                   	push   %ebx
   11fb2:	e8 3b 4d ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11fb7:	05 49 00 02 00       	add    $0x20049,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   11fbc:	8b 44 24 08          	mov    0x8(%esp),%eax
   11fc0:	64 8a 00             	mov    %fs:(%eax),%al
   11fc3:	89 c3                	mov    %eax,%ebx
	return _v;
   11fc5:	89 d8                	mov    %ebx,%eax
}
   11fc7:	5b                   	pop    %ebx
   11fc8:	c3                   	ret    

00011fc9 <put_fs_byte>:
{
   11fc9:	83 ec 04             	sub    $0x4,%esp
   11fcc:	e8 21 4d ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   11fd1:	05 2f 00 02 00       	add    $0x2002f,%eax
   11fd6:	8b 44 24 08          	mov    0x8(%esp),%eax
   11fda:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   11fdd:	0f b6 04 24          	movzbl (%esp),%eax
   11fe1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11fe5:	64 88 02             	mov    %al,%fs:(%edx)
}
   11fe8:	90                   	nop
   11fe9:	83 c4 04             	add    $0x4,%esp
   11fec:	c3                   	ret    

00011fed <file_read>:

// 文件读函数 - 根据i节点和文件结构，读取文件中数据。
// 由i节点我们可以知道设备号，由filp结构可以知道文件中当前读写指针位置。buf指定用户空间中缓冲区的位置，count是需要读取的字节数。
// 返回值是实际读取的字节数，或出错号（小于0）。
int file_read(struct m_inode * inode, struct file * filp, char * buf, int count)
{
   11fed:	53                   	push   %ebx
   11fee:	83 ec 28             	sub    $0x28,%esp
   11ff1:	e8 04 4d ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   11ff6:	81 c3 0a 00 02 00    	add    $0x2000a,%ebx

	// 首先判断参数的有效性。若需要读取的字节计数count小于等于零，则返回0.若还需要读取的字节数不等于0,就循环执行下面操作，直到数据全
	// 部读出或遇到问题。在读循环操作过程中，我们根据i节点和文件表结构信息，并利用bmap()得到包含文件当前读写位置的数据块在设备上对应
	// 的逻辑块号nr。若nr不为0,则从i节点指定的设备上读取该逻辑块。如果读操作失败则退出循环。若nr为0,表示指定的数据块不存在，置缓冲
	// 块指针为NULL。
	if ((left = count) <= 0)
   11ffc:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   12000:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   12004:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   12009:	0f 8f 41 01 00 00    	jg     12150 <file_read+0x163>
		return 0;
   1200f:	b8 00 00 00 00       	mov    $0x0,%eax
   12014:	e9 88 01 00 00       	jmp    121a1 <file_read+0x1b4>
	while (left) {
		// 根据文件的读写偏移位置得到当前写位置对应的逻辑块号
		if (nr = bmap(inode, (filp->f_pos) / BLOCK_SIZE)) {
   12019:	8b 44 24 34          	mov    0x34(%esp),%eax
   1201d:	8b 40 0c             	mov    0xc(%eax),%eax
   12020:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
   12026:	85 c0                	test   %eax,%eax
   12028:	0f 48 c2             	cmovs  %edx,%eax
   1202b:	c1 f8 0a             	sar    $0xa,%eax
   1202e:	83 ec 08             	sub    $0x8,%esp
   12031:	50                   	push   %eax
   12032:	ff 74 24 3c          	pushl  0x3c(%esp)
   12036:	e8 1b d8 ff ff       	call   f856 <bmap>
   1203b:	83 c4 10             	add    $0x10,%esp
   1203e:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12042:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12047:	74 2b                	je     12074 <file_read+0x87>
			// 得到该逻辑块号对应的高速缓冲区
			if (!(bh = bread(inode->i_dev, nr)))
   12049:	8b 44 24 30          	mov    0x30(%esp),%eax
   1204d:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   12051:	0f b7 c0             	movzwl %ax,%eax
   12054:	83 ec 08             	sub    $0x8,%esp
   12057:	ff 74 24 14          	pushl  0x14(%esp)
   1205b:	50                   	push   %eax
   1205c:	e8 71 e9 ff ff       	call   109d2 <bread>
   12061:	83 c4 10             	add    $0x10,%esp
   12064:	89 44 24 14          	mov    %eax,0x14(%esp)
   12068:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1206d:	75 0d                	jne    1207c <file_read+0x8f>
				break;
   1206f:	e9 e7 00 00 00       	jmp    1215b <file_read+0x16e>
		} else
			bh = NULL;
   12074:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   1207b:	00 
		// 接着我们计算文件读写指针在数据块中的偏移值nr，则在该数据块中我们希望读取的字节数为（BLOCK_SIZE - nr）。然后和现在还需读取的
		// 字节数left作比较，其中小值即为本次操作需读取的字节数chars。如果（BLOCK_SIZE - nr）> left，则说明该块是需要读取的最后一块
		// 数据，反之还需要读取下一块数据。之后调整读写文件指针。指针前移此次将读取的字节数chars。剩余字节数left相应减去chars。
		nr = filp->f_pos % BLOCK_SIZE;
   1207c:	8b 44 24 34          	mov    0x34(%esp),%eax
   12080:	8b 40 0c             	mov    0xc(%eax),%eax
   12083:	99                   	cltd   
   12084:	c1 ea 16             	shr    $0x16,%edx
   12087:	01 d0                	add    %edx,%eax
   12089:	25 ff 03 00 00       	and    $0x3ff,%eax
   1208e:	29 d0                	sub    %edx,%eax
   12090:	89 44 24 0c          	mov    %eax,0xc(%esp)
		chars = MIN( BLOCK_SIZE - nr , left );
   12094:	b8 00 04 00 00       	mov    $0x400,%eax
   12099:	2b 44 24 0c          	sub    0xc(%esp),%eax
   1209d:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
   120a1:	0f 4e 44 24 1c       	cmovle 0x1c(%esp),%eax
   120a6:	89 44 24 18          	mov    %eax,0x18(%esp)
		filp->f_pos += chars;
   120aa:	8b 44 24 34          	mov    0x34(%esp),%eax
   120ae:	8b 50 0c             	mov    0xc(%eax),%edx
   120b1:	8b 44 24 18          	mov    0x18(%esp),%eax
   120b5:	01 c2                	add    %eax,%edx
   120b7:	8b 44 24 34          	mov    0x34(%esp),%eax
   120bb:	89 50 0c             	mov    %edx,0xc(%eax)
		left -= chars;
   120be:	8b 44 24 18          	mov    0x18(%esp),%eax
   120c2:	29 44 24 1c          	sub    %eax,0x1c(%esp)
		// 若上面从设备上读到了数据，则将p指向缓冲块中开始读取数据的位置，并且复制chars字节到用户缓冲区buf中。否则往用户缓冲区中填入chars
		// 个值字节。
		if (bh) {
   120c6:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   120cb:	74 74                	je     12141 <file_read+0x154>
			char * p = nr + bh->b_data;
   120cd:	8b 44 24 14          	mov    0x14(%esp),%eax
   120d1:	8b 10                	mov    (%eax),%edx
   120d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   120d7:	01 d0                	add    %edx,%eax
   120d9:	89 44 24 10          	mov    %eax,0x10(%esp)
			while (chars-- > 0)
   120dd:	eb 29                	jmp    12108 <file_read+0x11b>
				put_fs_byte(*(p++), buf++);
   120df:	8b 44 24 38          	mov    0x38(%esp),%eax
   120e3:	8d 50 01             	lea    0x1(%eax),%edx
   120e6:	89 54 24 38          	mov    %edx,0x38(%esp)
   120ea:	8b 54 24 10          	mov    0x10(%esp),%edx
   120ee:	8d 4a 01             	lea    0x1(%edx),%ecx
   120f1:	89 4c 24 10          	mov    %ecx,0x10(%esp)
   120f5:	0f b6 12             	movzbl (%edx),%edx
   120f8:	0f be d2             	movsbl %dl,%edx
   120fb:	83 ec 08             	sub    $0x8,%esp
   120fe:	50                   	push   %eax
   120ff:	52                   	push   %edx
   12100:	e8 c4 fe ff ff       	call   11fc9 <put_fs_byte>
   12105:	83 c4 10             	add    $0x10,%esp
			while (chars-- > 0)
   12108:	8b 44 24 18          	mov    0x18(%esp),%eax
   1210c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1210f:	89 54 24 18          	mov    %edx,0x18(%esp)
   12113:	85 c0                	test   %eax,%eax
   12115:	7f c8                	jg     120df <file_read+0xf2>
			brelse(bh);
   12117:	83 ec 0c             	sub    $0xc,%esp
   1211a:	ff 74 24 20          	pushl  0x20(%esp)
   1211e:	e8 48 e8 ff ff       	call   1096b <brelse>
   12123:	83 c4 10             	add    $0x10,%esp
   12126:	eb 28                	jmp    12150 <file_read+0x163>
		} else {
			while (chars-- > 0)
				put_fs_byte(0, buf++);
   12128:	8b 44 24 38          	mov    0x38(%esp),%eax
   1212c:	8d 50 01             	lea    0x1(%eax),%edx
   1212f:	89 54 24 38          	mov    %edx,0x38(%esp)
   12133:	83 ec 08             	sub    $0x8,%esp
   12136:	50                   	push   %eax
   12137:	6a 00                	push   $0x0
   12139:	e8 8b fe ff ff       	call   11fc9 <put_fs_byte>
   1213e:	83 c4 10             	add    $0x10,%esp
			while (chars-- > 0)
   12141:	8b 44 24 18          	mov    0x18(%esp),%eax
   12145:	8d 50 ff             	lea    -0x1(%eax),%edx
   12148:	89 54 24 18          	mov    %edx,0x18(%esp)
   1214c:	85 c0                	test   %eax,%eax
   1214e:	7f d8                	jg     12128 <file_read+0x13b>
	while (left) {
   12150:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   12155:	0f 85 be fe ff ff    	jne    12019 <file_read+0x2c>
		}
	}
	// 修改该i节点的访问时间为当前时间。返回读取的字节数，若读取字节数为0,则返回出错号。
	// CURRENT_TIME是定义在include/linux/sched.h上的宏，用于计算UNIX时间。即从1970年1月1日0时0秒开始，到当前时间。单位是秒。
	inode->i_atime = CURRENT_TIME;
   1215b:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   12161:	8b 10                	mov    (%eax),%edx
   12163:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   12169:	8b 00                	mov    (%eax),%eax
   1216b:	01 d0                	add    %edx,%eax
   1216d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   12172:	f7 e2                	mul    %edx
   12174:	c1 ea 05             	shr    $0x5,%edx
   12177:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   1217d:	8b 00                	mov    (%eax),%eax
   1217f:	01 c2                	add    %eax,%edx
   12181:	8b 44 24 30          	mov    0x30(%esp),%eax
   12185:	89 50 28             	mov    %edx,0x28(%eax)
	return (count - left) ? (count-left) : -ERROR;
   12188:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   1218c:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
   12190:	74 0a                	je     1219c <file_read+0x1af>
   12192:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   12196:	2b 44 24 1c          	sub    0x1c(%esp),%eax
   1219a:	eb 05                	jmp    121a1 <file_read+0x1b4>
   1219c:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
}
   121a1:	83 c4 28             	add    $0x28,%esp
   121a4:	5b                   	pop    %ebx
   121a5:	c3                   	ret    

000121a6 <file_write>:

// 文件写函数 - 根据i节点和文件结构信息，将用户数据写入文件中。
// 由i节点我们可以知道设备号，而由file结构可以知道文件中当前读写指针位置。buf指定用户态中缓冲区的位置，count为需要写入的字节数。
// 返回值是实际写入的字节数，或出错号（小于0).
int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
   121a6:	53                   	push   %ebx
   121a7:	83 ec 28             	sub    $0x28,%esp
   121aa:	e8 4b 4b ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   121af:	81 c3 51 fe 01 00    	add    $0x1fe51,%ebx
	off_t pos;
	int block, c;
	struct buffer_head * bh;
	char * p;
	int i = 0;
   121b5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   121bc:	00 
	 */
	/*
	 * OK，当许多进程同时写时，append操作可能不行，但那又怎样。不管怎样那样做会导致混乱一团。
	 */
	// 首先确定数据写入文件的位置。如果是要向文件后添加数据，则将文件读写指针移到文件尾部。否则就将在文件当前读写指针处写入。
	if (filp->f_flags & O_APPEND)
   121bd:	8b 44 24 34          	mov    0x34(%esp),%eax
   121c1:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   121c5:	0f b7 c0             	movzwl %ax,%eax
   121c8:	25 00 04 00 00       	and    $0x400,%eax
   121cd:	85 c0                	test   %eax,%eax
   121cf:	74 10                	je     121e1 <file_write+0x3b>
		pos = inode->i_size;
   121d1:	8b 44 24 30          	mov    0x30(%esp),%eax
   121d5:	8b 40 04             	mov    0x4(%eax),%eax
   121d8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   121dc:	e9 39 01 00 00       	jmp    1231a <file_write+0x174>
	else
		pos = filp->f_pos;
   121e1:	8b 44 24 34          	mov    0x34(%esp),%eax
   121e5:	8b 40 0c             	mov    0xc(%eax),%eax
   121e8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	// 然后在已写入字节数i（刚开始时为0）小于指定写入字节数count时，循环执行以下操作。在循环操作过程中，我们先取文件数据块
	// 号（pos/BLOCK_SIZE）在设备上对应的逻辑块号block。如果对应的逻辑块不存在就创建一块。如果得到的逻辑块号 = 0,则表示
	// 创建失败，于是退出循环。否则我们根据该逻辑块号读取设备上的相应逻辑块，若出错也退出循环。
	while (i < count) {
   121ec:	e9 29 01 00 00       	jmp    1231a <file_write+0x174>
		if (!(block = create_block(inode, pos / BLOCK_SIZE)))
   121f1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   121f5:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
   121fb:	85 c0                	test   %eax,%eax
   121fd:	0f 48 c2             	cmovs  %edx,%eax
   12200:	c1 f8 0a             	sar    $0xa,%eax
   12203:	83 ec 08             	sub    $0x8,%esp
   12206:	50                   	push   %eax
   12207:	ff 74 24 3c          	pushl  0x3c(%esp)
   1220b:	e8 6c d6 ff ff       	call   f87c <create_block>
   12210:	83 c4 10             	add    $0x10,%esp
   12213:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12217:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1221c:	0f 84 08 01 00 00    	je     1232a <file_write+0x184>
			break;
		if (!(bh = bread(inode->i_dev, block)))
   12222:	8b 44 24 30          	mov    0x30(%esp),%eax
   12226:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1222a:	0f b7 c0             	movzwl %ax,%eax
   1222d:	83 ec 08             	sub    $0x8,%esp
   12230:	ff 74 24 14          	pushl  0x14(%esp)
   12234:	50                   	push   %eax
   12235:	e8 98 e7 ff ff       	call   109d2 <bread>
   1223a:	83 c4 10             	add    $0x10,%esp
   1223d:	89 44 24 08          	mov    %eax,0x8(%esp)
   12241:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   12246:	0f 84 e1 00 00 00    	je     1232d <file_write+0x187>
			break;
		// 此时缓冲块指针bh正指向刚读入的文件数据块。现在再求出文件当前读写指针在该数据块中的偏移值c，并将指针p指向缓冲块中开始写入
		// 数据的位置，并置该缓冲块已修改标志。对于块中当前指针，从开始读写位置到块末共可写入c = (BLOCK_SIZE - c)个字节。若c大
		// 于剩余还需写入的字节数（count - i），则此次只需再定稿c = (count-i)个字节即可。
		c = pos % BLOCK_SIZE;
   1224c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12250:	99                   	cltd   
   12251:	c1 ea 16             	shr    $0x16,%edx
   12254:	01 d0                	add    %edx,%eax
   12256:	25 ff 03 00 00       	and    $0x3ff,%eax
   1225b:	29 d0                	sub    %edx,%eax
   1225d:	89 44 24 18          	mov    %eax,0x18(%esp)
		p = c + bh->b_data;
   12261:	8b 44 24 08          	mov    0x8(%esp),%eax
   12265:	8b 10                	mov    (%eax),%edx
   12267:	8b 44 24 18          	mov    0x18(%esp),%eax
   1226b:	01 d0                	add    %edx,%eax
   1226d:	89 44 24 14          	mov    %eax,0x14(%esp)
		bh->b_dirt = 1;
   12271:	8b 44 24 08          	mov    0x8(%esp),%eax
   12275:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		c = BLOCK_SIZE - c;
   12279:	b8 00 04 00 00       	mov    $0x400,%eax
   1227e:	2b 44 24 18          	sub    0x18(%esp),%eax
   12282:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (c > count - i) c = count - i;
   12286:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   1228a:	2b 44 24 10          	sub    0x10(%esp),%eax
   1228e:	39 44 24 18          	cmp    %eax,0x18(%esp)
   12292:	7e 0c                	jle    122a0 <file_write+0xfa>
   12294:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   12298:	2b 44 24 10          	sub    0x10(%esp),%eax
   1229c:	89 44 24 18          	mov    %eax,0x18(%esp)
		// 在写入数据之前，我们先预先设置好下一次循环操作要读写文件中的位置。因此我们把pos指针前移此次需要写入的字节数。如果此时pos
		// 位置值超过了文件当前长度，则修改i节点文件长度字段，并置i节点已修改标志。然后把此次要写入的字节数c累加到已写入字节计数值i中，
		// 供循环判断。使用接着双用户缓冲区buf中复制c个字节到调整缓冲块中p指向的开始位置处。复制完后就释放该缓冲块。
		pos += c;
   122a0:	8b 44 24 18          	mov    0x18(%esp),%eax
   122a4:	01 44 24 1c          	add    %eax,0x1c(%esp)
		if (pos > inode->i_size) {
   122a8:	8b 44 24 30          	mov    0x30(%esp),%eax
   122ac:	8b 50 04             	mov    0x4(%eax),%edx
   122af:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   122b3:	39 c2                	cmp    %eax,%edx
   122b5:	73 13                	jae    122ca <file_write+0x124>
			inode->i_size = pos;
   122b7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   122bb:	8b 44 24 30          	mov    0x30(%esp),%eax
   122bf:	89 50 04             	mov    %edx,0x4(%eax)
			inode->i_dirt = 1;
   122c2:	8b 44 24 30          	mov    0x30(%esp),%eax
   122c6:	c6 40 37 01          	movb   $0x1,0x37(%eax)
		}
		i += c;
   122ca:	8b 44 24 18          	mov    0x18(%esp),%eax
   122ce:	01 44 24 10          	add    %eax,0x10(%esp)
		while (c-- > 0)
   122d2:	eb 28                	jmp    122fc <file_write+0x156>
			*(p++) = get_fs_byte(buf++);
   122d4:	8b 44 24 38          	mov    0x38(%esp),%eax
   122d8:	8d 50 01             	lea    0x1(%eax),%edx
   122db:	89 54 24 38          	mov    %edx,0x38(%esp)
   122df:	83 ec 0c             	sub    $0xc,%esp
   122e2:	50                   	push   %eax
   122e3:	e8 c9 fc ff ff       	call   11fb1 <get_fs_byte>
   122e8:	83 c4 10             	add    $0x10,%esp
   122eb:	89 c1                	mov    %eax,%ecx
   122ed:	8b 44 24 14          	mov    0x14(%esp),%eax
   122f1:	8d 50 01             	lea    0x1(%eax),%edx
   122f4:	89 54 24 14          	mov    %edx,0x14(%esp)
   122f8:	89 ca                	mov    %ecx,%edx
   122fa:	88 10                	mov    %dl,(%eax)
		while (c-- > 0)
   122fc:	8b 44 24 18          	mov    0x18(%esp),%eax
   12300:	8d 50 ff             	lea    -0x1(%eax),%edx
   12303:	89 54 24 18          	mov    %edx,0x18(%esp)
   12307:	85 c0                	test   %eax,%eax
   12309:	7f c9                	jg     122d4 <file_write+0x12e>
		brelse(bh);
   1230b:	83 ec 0c             	sub    $0xc,%esp
   1230e:	ff 74 24 14          	pushl  0x14(%esp)
   12312:	e8 54 e6 ff ff       	call   1096b <brelse>
   12317:	83 c4 10             	add    $0x10,%esp
	while (i < count) {
   1231a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1231e:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
   12322:	0f 8c c9 fe ff ff    	jl     121f1 <file_write+0x4b>
   12328:	eb 04                	jmp    1232e <file_write+0x188>
			break;
   1232a:	90                   	nop
   1232b:	eb 01                	jmp    1232e <file_write+0x188>
			break;
   1232d:	90                   	nop
    }
	// 当数据已经全部写入文件或者在写操作过程中发生问题时就会退出循环。此时我们更改文件修改时间为当前时间，并调整文件读写指针。如果
	// 此次操作不是在文件尾添加数据，则把文件读写指针调整到当前读写位置pos处，并更改文件i节点的修改时间为当前时间。最后返回写入的
	// 字节数，若写入字节数为0,则返回出错号-1。
	inode->i_mtime = CURRENT_TIME;
   1232e:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   12334:	8b 10                	mov    (%eax),%edx
   12336:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   1233c:	8b 00                	mov    (%eax),%eax
   1233e:	01 d0                	add    %edx,%eax
   12340:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   12345:	f7 e2                	mul    %edx
   12347:	c1 ea 05             	shr    $0x5,%edx
   1234a:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   12350:	8b 00                	mov    (%eax),%eax
   12352:	01 c2                	add    %eax,%edx
   12354:	8b 44 24 30          	mov    0x30(%esp),%eax
   12358:	89 50 08             	mov    %edx,0x8(%eax)
	if (!(filp->f_flags & O_APPEND)) {
   1235b:	8b 44 24 34          	mov    0x34(%esp),%eax
   1235f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   12363:	0f b7 c0             	movzwl %ax,%eax
   12366:	25 00 04 00 00       	and    $0x400,%eax
   1236b:	85 c0                	test   %eax,%eax
   1236d:	75 38                	jne    123a7 <file_write+0x201>
		filp->f_pos = pos;
   1236f:	8b 44 24 34          	mov    0x34(%esp),%eax
   12373:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   12377:	89 50 0c             	mov    %edx,0xc(%eax)
		inode->i_ctime = CURRENT_TIME;
   1237a:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   12380:	8b 10                	mov    (%eax),%edx
   12382:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   12388:	8b 00                	mov    (%eax),%eax
   1238a:	01 d0                	add    %edx,%eax
   1238c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   12391:	f7 e2                	mul    %edx
   12393:	c1 ea 05             	shr    $0x5,%edx
   12396:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   1239c:	8b 00                	mov    (%eax),%eax
   1239e:	01 c2                	add    %eax,%edx
   123a0:	8b 44 24 30          	mov    0x30(%esp),%eax
   123a4:	89 50 2c             	mov    %edx,0x2c(%eax)
	}
	return (i ? i : -1);
   123a7:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   123ac:	74 06                	je     123b4 <file_write+0x20e>
   123ae:	8b 44 24 10          	mov    0x10(%esp),%eax
   123b2:	eb 05                	jmp    123b9 <file_write+0x213>
   123b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   123b9:	83 c4 28             	add    $0x28,%esp
   123bc:	5b                   	pop    %ebx
   123bd:	c3                   	ret    

000123be <put_fs_byte>:
{
   123be:	83 ec 04             	sub    $0x4,%esp
   123c1:	e8 2c 49 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   123c6:	05 3a fc 01 00       	add    $0x1fc3a,%eax
   123cb:	8b 44 24 08          	mov    0x8(%esp),%eax
   123cf:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   123d2:	0f b6 04 24          	movzbl (%esp),%eax
   123d6:	8b 54 24 0c          	mov    0xc(%esp),%edx
   123da:	64 88 02             	mov    %al,%fs:(%edx)
}
   123dd:	90                   	nop
   123de:	83 c4 04             	add    $0x4,%esp
   123e1:	c3                   	ret    

000123e2 <cp_stat>:
#include <asm/segment.h>

// 复制文件状态信息。
// 参数inode是文件i节点，statbuf是用户数据空间中stat文件状态结构指针，用于存放取得的状态信息。
static void cp_stat(struct m_inode * inode, struct stat * statbuf)
{
   123e2:	53                   	push   %ebx
   123e3:	83 ec 38             	sub    $0x38,%esp
   123e6:	e8 07 49 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   123eb:	05 15 fc 01 00       	add    $0x1fc15,%eax
	struct stat tmp;
	int i;

	// 首先验证（或分配）存放数据的内存空间。然后临时复制相应节点上的信息。
	verify_area(statbuf, sizeof (struct stat));
   123f0:	83 ec 08             	sub    $0x8,%esp
   123f3:	6a 20                	push   $0x20
   123f5:	ff 74 24 50          	pushl  0x50(%esp)
   123f9:	89 c3                	mov    %eax,%ebx
   123fb:	e8 fb 64 ff ff       	call   88fb <verify_area>
   12400:	83 c4 10             	add    $0x10,%esp
	tmp.st_dev = inode->i_dev;              						// 文件所在设备号。
   12403:	8b 44 24 40          	mov    0x40(%esp),%eax
   12407:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1240b:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	tmp.st_ino = inode->i_num;              						// 文件i节点号。
   12410:	8b 44 24 40          	mov    0x40(%esp),%eax
   12414:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   12418:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	tmp.st_mode = inode->i_mode;            						// 文件属性。
   1241d:	8b 44 24 40          	mov    0x40(%esp),%eax
   12421:	0f b7 00             	movzwl (%eax),%eax
   12424:	66 89 44 24 10       	mov    %ax,0x10(%esp)
	tmp.st_nlink = inode->i_nlinks;         						// 文件连接数。
   12429:	8b 44 24 40          	mov    0x40(%esp),%eax
   1242d:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   12431:	88 44 24 12          	mov    %al,0x12(%esp)
	tmp.st_uid = inode->i_uid;              						// 文件的用户ID。
   12435:	8b 44 24 40          	mov    0x40(%esp),%eax
   12439:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   1243d:	66 89 44 24 14       	mov    %ax,0x14(%esp)
	tmp.st_gid = inode->i_gid;              						// 文件的组ID。
   12442:	8b 44 24 40          	mov    0x40(%esp),%eax
   12446:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   1244a:	0f b6 c0             	movzbl %al,%eax
   1244d:	66 89 44 24 16       	mov    %ax,0x16(%esp)
	tmp.st_rdev = inode->i_zone[0];         						// 设备号（若是特殊字符文件或块设备文件)。
   12452:	8b 44 24 40          	mov    0x40(%esp),%eax
   12456:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1245a:	66 89 44 24 18       	mov    %ax,0x18(%esp)
	tmp.st_size = inode->i_size;            						// 文件字节长度（如果文件是常规文件）。
   1245f:	8b 44 24 40          	mov    0x40(%esp),%eax
   12463:	8b 40 04             	mov    0x4(%eax),%eax
   12466:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	tmp.st_atime = inode->i_atime;          						// 最后访问时间。
   1246a:	8b 44 24 40          	mov    0x40(%esp),%eax
   1246e:	8b 40 28             	mov    0x28(%eax),%eax
   12471:	89 44 24 20          	mov    %eax,0x20(%esp)
	tmp.st_mtime = inode->i_mtime;          						// 最后修改时间。
   12475:	8b 44 24 40          	mov    0x40(%esp),%eax
   12479:	8b 40 08             	mov    0x8(%eax),%eax
   1247c:	89 44 24 24          	mov    %eax,0x24(%esp)
	tmp.st_ctime = inode->i_ctime;          						// 最后i节点修改时间。
   12480:	8b 44 24 40          	mov    0x40(%esp),%eax
   12484:	8b 40 2c             	mov    0x2c(%eax),%eax
   12487:	89 44 24 28          	mov    %eax,0x28(%esp)
	// 最后将这些状态信息复制到用户缓冲区中。
	for (i = 0 ; i<sizeof (tmp) ; i++)
   1248b:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   12492:	00 
   12493:	eb 2c                	jmp    124c1 <cp_stat+0xdf>
		put_fs_byte(((char *) &tmp)[i], i + (char *) statbuf);
   12495:	8b 54 24 2c          	mov    0x2c(%esp),%edx
   12499:	8b 44 24 44          	mov    0x44(%esp),%eax
   1249d:	01 c2                	add    %eax,%edx
   1249f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   124a3:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
   124a7:	01 c8                	add    %ecx,%eax
   124a9:	0f b6 00             	movzbl (%eax),%eax
   124ac:	0f be c0             	movsbl %al,%eax
   124af:	83 ec 08             	sub    $0x8,%esp
   124b2:	52                   	push   %edx
   124b3:	50                   	push   %eax
   124b4:	e8 05 ff ff ff       	call   123be <put_fs_byte>
   124b9:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i<sizeof (tmp) ; i++)
   124bc:	83 44 24 2c 01       	addl   $0x1,0x2c(%esp)
   124c1:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   124c5:	83 f8 1f             	cmp    $0x1f,%eax
   124c8:	76 cb                	jbe    12495 <cp_stat+0xb3>
}
   124ca:	90                   	nop
   124cb:	83 c4 38             	add    $0x38,%esp
   124ce:	5b                   	pop    %ebx
   124cf:	c3                   	ret    

000124d0 <sys_stat>:
// 文件状态系统调用。
// 根据给定的文件名获取相关文件状态信息。
// 参数filename是指定的文件名，statbuf是存放状态信息的缓冲区指针。
// 返回：成功返回0,若出错则返回出错码。
int sys_stat(char * filename, struct stat * statbuf)
{
   124d0:	53                   	push   %ebx
   124d1:	83 ec 18             	sub    $0x18,%esp
   124d4:	e8 21 48 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   124d9:	81 c3 27 fb 01 00    	add    $0x1fb27,%ebx
	struct m_inode * inode;

	// 首先根据文件名找出对应的i节点。然后将i节点上的文件状态信息复制到用户缓冲区中，并放回i节点。
	if (!(inode = namei(filename)))
   124df:	83 ec 0c             	sub    $0xc,%esp
   124e2:	ff 74 24 2c          	pushl  0x2c(%esp)
   124e6:	e8 c2 27 00 00       	call   14cad <namei>
   124eb:	83 c4 10             	add    $0x10,%esp
   124ee:	89 44 24 0c          	mov    %eax,0xc(%esp)
   124f2:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   124f7:	75 07                	jne    12500 <sys_stat+0x30>
		return -ENOENT;
   124f9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   124fe:	eb 27                	jmp    12527 <sys_stat+0x57>
	cp_stat(inode, statbuf);
   12500:	83 ec 08             	sub    $0x8,%esp
   12503:	ff 74 24 2c          	pushl  0x2c(%esp)
   12507:	ff 74 24 18          	pushl  0x18(%esp)
   1250b:	e8 d2 fe ff ff       	call   123e2 <cp_stat>
   12510:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   12513:	83 ec 0c             	sub    $0xc,%esp
   12516:	ff 74 24 18          	pushl  0x18(%esp)
   1251a:	e8 83 d3 ff ff       	call   f8a2 <iput>
   1251f:	83 c4 10             	add    $0x10,%esp
	return 0;
   12522:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12527:	83 c4 18             	add    $0x18,%esp
   1252a:	5b                   	pop    %ebx
   1252b:	c3                   	ret    

0001252c <sys_lstat>:

// 文件状态系统调用。
// 根据给定的文件名获取相关文件状态信息。文件路径名中有符号链接文件名，则取符号文件的状态。
// 参数：filename是指定的文件名，statbuf是存放状态信息的缓冲区指针。
int sys_lstat(char * filename, struct stat * statbuf)
{
   1252c:	53                   	push   %ebx
   1252d:	83 ec 18             	sub    $0x18,%esp
   12530:	e8 c5 47 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   12535:	81 c3 cb fa 01 00    	add    $0x1facb,%ebx
	struct m_inode * inode;

	// 首先根据文件名找出对应的i节点。然后将i节点上的文件状态信息复制到用户缓冲区中，并放回该i节点。
	if (!(inode = lnamei(filename)))        					// 取指定路径名i节点，不跟随符号链接。
   1253b:	83 ec 0c             	sub    $0xc,%esp
   1253e:	ff 74 24 2c          	pushl  0x2c(%esp)
   12542:	e8 42 27 00 00       	call   14c89 <lnamei>
   12547:	83 c4 10             	add    $0x10,%esp
   1254a:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1254e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12553:	75 07                	jne    1255c <sys_lstat+0x30>
		return -ENOENT;
   12555:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1255a:	eb 27                	jmp    12583 <sys_lstat+0x57>
	cp_stat(inode, statbuf);
   1255c:	83 ec 08             	sub    $0x8,%esp
   1255f:	ff 74 24 2c          	pushl  0x2c(%esp)
   12563:	ff 74 24 18          	pushl  0x18(%esp)
   12567:	e8 76 fe ff ff       	call   123e2 <cp_stat>
   1256c:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   1256f:	83 ec 0c             	sub    $0xc,%esp
   12572:	ff 74 24 18          	pushl  0x18(%esp)
   12576:	e8 27 d3 ff ff       	call   f8a2 <iput>
   1257b:	83 c4 10             	add    $0x10,%esp
	return 0;
   1257e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12583:	83 c4 18             	add    $0x18,%esp
   12586:	5b                   	pop    %ebx
   12587:	c3                   	ret    

00012588 <sys_fstat>:
// 文件状态系统调用。
// 根据给定的文件句柄获取相关文件状态信息。
// 参数fd是指定文件的句柄（描述符），statbuf是存放状态信息的缓冲区指针。
// 返回：成功返回0,若出错则返回出错码。
int sys_fstat(unsigned int fd, struct stat * statbuf)
{
   12588:	83 ec 1c             	sub    $0x1c,%esp
   1258b:	e8 62 47 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   12590:	05 70 fa 01 00       	add    $0x1fa70,%eax
	struct m_inode * inode;

	// 首先取文件句柄对应的文件结构，然后从中得到文件的i节点。然后将i节点上的文件状态信息复制到用户缓冲区中。如果
	// 文件句柄值大于一个程序最多打开文件数NR_OPEN，或者该句柄的文件结构指针为空，或者对应文件结构的i节点字段为空，
	// 则出错，返回出错码并退出。
	if (fd >= NR_OPEN || !(f = current->filp[fd]) || !(inode = f->f_inode))
   12595:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
   1259a:	77 33                	ja     125cf <sys_fstat+0x47>
   1259c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   125a2:	8b 00                	mov    (%eax),%eax
   125a4:	8b 54 24 20          	mov    0x20(%esp),%edx
   125a8:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   125ae:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   125b2:	89 44 24 0c          	mov    %eax,0xc(%esp)
   125b6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   125bb:	74 12                	je     125cf <sys_fstat+0x47>
   125bd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   125c1:	8b 40 08             	mov    0x8(%eax),%eax
   125c4:	89 44 24 08          	mov    %eax,0x8(%esp)
   125c8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   125cd:	75 07                	jne    125d6 <sys_fstat+0x4e>
		return -EBADF;
   125cf:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   125d4:	eb 18                	jmp    125ee <sys_fstat+0x66>
	cp_stat(inode, statbuf);
   125d6:	83 ec 08             	sub    $0x8,%esp
   125d9:	ff 74 24 2c          	pushl  0x2c(%esp)
   125dd:	ff 74 24 14          	pushl  0x14(%esp)
   125e1:	e8 fc fd ff ff       	call   123e2 <cp_stat>
   125e6:	83 c4 10             	add    $0x10,%esp
	return 0;
   125e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   125ee:	83 c4 1c             	add    $0x1c,%esp
   125f1:	c3                   	ret    

000125f2 <sys_readlink>:
// 该调用读取符号链接文件的内容（即该符号链接所指向文件的路径名字符串），并放到指定长度的用户缓冲区中。若缓冲区
// 太小，就会截断符号链接的内容。
// 参数：path -- 符号链接文件路径名；buf -- 用户缓冲区；bufsiz -- 缓冲区长度。
// 返回：成功则返回放入缓冲区中的字符数；若失败则返回出错码。
int sys_readlink(const char * path, char * buf, int bufsiz)
{
   125f2:	53                   	push   %ebx
   125f3:	83 ec 18             	sub    $0x18,%esp
   125f6:	e8 ff 46 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   125fb:	81 c3 05 fa 01 00    	add    $0x1fa05,%ebx
	int i;
	char c;

	// 首先检查和验证函数参数的有效性，并对其进行调整。用户缓冲区字节长度bufsiz必须在1--1023之间。然后取得符号链接
	// 文件名的i节点，并读取该文件的第1块数据内容。之后放回i节点。
	if (bufsiz <= 0)
   12601:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   12606:	7f 0a                	jg     12612 <sys_readlink+0x20>
		return -EBADF;
   12608:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   1260d:	e9 07 01 00 00       	jmp    12719 <sys_readlink+0x127>
	if (bufsiz > 1023)
   12612:	81 7c 24 28 ff 03 00 	cmpl   $0x3ff,0x28(%esp)
   12619:	00 
   1261a:	7e 08                	jle    12624 <sys_readlink+0x32>
		bufsiz = 1023;
   1261c:	c7 44 24 28 ff 03 00 	movl   $0x3ff,0x28(%esp)
   12623:	00 
	verify_area(buf, bufsiz);
   12624:	83 ec 08             	sub    $0x8,%esp
   12627:	ff 74 24 30          	pushl  0x30(%esp)
   1262b:	ff 74 24 30          	pushl  0x30(%esp)
   1262f:	e8 c7 62 ff ff       	call   88fb <verify_area>
   12634:	83 c4 10             	add    $0x10,%esp
	if (!(inode = lnamei(path)))
   12637:	83 ec 0c             	sub    $0xc,%esp
   1263a:	ff 74 24 2c          	pushl  0x2c(%esp)
   1263e:	e8 46 26 00 00       	call   14c89 <lnamei>
   12643:	83 c4 10             	add    $0x10,%esp
   12646:	89 44 24 04          	mov    %eax,0x4(%esp)
   1264a:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   1264f:	75 0a                	jne    1265b <sys_readlink+0x69>
		return -ENOENT;
   12651:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   12656:	e9 be 00 00 00       	jmp    12719 <sys_readlink+0x127>
	if (inode->i_zone[0])
   1265b:	8b 44 24 04          	mov    0x4(%esp),%eax
   1265f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   12663:	66 85 c0             	test   %ax,%ax
   12666:	74 29                	je     12691 <sys_readlink+0x9f>
		bh = bread(inode->i_dev, inode->i_zone[0]);
   12668:	8b 44 24 04          	mov    0x4(%esp),%eax
   1266c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   12670:	0f b7 d0             	movzwl %ax,%edx
   12673:	8b 44 24 04          	mov    0x4(%esp),%eax
   12677:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1267b:	0f b7 c0             	movzwl %ax,%eax
   1267e:	83 ec 08             	sub    $0x8,%esp
   12681:	52                   	push   %edx
   12682:	50                   	push   %eax
   12683:	e8 4a e3 ff ff       	call   109d2 <bread>
   12688:	83 c4 10             	add    $0x10,%esp
   1268b:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1268f:	eb 08                	jmp    12699 <sys_readlink+0xa7>
	else
		bh = NULL;
   12691:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   12698:	00 
	iput(inode);
   12699:	83 ec 0c             	sub    $0xc,%esp
   1269c:	ff 74 24 10          	pushl  0x10(%esp)
   126a0:	e8 fd d1 ff ff       	call   f8a2 <iput>
   126a5:	83 c4 10             	add    $0x10,%esp
	// 如果读取文件数据内容成功，则从内容中复制最多bufsiz个字符到用户缓冲区中，不复制NULL字符。最后释放缓冲块，并返回
	// 复制的字节数。
	if (!bh)
   126a8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   126ad:	75 07                	jne    126b6 <sys_readlink+0xc4>
		return 0;
   126af:	b8 00 00 00 00       	mov    $0x0,%eax
   126b4:	eb 63                	jmp    12719 <sys_readlink+0x127>
	i = 0;
   126b6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   126bd:	00 
	while (i < bufsiz && (c = bh->b_data[i])) {
   126be:	eb 22                	jmp    126e2 <sys_readlink+0xf0>
		i++;
   126c0:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
		put_fs_byte(c, buf++);
   126c5:	8b 44 24 24          	mov    0x24(%esp),%eax
   126c9:	8d 50 01             	lea    0x1(%eax),%edx
   126cc:	89 54 24 24          	mov    %edx,0x24(%esp)
   126d0:	0f be 54 24 03       	movsbl 0x3(%esp),%edx
   126d5:	83 ec 08             	sub    $0x8,%esp
   126d8:	50                   	push   %eax
   126d9:	52                   	push   %edx
   126da:	e8 df fc ff ff       	call   123be <put_fs_byte>
   126df:	83 c4 10             	add    $0x10,%esp
	while (i < bufsiz && (c = bh->b_data[i])) {
   126e2:	8b 44 24 08          	mov    0x8(%esp),%eax
   126e6:	3b 44 24 28          	cmp    0x28(%esp),%eax
   126ea:	7d 1a                	jge    12706 <sys_readlink+0x114>
   126ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
   126f0:	8b 10                	mov    (%eax),%edx
   126f2:	8b 44 24 08          	mov    0x8(%esp),%eax
   126f6:	01 d0                	add    %edx,%eax
   126f8:	0f b6 00             	movzbl (%eax),%eax
   126fb:	88 44 24 03          	mov    %al,0x3(%esp)
   126ff:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
   12704:	75 ba                	jne    126c0 <sys_readlink+0xce>
	}
	brelse(bh);
   12706:	83 ec 0c             	sub    $0xc,%esp
   12709:	ff 74 24 18          	pushl  0x18(%esp)
   1270d:	e8 59 e2 ff ff       	call   1096b <brelse>
   12712:	83 c4 10             	add    $0x10,%esp
	return i;
   12715:	8b 44 24 08          	mov    0x8(%esp),%eax
}
   12719:	83 c4 18             	add    $0x18,%esp
   1271c:	5b                   	pop    %ebx
   1271d:	c3                   	ret    

0001271e <strncpy>:
{
   1271e:	57                   	push   %edi
   1271f:	56                   	push   %esi
   12720:	53                   	push   %ebx
   12721:	e8 cc 45 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   12726:	05 da f8 01 00       	add    $0x1f8da,%eax
__asm__(
   1272b:	8b 54 24 14          	mov    0x14(%esp),%edx
   1272f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   12733:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   12737:	89 d6                	mov    %edx,%esi
   12739:	89 df                	mov    %ebx,%edi
   1273b:	fc                   	cld    
   1273c:	49                   	dec    %ecx
   1273d:	78 08                	js     12747 <strncpy+0x29>
   1273f:	ac                   	lods   %ds:(%esi),%al
   12740:	aa                   	stos   %al,%es:(%edi)
   12741:	84 c0                	test   %al,%al
   12743:	75 f7                	jne    1273c <strncpy+0x1e>
   12745:	f3 aa                	rep stos %al,%es:(%edi)
return dest;												// 返回目的字符串指针.
   12747:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   1274b:	5b                   	pop    %ebx
   1274c:	5e                   	pop    %esi
   1274d:	5f                   	pop    %edi
   1274e:	c3                   	ret    

0001274f <strchr>:
{
   1274f:	56                   	push   %esi
   12750:	83 ec 04             	sub    $0x4,%esp
   12753:	e8 9a 45 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   12758:	05 a8 f8 01 00       	add    $0x1f8a8,%eax
   1275d:	8b 44 24 10          	mov    0x10(%esp),%eax
   12761:	88 04 24             	mov    %al,(%esp)
__asm__(
   12764:	8b 54 24 0c          	mov    0xc(%esp),%edx
   12768:	0f b6 04 24          	movzbl (%esp),%eax
   1276c:	89 d6                	mov    %edx,%esi
   1276e:	fc                   	cld    
   1276f:	88 c4                	mov    %al,%ah
   12771:	ac                   	lods   %ds:(%esi),%al
   12772:	38 e0                	cmp    %ah,%al
   12774:	74 09                	je     1277f <strchr+0x30>
   12776:	84 c0                	test   %al,%al
   12778:	75 f7                	jne    12771 <strchr+0x22>
   1277a:	be 01 00 00 00       	mov    $0x1,%esi
   1277f:	89 f0                	mov    %esi,%eax
   12781:	48                   	dec    %eax
}
   12782:	83 c4 04             	add    $0x4,%esp
   12785:	5e                   	pop    %esi
   12786:	c3                   	ret    

00012787 <get_fs_byte>:
{
   12787:	53                   	push   %ebx
   12788:	e8 65 45 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1278d:	05 73 f8 01 00       	add    $0x1f873,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   12792:	8b 44 24 08          	mov    0x8(%esp),%eax
   12796:	64 8a 00             	mov    %fs:(%eax),%al
   12799:	89 c3                	mov    %eax,%ebx
	return _v;
   1279b:	89 d8                	mov    %ebx,%eax
}
   1279d:	5b                   	pop    %ebx
   1279e:	c3                   	ret    

0001279f <get_fs_long>:
{
   1279f:	83 ec 10             	sub    $0x10,%esp
   127a2:	e8 4b 45 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   127a7:	05 59 f8 01 00       	add    $0x1f859,%eax
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   127ac:	8b 44 24 14          	mov    0x14(%esp),%eax
   127b0:	64 8b 00             	mov    %fs:(%eax),%eax
   127b3:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
   127b7:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   127bb:	83 c4 10             	add    $0x10,%esp
   127be:	c3                   	ret    

000127bf <put_fs_long>:

//// 将一长字存放在fs段中指定内存地址处.
// 参数:val - 长字值;addr - 内存地址.
// %0 - 寄存器(长字值val);%1 - (内存地址addr).
static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
   127bf:	e8 2e 45 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   127c4:	05 3c f8 01 00       	add    $0x1f83c,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   127c9:	8b 44 24 04          	mov    0x4(%esp),%eax
   127cd:	8b 54 24 08          	mov    0x8(%esp),%edx
   127d1:	64 89 02             	mov    %eax,%fs:(%edx)
}
   127d4:	90                   	nop
   127d5:	c3                   	ret    

000127d6 <get_fs>:
 */

//// 取fs段寄存器值(选择符).
// 返回:fs段寄存器值.
static inline unsigned long get_fs()
{
   127d6:	83 ec 10             	sub    $0x10,%esp
   127d9:	e8 14 45 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   127de:	05 22 f8 01 00       	add    $0x1f822,%eax
	unsigned short _v;
	__asm__("mov %%fs,%%ax":"=a" (_v):);
   127e3:	66 8c e0             	mov    %fs,%ax
   127e6:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	return _v;
   127eb:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
}
   127f0:	83 c4 10             	add    $0x10,%esp
   127f3:	c3                   	ret    

000127f4 <get_ds>:

//// 取ds面寄存器值.
// 返回:ds段寄存器值.
static inline unsigned long get_ds()
{
   127f4:	83 ec 10             	sub    $0x10,%esp
   127f7:	e8 f6 44 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   127fc:	05 04 f8 01 00       	add    $0x1f804,%eax
	unsigned short _v;
	__asm__("mov %%ds,%%ax":"=a" (_v):);
   12801:	66 8c d8             	mov    %ds,%ax
   12804:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	return _v;
   12809:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
}
   1280e:	83 c4 10             	add    $0x10,%esp
   12811:	c3                   	ret    

00012812 <set_fs>:

//// 设置fs段寄存器.
// 参数:val - 段值(选择符).
static inline void set_fs(unsigned long val)
{
   12812:	e8 db 44 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   12817:	05 e9 f7 01 00       	add    $0x1f7e9,%eax
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
   1281c:	8b 44 24 04          	mov    0x4(%esp),%eax
   12820:	8e e0                	mov    %eax,%fs
}
   12822:	90                   	nop
   12823:	c3                   	ret    

00012824 <sys_uselib>:
// 参数：library - 库文件名。
// 为进程选择一个库文件，并替换进程当前库文件i节点字段值为这里指定库文件名的i节点指针。如果library指针为空，则把进程
// 当前的库文件释放掉。
// 返回：成功返回0，否则返回出错码。
int sys_uselib(const char * library)
{
   12824:	56                   	push   %esi
   12825:	53                   	push   %ebx
   12826:	83 ec 14             	sub    $0x14,%esp
   12829:	e8 cc 44 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1282e:	81 c3 d2 f7 01 00    	add    $0x1f7d2,%ebx
	unsigned long base;

	// 首先判断当前进程是否普通进程。这是通过查看当前进程的空间长度来做到的。因为普通进程的空间长度被设置为TASK_SIZE（64
	// MB）。因此若进程逻辑地址空间长度不等于TASK_SIZE则返回出错码（无效参数）。否则取库文件i节点inode。若库文件名指针
	// 空，则设置inode等于NULL。
	if (get_limit(0x17) != TASK_SIZE)
   12834:	b8 17 00 00 00       	mov    $0x17,%eax
   12839:	0f 03 c0             	lsl    %ax,%eax
   1283c:	40                   	inc    %eax
   1283d:	89 44 24 08          	mov    %eax,0x8(%esp)
   12841:	8b 44 24 08          	mov    0x8(%esp),%eax
   12845:	3d 00 00 00 04       	cmp    $0x4000000,%eax
   1284a:	74 0a                	je     12856 <sys_uselib+0x32>
		return -EINVAL;
   1284c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   12851:	e9 d8 00 00 00       	jmp    1292e <sys_uselib+0x10a>
	if (library) {
   12856:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   1285b:	74 24                	je     12881 <sys_uselib+0x5d>
		if (!(inode = namei(library)))							/* get library inode */
   1285d:	83 ec 0c             	sub    $0xc,%esp
   12860:	ff 74 24 2c          	pushl  0x2c(%esp)
   12864:	e8 44 24 00 00       	call   14cad <namei>
   12869:	83 c4 10             	add    $0x10,%esp
   1286c:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12870:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12875:	75 12                	jne    12889 <sys_uselib+0x65>
			return -ENOENT;                 					/* 取库文件i节点 */
   12877:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1287c:	e9 ad 00 00 00       	jmp    1292e <sys_uselib+0x10a>
	} else
		inode = NULL;
   12881:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   12888:	00 
	/* we should check filetypes (headers etc), but we don't */
	/* 我们应该检查一下文件类型（如头部信息等），但是我们还没有这样做。*/
	// 然后放回进程原库文件i节点，并预置进程库i节点字段为空。接着取得进程的库代码所在位置，并释放原库代码的页表所占用的内存
	// 页面。最后让进程库i节点字段指向新库i节点，并返回0（成功）。
	iput(current->library);
   12889:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1288f:	8b 00                	mov    (%eax),%eax
   12891:	8b 80 40 03 00 00    	mov    0x340(%eax),%eax
   12897:	83 ec 0c             	sub    $0xc,%esp
   1289a:	50                   	push   %eax
   1289b:	e8 02 d0 ff ff       	call   f8a2 <iput>
   128a0:	83 c4 10             	add    $0x10,%esp
	current->library = NULL;
   128a3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   128a9:	8b 00                	mov    (%eax),%eax
   128ab:	c7 80 40 03 00 00 00 	movl   $0x0,0x340(%eax)
   128b2:	00 00 00 
	base = get_base(current->ldt[2]);
   128b5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   128bb:	8b 00                	mov    (%eax),%eax
   128bd:	05 a8 03 00 00       	add    $0x3a8,%eax
   128c2:	8d 70 02             	lea    0x2(%eax),%esi
   128c5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   128cb:	8b 00                	mov    (%eax),%eax
   128cd:	05 a8 03 00 00       	add    $0x3a8,%eax
   128d2:	8d 48 04             	lea    0x4(%eax),%ecx
   128d5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   128db:	8b 00                	mov    (%eax),%eax
   128dd:	05 a8 03 00 00       	add    $0x3a8,%eax
   128e2:	83 c0 07             	add    $0x7,%eax
   128e5:	8a 30                	mov    (%eax),%dh
   128e7:	8a 11                	mov    (%ecx),%dl
   128e9:	c1 e2 10             	shl    $0x10,%edx
   128ec:	66 8b 16             	mov    (%esi),%dx
   128ef:	89 d0                	mov    %edx,%eax
   128f1:	89 44 24 04          	mov    %eax,0x4(%esp)
   128f5:	8b 44 24 04          	mov    0x4(%esp),%eax
   128f9:	89 04 24             	mov    %eax,(%esp)
	base += LIBRARY_OFFSET;
   128fc:	81 04 24 00 00 c0 03 	addl   $0x3c00000,(%esp)
	free_page_tables(base, LIBRARY_SIZE);
   12903:	83 ec 08             	sub    $0x8,%esp
   12906:	68 00 00 40 00       	push   $0x400000
   1290b:	ff 74 24 0c          	pushl  0xc(%esp)
   1290f:	e8 f1 a1 ff ff       	call   cb05 <free_page_tables>
   12914:	83 c4 10             	add    $0x10,%esp
	current->library = inode;
   12917:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1291d:	8b 00                	mov    (%eax),%eax
   1291f:	8b 54 24 0c          	mov    0xc(%esp),%edx
   12923:	89 90 40 03 00 00    	mov    %edx,0x340(%eax)
	return 0;
   12929:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1292e:	83 c4 14             	add    $0x14,%esp
   12931:	5b                   	pop    %ebx
   12932:	5e                   	pop    %esi
   12933:	c3                   	ret    

00012934 <create_tables>:
 */
// 在新任务中创建参数和环境变量指针表.
// 参数:p - 数据段中参数和环境信息偏移指针;argc - 参数个数;envc - 环境变量个数.
// 返回:栈指针值.
static unsigned long * create_tables(char * p, int argc, int envc)
{
   12934:	83 ec 10             	sub    $0x10,%esp
   12937:	e8 b6 43 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1293c:	05 c4 f6 01 00       	add    $0x1f6c4,%eax
	// 栈指针是以4字节(1节)为边界进行寻址的,因此这里需让sp为4的整数倍值.此时sp位于参数环境表的末端.然后我们先把sp向下
	// (低地址方向)移动,在栈中空出环境变量指针占用的空间,并让环境变量指针envp指向该处.多空出的一个位置用于在最后存放一
	// 个NULL值.下面指针加1,sp将递增指针宽度字节值(4字节).再把sp向下移动,空出命令行参数指针占用的空间,并让argv指针
	// 指向该处.同样,多空处的一个位置用于存放一个NULL值.此时sp指向参数指针块的起始处,我们将环境参数块指针envp和命令行
	// 参数块指针以及命令行参数个数值分别压入栈中.
	sp = (unsigned long *) (0xfffffffc & (unsigned long) p);
   12941:	8b 44 24 14          	mov    0x14(%esp),%eax
   12945:	83 e0 fc             	and    $0xfffffffc,%eax
   12948:	89 44 24 04          	mov    %eax,0x4(%esp)
	sp -= envc + 1;
   1294c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12950:	8d 50 01             	lea    0x1(%eax),%edx
   12953:	b8 00 00 00 00       	mov    $0x0,%eax
   12958:	29 d0                	sub    %edx,%eax
   1295a:	c1 e0 02             	shl    $0x2,%eax
   1295d:	01 44 24 04          	add    %eax,0x4(%esp)
	envp = sp;
   12961:	8b 44 24 04          	mov    0x4(%esp),%eax
   12965:	89 44 24 08          	mov    %eax,0x8(%esp)
	sp -= argc + 1;
   12969:	8b 44 24 18          	mov    0x18(%esp),%eax
   1296d:	8d 50 01             	lea    0x1(%eax),%edx
   12970:	b8 00 00 00 00       	mov    $0x0,%eax
   12975:	29 d0                	sub    %edx,%eax
   12977:	c1 e0 02             	shl    $0x2,%eax
   1297a:	01 44 24 04          	add    %eax,0x4(%esp)
	argv = sp;
   1297e:	8b 44 24 04          	mov    0x4(%esp),%eax
   12982:	89 44 24 0c          	mov    %eax,0xc(%esp)
	put_fs_long((unsigned long)envp, --sp);
   12986:	83 6c 24 04 04       	subl   $0x4,0x4(%esp)
   1298b:	8b 44 24 08          	mov    0x8(%esp),%eax
   1298f:	ff 74 24 04          	pushl  0x4(%esp)
   12993:	50                   	push   %eax
   12994:	e8 26 fe ff ff       	call   127bf <put_fs_long>
   12999:	83 c4 08             	add    $0x8,%esp
	put_fs_long((unsigned long)argv, --sp);
   1299c:	83 6c 24 04 04       	subl   $0x4,0x4(%esp)
   129a1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   129a5:	ff 74 24 04          	pushl  0x4(%esp)
   129a9:	50                   	push   %eax
   129aa:	e8 10 fe ff ff       	call   127bf <put_fs_long>
   129af:	83 c4 08             	add    $0x8,%esp
	put_fs_long((unsigned long)argc, --sp);
   129b2:	83 6c 24 04 04       	subl   $0x4,0x4(%esp)
   129b7:	8b 44 24 18          	mov    0x18(%esp),%eax
   129bb:	ff 74 24 04          	pushl  0x4(%esp)
   129bf:	50                   	push   %eax
   129c0:	e8 fa fd ff ff       	call   127bf <put_fs_long>
   129c5:	83 c4 08             	add    $0x8,%esp
	// 再将命令行各参数指针和环境变量各指针分别放入前面空出来的相应地方,最后分别放置一个NULL指针.
	while (argc-- > 0) {
   129c8:	eb 32                	jmp    129fc <create_tables+0xc8>
		put_fs_long((unsigned long) p, argv++);
   129ca:	8b 44 24 0c          	mov    0xc(%esp),%eax
   129ce:	8d 50 04             	lea    0x4(%eax),%edx
   129d1:	89 54 24 0c          	mov    %edx,0xc(%esp)
   129d5:	8b 54 24 14          	mov    0x14(%esp),%edx
   129d9:	50                   	push   %eax
   129da:	52                   	push   %edx
   129db:	e8 df fd ff ff       	call   127bf <put_fs_long>
   129e0:	83 c4 08             	add    $0x8,%esp
		while (get_fs_byte(p++)) /* nothing */ ;	// p指针指向下一个参数串.
   129e3:	90                   	nop
   129e4:	8b 44 24 14          	mov    0x14(%esp),%eax
   129e8:	8d 50 01             	lea    0x1(%eax),%edx
   129eb:	89 54 24 14          	mov    %edx,0x14(%esp)
   129ef:	50                   	push   %eax
   129f0:	e8 92 fd ff ff       	call   12787 <get_fs_byte>
   129f5:	83 c4 04             	add    $0x4,%esp
   129f8:	84 c0                	test   %al,%al
   129fa:	75 e8                	jne    129e4 <create_tables+0xb0>
	while (argc-- > 0) {
   129fc:	8b 44 24 18          	mov    0x18(%esp),%eax
   12a00:	8d 50 ff             	lea    -0x1(%eax),%edx
   12a03:	89 54 24 18          	mov    %edx,0x18(%esp)
   12a07:	85 c0                	test   %eax,%eax
   12a09:	7f bf                	jg     129ca <create_tables+0x96>
	}
	put_fs_long(0, argv);
   12a0b:	ff 74 24 0c          	pushl  0xc(%esp)
   12a0f:	6a 00                	push   $0x0
   12a11:	e8 a9 fd ff ff       	call   127bf <put_fs_long>
   12a16:	83 c4 08             	add    $0x8,%esp
	while (envc-- > 0) {
   12a19:	eb 32                	jmp    12a4d <create_tables+0x119>
		put_fs_long((unsigned long) p, envp++);
   12a1b:	8b 44 24 08          	mov    0x8(%esp),%eax
   12a1f:	8d 50 04             	lea    0x4(%eax),%edx
   12a22:	89 54 24 08          	mov    %edx,0x8(%esp)
   12a26:	8b 54 24 14          	mov    0x14(%esp),%edx
   12a2a:	50                   	push   %eax
   12a2b:	52                   	push   %edx
   12a2c:	e8 8e fd ff ff       	call   127bf <put_fs_long>
   12a31:	83 c4 08             	add    $0x8,%esp
		while (get_fs_byte(p++)) /* nothing */ ;	// p指针指向下一个参数串.
   12a34:	90                   	nop
   12a35:	8b 44 24 14          	mov    0x14(%esp),%eax
   12a39:	8d 50 01             	lea    0x1(%eax),%edx
   12a3c:	89 54 24 14          	mov    %edx,0x14(%esp)
   12a40:	50                   	push   %eax
   12a41:	e8 41 fd ff ff       	call   12787 <get_fs_byte>
   12a46:	83 c4 04             	add    $0x4,%esp
   12a49:	84 c0                	test   %al,%al
   12a4b:	75 e8                	jne    12a35 <create_tables+0x101>
	while (envc-- > 0) {
   12a4d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12a51:	8d 50 ff             	lea    -0x1(%eax),%edx
   12a54:	89 54 24 1c          	mov    %edx,0x1c(%esp)
   12a58:	85 c0                	test   %eax,%eax
   12a5a:	7f bf                	jg     12a1b <create_tables+0xe7>
	}
	put_fs_long(0, envp);
   12a5c:	ff 74 24 08          	pushl  0x8(%esp)
   12a60:	6a 00                	push   $0x0
   12a62:	e8 58 fd ff ff       	call   127bf <put_fs_long>
   12a67:	83 c4 08             	add    $0x8,%esp
	return sp;										// 返回构造的当前新栈指针.
   12a6a:	8b 44 24 04          	mov    0x4(%esp),%eax
}
   12a6e:	83 c4 10             	add    $0x10,%esp
   12a71:	c3                   	ret    

00012a72 <count>:
// 计算参数个数.
// 参数:argv - 参数指针数组,最后一个指针项是NULL.
// 统计参数指针数组中指针的个数.
// 返回:参数个数.
static int count(char ** argv)
{
   12a72:	83 ec 10             	sub    $0x10,%esp
   12a75:	e8 78 42 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   12a7a:	05 86 f5 01 00       	add    $0x1f586,%eax
	int i = 0;
   12a7f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   12a86:	00 
	char ** tmp;

	if (tmp = argv)
   12a87:	8b 44 24 14          	mov    0x14(%esp),%eax
   12a8b:	89 44 24 08          	mov    %eax,0x8(%esp)
   12a8f:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   12a94:	74 1f                	je     12ab5 <count+0x43>
		while (get_fs_long((unsigned long *) (tmp++)))
   12a96:	eb 05                	jmp    12a9d <count+0x2b>
			i++;
   12a98:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
		while (get_fs_long((unsigned long *) (tmp++)))
   12a9d:	8b 44 24 08          	mov    0x8(%esp),%eax
   12aa1:	8d 50 04             	lea    0x4(%eax),%edx
   12aa4:	89 54 24 08          	mov    %edx,0x8(%esp)
   12aa8:	50                   	push   %eax
   12aa9:	e8 f1 fc ff ff       	call   1279f <get_fs_long>
   12aae:	83 c4 04             	add    $0x4,%esp
   12ab1:	85 c0                	test   %eax,%eax
   12ab3:	75 e3                	jne    12a98 <count+0x26>

	return i;
   12ab5:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   12ab9:	83 c4 10             	add    $0x10,%esp
   12abc:	c3                   	ret    

00012abd <copy_strings>:
// 并始终指向参数字符串的头部.字符串来源标志from_kmem应该是TYT为了给execve()增添执行脚本文件的功能而新加的参数.当没有运行
// 脚本文件的功能时,所有参数字符串都在用户数据空间中。
// 返回:参数和环境空间当前头部指针.若出错则返回0.
static unsigned long copy_strings(int argc, char ** argv, unsigned long *page,
		unsigned long p, int from_kmem)
{
   12abd:	56                   	push   %esi
   12abe:	53                   	push   %ebx
   12abf:	83 ec 24             	sub    $0x24,%esp
   12ac2:	e8 33 42 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   12ac7:	81 c3 39 f5 01 00    	add    $0x1f539,%ebx
	char *tmp, *pag;
	int len, offset = 0;
   12acd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   12ad4:	00 
	unsigned long old_fs, new_fs;

	if (!p)
   12ad5:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
   12ada:	75 0a                	jne    12ae6 <copy_strings+0x29>
		return 0;												/* bullet-proofing */	/* 偏移指针验证 */
   12adc:	b8 00 00 00 00       	mov    $0x0,%eax
   12ae1:	e9 bb 01 00 00       	jmp    12ca1 <copy_strings+0x1e4>
	// 首先取当前段寄存器ds(指向内核数据段)和fs值,分别保存到变量new_fs和old_fs中.如果字符串和字符串数组(指针)来自内核空间,则设置fs段寄存器指向内核数据段.
	new_fs = get_ds();
   12ae6:	e8 09 fd ff ff       	call   127f4 <get_ds>
   12aeb:	89 44 24 0c          	mov    %eax,0xc(%esp)
	old_fs = get_fs();
   12aef:	e8 e2 fc ff ff       	call   127d6 <get_fs>
   12af4:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (from_kmem == 2)											// 若串指针在内核空间则设置fs指向内核空间.
   12af8:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
   12afd:	0f 85 71 01 00 00    	jne    12c74 <copy_strings+0x1b7>
		set_fs(new_fs);
   12b03:	ff 74 24 0c          	pushl  0xc(%esp)
   12b07:	e8 06 fd ff ff       	call   12812 <set_fs>
   12b0c:	83 c4 04             	add    $0x4,%esp
	// 然后循环处理各个参数,从最后一个参数逆向开始复制,复制到指定偏移地址处.在循环中,首先取需要复制的当前字符串指针.如果字符串
	// 在用户空间而字符串数组(字符串指针)在内核空间,则设置fs段寄存器指向内核数据段(ds).并在内核数据空间中取了字符串指针tmp之
	// 后就立刻恢复fs段寄存器原值(fs再指回用户空间).否则不用修改fs值而直接从用户空间取字符串指针到tmp.
	while (argc-- > 0) {
   12b0f:	e9 60 01 00 00       	jmp    12c74 <copy_strings+0x1b7>
		if (from_kmem == 1)										// 若串指针在内核空间,则fs指向内核空间.
   12b14:	83 7c 24 40 01       	cmpl   $0x1,0x40(%esp)
   12b19:	75 0c                	jne    12b27 <copy_strings+0x6a>
			set_fs(new_fs);
   12b1b:	ff 74 24 0c          	pushl  0xc(%esp)
   12b1f:	e8 ee fc ff ff       	call   12812 <set_fs>
   12b24:	83 c4 04             	add    $0x4,%esp
		if (!(tmp = (char *)get_fs_long(((unsigned long *)argv) + argc)))
   12b27:	8b 44 24 30          	mov    0x30(%esp),%eax
   12b2b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12b32:	8b 44 24 34          	mov    0x34(%esp),%eax
   12b36:	01 d0                	add    %edx,%eax
   12b38:	50                   	push   %eax
   12b39:	e8 61 fc ff ff       	call   1279f <get_fs_long>
   12b3e:	83 c4 04             	add    $0x4,%esp
   12b41:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   12b45:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   12b4a:	75 12                	jne    12b5e <copy_strings+0xa1>
			panic("argc is wrong");
   12b4c:	83 ec 0c             	sub    $0xc,%esp
   12b4f:	8d 83 50 51 ff ff    	lea    -0xaeb0(%ebx),%eax
   12b55:	50                   	push   %eax
   12b56:	e8 83 67 ff ff       	call   92de <panic>
   12b5b:	83 c4 10             	add    $0x10,%esp
		if (from_kmem == 1)										// 若串指针在内核空间,则fs指回用户空间.
   12b5e:	83 7c 24 40 01       	cmpl   $0x1,0x40(%esp)
   12b63:	75 0f                	jne    12b74 <copy_strings+0xb7>
			set_fs(old_fs);
   12b65:	83 ec 0c             	sub    $0xc,%esp
   12b68:	ff 74 24 14          	pushl  0x14(%esp)
   12b6c:	e8 a1 fc ff ff       	call   12812 <set_fs>
   12b71:	83 c4 10             	add    $0x10,%esp
		// 然后从用户空间取该字符串,并计算参数字符串长度len.此后tmp指向该字符串末端.如果该字符串长度超过此时参数和环境空间中还剩余
		// 的空闲长度,则空间不够了.于是恢复fs段寄存器值(如果被改变的话)并返回0.不过因为参数和环境空间留128KB,所以通常不可能发生这
		// 种情况.
		len = 0;												/* remember zero-padding */
   12b74:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   12b7b:	00 
		do {													/* 我们知道串是以NULL字节结尾的 */
			len++;
   12b7c:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
		} while (get_fs_byte(tmp++));
   12b81:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12b85:	8d 50 01             	lea    0x1(%eax),%edx
   12b88:	89 54 24 1c          	mov    %edx,0x1c(%esp)
   12b8c:	83 ec 0c             	sub    $0xc,%esp
   12b8f:	50                   	push   %eax
   12b90:	e8 f2 fb ff ff       	call   12787 <get_fs_byte>
   12b95:	83 c4 10             	add    $0x10,%esp
   12b98:	84 c0                	test   %al,%al
   12b9a:	75 e0                	jne    12b7c <copy_strings+0xbf>
			return 0;
		}
		// 接着我们逆向逐个字符地把字符串复制到参数和环境空间末端处.在循环复制字符串的字符过程中,我们首先要判断参数和环境空间中相应位
		// 置处是否已经有内存页面.如果还没有就先为其申请1页内存页面.偏移量offset被用途为在一个页面中的当前指针偏移值.因为刚开始执行
		// 本函数时,偏移变量offset被初始化为0,所以(offset-1 < 0)肯定成立而使得offset重新被设置为当前p指针在页面范围内的偏移值.
		while (len) {
   12b9c:	e9 c8 00 00 00       	jmp    12c69 <copy_strings+0x1ac>
			--p; --tmp; --len;
   12ba1:	83 6c 24 3c 01       	subl   $0x1,0x3c(%esp)
   12ba6:	83 6c 24 1c 01       	subl   $0x1,0x1c(%esp)
   12bab:	83 6c 24 14 01       	subl   $0x1,0x14(%esp)
			if (--offset < 0) {
   12bb0:	83 6c 24 10 01       	subl   $0x1,0x10(%esp)
   12bb5:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   12bba:	0f 89 8a 00 00 00    	jns    12c4a <copy_strings+0x18d>
				offset = p % PAGE_SIZE;
   12bc0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   12bc4:	25 ff 0f 00 00       	and    $0xfff,%eax
   12bc9:	89 44 24 10          	mov    %eax,0x10(%esp)
				if (from_kmem == 2)								// 若串在内核空间则fs指回用户空间.
   12bcd:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
   12bd2:	75 0f                	jne    12be3 <copy_strings+0x126>
					set_fs(old_fs);
   12bd4:	83 ec 0c             	sub    $0xc,%esp
   12bd7:	ff 74 24 14          	pushl  0x14(%esp)
   12bdb:	e8 32 fc ff ff       	call   12812 <set_fs>
   12be0:	83 c4 10             	add    $0x10,%esp
				// 如果当前偏移值p所在的串空间页面指针数组项page[p/PAGE_SIZE] == 0,表示此时p指针所处的空间内存页面还不存在,则需申请一空闲
				// 内存页,并将该页面指针填入指针数组,同时也使页面指针pag指向该新页面.若申请不到空闲页面则返回0.
				if (!(pag = (char *) page[p / PAGE_SIZE]) &&
   12be3:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   12be7:	c1 e8 0c             	shr    $0xc,%eax
   12bea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12bf1:	8b 44 24 38          	mov    0x38(%esp),%eax
   12bf5:	01 d0                	add    %edx,%eax
   12bf7:	8b 00                	mov    (%eax),%eax
   12bf9:	89 44 24 18          	mov    %eax,0x18(%esp)
   12bfd:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   12c02:	75 30                	jne    12c34 <copy_strings+0x177>
				    !(pag = (char *) (page[p / PAGE_SIZE] =
   12c04:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   12c08:	c1 e8 0c             	shr    $0xc,%eax
   12c0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12c12:	8b 44 24 38          	mov    0x38(%esp),%eax
   12c16:	8d 34 02             	lea    (%edx,%eax,1),%esi
				      get_free_page())))
   12c19:	e8 ce b3 ff ff       	call   dfec <get_free_page>
				    !(pag = (char *) (page[p / PAGE_SIZE] =
   12c1e:	89 06                	mov    %eax,(%esi)
   12c20:	8b 06                	mov    (%esi),%eax
   12c22:	89 44 24 18          	mov    %eax,0x18(%esp)
				if (!(pag = (char *) page[p / PAGE_SIZE]) &&
   12c26:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   12c2b:	75 07                	jne    12c34 <copy_strings+0x177>
					return 0;
   12c2d:	b8 00 00 00 00       	mov    $0x0,%eax
   12c32:	eb 6d                	jmp    12ca1 <copy_strings+0x1e4>
				if (from_kmem == 2)								// 若串在内核空间则fs指向内核空间.
   12c34:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
   12c39:	75 0f                	jne    12c4a <copy_strings+0x18d>
					set_fs(new_fs);
   12c3b:	83 ec 0c             	sub    $0xc,%esp
   12c3e:	ff 74 24 18          	pushl  0x18(%esp)
   12c42:	e8 cb fb ff ff       	call   12812 <set_fs>
   12c47:	83 c4 10             	add    $0x10,%esp

			}
			// 然后从fs段中复制字符串的1字节到参数和环境空间内存页面pag的offset处.
			*(pag + offset) = get_fs_byte(tmp);
   12c4a:	83 ec 0c             	sub    $0xc,%esp
   12c4d:	ff 74 24 28          	pushl  0x28(%esp)
   12c51:	e8 31 fb ff ff       	call   12787 <get_fs_byte>
   12c56:	83 c4 10             	add    $0x10,%esp
   12c59:	89 c1                	mov    %eax,%ecx
   12c5b:	8b 54 24 10          	mov    0x10(%esp),%edx
   12c5f:	8b 44 24 18          	mov    0x18(%esp),%eax
   12c63:	01 d0                	add    %edx,%eax
   12c65:	89 ca                	mov    %ecx,%edx
   12c67:	88 10                	mov    %dl,(%eax)
		while (len) {
   12c69:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   12c6e:	0f 85 2d ff ff ff    	jne    12ba1 <copy_strings+0xe4>
	while (argc-- > 0) {
   12c74:	8b 44 24 30          	mov    0x30(%esp),%eax
   12c78:	8d 50 ff             	lea    -0x1(%eax),%edx
   12c7b:	89 54 24 30          	mov    %edx,0x30(%esp)
   12c7f:	85 c0                	test   %eax,%eax
   12c81:	0f 8f 8d fe ff ff    	jg     12b14 <copy_strings+0x57>
		}
	}
	// 如果字符串和字符串数组在内核空间,则恢复fs段寄存器原值.最后,返回参数和环境空间中已复制参数的头部偏移值.
	if (from_kmem == 2)
   12c87:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
   12c8c:	75 0f                	jne    12c9d <copy_strings+0x1e0>
		set_fs(old_fs);
   12c8e:	83 ec 0c             	sub    $0xc,%esp
   12c91:	ff 74 24 14          	pushl  0x14(%esp)
   12c95:	e8 78 fb ff ff       	call   12812 <set_fs>
   12c9a:	83 c4 10             	add    $0x10,%esp
	return p;
   12c9d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
}
   12ca1:	83 c4 24             	add    $0x24,%esp
   12ca4:	5b                   	pop    %ebx
   12ca5:	5e                   	pop    %esi
   12ca6:	c3                   	ret    

00012ca7 <change_ldt>:
// 修改任务的局部描述符表内容.
// 修改局部描述符表LDT中描述符的段基址和段限长,并将参数和环境空间页面放置在数据段末端.
// 参数:text_size - 执行文件头部中a_text字段给出的代码段长度值;page - 参数和环境空间页面指针数组.
// 返回:数据段限长值(64MB)
static unsigned long change_ldt(unsigned long text_size, unsigned long * page)
{
   12ca7:	57                   	push   %edi
   12ca8:	56                   	push   %esi
   12ca9:	53                   	push   %ebx
   12caa:	83 ec 20             	sub    $0x20,%esp
   12cad:	e8 48 40 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   12cb2:	81 c3 4e f3 01 00    	add    $0x1f34e,%ebx
	int i;

	// 首先把代码和数据段长度均设置为64MB.然后取当前进程局部描述符表代码段描述符中代码段基址.代码段基址与数据段基址相同.
	// 再使用这些新值重新设置局部表中代码段和数据段描述符中的基址和段限长.这里请注意,由于被加载的新程序的代码和数据段基址
	// 与原程序的相同,因此没有必要再重复设置它们,即186和188行上的两条设置段基址的语句多余,可省略.
	code_limit = TASK_SIZE;
   12cb8:	c7 44 24 14 00 00 00 	movl   $0x4000000,0x14(%esp)
   12cbf:	04 
	data_limit = TASK_SIZE;
   12cc0:	c7 44 24 10 00 00 00 	movl   $0x4000000,0x10(%esp)
   12cc7:	04 
	code_base = get_base(current->ldt[1]);
   12cc8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12cce:	8b 00                	mov    (%eax),%eax
   12cd0:	05 a0 03 00 00       	add    $0x3a0,%eax
   12cd5:	8d 70 02             	lea    0x2(%eax),%esi
   12cd8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12cde:	8b 00                	mov    (%eax),%eax
   12ce0:	05 a0 03 00 00       	add    $0x3a0,%eax
   12ce5:	8d 48 04             	lea    0x4(%eax),%ecx
   12ce8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12cee:	8b 00                	mov    (%eax),%eax
   12cf0:	05 a0 03 00 00       	add    $0x3a0,%eax
   12cf5:	83 c0 07             	add    $0x7,%eax
   12cf8:	8a 30                	mov    (%eax),%dh
   12cfa:	8a 11                	mov    (%ecx),%dl
   12cfc:	c1 e2 10             	shl    $0x10,%edx
   12cff:	66 8b 16             	mov    (%esi),%dx
   12d02:	89 d0                	mov    %edx,%eax
   12d04:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12d08:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12d0c:	89 44 24 08          	mov    %eax,0x8(%esp)
	data_base = code_base;
   12d10:	8b 44 24 08          	mov    0x8(%esp),%eax
   12d14:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	set_base(current->ldt[1], code_base);
   12d18:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12d1e:	8b 00                	mov    (%eax),%eax
   12d20:	05 a0 03 00 00       	add    $0x3a0,%eax
   12d25:	8d 48 02             	lea    0x2(%eax),%ecx
   12d28:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12d2e:	8b 00                	mov    (%eax),%eax
   12d30:	05 a0 03 00 00       	add    $0x3a0,%eax
   12d35:	8d 70 04             	lea    0x4(%eax),%esi
   12d38:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12d3e:	8b 00                	mov    (%eax),%eax
   12d40:	05 a0 03 00 00       	add    $0x3a0,%eax
   12d45:	8d 78 07             	lea    0x7(%eax),%edi
   12d48:	8b 44 24 08          	mov    0x8(%esp),%eax
   12d4c:	89 c2                	mov    %eax,%edx
   12d4e:	66 89 11             	mov    %dx,(%ecx)
   12d51:	c1 ca 10             	ror    $0x10,%edx
   12d54:	88 16                	mov    %dl,(%esi)
   12d56:	88 37                	mov    %dh,(%edi)
   12d58:	89 d0                	mov    %edx,%eax
   12d5a:	89 44 24 04          	mov    %eax,0x4(%esp)
	set_limit(current->ldt[1], code_limit);
   12d5e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12d64:	8b 00                	mov    (%eax),%eax
   12d66:	8d 88 a0 03 00 00    	lea    0x3a0(%eax),%ecx
   12d6c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12d72:	8b 00                	mov    (%eax),%eax
   12d74:	05 a0 03 00 00       	add    $0x3a0,%eax
   12d79:	83 c0 06             	add    $0x6,%eax
   12d7c:	8b 54 24 14          	mov    0x14(%esp),%edx
   12d80:	83 ea 01             	sub    $0x1,%edx
   12d83:	c1 ea 0c             	shr    $0xc,%edx
   12d86:	66 89 11             	mov    %dx,(%ecx)
   12d89:	c1 ca 10             	ror    $0x10,%edx
   12d8c:	8a 30                	mov    (%eax),%dh
   12d8e:	80 e6 f0             	and    $0xf0,%dh
   12d91:	08 f2                	or     %dh,%dl
   12d93:	88 10                	mov    %dl,(%eax)
	set_base(current->ldt[2], data_base);
   12d95:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12d9b:	8b 00                	mov    (%eax),%eax
   12d9d:	05 a8 03 00 00       	add    $0x3a8,%eax
   12da2:	8d 48 02             	lea    0x2(%eax),%ecx
   12da5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12dab:	8b 00                	mov    (%eax),%eax
   12dad:	05 a8 03 00 00       	add    $0x3a8,%eax
   12db2:	8d 70 04             	lea    0x4(%eax),%esi
   12db5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12dbb:	8b 00                	mov    (%eax),%eax
   12dbd:	05 a8 03 00 00       	add    $0x3a8,%eax
   12dc2:	8d 78 07             	lea    0x7(%eax),%edi
   12dc5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12dc9:	89 c2                	mov    %eax,%edx
   12dcb:	66 89 11             	mov    %dx,(%ecx)
   12dce:	c1 ca 10             	ror    $0x10,%edx
   12dd1:	88 16                	mov    %dl,(%esi)
   12dd3:	88 37                	mov    %dh,(%edi)
   12dd5:	89 d0                	mov    %edx,%eax
   12dd7:	89 04 24             	mov    %eax,(%esp)
	set_limit(current->ldt[2], data_limit);
   12dda:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12de0:	8b 00                	mov    (%eax),%eax
   12de2:	8d 88 a8 03 00 00    	lea    0x3a8(%eax),%ecx
   12de8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12dee:	8b 00                	mov    (%eax),%eax
   12df0:	05 a8 03 00 00       	add    $0x3a8,%eax
   12df5:	83 c0 06             	add    $0x6,%eax
   12df8:	8b 54 24 10          	mov    0x10(%esp),%edx
   12dfc:	83 ea 01             	sub    $0x1,%edx
   12dff:	c1 ea 0c             	shr    $0xc,%edx
   12e02:	66 89 11             	mov    %dx,(%ecx)
   12e05:	c1 ca 10             	ror    $0x10,%edx
   12e08:	8a 30                	mov    (%eax),%dh
   12e0a:	80 e6 f0             	and    $0xf0,%dh
   12e0d:	08 f2                	or     %dh,%dl
   12e0f:	88 10                	mov    %dl,(%eax)
	/* make sure fs points to the NEW data segment */
	/* 要确信fs段寄存器已指向新的数据段 */
	// fs段寄存器中放入局部表数据段描述符的选择符(0x17).即默认情况下fs都指向任务数据段.
	__asm__("pushl $0x17\n\tpop %%fs"::);
   12e11:	6a 17                	push   $0x17
   12e13:	0f a1                	pop    %fs
	// 然后将参数和环境空间已存放数据的页面(最多有MAX_ARG_PAGES页,128KB)放到数据段末端.方法是从进程空间库代码位置开始处
	// 逆向一页一页地放.库文件代码占用进程空间最后4MB.函数put_dirty_page()用于把物理页面映射到进程逻辑空间中.在mm/memory.c中.
	data_base += data_limit - LIBRARY_SIZE;
   12e15:	8b 54 24 10          	mov    0x10(%esp),%edx
   12e19:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12e1d:	01 d0                	add    %edx,%eax
   12e1f:	2d 00 00 40 00       	sub    $0x400000,%eax
   12e24:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	for (i = MAX_ARG_PAGES - 1 ; i >= 0 ; i--) {
   12e28:	c7 44 24 18 1f 00 00 	movl   $0x1f,0x18(%esp)
   12e2f:	00 
   12e30:	eb 47                	jmp    12e79 <change_ldt+0x1d2>
		data_base -= PAGE_SIZE;
   12e32:	81 6c 24 1c 00 10 00 	subl   $0x1000,0x1c(%esp)
   12e39:	00 
		if (page[i])									// 若该页面存在,就放置该页面.
   12e3a:	8b 44 24 18          	mov    0x18(%esp),%eax
   12e3e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12e45:	8b 44 24 34          	mov    0x34(%esp),%eax
   12e49:	01 d0                	add    %edx,%eax
   12e4b:	8b 00                	mov    (%eax),%eax
   12e4d:	85 c0                	test   %eax,%eax
   12e4f:	74 23                	je     12e74 <change_ldt+0x1cd>
			put_dirty_page(page[i], data_base);
   12e51:	8b 44 24 18          	mov    0x18(%esp),%eax
   12e55:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12e5c:	8b 44 24 34          	mov    0x34(%esp),%eax
   12e60:	01 d0                	add    %edx,%eax
   12e62:	8b 00                	mov    (%eax),%eax
   12e64:	83 ec 08             	sub    $0x8,%esp
   12e67:	ff 74 24 24          	pushl  0x24(%esp)
   12e6b:	50                   	push   %eax
   12e6c:	e8 de a0 ff ff       	call   cf4f <put_dirty_page>
   12e71:	83 c4 10             	add    $0x10,%esp
	for (i = MAX_ARG_PAGES - 1 ; i >= 0 ; i--) {
   12e74:	83 6c 24 18 01       	subl   $0x1,0x18(%esp)
   12e79:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   12e7e:	79 b2                	jns    12e32 <change_ldt+0x18b>
	}
	return data_limit;									// 最后返回数据段限长(64MB).
   12e80:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   12e84:	83 c4 20             	add    $0x20,%esp
   12e87:	5b                   	pop    %ebx
   12e88:	5e                   	pop    %esi
   12e89:	5f                   	pop    %edi
   12e8a:	c3                   	ret    

00012e8b <do_execve>:
// argv - 命令行参数指针数组的指针;
// envp - 环境变更指针数组的指针.
// 返回:如果调用成功,则不返回;否则设置出错号,并返回-1.
int do_execve(unsigned long * eip, long tmp, char * filename,
	char ** argv, char ** envp)
{
   12e8b:	57                   	push   %edi
   12e8c:	56                   	push   %esi
   12e8d:	53                   	push   %ebx
   12e8e:	81 ec 00 02 00 00    	sub    $0x200,%esp
   12e94:	e8 61 3e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   12e99:	81 c3 67 f1 01 00    	add    $0x1f167,%ebx
	struct exec ex;
	unsigned long page[MAX_ARG_PAGES];							// 参数和环境串空间页面指针数组.
	int i, argc, envc;
	int e_uid, e_gid;											// 有效用户ID和有效组ID.
	int retval;
	int sh_bang = 0;											// 控制是否需要执行脚本程序.
   12e9f:	c7 84 24 ec 01 00 00 	movl   $0x0,0x1ec(%esp)
   12ea6:	00 00 00 00 
	unsigned long p = PAGE_SIZE * MAX_ARG_PAGES - 4;			// p指向参数和环境空间的最后部.
   12eaa:	c7 84 24 e8 01 00 00 	movl   $0x1fffc,0x1e8(%esp)
   12eb1:	fc ff 01 00 

	// 在内核中打印要执行的文件的文件名字
	char s, filename1[128];
	int index = 0;
   12eb5:	c7 84 24 e4 01 00 00 	movl   $0x0,0x1e4(%esp)
   12ebc:	00 00 00 00 
	while (1) {
		s = get_fs_byte(filename + index);
   12ec0:	8b 94 24 18 02 00 00 	mov    0x218(%esp),%edx
   12ec7:	8b 84 24 e4 01 00 00 	mov    0x1e4(%esp),%eax
   12ece:	01 d0                	add    %edx,%eax
   12ed0:	50                   	push   %eax
   12ed1:	e8 b1 f8 ff ff       	call   12787 <get_fs_byte>
   12ed6:	83 c4 04             	add    $0x4,%esp
   12ed9:	88 84 24 df 01 00 00 	mov    %al,0x1df(%esp)
		if (s) {
   12ee0:	80 bc 24 df 01 00 00 	cmpb   $0x0,0x1df(%esp)
   12ee7:	00 
   12ee8:	74 24                	je     12f0e <do_execve+0x83>
			*(filename1 + index) = s;
   12eea:	8b 84 24 e4 01 00 00 	mov    0x1e4(%esp),%eax
   12ef1:	8d 94 24 94 00 00 00 	lea    0x94(%esp),%edx
   12ef8:	01 c2                	add    %eax,%edx
   12efa:	0f b6 84 24 df 01 00 	movzbl 0x1df(%esp),%eax
   12f01:	00 
   12f02:	88 02                	mov    %al,(%edx)
			index++;
   12f04:	83 84 24 e4 01 00 00 	addl   $0x1,0x1e4(%esp)
   12f0b:	01 
		s = get_fs_byte(filename + index);
   12f0c:	eb b2                	jmp    12ec0 <do_execve+0x35>
		} else {
			break;
   12f0e:	90                   	nop
		}
	}
	*(filename1 + index + 1) = '\0';
   12f0f:	8b 84 24 e4 01 00 00 	mov    0x1e4(%esp),%eax
   12f16:	8d 50 01             	lea    0x1(%eax),%edx
   12f19:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
   12f20:	01 d0                	add    %edx,%eax
   12f22:	c6 00 00             	movb   $0x0,(%eax)
	Log(LOG_INFO_TYPE, "<<<<< process pid = %d do_execve : %s >>>>>\n", current->pid, filename1);
   12f25:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   12f2b:	8b 00                	mov    (%eax),%eax
   12f2d:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
   12f33:	8d 94 24 94 00 00 00 	lea    0x94(%esp),%edx
   12f3a:	52                   	push   %edx
   12f3b:	50                   	push   %eax
   12f3c:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
   12f42:	50                   	push   %eax
   12f43:	6a 00                	push   $0x0
   12f45:	e8 55 2c 01 00       	call   25b9f <Log>
   12f4a:	83 c4 10             	add    $0x10,%esp
	// 上行把p初始设置成位于128KB空间的最后1个长字处.在初始参数和环境空间的操作过程中,p将用来指明在128KB空间中的当前位置.
	// 另外,参数eip[1]是调用本次系统调用的原用户程序代码段寄存器CS值,其中的段选择符当然必须是当前任务的代码段选择符(0x000f).
	// 若不是该值,那么CS只能会是内核代码段的选择符0x0008.但这是绝对不允许的,因为内核代码是常驻内存而不能被替换掉的.因此下面根据
	// eip[1]的值确认是否符合正常情况.然后再初始化128KB的参数和环境串空间,把所有字节清零,并取出执行文件的i节点.再根据函数参数
	// 分别计算出命令行参数和环境字符串的个数argc和envc.另外,执行文件必须是常规文件.
	if ((0xffff & eip[1]) != 0x000f)
   12f4d:	8b 84 24 10 02 00 00 	mov    0x210(%esp),%eax
   12f54:	83 c0 04             	add    $0x4,%eax
   12f57:	8b 00                	mov    (%eax),%eax
   12f59:	0f b7 c0             	movzwl %ax,%eax
   12f5c:	83 f8 0f             	cmp    $0xf,%eax
   12f5f:	74 12                	je     12f73 <do_execve+0xe8>
		panic("execve called from supervisor mode");
   12f61:	83 ec 0c             	sub    $0xc,%esp
   12f64:	8d 83 90 51 ff ff    	lea    -0xae70(%ebx),%eax
   12f6a:	50                   	push   %eax
   12f6b:	e8 6e 63 ff ff       	call   92de <panic>
   12f70:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)						/* clear page-table */
   12f73:	c7 84 24 f8 01 00 00 	movl   $0x0,0x1f8(%esp)
   12f7a:	00 00 00 00 
   12f7e:	eb 1a                	jmp    12f9a <do_execve+0x10f>
		page[i] = 0;
   12f80:	8b 84 24 f8 01 00 00 	mov    0x1f8(%esp),%eax
   12f87:	c7 84 84 14 01 00 00 	movl   $0x0,0x114(%esp,%eax,4)
   12f8e:	00 00 00 00 
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)						/* clear page-table */
   12f92:	83 84 24 f8 01 00 00 	addl   $0x1,0x1f8(%esp)
   12f99:	01 
   12f9a:	83 bc 24 f8 01 00 00 	cmpl   $0x1f,0x1f8(%esp)
   12fa1:	1f 
   12fa2:	7e dc                	jle    12f80 <do_execve+0xf5>
	if (!(inode = namei(filename)))								/* get executables inode */
   12fa4:	8b 84 24 18 02 00 00 	mov    0x218(%esp),%eax
   12fab:	83 ec 0c             	sub    $0xc,%esp
   12fae:	50                   	push   %eax
   12faf:	e8 f9 1c 00 00       	call   14cad <namei>
   12fb4:	83 c4 10             	add    $0x10,%esp
   12fb7:	89 84 24 fc 01 00 00 	mov    %eax,0x1fc(%esp)
   12fbe:	83 bc 24 fc 01 00 00 	cmpl   $0x0,0x1fc(%esp)
   12fc5:	00 
   12fc6:	75 0a                	jne    12fd2 <do_execve+0x147>
		return -ENOENT;
   12fc8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   12fcd:	e9 eb 0a 00 00       	jmp    13abd <do_execve+0xc32>
	argc = count(argv);											// 命令行参数个数.
   12fd2:	83 ec 0c             	sub    $0xc,%esp
   12fd5:	ff b4 24 28 02 00 00 	pushl  0x228(%esp)
   12fdc:	e8 91 fa ff ff       	call   12a72 <count>
   12fe1:	83 c4 10             	add    $0x10,%esp
   12fe4:	89 84 24 f4 01 00 00 	mov    %eax,0x1f4(%esp)
	envc = count(envp);											// 环境字符串变量个数.
   12feb:	83 ec 0c             	sub    $0xc,%esp
   12fee:	ff b4 24 2c 02 00 00 	pushl  0x22c(%esp)
   12ff5:	e8 78 fa ff ff       	call   12a72 <count>
   12ffa:	83 c4 10             	add    $0x10,%esp
   12ffd:	89 84 24 d8 01 00 00 	mov    %eax,0x1d8(%esp)

restart_interp:
	if (!S_ISREG(inode->i_mode)) {								/* must be regular file */
   13004:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   1300b:	0f b7 00             	movzwl (%eax),%eax
   1300e:	0f b7 c0             	movzwl %ax,%eax
   13011:	25 00 f0 00 00       	and    $0xf000,%eax
   13016:	3d 00 80 00 00       	cmp    $0x8000,%eax
   1301b:	74 10                	je     1302d <do_execve+0x1a2>
		retval = -EACCES;
   1301d:	c7 84 24 f0 01 00 00 	movl   $0xfffffff3,0x1f0(%esp)
   13024:	f3 ff ff ff 
		goto exec_error2;										// 若不是常规文件则置出错码,跳转到376行.
   13028:	e9 3e 0a 00 00       	jmp    13a6b <do_execve+0xbe0>
	// 字段值取到i中后,我们首先查看属性中是否设置了"设置-用户-ID"(set-user-ID)标志和"设置-组-ID)(set-group-id)标志.这两
	// 个标志主要是让一般用户能够执行特权用户(如超级用户root)的程序,例如改变密码的程序passwd等.如果set-user-ID标志置位,则
	// 后面执行进程的有效用户ID(euid)就设置成执行文件的用户ID,否则设置成当前进程的euid.如果执行文件set-group-id被置位的话,
	// 则执行进程的有效组ID(egid)就设置为执行执行文件的组ID.否则设置成当前进程的egid.这里暂把这两个判断出来的值保存在变量
	// e_uid和e_gid中.
	i = inode->i_mode;
   1302d:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   13034:	0f b7 00             	movzwl (%eax),%eax
   13037:	0f b7 c0             	movzwl %ax,%eax
   1303a:	89 84 24 f8 01 00 00 	mov    %eax,0x1f8(%esp)
	e_uid = (i & S_ISUID) ? inode->i_uid : current->euid;
   13041:	8b 84 24 f8 01 00 00 	mov    0x1f8(%esp),%eax
   13048:	25 00 08 00 00       	and    $0x800,%eax
   1304d:	85 c0                	test   %eax,%eax
   1304f:	74 10                	je     13061 <do_execve+0x1d6>
   13051:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   13058:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   1305c:	0f b7 c0             	movzwl %ax,%eax
   1305f:	eb 12                	jmp    13073 <do_execve+0x1e8>
   13061:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13067:	8b 00                	mov    (%eax),%eax
   13069:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
   13070:	0f b7 c0             	movzwl %ax,%eax
   13073:	89 84 24 d4 01 00 00 	mov    %eax,0x1d4(%esp)
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
   1307a:	8b 84 24 f8 01 00 00 	mov    0x1f8(%esp),%eax
   13081:	25 00 04 00 00       	and    $0x400,%eax
   13086:	85 c0                	test   %eax,%eax
   13088:	74 10                	je     1309a <do_execve+0x20f>
   1308a:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   13091:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   13095:	0f b6 c0             	movzbl %al,%eax
   13098:	eb 12                	jmp    130ac <do_execve+0x221>
   1309a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   130a0:	8b 00                	mov    (%eax),%eax
   130a2:	0f b7 80 d4 02 00 00 	movzwl 0x2d4(%eax),%eax
   130a9:	0f b7 c0             	movzwl %ax,%eax
   130ac:	89 84 24 d0 01 00 00 	mov    %eax,0x1d0(%esp)
	// 现在根据进程的euid和egid和执行文件的访问属性进行比较.如果执行文件属于运行进程的用户,则把文件属性值i右移6位,此时其最低3
	// 位是文件宿主的访问权限标志.否则的话如果执行文件与当前进程的用户属于同组,则使属性最低3位是执行文件组用户的访问权限标志.否则
	// 此时属性字最低3位就是其他用户访问该执行文件的权限.然后我们根据属性字i的最低3位值来判断当前进程是否有权限运行这个执行文件.
	// 如果选出的相应用户没有运行该文件的权力(位0是执行权限),并且其他用户也没有任何权限或者当前进程用户不是超级用户,则表明当前进
	// 程没有权力运行这个执行文件.于是置不可执行出错码,并跳转到exec_error2处去作退出处理.
	if (current->euid == inode->i_uid)
   130b3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   130b9:	8b 00                	mov    (%eax),%eax
   130bb:	0f b7 90 ce 02 00 00 	movzwl 0x2ce(%eax),%edx
   130c2:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   130c9:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   130cd:	66 39 c2             	cmp    %ax,%dx
   130d0:	75 0a                	jne    130dc <do_execve+0x251>
		i >>= 6;
   130d2:	c1 bc 24 f8 01 00 00 	sarl   $0x6,0x1f8(%esp)
   130d9:	06 
   130da:	eb 26                	jmp    13102 <do_execve+0x277>
	else if (in_group_p(inode->i_gid))
   130dc:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   130e3:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   130e7:	0f b6 c0             	movzbl %al,%eax
   130ea:	83 ec 0c             	sub    $0xc,%esp
   130ed:	50                   	push   %eax
   130ee:	e8 88 74 ff ff       	call   a57b <in_group_p>
   130f3:	83 c4 10             	add    $0x10,%esp
   130f6:	85 c0                	test   %eax,%eax
   130f8:	74 08                	je     13102 <do_execve+0x277>
		i >>= 3;
   130fa:	c1 bc 24 f8 01 00 00 	sarl   $0x3,0x1f8(%esp)
   13101:	03 
	if (!(i & 1) &&
   13102:	8b 84 24 f8 01 00 00 	mov    0x1f8(%esp),%eax
   13109:	83 e0 01             	and    $0x1,%eax
   1310c:	85 c0                	test   %eax,%eax
   1310e:	75 38                	jne    13148 <do_execve+0x2bd>
	    !((inode->i_mode & 0111) && suser())) {
   13110:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   13117:	0f b7 00             	movzwl (%eax),%eax
   1311a:	0f b7 c0             	movzwl %ax,%eax
   1311d:	83 e0 49             	and    $0x49,%eax
	if (!(i & 1) &&
   13120:	85 c0                	test   %eax,%eax
   13122:	74 14                	je     13138 <do_execve+0x2ad>
	    !((inode->i_mode & 0111) && suser())) {
   13124:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1312a:	8b 00                	mov    (%eax),%eax
   1312c:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
   13133:	66 85 c0             	test   %ax,%ax
   13136:	74 10                	je     13148 <do_execve+0x2bd>
		retval = -ENOEXEC;
   13138:	c7 84 24 f0 01 00 00 	movl   $0xfffffff8,0x1f0(%esp)
   1313f:	f8 ff ff ff 
		goto exec_error2;
   13143:	e9 23 09 00 00       	jmp    13a6b <do_execve+0xbe0>
	// 的解释程序名及后面的参数(若有的话),然后将这些参数和脚本文件名放进执行文件(此时是解释程序)的命令行参数空间中.在这之前我们当然
	// 需要先把函数指定的原有命令行参数和环境字符串放到128KB空间中,而这里建立起来的命令行参数则放到它们前面位置处(因为是逆向放置).
	// 最后让内核执行脚本文件的解释程序.下面就是在设置好解释程序的脚本文件名等参数后,取出解释程序的i节点并跳转到229行支执行解释程序.
	// 由于我们需要跳转到执行过的代码229行支.因此在下面确认并处理了脚本文件之后需要设置一个禁止再次执行下面的脚本处理代码标志sh_bang.
	// 在后面的代码中该标志也用来表示我们已经设置好执行文件的命令行参数,不要重复设置.
	if (!(bh = bread(inode->i_dev, inode->i_zone[0]))) {
   13148:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   1314f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   13153:	0f b7 d0             	movzwl %ax,%edx
   13156:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   1315d:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   13161:	0f b7 c0             	movzwl %ax,%eax
   13164:	83 ec 08             	sub    $0x8,%esp
   13167:	52                   	push   %edx
   13168:	50                   	push   %eax
   13169:	e8 64 d8 ff ff       	call   109d2 <bread>
   1316e:	83 c4 10             	add    $0x10,%esp
   13171:	89 84 24 cc 01 00 00 	mov    %eax,0x1cc(%esp)
   13178:	83 bc 24 cc 01 00 00 	cmpl   $0x0,0x1cc(%esp)
   1317f:	00 
   13180:	75 10                	jne    13192 <do_execve+0x307>
		retval = -EACCES;
   13182:	c7 84 24 f0 01 00 00 	movl   $0xfffffff3,0x1f0(%esp)
   13189:	f3 ff ff ff 
		goto exec_error2;
   1318d:	e9 d9 08 00 00       	jmp    13a6b <do_execve+0xbe0>
	}
	ex = *((struct exec *) bh->b_data);								/* read exec-header */
   13192:	8b 84 24 cc 01 00 00 	mov    0x1cc(%esp),%eax
   13199:	8b 00                	mov    (%eax),%eax
   1319b:	8b 10                	mov    (%eax),%edx
   1319d:	89 94 24 94 01 00 00 	mov    %edx,0x194(%esp)
   131a4:	8b 50 04             	mov    0x4(%eax),%edx
   131a7:	89 94 24 98 01 00 00 	mov    %edx,0x198(%esp)
   131ae:	8b 50 08             	mov    0x8(%eax),%edx
   131b1:	89 94 24 9c 01 00 00 	mov    %edx,0x19c(%esp)
   131b8:	8b 50 0c             	mov    0xc(%eax),%edx
   131bb:	89 94 24 a0 01 00 00 	mov    %edx,0x1a0(%esp)
   131c2:	8b 50 10             	mov    0x10(%eax),%edx
   131c5:	89 94 24 a4 01 00 00 	mov    %edx,0x1a4(%esp)
   131cc:	8b 50 14             	mov    0x14(%eax),%edx
   131cf:	89 94 24 a8 01 00 00 	mov    %edx,0x1a8(%esp)
   131d6:	8b 50 18             	mov    0x18(%eax),%edx
   131d9:	89 94 24 ac 01 00 00 	mov    %edx,0x1ac(%esp)
   131e0:	8b 40 1c             	mov    0x1c(%eax),%eax
   131e3:	89 84 24 b0 01 00 00 	mov    %eax,0x1b0(%esp)
	if ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) {
   131ea:	8b 84 24 cc 01 00 00 	mov    0x1cc(%esp),%eax
   131f1:	8b 00                	mov    (%eax),%eax
   131f3:	0f b6 00             	movzbl (%eax),%eax
   131f6:	3c 23                	cmp    $0x23,%al
   131f8:	0f 85 61 03 00 00    	jne    1355f <do_execve+0x6d4>
   131fe:	8b 84 24 cc 01 00 00 	mov    0x1cc(%esp),%eax
   13205:	8b 00                	mov    (%eax),%eax
   13207:	83 c0 01             	add    $0x1,%eax
   1320a:	0f b6 00             	movzbl (%eax),%eax
   1320d:	3c 21                	cmp    $0x21,%al
   1320f:	0f 85 4a 03 00 00    	jne    1355f <do_execve+0x6d4>
   13215:	83 bc 24 ec 01 00 00 	cmpl   $0x0,0x1ec(%esp)
   1321c:	00 
   1321d:	0f 85 3c 03 00 00    	jne    1355f <do_execve+0x6d4>
		unsigned long old_fs;

		// 从这里开始，我们从脚本文件中提取解释程序名及其参数，并把解释程序名、解释程序的参数和脚本文件名组合放入环境参数块中。首先复制脚本
		// 文件头1行字符‘#!’后面的字符串到buf中，其中含有脚本解释程序名（例如/bin/sh），也可能还包含解释程序的几个参数。然后对buf中的内容
		// 进行处理。删除开始的空格、制表符。
		strncpy(buf, bh->b_data + 2, 127);
   13223:	8b 84 24 cc 01 00 00 	mov    0x1cc(%esp),%eax
   1322a:	8b 00                	mov    (%eax),%eax
   1322c:	83 c0 02             	add    $0x2,%eax
   1322f:	83 ec 04             	sub    $0x4,%esp
   13232:	6a 7f                	push   $0x7f
   13234:	50                   	push   %eax
   13235:	8d 44 24 18          	lea    0x18(%esp),%eax
   13239:	50                   	push   %eax
   1323a:	e8 df f4 ff ff       	call   1271e <strncpy>
   1323f:	83 c4 10             	add    $0x10,%esp
		brelse(bh);             									// 释放缓冲块并放回脚本文件i节点。
   13242:	83 ec 0c             	sub    $0xc,%esp
   13245:	ff b4 24 d8 01 00 00 	pushl  0x1d8(%esp)
   1324c:	e8 1a d7 ff ff       	call   1096b <brelse>
   13251:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   13254:	83 ec 0c             	sub    $0xc,%esp
   13257:	ff b4 24 08 02 00 00 	pushl  0x208(%esp)
   1325e:	e8 3f c6 ff ff       	call   f8a2 <iput>
   13263:	83 c4 10             	add    $0x10,%esp
		buf[127] = '\0';
   13266:	c6 84 24 8b 00 00 00 	movb   $0x0,0x8b(%esp)
   1326d:	00 
		if (cp = strchr(buf, '\n')) {
   1326e:	83 ec 08             	sub    $0x8,%esp
   13271:	6a 0a                	push   $0xa
   13273:	8d 44 24 18          	lea    0x18(%esp),%eax
   13277:	50                   	push   %eax
   13278:	e8 d2 f4 ff ff       	call   1274f <strchr>
   1327d:	83 c4 10             	add    $0x10,%esp
   13280:	89 84 24 e0 01 00 00 	mov    %eax,0x1e0(%esp)
   13287:	83 bc 24 e0 01 00 00 	cmpl   $0x0,0x1e0(%esp)
   1328e:	00 
   1328f:	74 3b                	je     132cc <do_execve+0x441>
			*cp = '\0';     										// 第1个换行符换成NULL并去掉行头空格制表符。
   13291:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13298:	c6 00 00             	movb   $0x0,(%eax)
			for (cp = buf; (*cp == ' ') || (*cp == '\t'); cp++);
   1329b:	8d 44 24 0c          	lea    0xc(%esp),%eax
   1329f:	89 84 24 e0 01 00 00 	mov    %eax,0x1e0(%esp)
   132a6:	eb 08                	jmp    132b0 <do_execve+0x425>
   132a8:	83 84 24 e0 01 00 00 	addl   $0x1,0x1e0(%esp)
   132af:	01 
   132b0:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   132b7:	0f b6 00             	movzbl (%eax),%eax
   132ba:	3c 20                	cmp    $0x20,%al
   132bc:	74 ea                	je     132a8 <do_execve+0x41d>
   132be:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   132c5:	0f b6 00             	movzbl (%eax),%eax
   132c8:	3c 09                	cmp    $0x9,%al
   132ca:	74 dc                	je     132a8 <do_execve+0x41d>
		}
		if (!cp || *cp == '\0') {       							// 若该行没有其他内容，则出错。
   132cc:	83 bc 24 e0 01 00 00 	cmpl   $0x0,0x1e0(%esp)
   132d3:	00 
   132d4:	74 0e                	je     132e4 <do_execve+0x459>
   132d6:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   132dd:	0f b6 00             	movzbl (%eax),%eax
   132e0:	84 c0                	test   %al,%al
   132e2:	75 10                	jne    132f4 <do_execve+0x469>
			retval = -ENOEXEC; 										/* No interpreter name found */
   132e4:	c7 84 24 f0 01 00 00 	movl   $0xfffffff8,0x1f0(%esp)
   132eb:	f8 ff ff ff 
			goto exec_error1;       								/* 没有找到脚本解释程序名 */
   132ef:	e9 89 07 00 00       	jmp    13a7d <do_execve+0xbf2>
		}
		// 此时我们得到了开头是脚本解释程序名的一行内容（字符串）。下面分析该行。首先取第一个字符串，它应该是解释程序名，此时i_name指向该
		// 名称。若解释程序名后还有字符，则它们应该是解释程序的参数串，于是令i_arg指向该串。
		interp = i_name = cp;
   132f4:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   132fb:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
   13302:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
   13309:	89 84 24 c8 01 00 00 	mov    %eax,0x1c8(%esp)
		i_arg = 0;
   13310:	c7 84 24 8c 00 00 00 	movl   $0x0,0x8c(%esp)
   13317:	00 00 00 00 
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
   1331b:	eb 27                	jmp    13344 <do_execve+0x4b9>
 			if (*cp == '/')
   1331d:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13324:	0f b6 00             	movzbl (%eax),%eax
   13327:	3c 2f                	cmp    $0x2f,%al
   13329:	75 11                	jne    1333c <do_execve+0x4b1>
				i_name = cp+1;
   1332b:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13332:	83 c0 01             	add    $0x1,%eax
   13335:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
   1333c:	83 84 24 e0 01 00 00 	addl   $0x1,0x1e0(%esp)
   13343:	01 
   13344:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   1334b:	0f b6 00             	movzbl (%eax),%eax
   1334e:	84 c0                	test   %al,%al
   13350:	74 1c                	je     1336e <do_execve+0x4e3>
   13352:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13359:	0f b6 00             	movzbl (%eax),%eax
   1335c:	3c 20                	cmp    $0x20,%al
   1335e:	74 0e                	je     1336e <do_execve+0x4e3>
   13360:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13367:	0f b6 00             	movzbl (%eax),%eax
   1336a:	3c 09                	cmp    $0x9,%al
   1336c:	75 af                	jne    1331d <do_execve+0x492>
		}
		if (*cp) {
   1336e:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13375:	0f b6 00             	movzbl (%eax),%eax
   13378:	84 c0                	test   %al,%al
   1337a:	74 22                	je     1339e <do_execve+0x513>
			*cp++ = '\0';           								// 解释程序名尾添加NULL字符。
   1337c:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13383:	8d 50 01             	lea    0x1(%eax),%edx
   13386:	89 94 24 e0 01 00 00 	mov    %edx,0x1e0(%esp)
   1338d:	c6 00 00             	movb   $0x0,(%eax)
			i_arg = cp;             								// i_arg指向解释程序参数。
   13390:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
   13397:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
		// 这里我们把sh_bang标志置上，然后把函数参数提供的原有参数和环境字符串放入到空间中。环境字符串和参数个数分别是envc和
		// argc-1个。少复制的一个原有参数是原来的执行文件名，即这里的脚本文件名。[[?? 可以看出，实际上我们不需要去另行处理脚本
		// 文件名，即这里完全可以复制argc个参数，包括原来执行文件名（即现在的脚本文件名）。因为它位于同一个位置上]]。注意！这里
		// 指针p随着复制信息增加而逐渐向小地址方向移动，因此这两个复制串函数执行完后，环境参数串信息块位于程序命令行参数串信息块
		// 的上方，并且p指向程序的第1个参数串。copy_strings()最后一个参数（0）指明参数字符串在用户空间。
		if (sh_bang++ == 0) {
   1339e:	8b 84 24 ec 01 00 00 	mov    0x1ec(%esp),%eax
   133a5:	8d 50 01             	lea    0x1(%eax),%edx
   133a8:	89 94 24 ec 01 00 00 	mov    %edx,0x1ec(%esp)
   133af:	85 c0                	test   %eax,%eax
   133b1:	75 6e                	jne    13421 <do_execve+0x596>
			p = copy_strings(envc, envp, page, p, 0);
   133b3:	83 ec 0c             	sub    $0xc,%esp
   133b6:	6a 00                	push   $0x0
   133b8:	ff b4 24 f8 01 00 00 	pushl  0x1f8(%esp)
   133bf:	8d 84 24 28 01 00 00 	lea    0x128(%esp),%eax
   133c6:	50                   	push   %eax
   133c7:	ff b4 24 38 02 00 00 	pushl  0x238(%esp)
   133ce:	ff b4 24 f4 01 00 00 	pushl  0x1f4(%esp)
   133d5:	e8 e3 f6 ff ff       	call   12abd <copy_strings>
   133da:	83 c4 20             	add    $0x20,%esp
   133dd:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
			p = copy_strings(--argc, argv + 1, page, p, 0);
   133e4:	8b 84 24 1c 02 00 00 	mov    0x21c(%esp),%eax
   133eb:	8d 50 04             	lea    0x4(%eax),%edx
   133ee:	83 ac 24 f4 01 00 00 	subl   $0x1,0x1f4(%esp)
   133f5:	01 
   133f6:	83 ec 0c             	sub    $0xc,%esp
   133f9:	6a 00                	push   $0x0
   133fb:	ff b4 24 f8 01 00 00 	pushl  0x1f8(%esp)
   13402:	8d 84 24 28 01 00 00 	lea    0x128(%esp),%eax
   13409:	50                   	push   %eax
   1340a:	52                   	push   %edx
   1340b:	ff b4 24 10 02 00 00 	pushl  0x210(%esp)
   13412:	e8 a6 f6 ff ff       	call   12abd <copy_strings>
   13417:	83 c4 20             	add    $0x20,%esp
   1341a:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
         */
		// 接着我们逆向复制脚本文件名、解释程序的参数和解释程序文件名到参数和环境空间中。若出错，则置出错吗，跳转到exec_error1。
		// 另外，由于本函数参数提供的脚本文件名filename在用户空间，但这里赋予copy_strings()的脚本文件名的指针在内核空间，因此
		// 这个复制字符串函数的最后一个参数（字符串来源标志）需要被设置成1。若字符串在内核空间，则copy_strings()的最后一个参数
		// 要设置成功，如下面。
		p = copy_strings(1, &filename, page, p, 1);
   13421:	83 ec 0c             	sub    $0xc,%esp
   13424:	6a 01                	push   $0x1
   13426:	ff b4 24 f8 01 00 00 	pushl  0x1f8(%esp)
   1342d:	8d 84 24 28 01 00 00 	lea    0x128(%esp),%eax
   13434:	50                   	push   %eax
   13435:	8d 84 24 30 02 00 00 	lea    0x230(%esp),%eax
   1343c:	50                   	push   %eax
   1343d:	6a 01                	push   $0x1
   1343f:	e8 79 f6 ff ff       	call   12abd <copy_strings>
   13444:	83 c4 20             	add    $0x20,%esp
   13447:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
		argc++;
   1344e:	83 84 24 f4 01 00 00 	addl   $0x1,0x1f4(%esp)
   13455:	01 
		if (i_arg) {            									// 复制解释程序的多个参数。
   13456:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
   1345d:	85 c0                	test   %eax,%eax
   1345f:	74 35                	je     13496 <do_execve+0x60b>
			p = copy_strings(1, &i_arg, page, p, 2);
   13461:	83 ec 0c             	sub    $0xc,%esp
   13464:	6a 02                	push   $0x2
   13466:	ff b4 24 f8 01 00 00 	pushl  0x1f8(%esp)
   1346d:	8d 84 24 28 01 00 00 	lea    0x128(%esp),%eax
   13474:	50                   	push   %eax
   13475:	8d 84 24 a4 00 00 00 	lea    0xa4(%esp),%eax
   1347c:	50                   	push   %eax
   1347d:	6a 01                	push   $0x1
   1347f:	e8 39 f6 ff ff       	call   12abd <copy_strings>
   13484:	83 c4 20             	add    $0x20,%esp
   13487:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
			argc++;
   1348e:	83 84 24 f4 01 00 00 	addl   $0x1,0x1f4(%esp)
   13495:	01 
		}
		p = copy_strings(1, &i_name, page, p, 2);
   13496:	83 ec 0c             	sub    $0xc,%esp
   13499:	6a 02                	push   $0x2
   1349b:	ff b4 24 f8 01 00 00 	pushl  0x1f8(%esp)
   134a2:	8d 84 24 28 01 00 00 	lea    0x128(%esp),%eax
   134a9:	50                   	push   %eax
   134aa:	8d 84 24 a8 00 00 00 	lea    0xa8(%esp),%eax
   134b1:	50                   	push   %eax
   134b2:	6a 01                	push   $0x1
   134b4:	e8 04 f6 ff ff       	call   12abd <copy_strings>
   134b9:	83 c4 20             	add    $0x20,%esp
   134bc:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
		argc++;
   134c3:	83 84 24 f4 01 00 00 	addl   $0x1,0x1f4(%esp)
   134ca:	01 
		if (!p) {
   134cb:	83 bc 24 e8 01 00 00 	cmpl   $0x0,0x1e8(%esp)
   134d2:	00 
   134d3:	75 10                	jne    134e5 <do_execve+0x65a>
			retval = -ENOMEM;
   134d5:	c7 84 24 f0 01 00 00 	movl   $0xfffffff4,0x1f0(%esp)
   134dc:	f4 ff ff ff 
			goto exec_error1;
   134e0:	e9 98 05 00 00       	jmp    13a7d <do_execve+0xbf2>
		// 最后我们取得解释程序的i节点指针，然后跳转到204行去执行解释程序。为了获得解释程序的i节点，我们需要使用namei()函数，但是该函数
		// 所使用的参数（文件名）是从用户数据空间得到的，即从段寄存器fs所指空间中取得。因此在调用namei()函数之前我们需要先临时让fs指向内
		// 核数据空间，以让函数能从内核空间得到解释程序名，并在namei()返回后恢复fs的默认设置。因此这里我们先临时保存原fs段寄存器（原指向
		// 用户数据段）的值，将其设置成指向内核数据段，然后取解释程序的i节点。之后再恢复fs的原值。并跳转到restart_interp（204行）处重新
		// 处理新的执行文件 -- 脚本文件的解释程序。
		old_fs = get_fs();
   134e5:	e8 ec f2 ff ff       	call   127d6 <get_fs>
   134ea:	89 84 24 c4 01 00 00 	mov    %eax,0x1c4(%esp)
		set_fs(get_ds());
   134f1:	e8 fe f2 ff ff       	call   127f4 <get_ds>
   134f6:	83 ec 0c             	sub    $0xc,%esp
   134f9:	50                   	push   %eax
   134fa:	e8 13 f3 ff ff       	call   12812 <set_fs>
   134ff:	83 c4 10             	add    $0x10,%esp
		if (!(inode = namei(interp))) { 						/* get executables inode */
   13502:	83 ec 0c             	sub    $0xc,%esp
   13505:	ff b4 24 d4 01 00 00 	pushl  0x1d4(%esp)
   1350c:	e8 9c 17 00 00       	call   14cad <namei>
   13511:	83 c4 10             	add    $0x10,%esp
   13514:	89 84 24 fc 01 00 00 	mov    %eax,0x1fc(%esp)
   1351b:	83 bc 24 fc 01 00 00 	cmpl   $0x0,0x1fc(%esp)
   13522:	00 
   13523:	75 23                	jne    13548 <do_execve+0x6bd>
			set_fs(old_fs);       								/* 取得解释程序的i节点 */
   13525:	83 ec 0c             	sub    $0xc,%esp
   13528:	ff b4 24 d0 01 00 00 	pushl  0x1d0(%esp)
   1352f:	e8 de f2 ff ff       	call   12812 <set_fs>
   13534:	83 c4 10             	add    $0x10,%esp
			retval = -ENOENT;
   13537:	c7 84 24 f0 01 00 00 	movl   $0xfffffffe,0x1f0(%esp)
   1353e:	fe ff ff ff 
			goto exec_error1;
   13542:	90                   	nop
   13543:	e9 35 05 00 00       	jmp    13a7d <do_execve+0xbf2>
		}
		set_fs(old_fs);
   13548:	83 ec 0c             	sub    $0xc,%esp
   1354b:	ff b4 24 d0 01 00 00 	pushl  0x1d0(%esp)
   13552:	e8 bb f2 ff ff       	call   12812 <set_fs>
   13557:	83 c4 10             	add    $0x10,%esp
   1355a:	e9 a5 fa ff ff       	jmp    13004 <do_execve+0x179>
	// 此时缓冲块中的执行文件头结构已经复制到了ex中.于是先释放该缓冲块,并开始对ex中的执行头信息进行判断处理.对于Linux0.12内核来说,
	// 它仅支持ZMAGIC执行格式,并且执行文件代码都从逻辑地址0开始执行,因此不支持含有代码或数据重定位信息的执行文件.当然,如果执行文件
	// 实在太大或者执行文件残缺不全,那么我们也不能运行它.因此对于下列情况将不执行程序:如果执行文件不是需求页可执行文件(ZMAGIC),或者
	// 代码和数据重定位部分长度不等于0,或者(代码段+数据段+堆)长度超过50MB,或者执行文件长度小于(代码段+数据段+符号表长度+执行头部分)
	// 长度的总和.
	brelse(bh);
   1355f:	83 ec 0c             	sub    $0xc,%esp
   13562:	ff b4 24 d8 01 00 00 	pushl  0x1d8(%esp)
   13569:	e8 fd d3 ff ff       	call   1096b <brelse>
   1356e:	83 c4 10             	add    $0x10,%esp
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
   13571:	8b 84 24 94 01 00 00 	mov    0x194(%esp),%eax
   13578:	3d 0b 01 00 00       	cmp    $0x10b,%eax
   1357d:	75 7a                	jne    135f9 <do_execve+0x76e>
   1357f:	8b 84 24 ac 01 00 00 	mov    0x1ac(%esp),%eax
   13586:	85 c0                	test   %eax,%eax
   13588:	75 6f                	jne    135f9 <do_execve+0x76e>
   1358a:	8b 84 24 b0 01 00 00 	mov    0x1b0(%esp),%eax
   13591:	85 c0                	test   %eax,%eax
   13593:	75 64                	jne    135f9 <do_execve+0x76e>
		ex.a_text + ex.a_data + ex.a_bss > 0x3000000 ||
   13595:	8b 94 24 98 01 00 00 	mov    0x198(%esp),%edx
   1359c:	8b 84 24 9c 01 00 00 	mov    0x19c(%esp),%eax
   135a3:	01 c2                	add    %eax,%edx
   135a5:	8b 84 24 a0 01 00 00 	mov    0x1a0(%esp),%eax
   135ac:	01 d0                	add    %edx,%eax
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
   135ae:	3d 00 00 00 03       	cmp    $0x3000000,%eax
   135b3:	77 44                	ja     135f9 <do_execve+0x76e>
		inode->i_size < ex.a_text + ex.a_data + ex.a_syms + N_TXTOFF(ex)) {
   135b5:	8b 84 24 fc 01 00 00 	mov    0x1fc(%esp),%eax
   135bc:	8b 40 04             	mov    0x4(%eax),%eax
   135bf:	8b 8c 24 98 01 00 00 	mov    0x198(%esp),%ecx
   135c6:	8b 94 24 9c 01 00 00 	mov    0x19c(%esp),%edx
   135cd:	01 d1                	add    %edx,%ecx
   135cf:	8b 94 24 a4 01 00 00 	mov    0x1a4(%esp),%edx
   135d6:	01 d1                	add    %edx,%ecx
   135d8:	8b 94 24 94 01 00 00 	mov    0x194(%esp),%edx
   135df:	81 fa 0b 01 00 00    	cmp    $0x10b,%edx
   135e5:	75 07                	jne    135ee <do_execve+0x763>
   135e7:	ba 00 04 00 00       	mov    $0x400,%edx
   135ec:	eb 05                	jmp    135f3 <do_execve+0x768>
   135ee:	ba 20 00 00 00       	mov    $0x20,%edx
   135f3:	01 ca                	add    %ecx,%edx
		ex.a_text + ex.a_data + ex.a_bss > 0x3000000 ||
   135f5:	39 d0                	cmp    %edx,%eax
   135f7:	73 10                	jae    13609 <do_execve+0x77e>
		retval = -ENOEXEC;
   135f9:	c7 84 24 f0 01 00 00 	movl   $0xfffffff8,0x1f0(%esp)
   13600:	f8 ff ff ff 
		goto exec_error2;
   13604:	e9 62 04 00 00       	jmp    13a6b <do_execve+0xbe0>
	}
	// 另外,如果执行文件中代码开始处没有位于1个页面(1024字节)边界处,则也不能执行.因为需求页(Demand paging)技术要求加载执行文件内容
	// 时以页面为单位,因此要求执行文件映像中代码和数据都从页面边界处开始.
	if (N_TXTOFF(ex) != BLOCK_SIZE) {
   13609:	8b 84 24 94 01 00 00 	mov    0x194(%esp),%eax
   13610:	3d 0b 01 00 00       	cmp    $0x10b,%eax
   13615:	74 2a                	je     13641 <do_execve+0x7b6>
		printk("%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.", filename);
   13617:	8b 84 24 18 02 00 00 	mov    0x218(%esp),%eax
   1361e:	83 ec 08             	sub    $0x8,%esp
   13621:	50                   	push   %eax
   13622:	8d 83 b4 51 ff ff    	lea    -0xae4c(%ebx),%eax
   13628:	50                   	push   %eax
   13629:	e8 04 5d ff ff       	call   9332 <printk>
   1362e:	83 c4 10             	add    $0x10,%esp
		retval = -ENOEXEC;
   13631:	c7 84 24 f0 01 00 00 	movl   $0xfffffff8,0x1f0(%esp)
   13638:	f8 ff ff ff 
		goto exec_error2;
   1363c:	e9 2a 04 00 00       	jmp    13a6b <do_execve+0xbe0>
	}
	// 如果sh_bang标志没有设置,则复制指定个数的命令行参数和环境字符串到参数和环境空间中.若sh_bang标志已经设置,则表明将运行脚本解释程序,
	// 此时一环境变量页面已经复制,无须再复制.同样,若sh_bang没有置位而需要复制的话,那么此时指针p随着复制信息增加而逐渐向小地址方向移动,
	// 因此这两个复制串函数执行完后,环境参数串信息块位于程序参数串信息块的上方,并且p指向程序的第1个参数串.事实上,p是128KB参数和环境空间
	// 中的偏移值.因此如果p=0,则表示环境变量与参数空间页面已经被占满,容纳不下了.
	if (!sh_bang) {
   13641:	83 bc 24 ec 01 00 00 	cmpl   $0x0,0x1ec(%esp)
   13648:	00 
   13649:	75 7c                	jne    136c7 <do_execve+0x83c>
		p = copy_strings(envc, envp, page, p, 0);
   1364b:	83 ec 0c             	sub    $0xc,%esp
   1364e:	6a 00                	push   $0x0
   13650:	ff b4 24 f8 01 00 00 	pushl  0x1f8(%esp)
   13657:	8d 84 24 28 01 00 00 	lea    0x128(%esp),%eax
   1365e:	50                   	push   %eax
   1365f:	ff b4 24 38 02 00 00 	pushl  0x238(%esp)
   13666:	ff b4 24 f4 01 00 00 	pushl  0x1f4(%esp)
   1366d:	e8 4b f4 ff ff       	call   12abd <copy_strings>
   13672:	83 c4 20             	add    $0x20,%esp
   13675:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
		p = copy_strings(argc, argv, page, p, 0);
   1367c:	83 ec 0c             	sub    $0xc,%esp
   1367f:	6a 00                	push   $0x0
   13681:	ff b4 24 f8 01 00 00 	pushl  0x1f8(%esp)
   13688:	8d 84 24 28 01 00 00 	lea    0x128(%esp),%eax
   1368f:	50                   	push   %eax
   13690:	ff b4 24 34 02 00 00 	pushl  0x234(%esp)
   13697:	ff b4 24 10 02 00 00 	pushl  0x210(%esp)
   1369e:	e8 1a f4 ff ff       	call   12abd <copy_strings>
   136a3:	83 c4 20             	add    $0x20,%esp
   136a6:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
		if (!p) {
   136ad:	83 bc 24 e8 01 00 00 	cmpl   $0x0,0x1e8(%esp)
   136b4:	00 
   136b5:	75 10                	jne    136c7 <do_execve+0x83c>
			retval = -ENOMEM;
   136b7:	c7 84 24 f0 01 00 00 	movl   $0xfffffff4,0x1f0(%esp)
   136be:	f4 ff ff ff 
			goto exec_error2;
   136c2:	e9 a4 03 00 00       	jmp    13a6b <do_execve+0xbe0>
	// get_free_page()分配了物理内存页来保存数据,并在chang_ldt()函数中使用put_page()到了进程逻辑空间的末端处.另外,在create_tables()
	// 中也会由于在用户栈上存放参数和环境指针表而引起缺页异常,从而内存管理程序也会就此为用户栈空间映射物理内存页.
	//
	// 这里我们首先放回进程原执行程序的i节点,并且让进程executable字段指向新执行文件的i节点.然后复位原进程的所有信号处理句柄,但对于SIG_IGN
	// 句柄无须复位.
	if (current->executable)
   136c7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   136cd:	8b 00                	mov    (%eax),%eax
   136cf:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
   136d5:	85 c0                	test   %eax,%eax
   136d7:	74 1a                	je     136f3 <do_execve+0x868>
		iput(current->executable);
   136d9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   136df:	8b 00                	mov    (%eax),%eax
   136e1:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
   136e7:	83 ec 0c             	sub    $0xc,%esp
   136ea:	50                   	push   %eax
   136eb:	e8 b2 c1 ff ff       	call   f8a2 <iput>
   136f0:	83 c4 10             	add    $0x10,%esp
	current->executable = inode;
   136f3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   136f9:	8b 00                	mov    (%eax),%eax
   136fb:	8b 94 24 fc 01 00 00 	mov    0x1fc(%esp),%edx
   13702:	89 90 3c 03 00 00    	mov    %edx,0x33c(%eax)
	current->signal = 0;
   13708:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1370e:	8b 00                	mov    (%eax),%eax
   13710:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	for (i = 0 ; i < 32 ; i++) {
   13717:	c7 84 24 f8 01 00 00 	movl   $0x0,0x1f8(%esp)
   1371e:	00 00 00 00 
   13722:	e9 83 00 00 00       	jmp    137aa <do_execve+0x91f>
		current->sigaction[i].sa_mask = 0;
   13727:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1372d:	8b 00                	mov    (%eax),%eax
   1372f:	8b 94 24 f8 01 00 00 	mov    0x1f8(%esp),%edx
   13736:	83 c2 01             	add    $0x1,%edx
   13739:	c1 e2 04             	shl    $0x4,%edx
   1373c:	01 d0                	add    %edx,%eax
   1373e:	83 c0 04             	add    $0x4,%eax
   13741:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		current->sigaction[i].sa_flags = 0;
   13747:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1374d:	8b 00                	mov    (%eax),%eax
   1374f:	8b 94 24 f8 01 00 00 	mov    0x1f8(%esp),%edx
   13756:	83 c2 01             	add    $0x1,%edx
   13759:	c1 e2 04             	shl    $0x4,%edx
   1375c:	01 d0                	add    %edx,%eax
   1375e:	83 c0 08             	add    $0x8,%eax
   13761:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (current->sigaction[i].sa_handler != SIG_IGN)
   13767:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1376d:	8b 00                	mov    (%eax),%eax
   1376f:	8b 94 24 f8 01 00 00 	mov    0x1f8(%esp),%edx
   13776:	83 c2 01             	add    $0x1,%edx
   13779:	c1 e2 04             	shl    $0x4,%edx
   1377c:	01 d0                	add    %edx,%eax
   1377e:	8b 00                	mov    (%eax),%eax
   13780:	83 f8 01             	cmp    $0x1,%eax
   13783:	74 1d                	je     137a2 <do_execve+0x917>
			current->sigaction[i].sa_handler = NULL;
   13785:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1378b:	8b 00                	mov    (%eax),%eax
   1378d:	8b 94 24 f8 01 00 00 	mov    0x1f8(%esp),%edx
   13794:	83 c2 01             	add    $0x1,%edx
   13797:	c1 e2 04             	shl    $0x4,%edx
   1379a:	01 d0                	add    %edx,%eax
   1379c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	for (i = 0 ; i < 32 ; i++) {
   137a2:	83 84 24 f8 01 00 00 	addl   $0x1,0x1f8(%esp)
   137a9:	01 
   137aa:	83 bc 24 f8 01 00 00 	cmpl   $0x1f,0x1f8(%esp)
   137b1:	1f 
   137b2:	0f 8e 6f ff ff ff    	jle    13727 <do_execve+0x89c>
	}
	// 再根据设定的执行时关闭文件句柄(close_on_exec)位图标志,关闭指定的打开文件并复位该标志
	for (i = 0 ; i < NR_OPEN ; i++)
   137b8:	c7 84 24 f8 01 00 00 	movl   $0x0,0x1f8(%esp)
   137bf:	00 00 00 00 
   137c3:	eb 3c                	jmp    13801 <do_execve+0x976>
		if ((current->close_on_exec >> i) & 1)
   137c5:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   137cb:	8b 00                	mov    (%eax),%eax
   137cd:	8b 90 44 03 00 00    	mov    0x344(%eax),%edx
   137d3:	8b 84 24 f8 01 00 00 	mov    0x1f8(%esp),%eax
   137da:	89 c1                	mov    %eax,%ecx
   137dc:	d3 ea                	shr    %cl,%edx
   137de:	89 d0                	mov    %edx,%eax
   137e0:	83 e0 01             	and    $0x1,%eax
   137e3:	85 c0                	test   %eax,%eax
   137e5:	74 12                	je     137f9 <do_execve+0x96e>
			sys_close(i);
   137e7:	83 ec 0c             	sub    $0xc,%esp
   137ea:	ff b4 24 04 02 00 00 	pushl  0x204(%esp)
   137f1:	e8 a7 b4 ff ff       	call   ec9d <sys_close>
   137f6:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_OPEN ; i++)
   137f9:	83 84 24 f8 01 00 00 	addl   $0x1,0x1f8(%esp)
   13800:	01 
   13801:	83 bc 24 f8 01 00 00 	cmpl   $0x13,0x1f8(%esp)
   13808:	13 
   13809:	7e ba                	jle    137c5 <do_execve+0x93a>
	current->close_on_exec = 0;
   1380b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13811:	8b 00                	mov    (%eax),%eax
   13813:	c7 80 44 03 00 00 00 	movl   $0x0,0x344(%eax)
   1381a:	00 00 00 
	// 然后根据当前进程指定的基地址和限长,释放原来程序的代码段和数据段所对应的内存页表指定的物理内存页面及页表本身.此时新执行文件并没有占用主
	// 内存区任何页面,因此在处理器真正运行新执行文件代码时就会引起缺页异常中断,此时内存管理程序即会执行缺页处理页为新执行文件申请内存页面和
	// 设置相关页表项,并且把相关执行文件页面读入内存中.如果"上次任务使用了协处理器"指向的是当前进程,则将其置空,并复位使用了协处理器的标志.
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
   1381d:	b8 0f 00 00 00       	mov    $0xf,%eax
   13822:	0f 03 c0             	lsl    %ax,%eax
   13825:	40                   	inc    %eax
   13826:	89 84 24 c0 01 00 00 	mov    %eax,0x1c0(%esp)
   1382d:	8b 8c 24 c0 01 00 00 	mov    0x1c0(%esp),%ecx
   13834:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1383a:	8b 00                	mov    (%eax),%eax
   1383c:	05 a0 03 00 00       	add    $0x3a0,%eax
   13841:	8d 78 02             	lea    0x2(%eax),%edi
   13844:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1384a:	8b 00                	mov    (%eax),%eax
   1384c:	05 a0 03 00 00       	add    $0x3a0,%eax
   13851:	8d 70 04             	lea    0x4(%eax),%esi
   13854:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1385a:	8b 00                	mov    (%eax),%eax
   1385c:	05 a0 03 00 00       	add    $0x3a0,%eax
   13861:	83 c0 07             	add    $0x7,%eax
   13864:	8a 30                	mov    (%eax),%dh
   13866:	8a 16                	mov    (%esi),%dl
   13868:	c1 e2 10             	shl    $0x10,%edx
   1386b:	66 8b 17             	mov    (%edi),%dx
   1386e:	89 d0                	mov    %edx,%eax
   13870:	89 84 24 bc 01 00 00 	mov    %eax,0x1bc(%esp)
   13877:	8b 84 24 bc 01 00 00 	mov    0x1bc(%esp),%eax
   1387e:	83 ec 08             	sub    $0x8,%esp
   13881:	51                   	push   %ecx
   13882:	50                   	push   %eax
   13883:	e8 7d 92 ff ff       	call   cb05 <free_page_tables>
   13888:	83 c4 10             	add    $0x10,%esp
	free_page_tables(get_base(current->ldt[2]), get_limit(0x17));
   1388b:	b8 17 00 00 00       	mov    $0x17,%eax
   13890:	0f 03 c0             	lsl    %ax,%eax
   13893:	40                   	inc    %eax
   13894:	89 84 24 b8 01 00 00 	mov    %eax,0x1b8(%esp)
   1389b:	8b 8c 24 b8 01 00 00 	mov    0x1b8(%esp),%ecx
   138a2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   138a8:	8b 00                	mov    (%eax),%eax
   138aa:	05 a8 03 00 00       	add    $0x3a8,%eax
   138af:	8d 78 02             	lea    0x2(%eax),%edi
   138b2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   138b8:	8b 00                	mov    (%eax),%eax
   138ba:	05 a8 03 00 00       	add    $0x3a8,%eax
   138bf:	8d 70 04             	lea    0x4(%eax),%esi
   138c2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   138c8:	8b 00                	mov    (%eax),%eax
   138ca:	05 a8 03 00 00       	add    $0x3a8,%eax
   138cf:	83 c0 07             	add    $0x7,%eax
   138d2:	8a 30                	mov    (%eax),%dh
   138d4:	8a 16                	mov    (%esi),%dl
   138d6:	c1 e2 10             	shl    $0x10,%edx
   138d9:	66 8b 17             	mov    (%edi),%dx
   138dc:	89 d0                	mov    %edx,%eax
   138de:	89 84 24 b4 01 00 00 	mov    %eax,0x1b4(%esp)
   138e5:	8b 84 24 b4 01 00 00 	mov    0x1b4(%esp),%eax
   138ec:	83 ec 08             	sub    $0x8,%esp
   138ef:	51                   	push   %ecx
   138f0:	50                   	push   %eax
   138f1:	e8 0f 92 ff ff       	call   cb05 <free_page_tables>
   138f6:	83 c4 10             	add    $0x10,%esp
	if (last_task_used_math == current)
   138f9:	c7 c0 8c 3b 03 00    	mov    $0x33b8c,%eax
   138ff:	8b 10                	mov    (%eax),%edx
   13901:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13907:	8b 00                	mov    (%eax),%eax
   13909:	39 c2                	cmp    %eax,%edx
   1390b:	75 0c                	jne    13919 <do_execve+0xa8e>
		last_task_used_math = NULL;
   1390d:	c7 c0 8c 3b 03 00    	mov    $0x33b8c,%eax
   13913:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	current->used_math = 0;
   13919:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1391f:	8b 00                	mov    (%eax),%eax
   13921:	66 c7 80 28 03 00 00 	movw   $0x0,0x328(%eax)
   13928:	00 00 
	// 然后我们根据新执行文件头结构中的代码长度字段a_text的值修改局部表中描述符基址和段限长,并将128KB的参数和环境空间页面放置在数据段末端.
	// 执行下面语句之后,p此时更改成以数据段起始处为原点的偏移值,但仍指向参数和环境空间数据开始处,即已转换成栈指针值.然后调用内部函数create_tables()
	// 在栈空间中创建环境和参数变量指针表,供程序的main()作为参数使用,并返回该栈指针.
	p += change_ldt(ex.a_text, page);
   1392a:	8b 84 24 98 01 00 00 	mov    0x198(%esp),%eax
   13931:	83 ec 08             	sub    $0x8,%esp
   13934:	8d 94 24 1c 01 00 00 	lea    0x11c(%esp),%edx
   1393b:	52                   	push   %edx
   1393c:	50                   	push   %eax
   1393d:	e8 65 f3 ff ff       	call   12ca7 <change_ldt>
   13942:	83 c4 10             	add    $0x10,%esp
   13945:	01 84 24 e8 01 00 00 	add    %eax,0x1e8(%esp)
	p -= LIBRARY_SIZE + MAX_ARG_PAGES * PAGE_SIZE;
   1394c:	81 ac 24 e8 01 00 00 	subl   $0x420000,0x1e8(%esp)
   13953:	00 00 42 00 
	p = (unsigned long) create_tables((char *)p, argc, envc);
   13957:	8b 84 24 e8 01 00 00 	mov    0x1e8(%esp),%eax
   1395e:	83 ec 04             	sub    $0x4,%esp
   13961:	ff b4 24 dc 01 00 00 	pushl  0x1dc(%esp)
   13968:	ff b4 24 fc 01 00 00 	pushl  0x1fc(%esp)
   1396f:	50                   	push   %eax
   13970:	e8 bf ef ff ff       	call   12934 <create_tables>
   13975:	83 c4 10             	add    $0x10,%esp
   13978:	89 84 24 e8 01 00 00 	mov    %eax,0x1e8(%esp)
	// 接着再修改进程各字段值为新执行文件的信息.即令进程任务结构代码尾字段end_code等于执行文件的代码段长度a_text;数据尾字段end_data等于
	// 执行文件的代码段长度加数据段长度(a_data + a_text);并令进程堆结尾字段brk = a_text + a_data + a_bss.brk用于指明进程当前数据段
	// (包括未初始化数据部分)末端位置,供内核为进程分配内存时指定分配开始位置.然后设置进程栈开始字段为栈指针所在页面,并重新设置进程的有效用户
	// id和有效组id.
	current->brk = ex.a_bss +
   1397f:	8b 8c 24 a0 01 00 00 	mov    0x1a0(%esp),%ecx
		(current->end_data = ex.a_data +
   13986:	8b b4 24 9c 01 00 00 	mov    0x19c(%esp),%esi
		(current->end_code = ex.a_text));
   1398d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13993:	8b 00                	mov    (%eax),%eax
   13995:	8b 94 24 98 01 00 00 	mov    0x198(%esp),%edx
   1399c:	89 90 1c 02 00 00    	mov    %edx,0x21c(%eax)
   139a2:	8b 90 1c 02 00 00    	mov    0x21c(%eax),%edx
		(current->end_data = ex.a_data +
   139a8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   139ae:	8b 00                	mov    (%eax),%eax
   139b0:	01 f2                	add    %esi,%edx
   139b2:	89 90 20 02 00 00    	mov    %edx,0x220(%eax)
   139b8:	8b 90 20 02 00 00    	mov    0x220(%eax),%edx
	current->brk = ex.a_bss +
   139be:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   139c4:	8b 00                	mov    (%eax),%eax
   139c6:	01 ca                	add    %ecx,%edx
   139c8:	89 90 24 02 00 00    	mov    %edx,0x224(%eax)
	current->start_stack = p & 0xfffff000;
   139ce:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   139d4:	8b 00                	mov    (%eax),%eax
   139d6:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   139dd:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
   139e3:	89 90 28 02 00 00    	mov    %edx,0x228(%eax)
	current->suid = current->euid = e_uid;
   139e9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   139ef:	8b 00                	mov    (%eax),%eax
   139f1:	8b 94 24 d4 01 00 00 	mov    0x1d4(%esp),%edx
   139f8:	66 89 90 ce 02 00 00 	mov    %dx,0x2ce(%eax)
   139ff:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   13a05:	8b 12                	mov    (%edx),%edx
   13a07:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
   13a0e:	66 89 82 d0 02 00 00 	mov    %ax,0x2d0(%edx)
	current->sgid = current->egid = e_gid;
   13a15:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13a1b:	8b 00                	mov    (%eax),%eax
   13a1d:	8b 94 24 d0 01 00 00 	mov    0x1d0(%esp),%edx
   13a24:	66 89 90 d4 02 00 00 	mov    %dx,0x2d4(%eax)
   13a2b:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   13a31:	8b 12                	mov    (%edx),%edx
   13a33:	0f b7 80 d4 02 00 00 	movzwl 0x2d4(%eax),%eax
   13a3a:	66 89 82 d6 02 00 00 	mov    %ax,0x2d6(%edx)
	// 最后将原调用系统中断的程序在堆栈上的代码指针替换为指向新执行程序的入口点,并将栈指针替换为新执行文件的栈指针.此后返回指令将弹出这些栈数
	// 据并使得CPU去执行新执行文件,因此不会返回到原调用系统中断的程序中去了.
	eip[0] = ex.a_entry;												/* eip, magic happens :-) */	/* eip,魔法起作用了 */
   13a41:	8b 94 24 a8 01 00 00 	mov    0x1a8(%esp),%edx
   13a48:	8b 84 24 10 02 00 00 	mov    0x210(%esp),%eax
   13a4f:	89 10                	mov    %edx,(%eax)
	eip[3] = p;															/* stack pointer */		/* esp,堆栈指针 */
   13a51:	8b 84 24 10 02 00 00 	mov    0x210(%esp),%eax
   13a58:	8d 50 0c             	lea    0xc(%eax),%edx
   13a5b:	8b 84 24 e8 01 00 00 	mov    0x1e8(%esp),%eax
   13a62:	89 02                	mov    %eax,(%edx)
	return 0;
   13a64:	b8 00 00 00 00       	mov    $0x0,%eax
   13a69:	eb 52                	jmp    13abd <do_execve+0xc32>
exec_error2:
	iput(inode);														// 放回i节点.
   13a6b:	83 ec 0c             	sub    $0xc,%esp
   13a6e:	ff b4 24 08 02 00 00 	pushl  0x208(%esp)
   13a75:	e8 28 be ff ff       	call   f8a2 <iput>
   13a7a:	83 c4 10             	add    $0x10,%esp
exec_error1:
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)
   13a7d:	c7 84 24 f8 01 00 00 	movl   $0x0,0x1f8(%esp)
   13a84:	00 00 00 00 
   13a88:	eb 22                	jmp    13aac <do_execve+0xc21>
		free_page(page[i]);												// 释放存放参数和环境串的内存页面.
   13a8a:	8b 84 24 f8 01 00 00 	mov    0x1f8(%esp),%eax
   13a91:	8b 84 84 14 01 00 00 	mov    0x114(%esp,%eax,4),%eax
   13a98:	83 ec 0c             	sub    $0xc,%esp
   13a9b:	50                   	push   %eax
   13a9c:	e8 ce 8f ff ff       	call   ca6f <free_page>
   13aa1:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)
   13aa4:	83 84 24 f8 01 00 00 	addl   $0x1,0x1f8(%esp)
   13aab:	01 
   13aac:	83 bc 24 f8 01 00 00 	cmpl   $0x1f,0x1f8(%esp)
   13ab3:	1f 
   13ab4:	7e d4                	jle    13a8a <do_execve+0xbff>
	return(retval);														// 返回出错码.
   13ab6:	8b 84 24 f0 01 00 00 	mov    0x1f0(%esp),%eax
}
   13abd:	81 c4 00 02 00 00    	add    $0x200,%esp
   13ac3:	5b                   	pop    %ebx
   13ac4:	5e                   	pop    %esi
   13ac5:	5f                   	pop    %edi
   13ac6:	c3                   	ret    

00013ac7 <get_fs_byte>:
{
   13ac7:	53                   	push   %ebx
   13ac8:	e8 25 32 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   13acd:	05 33 e5 01 00       	add    $0x1e533,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   13ad2:	8b 44 24 08          	mov    0x8(%esp),%eax
   13ad6:	64 8a 00             	mov    %fs:(%eax),%al
   13ad9:	89 c3                	mov    %eax,%ebx
	return _v;
   13adb:	89 d8                	mov    %ebx,%eax
}
   13add:	5b                   	pop    %ebx
   13ade:	c3                   	ret    

00013adf <put_fs_byte>:
{
   13adf:	83 ec 04             	sub    $0x4,%esp
   13ae2:	e8 0b 32 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   13ae7:	05 19 e5 01 00       	add    $0x1e519,%eax
   13aec:	8b 44 24 08          	mov    0x8(%esp),%eax
   13af0:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   13af3:	0f b6 04 24          	movzbl (%esp),%eax
   13af7:	8b 54 24 0c          	mov    0xc(%esp),%edx
   13afb:	64 88 02             	mov    %al,%fs:(%edx)
}
   13afe:	90                   	nop
   13aff:	83 c4 04             	add    $0x4,%esp
   13b02:	c3                   	ret    

00013b03 <put_fs_long>:
{
   13b03:	e8 ea 31 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   13b08:	05 f8 e4 01 00       	add    $0x1e4f8,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   13b0d:	8b 44 24 04          	mov    0x4(%esp),%eax
   13b11:	8b 54 24 08          	mov    0x8(%esp),%edx
   13b15:	64 89 02             	mov    %eax,%fs:(%edx)
}
   13b18:	90                   	nop
   13b19:	c3                   	ret    

00013b1a <read_pipe>:
#include <linux/kernel.h>

// 读管道操作函数。
// 参数inode是管道对应的i节点，buf是用户数据缓冲区指针，count是读取的字节数。
int read_pipe(struct m_inode * inode, char * buf, int count)
{
   13b1a:	53                   	push   %ebx
   13b1b:	83 ec 18             	sub    $0x18,%esp
   13b1e:	e8 d7 31 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   13b23:	81 c3 dd e4 01 00    	add    $0x1e4dd,%ebx
	int chars, size, read = 0;
   13b29:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   13b30:	00 
	// 如果需要读取的字节数count大于0,我们就循环执行以下操作。在循环读操作过程中，若当前管道中没有数据（size=0），
	// 则唤醒等待该节点的进程，这通常是写管道进程。如果已没有写管道者，即i节点引用计数小于2,则返回已读字节数退出。
	// 如果目前收到非阻塞信号，则立刻返回已读取字节数退出，若还没有收到任何数据，则返回重新启动系统调用号退出。
	// 否则就让进程在该管道上睡眠，用以等待信息的到来。宏PIPE_SIZE定义在include/linux/fs.h中。关于“重新启动
	// 系统调用号”，请参见kernel/signal.c程序。
	while (count > 0) {
   13b31:	e9 6f 01 00 00       	jmp    13ca5 <read_pipe+0x18b>
		while (!(size = PIPE_SIZE(*inode))) {     						// 取管道中数据长度值。
			// 唤醒等待向该管道写数据的进程
			wake_up(& PIPE_WRITE_WAIT(*inode));
   13b36:	8b 44 24 20          	mov    0x20(%esp),%eax
   13b3a:	83 c0 24             	add    $0x24,%eax
   13b3d:	83 ec 0c             	sub    $0xc,%esp
   13b40:	50                   	push   %eax
   13b41:	e8 61 37 ff ff       	call   72a7 <wake_up>
   13b46:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) 									/* are there any writers? */
   13b49:	8b 44 24 20          	mov    0x20(%esp),%eax
   13b4d:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   13b51:	66 83 f8 02          	cmp    $0x2,%ax
   13b55:	74 09                	je     13b60 <read_pipe+0x46>
				return read;
   13b57:	8b 44 24 04          	mov    0x4(%esp),%eax
   13b5b:	e9 67 01 00 00       	jmp    13cc7 <read_pipe+0x1ad>
			if (current->signal & ~current->blocked)
   13b60:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13b66:	8b 00                	mov    (%eax),%eax
   13b68:	8b 50 0c             	mov    0xc(%eax),%edx
   13b6b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13b71:	8b 00                	mov    (%eax),%eax
   13b73:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   13b79:	f7 d0                	not    %eax
   13b7b:	21 d0                	and    %edx,%eax
   13b7d:	85 c0                	test   %eax,%eax
   13b7f:	74 1a                	je     13b9b <read_pipe+0x81>
				return read ? read : -ERESTARTSYS;
   13b81:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   13b86:	74 09                	je     13b91 <read_pipe+0x77>
   13b88:	8b 44 24 04          	mov    0x4(%esp),%eax
   13b8c:	e9 36 01 00 00       	jmp    13cc7 <read_pipe+0x1ad>
   13b91:	b8 00 fe ff ff       	mov    $0xfffffe00,%eax
   13b96:	e9 2c 01 00 00       	jmp    13cc7 <read_pipe+0x1ad>
			// 当前进程没有数据可读则进入睡眠等待
			interruptible_sleep_on(& PIPE_READ_WAIT(*inode));
   13b9b:	8b 44 24 20          	mov    0x20(%esp),%eax
   13b9f:	83 c0 20             	add    $0x20,%eax
   13ba2:	83 ec 0c             	sub    $0xc,%esp
   13ba5:	50                   	push   %eax
   13ba6:	e8 b6 36 ff ff       	call   7261 <interruptible_sleep_on>
   13bab:	83 c4 10             	add    $0x10,%esp
		while (!(size = PIPE_SIZE(*inode))) {     						// 取管道中数据长度值。
   13bae:	8b 44 24 20          	mov    0x20(%esp),%eax
   13bb2:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
   13bb6:	8b 44 24 20          	mov    0x20(%esp),%eax
   13bba:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   13bbe:	29 c2                	sub    %eax,%edx
   13bc0:	89 d0                	mov    %edx,%eax
   13bc2:	0f b7 c0             	movzwl %ax,%eax
   13bc5:	25 ff 0f 00 00       	and    $0xfff,%eax
   13bca:	89 44 24 08          	mov    %eax,0x8(%esp)
   13bce:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   13bd3:	0f 84 5d ff ff ff    	je     13b36 <read_pipe+0x1c>
		}
		// 此时说明管道（缓冲区）中有数据。于是我们取管道尾指针到缓冲区末端的字节数chars。如果其大于还需要读取的字节数
		// count，则令其等于count。如果chars大于当前管道中含有数据的长度size，则令其等于size。然后把需读字节数count
		// 减去可读的字节数chars，并累加已读字节数read。
		chars = PAGE_SIZE - PIPE_TAIL(*inode);
   13bd9:	8b 44 24 20          	mov    0x20(%esp),%eax
   13bdd:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   13be1:	0f b7 c0             	movzwl %ax,%eax
   13be4:	ba 00 10 00 00       	mov    $0x1000,%edx
   13be9:	29 c2                	sub    %eax,%edx
   13beb:	89 d0                	mov    %edx,%eax
   13bed:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > count)
   13bf1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13bf5:	3b 44 24 28          	cmp    0x28(%esp),%eax
   13bf9:	7e 08                	jle    13c03 <read_pipe+0xe9>
			chars = count;
   13bfb:	8b 44 24 28          	mov    0x28(%esp),%eax
   13bff:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > size)
   13c03:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13c07:	3b 44 24 08          	cmp    0x8(%esp),%eax
   13c0b:	7e 08                	jle    13c15 <read_pipe+0xfb>
			chars = size;
   13c0d:	8b 44 24 08          	mov    0x8(%esp),%eax
   13c11:	89 44 24 0c          	mov    %eax,0xc(%esp)
		count -= chars;
   13c15:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13c19:	29 44 24 28          	sub    %eax,0x28(%esp)
		read += chars;
   13c1d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13c21:	01 44 24 04          	add    %eax,0x4(%esp)
		// 再令size指向管道尾指针处，并调整当前管道尾指针（前移chars字节）。若尾指针超过管道末端则绕回。然后将管道中的
		// 数据复制到用户缓冲区中。对于管道i节点，其i_size字段中是管道缓冲块指针。
		size = PIPE_TAIL(*inode);
   13c25:	8b 44 24 20          	mov    0x20(%esp),%eax
   13c29:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   13c2d:	0f b7 c0             	movzwl %ax,%eax
   13c30:	89 44 24 08          	mov    %eax,0x8(%esp)
		PIPE_TAIL(*inode) += chars;
   13c34:	8b 44 24 20          	mov    0x20(%esp),%eax
   13c38:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   13c3c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   13c40:	01 c2                	add    %eax,%edx
   13c42:	8b 44 24 20          	mov    0x20(%esp),%eax
   13c46:	66 89 50 10          	mov    %dx,0x10(%eax)
		PIPE_TAIL(*inode) &= (PAGE_SIZE - 1);
   13c4a:	8b 44 24 20          	mov    0x20(%esp),%eax
   13c4e:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   13c52:	66 25 ff 0f          	and    $0xfff,%ax
   13c56:	89 c2                	mov    %eax,%edx
   13c58:	8b 44 24 20          	mov    0x20(%esp),%eax
   13c5c:	66 89 50 10          	mov    %dx,0x10(%eax)
		while (chars-- > 0)
   13c60:	eb 34                	jmp    13c96 <read_pipe+0x17c>
			put_fs_byte(((char *)inode->i_size)[size++], buf++);
   13c62:	8b 44 24 24          	mov    0x24(%esp),%eax
   13c66:	8d 50 01             	lea    0x1(%eax),%edx
   13c69:	89 54 24 24          	mov    %edx,0x24(%esp)
   13c6d:	8b 54 24 08          	mov    0x8(%esp),%edx
   13c71:	8d 4a 01             	lea    0x1(%edx),%ecx
   13c74:	89 4c 24 08          	mov    %ecx,0x8(%esp)
   13c78:	89 d1                	mov    %edx,%ecx
   13c7a:	8b 54 24 20          	mov    0x20(%esp),%edx
   13c7e:	8b 52 04             	mov    0x4(%edx),%edx
   13c81:	01 ca                	add    %ecx,%edx
   13c83:	0f b6 12             	movzbl (%edx),%edx
   13c86:	0f be d2             	movsbl %dl,%edx
   13c89:	83 ec 08             	sub    $0x8,%esp
   13c8c:	50                   	push   %eax
   13c8d:	52                   	push   %edx
   13c8e:	e8 4c fe ff ff       	call   13adf <put_fs_byte>
   13c93:	83 c4 10             	add    $0x10,%esp
		while (chars-- > 0)
   13c96:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13c9a:	8d 50 ff             	lea    -0x1(%eax),%edx
   13c9d:	89 54 24 0c          	mov    %edx,0xc(%esp)
   13ca1:	85 c0                	test   %eax,%eax
   13ca3:	7f bd                	jg     13c62 <read_pipe+0x148>
	while (count > 0) {
   13ca5:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   13caa:	0f 8f fe fe ff ff    	jg     13bae <read_pipe+0x94>
	}
	// 当此次读管道操作结束，则唤醒等待该管道的进程，并返回读取的字节数。
	wake_up(& PIPE_WRITE_WAIT(*inode));
   13cb0:	8b 44 24 20          	mov    0x20(%esp),%eax
   13cb4:	83 c0 24             	add    $0x24,%eax
   13cb7:	83 ec 0c             	sub    $0xc,%esp
   13cba:	50                   	push   %eax
   13cbb:	e8 e7 35 ff ff       	call   72a7 <wake_up>
   13cc0:	83 c4 10             	add    $0x10,%esp
	return read;
   13cc3:	8b 44 24 04          	mov    0x4(%esp),%eax
}
   13cc7:	83 c4 18             	add    $0x18,%esp
   13cca:	5b                   	pop    %ebx
   13ccb:	c3                   	ret    

00013ccc <write_pipe>:

// 管道写操作函数。
// 参数inode是管道对应的i节点，buf是数据缓冲区指针，count是将写入管道的字节数。
int write_pipe(struct m_inode * inode, char * buf, int count)
{
   13ccc:	53                   	push   %ebx
   13ccd:	83 ec 18             	sub    $0x18,%esp
   13cd0:	e8 25 30 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   13cd5:	81 c3 2b e3 01 00    	add    $0x1e32b,%ebx
	int chars, size, written = 0;
   13cdb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   13ce2:	00 

	// 如果要写入的字节数count还大于0,那么我们就循环执行以下操作。在循环操作过程中，如果当前管道中已经满了（空闲空间
	// size = 0），则唤醒等待该管道的进程，通常唤醒的是读管道进程。如果已经没有读管道者，即i节点引用计数值小于2,则向
	// 当前进程发送SIGPIPE信号，并返回已写入的字节数退出；若写入0字节，则返回-1。否则让当前进程在该管道上睡眠，以等待
	// 读管道进程来读取数据，从而让管道腾出空间。宏PIPE_SIZE()、PIPE_HEAD()等定义在文件include/linux/fs.h中。
	while (count > 0) {
   13ce3:	e9 5f 01 00 00       	jmp    13e47 <write_pipe+0x17b>
		while (!(size = (PAGE_SIZE - 1) - PIPE_SIZE(*inode))) {
			wake_up(& PIPE_READ_WAIT(*inode));
   13ce8:	8b 44 24 20          	mov    0x20(%esp),%eax
   13cec:	83 c0 20             	add    $0x20,%eax
   13cef:	83 ec 0c             	sub    $0xc,%esp
   13cf2:	50                   	push   %eax
   13cf3:	e8 af 35 ff ff       	call   72a7 <wake_up>
   13cf8:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) { 								/* no readers */
   13cfb:	8b 44 24 20          	mov    0x20(%esp),%eax
   13cff:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   13d03:	66 83 f8 02          	cmp    $0x2,%ax
   13d07:	74 33                	je     13d3c <write_pipe+0x70>
				current->signal |= (1 << (SIGPIPE - 1));
   13d09:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13d0f:	8b 00                	mov    (%eax),%eax
   13d11:	8b 50 0c             	mov    0xc(%eax),%edx
   13d14:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13d1a:	8b 00                	mov    (%eax),%eax
   13d1c:	80 ce 10             	or     $0x10,%dh
   13d1f:	89 50 0c             	mov    %edx,0xc(%eax)
				return written ? written : -1;
   13d22:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   13d27:	74 09                	je     13d32 <write_pipe+0x66>
   13d29:	8b 44 24 04          	mov    0x4(%esp),%eax
   13d2d:	e9 37 01 00 00       	jmp    13e69 <write_pipe+0x19d>
   13d32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13d37:	e9 2d 01 00 00       	jmp    13e69 <write_pipe+0x19d>
			}
			sleep_on(& PIPE_WRITE_WAIT(*inode));
   13d3c:	8b 44 24 20          	mov    0x20(%esp),%eax
   13d40:	83 c0 24             	add    $0x24,%eax
   13d43:	83 ec 0c             	sub    $0xc,%esp
   13d46:	50                   	push   %eax
   13d47:	e8 38 35 ff ff       	call   7284 <sleep_on>
   13d4c:	83 c4 10             	add    $0x10,%esp
		while (!(size = (PAGE_SIZE - 1) - PIPE_SIZE(*inode))) {
   13d4f:	8b 44 24 20          	mov    0x20(%esp),%eax
   13d53:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
   13d57:	8b 44 24 20          	mov    0x20(%esp),%eax
   13d5b:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   13d5f:	29 c2                	sub    %eax,%edx
   13d61:	89 d0                	mov    %edx,%eax
   13d63:	0f b7 c0             	movzwl %ax,%eax
   13d66:	f7 d0                	not    %eax
   13d68:	25 ff 0f 00 00       	and    $0xfff,%eax
   13d6d:	89 44 24 08          	mov    %eax,0x8(%esp)
   13d71:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   13d76:	0f 84 6c ff ff ff    	je     13ce8 <write_pipe+0x1c>
		}
		// 程序执行到这里表示管道缓冲区中有可写空间size。于是我们取管道头指针到缓冲区末端空间字节数chars。写管道操作是从管道
		// 头指针处开始写的。如果chars大于还需要写入的字节数count，则令其等于count。如果chars大于当前管道中空闲空间长度size
		// 则令其等于size。然后把需要写入字节数count减去此次可写入的字节数chars，并把写入字节数累加到written中。
		chars = PAGE_SIZE - PIPE_HEAD(*inode);
   13d7c:	8b 44 24 20          	mov    0x20(%esp),%eax
   13d80:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   13d84:	0f b7 c0             	movzwl %ax,%eax
   13d87:	ba 00 10 00 00       	mov    $0x1000,%edx
   13d8c:	29 c2                	sub    %eax,%edx
   13d8e:	89 d0                	mov    %edx,%eax
   13d90:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > count)
   13d94:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13d98:	3b 44 24 28          	cmp    0x28(%esp),%eax
   13d9c:	7e 08                	jle    13da6 <write_pipe+0xda>
			chars = count;
   13d9e:	8b 44 24 28          	mov    0x28(%esp),%eax
   13da2:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > size)
   13da6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13daa:	3b 44 24 08          	cmp    0x8(%esp),%eax
   13dae:	7e 08                	jle    13db8 <write_pipe+0xec>
			chars = size;
   13db0:	8b 44 24 08          	mov    0x8(%esp),%eax
   13db4:	89 44 24 0c          	mov    %eax,0xc(%esp)
		count -= chars;
   13db8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13dbc:	29 44 24 28          	sub    %eax,0x28(%esp)
		written += chars;
   13dc0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13dc4:	01 44 24 04          	add    %eax,0x4(%esp)
		// 再令size指向管道数据头指针处，并调整当前管道数据头部指针（前移chars字节）。若头指针超过管道末端则绕回。然后从用户缓冲
		// 区复制chars个字节到管道头指针开始处。对于管道i节点，其i_size字段中是管道缓冲块指针。
		size = PIPE_HEAD(*inode);
   13dc8:	8b 44 24 20          	mov    0x20(%esp),%eax
   13dcc:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   13dd0:	0f b7 c0             	movzwl %ax,%eax
   13dd3:	89 44 24 08          	mov    %eax,0x8(%esp)
		PIPE_HEAD(*inode) += chars;
   13dd7:	8b 44 24 20          	mov    0x20(%esp),%eax
   13ddb:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   13ddf:	8b 54 24 0c          	mov    0xc(%esp),%edx
   13de3:	01 c2                	add    %eax,%edx
   13de5:	8b 44 24 20          	mov    0x20(%esp),%eax
   13de9:	66 89 50 0e          	mov    %dx,0xe(%eax)
		PIPE_HEAD(*inode) &= (PAGE_SIZE - 1);
   13ded:	8b 44 24 20          	mov    0x20(%esp),%eax
   13df1:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   13df5:	66 25 ff 0f          	and    $0xfff,%ax
   13df9:	89 c2                	mov    %eax,%edx
   13dfb:	8b 44 24 20          	mov    0x20(%esp),%eax
   13dff:	66 89 50 0e          	mov    %dx,0xe(%eax)
		while (chars-- > 0)
   13e03:	eb 33                	jmp    13e38 <write_pipe+0x16c>
			((char *)inode->i_size)[size++] = get_fs_byte(buf++);
   13e05:	8b 44 24 24          	mov    0x24(%esp),%eax
   13e09:	8d 50 01             	lea    0x1(%eax),%edx
   13e0c:	89 54 24 24          	mov    %edx,0x24(%esp)
   13e10:	83 ec 0c             	sub    $0xc,%esp
   13e13:	50                   	push   %eax
   13e14:	e8 ae fc ff ff       	call   13ac7 <get_fs_byte>
   13e19:	83 c4 10             	add    $0x10,%esp
   13e1c:	89 c1                	mov    %eax,%ecx
   13e1e:	8b 44 24 08          	mov    0x8(%esp),%eax
   13e22:	8d 50 01             	lea    0x1(%eax),%edx
   13e25:	89 54 24 08          	mov    %edx,0x8(%esp)
   13e29:	89 c2                	mov    %eax,%edx
   13e2b:	8b 44 24 20          	mov    0x20(%esp),%eax
   13e2f:	8b 40 04             	mov    0x4(%eax),%eax
   13e32:	01 d0                	add    %edx,%eax
   13e34:	89 ca                	mov    %ecx,%edx
   13e36:	88 10                	mov    %dl,(%eax)
		while (chars-- > 0)
   13e38:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13e3c:	8d 50 ff             	lea    -0x1(%eax),%edx
   13e3f:	89 54 24 0c          	mov    %edx,0xc(%esp)
   13e43:	85 c0                	test   %eax,%eax
   13e45:	7f be                	jg     13e05 <write_pipe+0x139>
	while (count > 0) {
   13e47:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   13e4c:	0f 8f fd fe ff ff    	jg     13d4f <write_pipe+0x83>
	}
	// 当此次写管道操作结束，则唤醒等待管道的进程，返回已写入的字节数，退出。
	wake_up(& PIPE_READ_WAIT(*inode));
   13e52:	8b 44 24 20          	mov    0x20(%esp),%eax
   13e56:	83 c0 20             	add    $0x20,%eax
   13e59:	83 ec 0c             	sub    $0xc,%esp
   13e5c:	50                   	push   %eax
   13e5d:	e8 45 34 ff ff       	call   72a7 <wake_up>
   13e62:	83 c4 10             	add    $0x10,%esp
	return written;
   13e65:	8b 44 24 04          	mov    0x4(%esp),%eax
}
   13e69:	83 c4 18             	add    $0x18,%esp
   13e6c:	5b                   	pop    %ebx
   13e6d:	c3                   	ret    

00013e6e <sys_pipe>:
// 创建管道系统调用。
// 在fildes所指的数组中创建一对句柄（描述符）。这对文件句柄指向一管道i节点。
// 参数：fildes - 文件句柄数组。fildes[0]用于读管道数据，fildes[1]向管道写入数据。
// 成功时返回0,出错时返回-1.
int sys_pipe(unsigned long * fildes)
{
   13e6e:	53                   	push   %ebx
   13e6f:	83 ec 28             	sub    $0x28,%esp
   13e72:	e8 83 2e ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   13e77:	81 c3 89 e1 01 00    	add    $0x1e189,%ebx
	int fd[2];                      						// 文件句柄数组。
	int i, j;

	// 首先从系统文件表中取两个空闲项（引用计数字段为0的项），并分别设置引用计数为1.
	// 若只有1个空闲项，则释放该项（引用计数复位）。若没有找到两个空闲项，则返回-1。
	j = 0;
   13e7d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   13e84:	00 
	for(i = 0; j < 2 && i < NR_FILE; i++)
   13e85:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   13e8c:	00 
   13e8d:	eb 4e                	jmp    13edd <sys_pipe+0x6f>
		if (!file_table[i].f_count)
   13e8f:	c7 c0 00 60 04 00    	mov    $0x46000,%eax
   13e95:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13e99:	c1 e2 04             	shl    $0x4,%edx
   13e9c:	01 d0                	add    %edx,%eax
   13e9e:	83 c0 04             	add    $0x4,%eax
   13ea1:	0f b7 00             	movzwl (%eax),%eax
   13ea4:	66 85 c0             	test   %ax,%ax
   13ea7:	75 2f                	jne    13ed8 <sys_pipe+0x6a>
			(f[j++] = i + file_table)->f_count++;
   13ea9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   13ead:	c1 e0 04             	shl    $0x4,%eax
   13eb0:	89 c1                	mov    %eax,%ecx
   13eb2:	8b 44 24 18          	mov    0x18(%esp),%eax
   13eb6:	8d 50 01             	lea    0x1(%eax),%edx
   13eb9:	89 54 24 18          	mov    %edx,0x18(%esp)
   13ebd:	c7 c2 00 60 04 00    	mov    $0x46000,%edx
   13ec3:	01 ca                	add    %ecx,%edx
   13ec5:	89 54 84 0c          	mov    %edx,0xc(%esp,%eax,4)
   13ec9:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
   13ecd:	0f b7 50 04          	movzwl 0x4(%eax),%edx
   13ed1:	83 c2 01             	add    $0x1,%edx
   13ed4:	66 89 50 04          	mov    %dx,0x4(%eax)
	for(i = 0; j < 2 && i < NR_FILE; i++)
   13ed8:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   13edd:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   13ee2:	7f 07                	jg     13eeb <sys_pipe+0x7d>
   13ee4:	83 7c 24 1c 3f       	cmpl   $0x3f,0x1c(%esp)
   13ee9:	7e a4                	jle    13e8f <sys_pipe+0x21>
	if (j == 1)
   13eeb:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   13ef0:	75 0a                	jne    13efc <sys_pipe+0x8e>
		f[0]->f_count = 0;
   13ef2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13ef6:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
	if (j < 2)
   13efc:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   13f01:	7f 0a                	jg     13f0d <sys_pipe+0x9f>
		return -1;
   13f03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13f08:	e9 8e 01 00 00       	jmp    1409b <sys_pipe+0x22d>
	// 针对上面取得的两个文件表结构项，分别分配一文件句柄号，并使进程文件结构指针数组的两项分别指向这两个文件
	// 结构。而文件句柄即是该数组的索引号。类似地，如果只有一个空闲文件句柄，则释放该句柄（置空相应数组项）。如
	// 果没有找到两个空闲句柄，则释放上面获取的两个文件结构项（复位引用计数值），并返回-1。
	j = 0;
   13f0d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   13f14:	00 
	for(i = 0; j < 2 && i < NR_OPEN; i++)
   13f15:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   13f1c:	00 
   13f1d:	eb 52                	jmp    13f71 <sys_pipe+0x103>
		if (!current->filp[i]) {
   13f1f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13f25:	8b 00                	mov    (%eax),%eax
   13f27:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13f2b:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   13f31:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   13f35:	85 c0                	test   %eax,%eax
   13f37:	75 33                	jne    13f6c <sys_pipe+0xfe>
			current->filp[ fd[j] = i ] = f[j];
   13f39:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13f3f:	8b 00                	mov    (%eax),%eax
   13f41:	8b 54 24 18          	mov    0x18(%esp),%edx
   13f45:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   13f49:	89 4c 94 04          	mov    %ecx,0x4(%esp,%edx,4)
   13f4d:	8b 54 24 18          	mov    0x18(%esp),%edx
   13f51:	8b 4c 94 04          	mov    0x4(%esp,%edx,4),%ecx
   13f55:	8b 54 24 18          	mov    0x18(%esp),%edx
   13f59:	8b 54 94 0c          	mov    0xc(%esp,%edx,4),%edx
   13f5d:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
   13f63:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
			j++;
   13f67:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
	for(i = 0; j < 2 && i < NR_OPEN; i++)
   13f6c:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   13f71:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   13f76:	7f 07                	jg     13f7f <sys_pipe+0x111>
   13f78:	83 7c 24 1c 13       	cmpl   $0x13,0x1c(%esp)
   13f7d:	7e a0                	jle    13f1f <sys_pipe+0xb1>
		}
	if (j == 1)
   13f7f:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   13f84:	75 1a                	jne    13fa0 <sys_pipe+0x132>
		current->filp[fd[0]] = NULL;
   13f86:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13f8c:	8b 00                	mov    (%eax),%eax
   13f8e:	8b 54 24 04          	mov    0x4(%esp),%edx
   13f92:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   13f98:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
   13f9f:	00 
	if (j < 2) {
   13fa0:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   13fa5:	7f 20                	jg     13fc7 <sys_pipe+0x159>
		f[0]->f_count = f[1]->f_count = 0;
   13fa7:	8b 44 24 10          	mov    0x10(%esp),%eax
   13fab:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
   13fb1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   13fb5:	0f b7 40 04          	movzwl 0x4(%eax),%eax
   13fb9:	66 89 42 04          	mov    %ax,0x4(%edx)
		return -1;
   13fbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13fc2:	e9 d4 00 00 00       	jmp    1409b <sys_pipe+0x22d>
	}
	// 然后利用函数get_pipe_inode()申请一个管道使用的i节点，并为管道分配一页内存作为缓冲区。如果不成功，则
	// 相应释放两个文件句柄和文件结构项，并返回-1.
	if (!(inode = get_pipe_inode())) {                		// fs/inode.c。
   13fc7:	e8 15 bc ff ff       	call   fbe1 <get_pipe_inode>
   13fcc:	89 44 24 14          	mov    %eax,0x14(%esp)
   13fd0:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   13fd5:	75 57                	jne    1402e <sys_pipe+0x1c0>
		current->filp[fd[0]] =
			current->filp[fd[1]] = NULL;
   13fd7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   13fdd:	8b 00                	mov    (%eax),%eax
   13fdf:	8b 54 24 08          	mov    0x8(%esp),%edx
   13fe3:	8d 8a d0 00 00 00    	lea    0xd0(%edx),%ecx
   13fe9:	c7 44 88 08 00 00 00 	movl   $0x0,0x8(%eax,%ecx,4)
   13ff0:	00 
		current->filp[fd[0]] =
   13ff1:	c7 c1 80 32 03 00    	mov    $0x33280,%ecx
   13ff7:	8b 09                	mov    (%ecx),%ecx
   13ff9:	8b 5c 24 04          	mov    0x4(%esp),%ebx
			current->filp[fd[1]] = NULL;
   13ffd:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   14003:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
		current->filp[fd[0]] =
   14007:	8d 93 d0 00 00 00    	lea    0xd0(%ebx),%edx
   1400d:	89 44 91 08          	mov    %eax,0x8(%ecx,%edx,4)
		f[0]->f_count = f[1]->f_count = 0;
   14011:	8b 44 24 10          	mov    0x10(%esp),%eax
   14015:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
   1401b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1401f:	0f b7 40 04          	movzwl 0x4(%eax),%eax
   14023:	66 89 42 04          	mov    %ax,0x4(%edx)
		return -1;
   14027:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1402c:	eb 6d                	jmp    1409b <sys_pipe+0x22d>
	}
	// 如果管道i节点申请成功，则对两个文件结构进行初始化操作，让它们都指向同一个管道i节点，并把读写指针都置零。
	// 第1个文件结构的文件模式为读，第2个文件结构的文件模式置为写。最后将文件句柄数组复制到对应的用户空间数组中，
	// 成功返回0,退出。
	f[0]->f_inode = f[1]->f_inode = inode;
   1402e:	8b 44 24 10          	mov    0x10(%esp),%eax
   14032:	8b 54 24 14          	mov    0x14(%esp),%edx
   14036:	89 50 08             	mov    %edx,0x8(%eax)
   14039:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1403d:	8b 40 08             	mov    0x8(%eax),%eax
   14040:	89 42 08             	mov    %eax,0x8(%edx)
	f[0]->f_pos = f[1]->f_pos = 0;
   14043:	8b 44 24 10          	mov    0x10(%esp),%eax
   14047:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1404e:	8b 54 24 0c          	mov    0xc(%esp),%edx
   14052:	8b 40 0c             	mov    0xc(%eax),%eax
   14055:	89 42 0c             	mov    %eax,0xc(%edx)
	f[0]->f_mode = 1;										/* read */
   14058:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1405c:	66 c7 00 01 00       	movw   $0x1,(%eax)
	f[1]->f_mode = 2;										/* write */
   14061:	8b 44 24 10          	mov    0x10(%esp),%eax
   14065:	66 c7 00 02 00       	movw   $0x2,(%eax)
	put_fs_long(fd[0], 0 + fildes);
   1406a:	8b 44 24 04          	mov    0x4(%esp),%eax
   1406e:	83 ec 08             	sub    $0x8,%esp
   14071:	ff 74 24 38          	pushl  0x38(%esp)
   14075:	50                   	push   %eax
   14076:	e8 88 fa ff ff       	call   13b03 <put_fs_long>
   1407b:	83 c4 10             	add    $0x10,%esp
	put_fs_long(fd[1], 1 + fildes);
   1407e:	8b 44 24 30          	mov    0x30(%esp),%eax
   14082:	83 c0 04             	add    $0x4,%eax
   14085:	8b 54 24 08          	mov    0x8(%esp),%edx
   14089:	83 ec 08             	sub    $0x8,%esp
   1408c:	50                   	push   %eax
   1408d:	52                   	push   %edx
   1408e:	e8 70 fa ff ff       	call   13b03 <put_fs_long>
   14093:	83 c4 10             	add    $0x10,%esp
	return 0;
   14096:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1409b:	83 c4 28             	add    $0x28,%esp
   1409e:	5b                   	pop    %ebx
   1409f:	c3                   	ret    

000140a0 <pipe_ioctl>:

// 管道io控制函数。
// 参数：pino - 管道i节点指针；cmd - 控制命令；arg - 参数。
// 函数返回0表示执行成功，否则返回出错码。
int pipe_ioctl(struct m_inode *pino, int cmd, int arg)
{
   140a0:	53                   	push   %ebx
   140a1:	83 ec 08             	sub    $0x8,%esp
   140a4:	e8 49 2c ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   140a9:	05 57 df 01 00       	add    $0x1df57,%eax
	// 如果命令是取管道中当前可读数据长度，则把管道数据长度值添入用户参数指定的位置处，并返回0。否则返回无效命令
	// 错误码。
	switch (cmd) {
   140ae:	8b 54 24 14          	mov    0x14(%esp),%edx
   140b2:	81 fa 1b 54 00 00    	cmp    $0x541b,%edx
   140b8:	75 49                	jne    14103 <pipe_ioctl+0x63>
		case FIONREAD:
			verify_area((void *) arg, 4);
   140ba:	8b 54 24 18          	mov    0x18(%esp),%edx
   140be:	83 ec 08             	sub    $0x8,%esp
   140c1:	6a 04                	push   $0x4
   140c3:	52                   	push   %edx
   140c4:	89 c3                	mov    %eax,%ebx
   140c6:	e8 30 48 ff ff       	call   88fb <verify_area>
   140cb:	83 c4 10             	add    $0x10,%esp
			put_fs_long(PIPE_SIZE(*pino), (unsigned long *) arg);
   140ce:	8b 44 24 18          	mov    0x18(%esp),%eax
   140d2:	8b 54 24 10          	mov    0x10(%esp),%edx
   140d6:	0f b7 4a 0e          	movzwl 0xe(%edx),%ecx
   140da:	8b 54 24 10          	mov    0x10(%esp),%edx
   140de:	0f b7 52 10          	movzwl 0x10(%edx),%edx
   140e2:	29 d1                	sub    %edx,%ecx
   140e4:	89 ca                	mov    %ecx,%edx
   140e6:	0f b7 d2             	movzwl %dx,%edx
   140e9:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
   140ef:	83 ec 08             	sub    $0x8,%esp
   140f2:	50                   	push   %eax
   140f3:	52                   	push   %edx
   140f4:	e8 0a fa ff ff       	call   13b03 <put_fs_long>
   140f9:	83 c4 10             	add    $0x10,%esp
			return 0;
   140fc:	b8 00 00 00 00       	mov    $0x0,%eax
   14101:	eb 05                	jmp    14108 <pipe_ioctl+0x68>
		default:
			return -EINVAL;
   14103:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}
}
   14108:	83 c4 08             	add    $0x8,%esp
   1410b:	5b                   	pop    %ebx
   1410c:	c3                   	ret    

0001410d <get_fs_byte>:
{
   1410d:	53                   	push   %ebx
   1410e:	e8 df 2b ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   14113:	05 ed de 01 00       	add    $0x1deed,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   14118:	8b 44 24 08          	mov    0x8(%esp),%eax
   1411c:	64 8a 00             	mov    %fs:(%eax),%al
   1411f:	89 c3                	mov    %eax,%ebx
	return _v;
   14121:	89 d8                	mov    %ebx,%eax
}
   14123:	5b                   	pop    %ebx
   14124:	c3                   	ret    

00014125 <strcpy>:
{
   14125:	57                   	push   %edi
   14126:	56                   	push   %esi
   14127:	e8 c6 2b ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1412c:	05 d4 de 01 00       	add    $0x1ded4,%eax
__asm__(
   14131:	8b 54 24 10          	mov    0x10(%esp),%edx
   14135:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   14139:	89 d6                	mov    %edx,%esi
   1413b:	89 cf                	mov    %ecx,%edi
   1413d:	fc                   	cld    
   1413e:	ac                   	lods   %ds:(%esi),%al
   1413f:	aa                   	stos   %al,%es:(%edi)
   14140:	84 c0                	test   %al,%al
   14142:	75 fa                	jne    1413e <strcpy+0x19>
return dest;												// 返回目的字符串指针.
   14144:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   14148:	5e                   	pop    %esi
   14149:	5f                   	pop    %edi
   1414a:	c3                   	ret    

0001414b <strcmp>:
{
   1414b:	57                   	push   %edi
   1414c:	56                   	push   %esi
   1414d:	e8 a0 2b ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   14152:	05 ae de 01 00       	add    $0x1deae,%eax
__asm__(
   14157:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1415b:	8b 54 24 10          	mov    0x10(%esp),%edx
   1415f:	89 c7                	mov    %eax,%edi
   14161:	89 d6                	mov    %edx,%esi
   14163:	fc                   	cld    
   14164:	ac                   	lods   %ds:(%esi),%al
   14165:	ae                   	scas   %es:(%edi),%al
   14166:	75 08                	jne    14170 <strcmp+0x25>
   14168:	84 c0                	test   %al,%al
   1416a:	75 f8                	jne    14164 <strcmp+0x19>
   1416c:	31 c0                	xor    %eax,%eax
   1416e:	eb 09                	jmp    14179 <strcmp+0x2e>
   14170:	b8 01 00 00 00       	mov    $0x1,%eax
   14175:	7c 02                	jl     14179 <strcmp+0x2e>
   14177:	f7 d8                	neg    %eax
}
   14179:	5e                   	pop    %esi
   1417a:	5f                   	pop    %edi
   1417b:	c3                   	ret    

0001417c <permission>:
 */
// 检测文件访问许可权限.
// 参数:inode - 文件的i节点指针;mask - 访问属性屏蔽码.
// 返回:访问许可返回1,否则返回0.
static int permission(struct m_inode * inode, int mask)
{
   1417c:	53                   	push   %ebx
   1417d:	83 ec 18             	sub    $0x18,%esp
   14180:	e8 75 2b ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   14185:	81 c3 7b de 01 00    	add    $0x1de7b,%ebx
	int mode = inode->i_mode;								// 文件访问属性.
   1418b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1418f:	0f b7 00             	movzwl (%eax),%eax
   14192:	0f b7 c0             	movzwl %ax,%eax
   14195:	89 44 24 0c          	mov    %eax,0xc(%esp)

	/* special case: not even root can read/write a deleted file */
	/* 特殊情况:即使是超级用户(root)也不能读/写一个已被删除的文件. */
	// 如果i节点有对应的设备,但该i节点的链接计数值等于0,表示该文件已被删除,则返回.
	if (inode->i_dev && !inode->i_nlinks)
   14199:	8b 44 24 20          	mov    0x20(%esp),%eax
   1419d:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   141a1:	66 85 c0             	test   %ax,%ax
   141a4:	74 13                	je     141b9 <permission+0x3d>
   141a6:	8b 44 24 20          	mov    0x20(%esp),%eax
   141aa:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   141ae:	84 c0                	test   %al,%al
   141b0:	75 07                	jne    141b9 <permission+0x3d>
		return 0;
   141b2:	b8 00 00 00 00       	mov    $0x0,%eax
   141b7:	eb 74                	jmp    1422d <permission+0xb1>
	// 如果进程的有效用户id(euid)与i节点的用户id相同,则取文件宿主的访问权限
	else if (current->euid == inode->i_uid)
   141b9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   141bf:	8b 00                	mov    (%eax),%eax
   141c1:	0f b7 90 ce 02 00 00 	movzwl 0x2ce(%eax),%edx
   141c8:	8b 44 24 20          	mov    0x20(%esp),%eax
   141cc:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   141d0:	66 39 c2             	cmp    %ax,%dx
   141d3:	75 07                	jne    141dc <permission+0x60>
		mode >>= 6;
   141d5:	c1 7c 24 0c 06       	sarl   $0x6,0xc(%esp)
   141da:	eb 20                	jmp    141fc <permission+0x80>
	// 如果进程有效组id(egid)与i节点的组id相同,则取组用户的访问权限
	else if (in_group_p(inode->i_gid))
   141dc:	8b 44 24 20          	mov    0x20(%esp),%eax
   141e0:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   141e4:	0f b6 c0             	movzbl %al,%eax
   141e7:	83 ec 0c             	sub    $0xc,%esp
   141ea:	50                   	push   %eax
   141eb:	e8 8b 63 ff ff       	call   a57b <in_group_p>
   141f0:	83 c4 10             	add    $0x10,%esp
   141f3:	85 c0                	test   %eax,%eax
   141f5:	74 05                	je     141fc <permission+0x80>
		mode >>= 3;
   141f7:	c1 7c 24 0c 03       	sarl   $0x3,0xc(%esp)
	// 最后判断如果所取的的访问权限与屏蔽码相同,或者是超级用户,则返回1,否则返回0.
	if (((mode & mask & 0007) == mask) || suser())
   141fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14200:	23 44 24 24          	and    0x24(%esp),%eax
   14204:	83 e0 07             	and    $0x7,%eax
   14207:	39 44 24 24          	cmp    %eax,0x24(%esp)
   1420b:	74 14                	je     14221 <permission+0xa5>
   1420d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   14213:	8b 00                	mov    (%eax),%eax
   14215:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
   1421c:	66 85 c0             	test   %ax,%ax
   1421f:	75 07                	jne    14228 <permission+0xac>
		return 1;
   14221:	b8 01 00 00 00       	mov    $0x1,%eax
   14226:	eb 05                	jmp    1422d <permission+0xb1>
	return 0;
   14228:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1422d:	83 c4 18             	add    $0x18,%esp
   14230:	5b                   	pop    %ebx
   14231:	c3                   	ret    

00014232 <match>:
 */
// 指定长度字符串比较函数.
// 参数:len - 比较的字符串长度;name - 文件名指针;de - 目录项结构.
// 返回:相同返回1,不同返回0.
static int match(int len, const char * name, struct dir_entry * de)
{
   14232:	57                   	push   %edi
   14233:	56                   	push   %esi
   14234:	53                   	push   %ebx
   14235:	e8 b8 2a ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1423a:	05 c6 dd 01 00       	add    $0x1ddc6,%eax
	register int same __asm__("ax");

	// 首先判断函数参数的有效性.如果目录项指针空,或者目录项i节点等于0,或者要比较的字符串长度超过文件名长度,则返回0(不匹配).
	if (!de || !de->inode || len > NAME_LEN)
   1423f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   14244:	74 13                	je     14259 <match+0x27>
   14246:	8b 44 24 18          	mov    0x18(%esp),%eax
   1424a:	0f b7 00             	movzwl (%eax),%eax
   1424d:	66 85 c0             	test   %ax,%ax
   14250:	74 07                	je     14259 <match+0x27>
   14252:	83 7c 24 10 0e       	cmpl   $0xe,0x10(%esp)
   14257:	7e 07                	jle    14260 <match+0x2e>
		return 0;
   14259:	b8 00 00 00 00       	mov    $0x0,%eax
   1425e:	eb 69                	jmp    142c9 <match+0x97>
	/* "" means "." ---> so paths like "/usr/lib//libc.a" work */
    /* ""当作"."来看待 ---> 这样就能处理象"/usr/lib//libc.a"那样的路径名 */
    // 如果比较的长度len等于0并且目录项中文件名的第1个字符是'.',并且只有这么一个字符,那么我们就认为是相同的,因此返回1(匹配)
	if (!len && (de->name[0] == '.') && (de->name[1] == '\0'))
   14260:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   14265:	75 1f                	jne    14286 <match+0x54>
   14267:	8b 44 24 18          	mov    0x18(%esp),%eax
   1426b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
   1426f:	3c 2e                	cmp    $0x2e,%al
   14271:	75 13                	jne    14286 <match+0x54>
   14273:	8b 44 24 18          	mov    0x18(%esp),%eax
   14277:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1427b:	84 c0                	test   %al,%al
   1427d:	75 07                	jne    14286 <match+0x54>
		return 1;
   1427f:	b8 01 00 00 00       	mov    $0x1,%eax
   14284:	eb 43                	jmp    142c9 <match+0x97>
	// 如果要比较的长度len小于NAME_LEN,但是目录项中文件名长度超过len,则也返回0(不匹配)
	// 第75行上对目录项中文件名长度是否超过len的判断方法是检测name[len]是否为NULL.若长度超过len,则name[len]处就是一个不是NULL的普通字符.而对于长度
	// 为len的字符串name,字符name[len]就应该是NULL.
	if (len < NAME_LEN && de->name[len])
   14286:	83 7c 24 10 0d       	cmpl   $0xd,0x10(%esp)
   1428b:	7f 1b                	jg     142a8 <match+0x76>
   1428d:	8b 54 24 18          	mov    0x18(%esp),%edx
   14291:	8b 44 24 10          	mov    0x10(%esp),%eax
   14295:	01 d0                	add    %edx,%eax
   14297:	83 c0 02             	add    $0x2,%eax
   1429a:	0f b6 00             	movzbl (%eax),%eax
   1429d:	84 c0                	test   %al,%al
   1429f:	74 07                	je     142a8 <match+0x76>
		return 0;
   142a1:	b8 00 00 00 00       	mov    $0x0,%eax
   142a6:	eb 21                	jmp    142c9 <match+0x97>
	__asm__(\
		"cld\n\t"							// 清方向标志位.
		"fs ; repe ; cmpsb\n\t"				// 用户空间执行循环比较[esi++]和[edi++]操作.
		"setz %%al"							// 若比较结果一样(zf=0)则置al=1(same=eax).
		:"=a" (same)
		:"0" (0), "S" ((long) name), "D" ((long) de->name), "c" (len)
   142a8:	8b 54 24 14          	mov    0x14(%esp),%edx
   142ac:	8b 44 24 18          	mov    0x18(%esp),%eax
   142b0:	83 c0 02             	add    $0x2,%eax
   142b3:	89 c3                	mov    %eax,%ebx
	__asm__(\
   142b5:	b8 00 00 00 00       	mov    $0x0,%eax
   142ba:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   142be:	89 d6                	mov    %edx,%esi
   142c0:	89 df                	mov    %ebx,%edi
   142c2:	fc                   	cld    
   142c3:	64 f3 a6             	repz cmpsb %es:(%edi),%fs:(%esi)
   142c6:	0f 94 c0             	sete   %al
		:);
	return same;							// 返回比较结果.
}
   142c9:	5b                   	pop    %ebx
   142ca:	5e                   	pop    %esi
   142cb:	5f                   	pop    %edi
   142cc:	c3                   	ret    

000142cd <find_entry>:
// 参数:*dir - 指定目录i节点的指针;name - 文件名;namelen - 文件名长度;该函数在指定目录的数据(文件)中搜索指定文件名的目录项.并对指定
// 文件名是'..'的情况根据当前进行的相关设置进行特殊处理.
// 返回:成功则返回高速缓冲区指针,并在*res_dir处返回的目录项结构指针.失败则返回空指针NULL.
static struct buffer_head * find_entry(struct m_inode ** dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
   142cd:	53                   	push   %ebx
   142ce:	83 ec 28             	sub    $0x28,%esp
   142d1:	e8 24 2a ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   142d6:	81 c3 2a dd 01 00    	add    $0x1dd2a,%ebx
	// 则不予处理.如果没有定义过NO_TRUNCATE,那么在文件名长度超过最大长度NAME_LEN时截短之.
#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
   142dc:	83 7c 24 38 0e       	cmpl   $0xe,0x38(%esp)
   142e1:	7e 08                	jle    142eb <find_entry+0x1e>
		namelen = NAME_LEN;
   142e3:	c7 44 24 38 0e 00 00 	movl   $0xe,0x38(%esp)
   142ea:	00 
#endif
	// 首先计算本目录中目录项项数entries.目录i节点i_size字段中含有本目录包含的数据长度,因此其除以一个目录项的长度(16字节)即可得到该目录中目录项数.然后
	// 置空返回目录项结构指针.
	entries = (*dir)->i_size / (sizeof (struct dir_entry));
   142eb:	8b 44 24 30          	mov    0x30(%esp),%eax
   142ef:	8b 00                	mov    (%eax),%eax
   142f1:	8b 40 04             	mov    0x4(%eax),%eax
   142f4:	c1 e8 04             	shr    $0x4,%eax
   142f7:	89 44 24 10          	mov    %eax,0x10(%esp)
	*res_dir = NULL;
   142fb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   142ff:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	// 只能访问该目录中的项而不能退到其父目录中去.也即对于该进程本目录就如同是文件系统的根目录.因此我们需要将文件名修改为'.'.
	// 否则,如果该目录的i节点号等于ROOT_INO(1号)的话,说明确实是文件系统的根i节点.则取文件系统的超级块.如果被安装到的i节点存在,则先放回原i节点,然后对被
	// 安装到的i节点进行处理.于是我们让*dir指向该被安装到的i节点;并且该i节点的引用数加1.即针对这种情况,我们悄悄进行了"偷梁换柱"工程:)
	/* check for '..', as we might have to do some "magic" for it */
	/* 检查目录项'..',因为我们可能需要对其进行特殊处理 */
	if (namelen == 2 && get_fs_byte(name) == '.' && get_fs_byte(name + 1) == '.') {
   14305:	83 7c 24 38 02       	cmpl   $0x2,0x38(%esp)
   1430a:	0f 85 b6 00 00 00    	jne    143c6 <find_entry+0xf9>
   14310:	ff 74 24 34          	pushl  0x34(%esp)
   14314:	e8 f4 fd ff ff       	call   1410d <get_fs_byte>
   14319:	83 c4 04             	add    $0x4,%esp
   1431c:	3c 2e                	cmp    $0x2e,%al
   1431e:	0f 85 a2 00 00 00    	jne    143c6 <find_entry+0xf9>
   14324:	8b 44 24 34          	mov    0x34(%esp),%eax
   14328:	83 c0 01             	add    $0x1,%eax
   1432b:	50                   	push   %eax
   1432c:	e8 dc fd ff ff       	call   1410d <get_fs_byte>
   14331:	83 c4 04             	add    $0x4,%esp
   14334:	3c 2e                	cmp    $0x2e,%al
   14336:	0f 85 8a 00 00 00    	jne    143c6 <find_entry+0xf9>
		/* '..' in a pseudo-root results in a faked '.' (just change namelen) */
		/* 伪根中的'..'如同一个假'.'(只需改变名字长度) */
		if ((*dir) == current->root)
   1433c:	8b 44 24 30          	mov    0x30(%esp),%eax
   14340:	8b 10                	mov    (%eax),%edx
   14342:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   14348:	8b 00                	mov    (%eax),%eax
   1434a:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
   14350:	39 c2                	cmp    %eax,%edx
   14352:	75 0a                	jne    1435e <find_entry+0x91>
			namelen = 1;
   14354:	c7 44 24 38 01 00 00 	movl   $0x1,0x38(%esp)
   1435b:	00 
   1435c:	eb 68                	jmp    143c6 <find_entry+0xf9>
		else if ((*dir)->i_num == ROOT_INO) {
   1435e:	8b 44 24 30          	mov    0x30(%esp),%eax
   14362:	8b 00                	mov    (%eax),%eax
   14364:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   14368:	66 83 f8 01          	cmp    $0x1,%ax
   1436c:	75 58                	jne    143c6 <find_entry+0xf9>
			/* '..' over a mount-point results in 'dir' being exchanged for the mounted
			   directory-inode. NOTE! We set mounted, so that we can iput the new dir */
			/* 在一个安装点上的'..'将导致目录交换到被安装文件系统的目录i节点上.注意! 由于我们设置了mounted标志,因而我们能够放回该新目录 */
			sb = get_super((*dir)->i_dev);
   1436e:	8b 44 24 30          	mov    0x30(%esp),%eax
   14372:	8b 00                	mov    (%eax),%eax
   14374:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   14378:	0f b7 c0             	movzwl %ax,%eax
   1437b:	83 ec 0c             	sub    $0xc,%esp
   1437e:	50                   	push   %eax
   1437f:	e8 22 cb ff ff       	call   10ea6 <get_super>
   14384:	83 c4 10             	add    $0x10,%esp
   14387:	89 44 24 0c          	mov    %eax,0xc(%esp)
			if (sb->s_imount) {
   1438b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1438f:	8b 40 5c             	mov    0x5c(%eax),%eax
   14392:	85 c0                	test   %eax,%eax
   14394:	74 30                	je     143c6 <find_entry+0xf9>
				iput(*dir);
   14396:	8b 44 24 30          	mov    0x30(%esp),%eax
   1439a:	8b 00                	mov    (%eax),%eax
   1439c:	83 ec 0c             	sub    $0xc,%esp
   1439f:	50                   	push   %eax
   143a0:	e8 fd b4 ff ff       	call   f8a2 <iput>
   143a5:	83 c4 10             	add    $0x10,%esp
				(*dir)=sb->s_imount;
   143a8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   143ac:	8b 50 5c             	mov    0x5c(%eax),%edx
   143af:	8b 44 24 30          	mov    0x30(%esp),%eax
   143b3:	89 10                	mov    %edx,(%eax)
				(*dir)->i_count++;
   143b5:	8b 44 24 30          	mov    0x30(%esp),%eax
   143b9:	8b 00                	mov    (%eax),%eax
   143bb:	0f b7 50 34          	movzwl 0x34(%eax),%edx
   143bf:	83 c2 01             	add    $0x1,%edx
   143c2:	66 89 50 34          	mov    %dx,0x34(%eax)
		}
	}
	// 现在我们开始正常操作，查找指定文件名的目录项在什么地方。因此我们需要读取目录的数据，即取出目录i节点对应块设备数据区中的数据块（逻辑块）信息。这些逻辑块的
	// 块号保存在i节点结构的i_zone[9]数组中.我们先取其中第1个块号.如果目录i节点指向的第一个直接盘块号为0,则说明该目录竟然不含数据,这不正常.于是返回NULL退出.
	// 否则我们就从节点所在设备读取指定的目录项数据块.当然,如果不成功,则也返回NULL退出.
	if (!(block = (*dir)->i_zone[0]))
   143c6:	8b 44 24 30          	mov    0x30(%esp),%eax
   143ca:	8b 00                	mov    (%eax),%eax
   143cc:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   143d0:	0f b7 c0             	movzwl %ax,%eax
   143d3:	89 44 24 08          	mov    %eax,0x8(%esp)
   143d7:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   143dc:	75 0a                	jne    143e8 <find_entry+0x11b>
		return NULL;
   143de:	b8 00 00 00 00       	mov    $0x0,%eax
   143e3:	e9 2e 01 00 00       	jmp    14516 <find_entry+0x249>
	if (!(bh = bread((*dir)->i_dev, block)))
   143e8:	8b 44 24 30          	mov    0x30(%esp),%eax
   143ec:	8b 00                	mov    (%eax),%eax
   143ee:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   143f2:	0f b7 c0             	movzwl %ax,%eax
   143f5:	83 ec 08             	sub    $0x8,%esp
   143f8:	ff 74 24 10          	pushl  0x10(%esp)
   143fc:	50                   	push   %eax
   143fd:	e8 d0 c5 ff ff       	call   109d2 <bread>
   14402:	83 c4 10             	add    $0x10,%esp
   14405:	89 44 24 18          	mov    %eax,0x18(%esp)
   14409:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1440e:	75 0a                	jne    1441a <find_entry+0x14d>
		return NULL;
   14410:	b8 00 00 00 00       	mov    $0x0,%eax
   14415:	e9 fc 00 00 00       	jmp    14516 <find_entry+0x249>
	// 此时我们就在这个读取的目录i节点数据块中搜索匹配指定文件名的目录项.首先让de指向缓冲块中的数据块部分,并在不超过目录项数据的条件下,循环执行搜索.其中i是目录
	// 中的目录项索引号,在循环开始时初始化为0.
	i = 0;
   1441a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   14421:	00 
	de = (struct dir_entry *) bh->b_data;
   14422:	8b 44 24 18          	mov    0x18(%esp),%eax
   14426:	8b 00                	mov    (%eax),%eax
   14428:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (i < entries) {
   1442c:	e9 c3 00 00 00       	jmp    144f4 <find_entry+0x227>
		// 如果当前目录项数据块已经搜索完,还没有找到匹配的目录项,则释放当前目录项数据块.再读入目录的下一个逻辑块.若这块为空,则只要还没有搜索完目录中的所有目录项,就
		// 跳过该块,继续读目录的下一逻辑块.若该块不空,就让de指向该数据块,然后在其中继续搜索.其中141行上i/DIR_ENTRIES_PER_BLOCK可得到当前搜索的目录项所在目录文件中的
		// 块号,而bmap()函数(inode.c)则可计算出在设备上对应的逻辑块号.
		if ((char *)de >= BLOCK_SIZE + bh->b_data) {
   14431:	8b 44 24 18          	mov    0x18(%esp),%eax
   14435:	8b 00                	mov    (%eax),%eax
   14437:	05 00 04 00 00       	add    $0x400,%eax
   1443c:	39 44 24 14          	cmp    %eax,0x14(%esp)
   14440:	72 7d                	jb     144bf <find_entry+0x1f2>
			brelse(bh);
   14442:	83 ec 0c             	sub    $0xc,%esp
   14445:	ff 74 24 24          	pushl  0x24(%esp)
   14449:	e8 1d c5 ff ff       	call   1096b <brelse>
   1444e:	83 c4 10             	add    $0x10,%esp
			bh = NULL;
   14451:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   14458:	00 
			if (!(block = bmap(*dir, i / DIR_ENTRIES_PER_BLOCK)) ||
   14459:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1445d:	c1 e8 06             	shr    $0x6,%eax
   14460:	89 c2                	mov    %eax,%edx
   14462:	8b 44 24 30          	mov    0x30(%esp),%eax
   14466:	8b 00                	mov    (%eax),%eax
   14468:	83 ec 08             	sub    $0x8,%esp
   1446b:	52                   	push   %edx
   1446c:	50                   	push   %eax
   1446d:	e8 e4 b3 ff ff       	call   f856 <bmap>
   14472:	83 c4 10             	add    $0x10,%esp
   14475:	89 44 24 08          	mov    %eax,0x8(%esp)
   14479:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1447e:	74 28                	je     144a8 <find_entry+0x1db>
			    !(bh = bread((*dir)->i_dev, block))) {
   14480:	8b 44 24 30          	mov    0x30(%esp),%eax
   14484:	8b 00                	mov    (%eax),%eax
   14486:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1448a:	0f b7 c0             	movzwl %ax,%eax
			if (!(block = bmap(*dir, i / DIR_ENTRIES_PER_BLOCK)) ||
   1448d:	83 ec 08             	sub    $0x8,%esp
   14490:	ff 74 24 10          	pushl  0x10(%esp)
   14494:	50                   	push   %eax
   14495:	e8 38 c5 ff ff       	call   109d2 <bread>
   1449a:	83 c4 10             	add    $0x10,%esp
   1449d:	89 44 24 18          	mov    %eax,0x18(%esp)
   144a1:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   144a6:	75 0d                	jne    144b5 <find_entry+0x1e8>
				i += DIR_ENTRIES_PER_BLOCK;
   144a8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   144ac:	83 c0 40             	add    $0x40,%eax
   144af:	89 44 24 1c          	mov    %eax,0x1c(%esp)
				continue;
   144b3:	eb 3f                	jmp    144f4 <find_entry+0x227>
			}
			de = (struct dir_entry *) bh->b_data;
   144b5:	8b 44 24 18          	mov    0x18(%esp),%eax
   144b9:	8b 00                	mov    (%eax),%eax
   144bb:	89 44 24 14          	mov    %eax,0x14(%esp)
		}
		// 如果找到匹配的目录项的话,则返回目录项结构指针de和该目录项i节点指针*dir以及该目录项数据块指针bh,并退出函数.否则继续在目录项数据块中比较下一个目录项.
		if (match(namelen, name, de)) {
   144bf:	83 ec 04             	sub    $0x4,%esp
   144c2:	ff 74 24 18          	pushl  0x18(%esp)
   144c6:	ff 74 24 3c          	pushl  0x3c(%esp)
   144ca:	ff 74 24 44          	pushl  0x44(%esp)
   144ce:	e8 5f fd ff ff       	call   14232 <match>
   144d3:	83 c4 10             	add    $0x10,%esp
   144d6:	85 c0                	test   %eax,%eax
   144d8:	74 10                	je     144ea <find_entry+0x21d>
			*res_dir = de;
   144da:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   144de:	8b 54 24 14          	mov    0x14(%esp),%edx
   144e2:	89 10                	mov    %edx,(%eax)
			return bh;
   144e4:	8b 44 24 18          	mov    0x18(%esp),%eax
   144e8:	eb 2c                	jmp    14516 <find_entry+0x249>
		}
		de++;
   144ea:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
		i++;
   144ef:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
	while (i < entries) {
   144f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   144f8:	3b 44 24 10          	cmp    0x10(%esp),%eax
   144fc:	0f 8c 2f ff ff ff    	jl     14431 <find_entry+0x164>
	}
	// 如果指定目录中的所有目录项都搜索赛后,还没有找到相应的目录项,则释放目录的数据块,最后返回NULL(失败).
	brelse(bh);
   14502:	83 ec 0c             	sub    $0xc,%esp
   14505:	ff 74 24 24          	pushl  0x24(%esp)
   14509:	e8 5d c4 ff ff       	call   1096b <brelse>
   1450e:	83 c4 10             	add    $0x10,%esp
	return NULL;
   14511:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14516:	83 c4 28             	add    $0x28,%esp
   14519:	5b                   	pop    %ebx
   1451a:	c3                   	ret    

0001451b <add_entry>:
// 根据指定的目录和文件名添加目录项。
// 参数：dir - 指定目录的i节点；name - 文件名；namelen - 文件名长度；
// 返回：高速缓冲区指针；res_dir - 返回的目录项结构指针。
static struct buffer_head * add_entry(struct m_inode * dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
   1451b:	53                   	push   %ebx
   1451c:	83 ec 18             	sub    $0x18,%esp
   1451f:	e8 d6 27 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   14524:	81 c3 dc da 01 00    	add    $0x1dadc,%ebx
	struct buffer_head * bh;
	struct dir_entry * de;

	// 同样，本函数一开始也需要对函数参数的有效性进行判断和验证。如果我们在前面定义了符号常数NO_TRUNCATE，那么如果文件
	// 名长度超过最大长度NAME_LEN，则不予处理。如果没有定义过NO_TRUNCATE，那么在文件长度超过最大长度NAME_LEN时截短之。
	*res_dir = NULL;                							// 用于返回目录项结构指针。
   1452a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   1452e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
   14534:	83 7c 24 28 0e       	cmpl   $0xe,0x28(%esp)
   14539:	7e 08                	jle    14543 <add_entry+0x28>
		namelen = NAME_LEN;
   1453b:	c7 44 24 28 0e 00 00 	movl   $0xe,0x28(%esp)
   14542:	00 
#endif
	// 现在我们开始操作，向指定目录中添加一个指定文件名的目录项。因此我们需要先读取目录的数据，即取出目录i节点对应块设备
	// 数据区中的数据块（逻辑块）信息。这些逻辑块的块号保存在i节点结构的i_zone[9]数组中。我们先取其第1个块号。如果目录
	// i节点指向的第一个直接磁盘块号为0,则说明该目录竟然不含数据，这不正常。于是返回NULL退出。否则我们就从节点所在设备读取
	// 指定的目录项数据块。如果不成功，则也返回NULL退出。另外，如果参数提供的文件名长度等于0,则也返回NULL退出。
	if (!namelen)
   14543:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   14548:	75 0a                	jne    14554 <add_entry+0x39>
		return NULL;
   1454a:	b8 00 00 00 00       	mov    $0x0,%eax
   1454f:	e9 0d 02 00 00       	jmp    14761 <add_entry+0x246>
	if (!(block = dir->i_zone[0]))
   14554:	8b 44 24 20          	mov    0x20(%esp),%eax
   14558:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1455c:	0f b7 c0             	movzwl %ax,%eax
   1455f:	89 04 24             	mov    %eax,(%esp)
   14562:	83 3c 24 00          	cmpl   $0x0,(%esp)
   14566:	75 0a                	jne    14572 <add_entry+0x57>
		return NULL;
   14568:	b8 00 00 00 00       	mov    $0x0,%eax
   1456d:	e9 ef 01 00 00       	jmp    14761 <add_entry+0x246>
	if (!(bh = bread(dir->i_dev, block)))
   14572:	8b 44 24 20          	mov    0x20(%esp),%eax
   14576:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1457a:	0f b7 c0             	movzwl %ax,%eax
   1457d:	83 ec 08             	sub    $0x8,%esp
   14580:	ff 74 24 08          	pushl  0x8(%esp)
   14584:	50                   	push   %eax
   14585:	e8 48 c4 ff ff       	call   109d2 <bread>
   1458a:	83 c4 10             	add    $0x10,%esp
   1458d:	89 44 24 08          	mov    %eax,0x8(%esp)
   14591:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   14596:	75 0a                	jne    145a2 <add_entry+0x87>
		return NULL;
   14598:	b8 00 00 00 00       	mov    $0x0,%eax
   1459d:	e9 bf 01 00 00       	jmp    14761 <add_entry+0x246>
	// 此时我们就在这个目录i节点数据块中循环查找最后未使用的空目录项。首先让目录项结构指针de指向缓冲块中的数据块部分，即第
	// 一个目录项处。其中i是目录中的目录项索引号，在循环开始时初始化为0。
	i = 0;
   145a2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   145a9:	00 
	de = (struct dir_entry *) bh->b_data;
   145aa:	8b 44 24 08          	mov    0x8(%esp),%eax
   145ae:	8b 00                	mov    (%eax),%eax
   145b0:	89 44 24 04          	mov    %eax,0x4(%esp)
		// 对应的逻辑块不存在就创建一块。若读取或创建操作失败则返回空。如果此次读取的磁盘逻辑块数据返回的缓冲块指针为空，说明这
		// 块逻辑块可能是因为不存在而新创建的空块，则把目录项索引值加上一块逻辑块所能容纳的目录项数DIR_ENTRIES_PER_BLOCK，
		// 用以跳过该块并继续搜索。否则说明新读入的块上有目录项数据，于是让目录项结构指针de指向该块的缓冲块数据部分，然后在其中
		// 继续搜索。其中i/DIR_ENTRIES_PER_BLOCK可计算得到当前搜索的目录项i所在目录文件中的块号，而create_block()函数
		// （inode.c）则可读取或创建出在设备上对应的逻辑块。
		if ((char *)de >= BLOCK_SIZE + bh->b_data) {
   145b4:	8b 44 24 08          	mov    0x8(%esp),%eax
   145b8:	8b 00                	mov    (%eax),%eax
   145ba:	05 00 04 00 00       	add    $0x400,%eax
   145bf:	39 44 24 04          	cmp    %eax,0x4(%esp)
   145c3:	0f 82 81 00 00 00    	jb     1464a <add_entry+0x12f>
			brelse(bh);
   145c9:	83 ec 0c             	sub    $0xc,%esp
   145cc:	ff 74 24 14          	pushl  0x14(%esp)
   145d0:	e8 96 c3 ff ff       	call   1096b <brelse>
   145d5:	83 c4 10             	add    $0x10,%esp
			bh = NULL;
   145d8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   145df:	00 
			block = create_block(dir, i / DIR_ENTRIES_PER_BLOCK);
   145e0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   145e4:	c1 e8 06             	shr    $0x6,%eax
   145e7:	83 ec 08             	sub    $0x8,%esp
   145ea:	50                   	push   %eax
   145eb:	ff 74 24 2c          	pushl  0x2c(%esp)
   145ef:	e8 88 b2 ff ff       	call   f87c <create_block>
   145f4:	83 c4 10             	add    $0x10,%esp
   145f7:	89 04 24             	mov    %eax,(%esp)
			if (!block)
   145fa:	83 3c 24 00          	cmpl   $0x0,(%esp)
   145fe:	75 0a                	jne    1460a <add_entry+0xef>
				return NULL;
   14600:	b8 00 00 00 00       	mov    $0x0,%eax
   14605:	e9 57 01 00 00       	jmp    14761 <add_entry+0x246>
			if (!(bh = bread(dir->i_dev, block))) {          			// 若空则跳过该块继续。
   1460a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1460e:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   14612:	0f b7 c0             	movzwl %ax,%eax
   14615:	83 ec 08             	sub    $0x8,%esp
   14618:	ff 74 24 08          	pushl  0x8(%esp)
   1461c:	50                   	push   %eax
   1461d:	e8 b0 c3 ff ff       	call   109d2 <bread>
   14622:	83 c4 10             	add    $0x10,%esp
   14625:	89 44 24 08          	mov    %eax,0x8(%esp)
   14629:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1462e:	75 10                	jne    14640 <add_entry+0x125>
				i += DIR_ENTRIES_PER_BLOCK;
   14630:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14634:	83 c0 40             	add    $0x40,%eax
   14637:	89 44 24 0c          	mov    %eax,0xc(%esp)
				continue;
   1463b:	e9 1c 01 00 00       	jmp    1475c <add_entry+0x241>
			}
			de = (struct dir_entry *) bh->b_data;
   14640:	8b 44 24 08          	mov    0x8(%esp),%eax
   14644:	8b 00                	mov    (%eax),%eax
   14646:	89 44 24 04          	mov    %eax,0x4(%esp)
		}
		// 如果当前所操作的目录项序号i乘上结构大小所得长度值已经超过目录i节点信息所指出的目录数据长度值i_size，则说明整个目录
		// 文件数据中没有由于删除文件留下的空目录项，因此我们只能把需要添加的新目录项附加到目录文件数据的末端处。于是对该处目录
		// 项进行设置（置该目录项的i节点指针为空），并更新该目录文件的长度值（加上一个目录项的长度），然后设置目录的i节点已修改
		// 标志，再更新该目录的改变时间为当前时间。
		if (i * sizeof(struct dir_entry) >= dir->i_size) {
   1464a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1464e:	c1 e0 04             	shl    $0x4,%eax
   14651:	89 c2                	mov    %eax,%edx
   14653:	8b 44 24 20          	mov    0x20(%esp),%eax
   14657:	8b 40 04             	mov    0x4(%eax),%eax
   1465a:	39 c2                	cmp    %eax,%edx
   1465c:	72 51                	jb     146af <add_entry+0x194>
			de->inode = 0;
   1465e:	8b 44 24 04          	mov    0x4(%esp),%eax
   14662:	66 c7 00 00 00       	movw   $0x0,(%eax)
			dir->i_size = (i + 1) * sizeof(struct dir_entry);
   14667:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1466b:	83 c0 01             	add    $0x1,%eax
   1466e:	c1 e0 04             	shl    $0x4,%eax
   14671:	89 c2                	mov    %eax,%edx
   14673:	8b 44 24 20          	mov    0x20(%esp),%eax
   14677:	89 50 04             	mov    %edx,0x4(%eax)
			dir->i_dirt = 1;
   1467a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1467e:	c6 40 37 01          	movb   $0x1,0x37(%eax)
			dir->i_ctime = CURRENT_TIME;
   14682:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   14688:	8b 10                	mov    (%eax),%edx
   1468a:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   14690:	8b 00                	mov    (%eax),%eax
   14692:	01 d0                	add    %edx,%eax
   14694:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   14699:	f7 e2                	mul    %edx
   1469b:	c1 ea 05             	shr    $0x5,%edx
   1469e:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   146a4:	8b 00                	mov    (%eax),%eax
   146a6:	01 c2                	add    %eax,%edx
   146a8:	8b 44 24 20          	mov    0x20(%esp),%eax
   146ac:	89 50 2c             	mov    %edx,0x2c(%eax)
		}
		// 若当前搜索的目录项de的i节点为空，则表示找到一个还未使用的空闲目录项或是添加的新目录项。于是更新目录的修改时间为当前
		// 时间，并从用户数据区复制文件名到该目录项的文件名字段，置含有本目录项的相应高速缓冲块已修改标志。返回该目录项的指针以及
		// 该高速缓冲块的指针，退出。
		if (!de->inode) {
   146af:	8b 44 24 04          	mov    0x4(%esp),%eax
   146b3:	0f b7 00             	movzwl (%eax),%eax
   146b6:	66 85 c0             	test   %ax,%ax
   146b9:	0f 85 93 00 00 00    	jne    14752 <add_entry+0x237>
			dir->i_mtime = CURRENT_TIME;
   146bf:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   146c5:	8b 10                	mov    (%eax),%edx
   146c7:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   146cd:	8b 00                	mov    (%eax),%eax
   146cf:	01 d0                	add    %edx,%eax
   146d1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   146d6:	f7 e2                	mul    %edx
   146d8:	c1 ea 05             	shr    $0x5,%edx
   146db:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   146e1:	8b 00                	mov    (%eax),%eax
   146e3:	01 c2                	add    %eax,%edx
   146e5:	8b 44 24 20          	mov    0x20(%esp),%eax
   146e9:	89 50 08             	mov    %edx,0x8(%eax)
			for (i = 0; i < NAME_LEN ; i++)
   146ec:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   146f3:	00 
   146f4:	eb 3d                	jmp    14733 <add_entry+0x218>
				de->name[i] = (i < namelen) ? get_fs_byte(name + i) : 0;
   146f6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   146fa:	3b 44 24 28          	cmp    0x28(%esp),%eax
   146fe:	7d 1a                	jge    1471a <add_entry+0x1ff>
   14700:	8b 54 24 0c          	mov    0xc(%esp),%edx
   14704:	8b 44 24 24          	mov    0x24(%esp),%eax
   14708:	01 d0                	add    %edx,%eax
   1470a:	83 ec 0c             	sub    $0xc,%esp
   1470d:	50                   	push   %eax
   1470e:	e8 fa f9 ff ff       	call   1410d <get_fs_byte>
   14713:	83 c4 10             	add    $0x10,%esp
   14716:	89 c1                	mov    %eax,%ecx
   14718:	eb 05                	jmp    1471f <add_entry+0x204>
   1471a:	b9 00 00 00 00       	mov    $0x0,%ecx
   1471f:	8b 54 24 04          	mov    0x4(%esp),%edx
   14723:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14727:	01 d0                	add    %edx,%eax
   14729:	83 c0 02             	add    $0x2,%eax
   1472c:	88 08                	mov    %cl,(%eax)
			for (i = 0; i < NAME_LEN ; i++)
   1472e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   14733:	83 7c 24 0c 0d       	cmpl   $0xd,0xc(%esp)
   14738:	7e bc                	jle    146f6 <add_entry+0x1db>
			bh->b_dirt = 1;
   1473a:	8b 44 24 08          	mov    0x8(%esp),%eax
   1473e:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
			*res_dir = de;
   14742:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   14746:	8b 54 24 04          	mov    0x4(%esp),%edx
   1474a:	89 10                	mov    %edx,(%eax)
			return bh;
   1474c:	8b 44 24 08          	mov    0x8(%esp),%eax
   14750:	eb 0f                	jmp    14761 <add_entry+0x246>
		}
		de++;           												// 如果该目录项已经被使用，则继续检测下一个目录项。
   14752:	83 44 24 04 10       	addl   $0x10,0x4(%esp)
		i++;
   14757:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
		if ((char *)de >= BLOCK_SIZE + bh->b_data) {
   1475c:	e9 53 fe ff ff       	jmp    145b4 <add_entry+0x99>
	}
	// 本函数执行不到这里。这也许是Linus在写这段代码时，先复制了上面find_entry()函数的代码，而后修改成本函数的。
	brelse(bh);
	return NULL;
}
   14761:	83 c4 18             	add    $0x18,%esp
   14764:	5b                   	pop    %ebx
   14765:	c3                   	ret    

00014766 <follow_link>:

// 查找符号链接的i节点.
// 参数:dir - 目录i节点;inode - 目录项i节点.
// 返回:返回符号链接到文件的i节点指针.出错返回NULL.
static struct m_inode * follow_link(struct m_inode * dir, struct m_inode * inode)
{
   14766:	53                   	push   %ebx
   14767:	83 ec 18             	sub    $0x18,%esp
   1476a:	e8 8b 25 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1476f:	81 c3 91 d8 01 00    	add    $0x1d891,%ebx
	unsigned short fs;													// 用于临时保存fs段寄存器值.
	struct buffer_head * bh;

	// 首先判断函数参数的有效性.如果没有给出目录i节点,我们就使用进程任务结构中设置的根i节点,并把链接数增1.如果没有给出目录
	// 项i节点,则放回目录i节点后返回NULL.如果指定目录项不是一个符号链接,就直接返回目录项对应的i节点inode.
	if (!dir) {
   14775:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   1477a:	75 25                	jne    147a1 <follow_link+0x3b>
		dir = current->root;
   1477c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   14782:	8b 00                	mov    (%eax),%eax
   14784:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
   1478a:	89 44 24 20          	mov    %eax,0x20(%esp)
		dir->i_count++;
   1478e:	8b 44 24 20          	mov    0x20(%esp),%eax
   14792:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   14796:	8d 50 01             	lea    0x1(%eax),%edx
   14799:	8b 44 24 20          	mov    0x20(%esp),%eax
   1479d:	66 89 50 34          	mov    %dx,0x34(%eax)
	}
	if (!inode) {
   147a1:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   147a6:	75 19                	jne    147c1 <follow_link+0x5b>
		iput(dir);
   147a8:	83 ec 0c             	sub    $0xc,%esp
   147ab:	ff 74 24 2c          	pushl  0x2c(%esp)
   147af:	e8 ee b0 ff ff       	call   f8a2 <iput>
   147b4:	83 c4 10             	add    $0x10,%esp
		return NULL;
   147b7:	b8 00 00 00 00       	mov    $0x0,%eax
   147bc:	e9 ea 00 00 00       	jmp    148ab <follow_link+0x145>
	}
	if (!S_ISLNK(inode->i_mode)) {
   147c1:	8b 44 24 24          	mov    0x24(%esp),%eax
   147c5:	0f b7 00             	movzwl (%eax),%eax
   147c8:	0f b7 c0             	movzwl %ax,%eax
   147cb:	25 00 f0 00 00       	and    $0xf000,%eax
   147d0:	3d 00 a0 00 00       	cmp    $0xa000,%eax
   147d5:	74 18                	je     147ef <follow_link+0x89>
		iput(dir);
   147d7:	83 ec 0c             	sub    $0xc,%esp
   147da:	ff 74 24 2c          	pushl  0x2c(%esp)
   147de:	e8 bf b0 ff ff       	call   f8a2 <iput>
   147e3:	83 c4 10             	add    $0x10,%esp
		return inode;
   147e6:	8b 44 24 24          	mov    0x24(%esp),%eax
   147ea:	e9 bc 00 00 00       	jmp    148ab <follow_link+0x145>
	}
	// 然后取fs段寄存器值.fs通常保存着指向任务数据段的选择符0x17.如果fs没有指向用户数据段,或者给出的目录项i节点第1个直接块
	// 块号等于0,或者是读取第1个直接块出错,则放回dir和inode两个i节点并返回NULL退出.否则说明现在fs正指向用户数据段,并且我
	// 们已经成功地读取了符号链接目录项的文件内容,并且文件内容已经在bh指向的缓冲块数据区中.实际上,这个缓冲块数据区中仅包含一
	// 个链接指向的文件路径名字符串.
	__asm__("mov %%fs, %0":"=r" (fs));
   147ef:	66 8c e0             	mov    %fs,%ax
   147f2:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	if (fs != 0x17 || !inode->i_zone[0] ||
   147f7:	66 83 7c 24 0e 17    	cmpw   $0x17,0xe(%esp)
   147fd:	75 3b                	jne    1483a <follow_link+0xd4>
   147ff:	8b 44 24 24          	mov    0x24(%esp),%eax
   14803:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   14807:	66 85 c0             	test   %ax,%ax
   1480a:	74 2e                	je     1483a <follow_link+0xd4>
	   !(bh = bread(inode->i_dev, inode->i_zone[0]))) {
   1480c:	8b 44 24 24          	mov    0x24(%esp),%eax
   14810:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   14814:	0f b7 d0             	movzwl %ax,%edx
   14817:	8b 44 24 24          	mov    0x24(%esp),%eax
   1481b:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1481f:	0f b7 c0             	movzwl %ax,%eax
	if (fs != 0x17 || !inode->i_zone[0] ||
   14822:	83 ec 08             	sub    $0x8,%esp
   14825:	52                   	push   %edx
   14826:	50                   	push   %eax
   14827:	e8 a6 c1 ff ff       	call   109d2 <bread>
   1482c:	83 c4 10             	add    $0x10,%esp
   1482f:	89 44 24 08          	mov    %eax,0x8(%esp)
   14833:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   14838:	75 25                	jne    1485f <follow_link+0xf9>
		iput(dir);
   1483a:	83 ec 0c             	sub    $0xc,%esp
   1483d:	ff 74 24 2c          	pushl  0x2c(%esp)
   14841:	e8 5c b0 ff ff       	call   f8a2 <iput>
   14846:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   14849:	83 ec 0c             	sub    $0xc,%esp
   1484c:	ff 74 24 30          	pushl  0x30(%esp)
   14850:	e8 4d b0 ff ff       	call   f8a2 <iput>
   14855:	83 c4 10             	add    $0x10,%esp
		return NULL;
   14858:	b8 00 00 00 00       	mov    $0x0,%eax
   1485d:	eb 4c                	jmp    148ab <follow_link+0x145>
	}
	// 此时我们已经不需要符号链接目录项的i节点了,于是把它放回.现在遇到一个问题,那就是内核函数处理的用户数据都是存放在用户数据
	// 空间中的,并使用了fs段寄存器来从用户空间传递数据到内核空间中.而这里需要处理的数据却在内核空间中.因此为了正确地处理位于
	// 内核中的用户数据,我们需要让fs段寄存器临时指向内核空间,即让fs=0x10.并在调用函数处理完后再恢复原fs的值.最后释放相应缓冲
	// 块,并返回_namei()解析得到符号链接指向的文件i节点.
	iput(inode);
   1485f:	83 ec 0c             	sub    $0xc,%esp
   14862:	ff 74 24 30          	pushl  0x30(%esp)
   14866:	e8 37 b0 ff ff       	call   f8a2 <iput>
   1486b:	83 c4 10             	add    $0x10,%esp
	__asm__("mov %0, %%fs"::"r" ((unsigned short) 0x10));
   1486e:	b8 10 00 00 00       	mov    $0x10,%eax
   14873:	8e e0                	mov    %eax,%fs
	inode = _namei(bh->b_data,dir,0);
   14875:	8b 44 24 08          	mov    0x8(%esp),%eax
   14879:	8b 00                	mov    (%eax),%eax
   1487b:	83 ec 04             	sub    $0x4,%esp
   1487e:	6a 00                	push   $0x0
   14880:	ff 74 24 28          	pushl  0x28(%esp)
   14884:	50                   	push   %eax
   14885:	e8 a4 02 00 00       	call   14b2e <_namei>
   1488a:	83 c4 10             	add    $0x10,%esp
   1488d:	89 44 24 24          	mov    %eax,0x24(%esp)
	__asm__("mov %0, %%fs"::"r" (fs));
   14891:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
   14896:	8e e0                	mov    %eax,%fs
	brelse(bh);
   14898:	83 ec 0c             	sub    $0xc,%esp
   1489b:	ff 74 24 14          	pushl  0x14(%esp)
   1489f:	e8 c7 c0 ff ff       	call   1096b <brelse>
   148a4:	83 c4 10             	add    $0x10,%esp
	return inode;
   148a7:	8b 44 24 24          	mov    0x24(%esp),%eax
}
   148ab:	83 c4 18             	add    $0x18,%esp
   148ae:	5b                   	pop    %ebx
   148af:	c3                   	ret    

000148b0 <get_dir>:
 */
// 从指定目录开始搜寻指定路径名的目录(或文件名)的i节点.
// 参数:pathname - 路径名;inode - 指定起始目录的i节点.
// 返回:目录或文件的i节点指针.失败时返回NULL.
static struct m_inode * get_dir(const char * pathname, struct m_inode * inode)
{
   148b0:	53                   	push   %ebx
   148b1:	83 ec 28             	sub    $0x28,%esp
   148b4:	e8 41 24 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   148b9:	81 c3 47 d7 01 00    	add    $0x1d747,%ebx
	int namelen, inr;
	struct dir_entry * de;
	struct m_inode * dir;

	// 首先判断参数有效性.如果给出的指定目录的i节点指针inode为空,则使用当前进程的工作目录i节点.
	if (!inode) {
   148bf:	8b 44 24 34          	mov    0x34(%esp),%eax
   148c3:	85 c0                	test   %eax,%eax
   148c5:	75 21                	jne    148e8 <get_dir+0x38>
		inode = current->pwd;									// 进程的当前工作目录i节点.
   148c7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   148cd:	8b 00                	mov    (%eax),%eax
   148cf:	8b 80 34 03 00 00    	mov    0x334(%eax),%eax
   148d5:	89 44 24 34          	mov    %eax,0x34(%esp)
		inode->i_count++;
   148d9:	8b 44 24 34          	mov    0x34(%esp),%eax
   148dd:	0f b7 50 34          	movzwl 0x34(%eax),%edx
   148e1:	83 c2 01             	add    $0x1,%edx
   148e4:	66 89 50 34          	mov    %dx,0x34(%eax)
	}
	// 如果用户指定路径名的第1个字符是'/',则说明路径名是绝对路径名.则应该从当前进程任务结构中设置的根(或伪根)i节点开始操作.
	// 于是我们需要先放回参数指定的或者设定的目录i节点,并取得进程使用的根i节点.然后把该i节点的引用计数加1,
	// 并删除路径名的第1个字符'/'.这样就可以保证进程只能以其设定的根i节点作为搜索的起点.
	if ((c = get_fs_byte(pathname)) == '/') {
   148e8:	ff 74 24 30          	pushl  0x30(%esp)
   148ec:	e8 1c f8 ff ff       	call   1410d <get_fs_byte>
   148f1:	83 c4 04             	add    $0x4,%esp
   148f4:	88 44 24 1b          	mov    %al,0x1b(%esp)
   148f8:	80 7c 24 1b 2f       	cmpb   $0x2f,0x1b(%esp)
   148fd:	75 36                	jne    14935 <get_dir+0x85>
		iput(inode);											// 放回原i节点.
   148ff:	8b 44 24 34          	mov    0x34(%esp),%eax
   14903:	83 ec 0c             	sub    $0xc,%esp
   14906:	50                   	push   %eax
   14907:	e8 96 af ff ff       	call   f8a2 <iput>
   1490c:	83 c4 10             	add    $0x10,%esp
		inode = current->root;									// 为进程指定的根i节点.
   1490f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   14915:	8b 00                	mov    (%eax),%eax
   14917:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
   1491d:	89 44 24 34          	mov    %eax,0x34(%esp)
		pathname++;
   14921:	83 44 24 30 01       	addl   $0x1,0x30(%esp)
		inode->i_count++;
   14926:	8b 44 24 34          	mov    0x34(%esp),%eax
   1492a:	0f b7 50 34          	movzwl 0x34(%eax),%edx
   1492e:	83 c2 01             	add    $0x1,%edx
   14931:	66 89 50 34          	mov    %dx,0x34(%eax)
	}
	// 然后针对路径名中的各个目录名部分和文件名进行循环处理。在循环处理过程中，我们先要对当前正在处理的目录名部分的i节点进行有效性判断，并且把
	// 变量thisname指向当前正在处理的目录名部分。如果该i节点表明当前处理的目录名部分不是目录类型，或者没有可进入该目录的访问许可，则放回该i节点
	// 并返回NULL退出。当然在刚进入循环时，当前目录的ｉ节点inode就是进程根i节点或者是当前工作目录的i节点，或者是参数指定的某个搜索起始目录的i节点。
	while (1) {
		thisname = pathname;
   14935:	8b 44 24 30          	mov    0x30(%esp),%eax
   14939:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (!S_ISDIR(inode->i_mode) || !permission(inode, MAY_EXEC)) {
   1493d:	8b 44 24 34          	mov    0x34(%esp),%eax
   14941:	0f b7 00             	movzwl (%eax),%eax
   14944:	0f b7 c0             	movzwl %ax,%eax
   14947:	25 00 f0 00 00       	and    $0xf000,%eax
   1494c:	3d 00 40 00 00       	cmp    $0x4000,%eax
   14951:	75 16                	jne    14969 <get_dir+0xb9>
   14953:	8b 44 24 34          	mov    0x34(%esp),%eax
   14957:	83 ec 08             	sub    $0x8,%esp
   1495a:	6a 01                	push   $0x1
   1495c:	50                   	push   %eax
   1495d:	e8 1a f8 ff ff       	call   1417c <permission>
   14962:	83 c4 10             	add    $0x10,%esp
   14965:	85 c0                	test   %eax,%eax
   14967:	75 1a                	jne    14983 <get_dir+0xd3>
			iput(inode);
   14969:	8b 44 24 34          	mov    0x34(%esp),%eax
   1496d:	83 ec 0c             	sub    $0xc,%esp
   14970:	50                   	push   %eax
   14971:	e8 2c af ff ff       	call   f8a2 <iput>
   14976:	83 c4 10             	add    $0x10,%esp
			return NULL;
   14979:	b8 00 00 00 00       	mov    $0x0,%eax
   1497e:	e9 12 01 00 00       	jmp    14a95 <get_dir+0x1e5>
		// 每次循环我们处理路径名中一个目录名(或文件名)部分.因此在每次循环中我们都要从路径名字符串中分离出一个目录名(或文件名).方法是从当前路径名指针
		// pathname开始处搜索检测字符,直到字符是一个结尾符(NULL)或者是一个'/'字符.此时变量namelen正好是当前处理目录名部分的长度,而变量thisname正指向
		// 该目录名部分的开始处.此时如果字符是结尾符NULL,则表明已经搜索到路径名末尾,并已到达最后指定目录名或文件名,则返回该i节点指针退出.
		// 注意!如果路径名中最后一个名称也是一个目录名,但其后面没有加上'/'字符,则函数不会返回该最后目录名的i节点!例如:对于路径/usr/src/linux,该函数将
		// 只返回src/目录名的i节点.
		for(namelen = 0; (c = get_fs_byte(pathname++)) && (c != '/'); namelen++)
   14983:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   1498a:	00 
   1498b:	eb 05                	jmp    14992 <get_dir+0xe2>
   1498d:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   14992:	8b 44 24 30          	mov    0x30(%esp),%eax
   14996:	8d 50 01             	lea    0x1(%eax),%edx
   14999:	89 54 24 30          	mov    %edx,0x30(%esp)
   1499d:	83 ec 0c             	sub    $0xc,%esp
   149a0:	50                   	push   %eax
   149a1:	e8 67 f7 ff ff       	call   1410d <get_fs_byte>
   149a6:	83 c4 10             	add    $0x10,%esp
   149a9:	88 44 24 1b          	mov    %al,0x1b(%esp)
   149ad:	80 7c 24 1b 00       	cmpb   $0x0,0x1b(%esp)
   149b2:	74 07                	je     149bb <get_dir+0x10b>
   149b4:	80 7c 24 1b 2f       	cmpb   $0x2f,0x1b(%esp)
   149b9:	75 d2                	jne    1498d <get_dir+0xdd>
			/* nothing */ ;
		if (!c)
   149bb:	80 7c 24 1b 00       	cmpb   $0x0,0x1b(%esp)
   149c0:	75 09                	jne    149cb <get_dir+0x11b>
			return inode;
   149c2:	8b 44 24 34          	mov    0x34(%esp),%eax
   149c6:	e9 ca 00 00 00       	jmp    14a95 <get_dir+0x1e5>
		// 在得到当前目录名部分(或文件名)后,我们调用查找目录项函数find_entry()在当前处理的目录中寻找指定名称的目录项.如果没有找到,则放回该i节点,并返回
		// NULL退出.然后在找到的目录项中取出其i节点号inr和设备号idev,释放包含该目录项的高速缓冲块并放回该i节点.然后取节点号inr的i节点inode,并以该目录
		// 项为当前目录继续循环处理路径名中的下一目录名部分(或文件名).如果当前处理的目录项是一个符号链接名,则使用follow_link()就可以得到其指向的目录项名i节点.
		if (!(bh = find_entry(&inode, thisname, namelen, &de))) {
   149cb:	8d 44 24 04          	lea    0x4(%esp),%eax
   149cf:	50                   	push   %eax
   149d0:	ff 74 24 20          	pushl  0x20(%esp)
   149d4:	ff 74 24 1c          	pushl  0x1c(%esp)
   149d8:	8d 44 24 40          	lea    0x40(%esp),%eax
   149dc:	50                   	push   %eax
   149dd:	e8 eb f8 ff ff       	call   142cd <find_entry>
   149e2:	83 c4 10             	add    $0x10,%esp
   149e5:	89 44 24 10          	mov    %eax,0x10(%esp)
   149e9:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   149ee:	75 1a                	jne    14a0a <get_dir+0x15a>
			iput(inode);
   149f0:	8b 44 24 34          	mov    0x34(%esp),%eax
   149f4:	83 ec 0c             	sub    $0xc,%esp
   149f7:	50                   	push   %eax
   149f8:	e8 a5 ae ff ff       	call   f8a2 <iput>
   149fd:	83 c4 10             	add    $0x10,%esp
			return NULL;
   14a00:	b8 00 00 00 00       	mov    $0x0,%eax
   14a05:	e9 8b 00 00 00       	jmp    14a95 <get_dir+0x1e5>
		}
		inr = de->inode;										// 当前目录名部分的i节点号.
   14a0a:	8b 44 24 04          	mov    0x4(%esp),%eax
   14a0e:	0f b7 00             	movzwl (%eax),%eax
   14a11:	0f b7 c0             	movzwl %ax,%eax
   14a14:	89 44 24 0c          	mov    %eax,0xc(%esp)
		brelse(bh);
   14a18:	83 ec 0c             	sub    $0xc,%esp
   14a1b:	ff 74 24 1c          	pushl  0x1c(%esp)
   14a1f:	e8 47 bf ff ff       	call   1096b <brelse>
   14a24:	83 c4 10             	add    $0x10,%esp
		dir = inode;
   14a27:	8b 44 24 34          	mov    0x34(%esp),%eax
   14a2b:	89 44 24 08          	mov    %eax,0x8(%esp)
		if (!(inode = iget(dir->i_dev, inr))) {					// 取i节点内容.
   14a2f:	8b 44 24 08          	mov    0x8(%esp),%eax
   14a33:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   14a37:	0f b7 c0             	movzwl %ax,%eax
   14a3a:	83 ec 08             	sub    $0x8,%esp
   14a3d:	ff 74 24 14          	pushl  0x14(%esp)
   14a41:	50                   	push   %eax
   14a42:	e8 1f b2 ff ff       	call   fc66 <iget>
   14a47:	83 c4 10             	add    $0x10,%esp
   14a4a:	89 44 24 34          	mov    %eax,0x34(%esp)
   14a4e:	8b 44 24 34          	mov    0x34(%esp),%eax
   14a52:	85 c0                	test   %eax,%eax
   14a54:	75 16                	jne    14a6c <get_dir+0x1bc>
			iput(dir);
   14a56:	83 ec 0c             	sub    $0xc,%esp
   14a59:	ff 74 24 14          	pushl  0x14(%esp)
   14a5d:	e8 40 ae ff ff       	call   f8a2 <iput>
   14a62:	83 c4 10             	add    $0x10,%esp
			return NULL;
   14a65:	b8 00 00 00 00       	mov    $0x0,%eax
   14a6a:	eb 29                	jmp    14a95 <get_dir+0x1e5>
		}
		if (!(inode = follow_link(dir, inode)))
   14a6c:	8b 44 24 34          	mov    0x34(%esp),%eax
   14a70:	83 ec 08             	sub    $0x8,%esp
   14a73:	50                   	push   %eax
   14a74:	ff 74 24 14          	pushl  0x14(%esp)
   14a78:	e8 e9 fc ff ff       	call   14766 <follow_link>
   14a7d:	83 c4 10             	add    $0x10,%esp
   14a80:	89 44 24 34          	mov    %eax,0x34(%esp)
   14a84:	8b 44 24 34          	mov    0x34(%esp),%eax
   14a88:	85 c0                	test   %eax,%eax
   14a8a:	0f 85 a5 fe ff ff    	jne    14935 <get_dir+0x85>
			return NULL;
   14a90:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
   14a95:	83 c4 28             	add    $0x28,%esp
   14a98:	5b                   	pop    %ebx
   14a99:	c3                   	ret    

00014a9a <dir_namei>:
// base - 搜索起始目录的i节点.
// 返回:指定目录名最顶层的i节点指针和最顶层目录名称及长度.出错时返回NULL.
// 注意!!这里"最顶层目录"是指路径名中最靠近末端的目录.
static struct m_inode * dir_namei(const char * pathname,
	int * namelen, const char ** name, struct m_inode * base)
{
   14a9a:	83 ec 1c             	sub    $0x1c,%esp
   14a9d:	e8 50 22 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   14aa2:	05 5e d5 01 00       	add    $0x1d55e,%eax
	struct m_inode * dir;

	// 首先取得指定路径名最顶层目录的i节点.然后对路径名pathname进行搜索检测,查出最后一个'/'字符后面的名字字符串,计算其长度,并且
	// 返回最顶层目录的i节点指针.注意!如果路径名最后一个字符是斜杠字符'/',那么返回的目录名为空,并且长度为0.但返回的i节点指针仍然
	// 指向最后一个'/'字符前目录名的i节点.
	if (!(dir = get_dir(pathname, base)))					// base是指定的起始目录i节点.
   14aa7:	83 ec 08             	sub    $0x8,%esp
   14aaa:	ff 74 24 34          	pushl  0x34(%esp)
   14aae:	ff 74 24 2c          	pushl  0x2c(%esp)
   14ab2:	e8 f9 fd ff ff       	call   148b0 <get_dir>
   14ab7:	83 c4 10             	add    $0x10,%esp
   14aba:	89 44 24 08          	mov    %eax,0x8(%esp)
   14abe:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   14ac3:	75 07                	jne    14acc <dir_namei+0x32>
		return NULL;
   14ac5:	b8 00 00 00 00       	mov    $0x0,%eax
   14aca:	eb 5e                	jmp    14b2a <dir_namei+0x90>
	basename = pathname;
   14acc:	8b 44 24 20          	mov    0x20(%esp),%eax
   14ad0:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (c = get_fs_byte(pathname++))
   14ad4:	eb 0f                	jmp    14ae5 <dir_namei+0x4b>
		if (c == '/')
   14ad6:	80 7c 24 07 2f       	cmpb   $0x2f,0x7(%esp)
   14adb:	75 08                	jne    14ae5 <dir_namei+0x4b>
			basename = pathname;
   14add:	8b 44 24 20          	mov    0x20(%esp),%eax
   14ae1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (c = get_fs_byte(pathname++))
   14ae5:	8b 44 24 20          	mov    0x20(%esp),%eax
   14ae9:	8d 50 01             	lea    0x1(%eax),%edx
   14aec:	89 54 24 20          	mov    %edx,0x20(%esp)
   14af0:	83 ec 0c             	sub    $0xc,%esp
   14af3:	50                   	push   %eax
   14af4:	e8 14 f6 ff ff       	call   1410d <get_fs_byte>
   14af9:	83 c4 10             	add    $0x10,%esp
   14afc:	88 44 24 07          	mov    %al,0x7(%esp)
   14b00:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
   14b05:	75 cf                	jne    14ad6 <dir_namei+0x3c>
	*namelen = pathname - basename - 1;
   14b07:	8b 54 24 20          	mov    0x20(%esp),%edx
   14b0b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14b0f:	29 c2                	sub    %eax,%edx
   14b11:	89 d0                	mov    %edx,%eax
   14b13:	8d 50 ff             	lea    -0x1(%eax),%edx
   14b16:	8b 44 24 24          	mov    0x24(%esp),%eax
   14b1a:	89 10                	mov    %edx,(%eax)
	*name = basename;
   14b1c:	8b 44 24 28          	mov    0x28(%esp),%eax
   14b20:	8b 54 24 0c          	mov    0xc(%esp),%edx
   14b24:	89 10                	mov    %edx,(%eax)
	return dir;
   14b26:	8b 44 24 08          	mov    0x8(%esp),%eax
}
   14b2a:	83 c4 1c             	add    $0x1c,%esp
   14b2d:	c3                   	ret    

00014b2e <_namei>:

// 取指定路径名的i节点内部函数.
// 参数:pathname - 路径名;base - 搜索起点目录i节点;follow_links - 是否跟随符号链接的标志,1 - 需要,0 不需要.
struct m_inode * _namei(const char * pathname, struct m_inode * base,
	int follow_links)
{
   14b2e:	53                   	push   %ebx
   14b2f:	83 ec 28             	sub    $0x28,%esp
   14b32:	e8 c3 21 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   14b37:	81 c3 c9 d4 01 00    	add    $0x1d4c9,%ebx
	struct buffer_head * bh;
	struct dir_entry * de;

	// 首先查找指定路径名中最顶层目录的目录名并得到其i节点.若不存在,则返回NULL退出.如果返回的最顶层名字的长度是0,则表示该路径名以一个目录名为
	// 最后一项.因此说明我们已经找到对应目录的i节点,可以直接返回该i节点退出.
	if (!(base = dir_namei(pathname, &namelen, &basename, base)))
   14b3d:	8b 44 24 34          	mov    0x34(%esp),%eax
   14b41:	50                   	push   %eax
   14b42:	8d 44 24 14          	lea    0x14(%esp),%eax
   14b46:	50                   	push   %eax
   14b47:	8d 44 24 14          	lea    0x14(%esp),%eax
   14b4b:	50                   	push   %eax
   14b4c:	ff 74 24 3c          	pushl  0x3c(%esp)
   14b50:	e8 45 ff ff ff       	call   14a9a <dir_namei>
   14b55:	83 c4 10             	add    $0x10,%esp
   14b58:	89 44 24 34          	mov    %eax,0x34(%esp)
   14b5c:	8b 44 24 34          	mov    0x34(%esp),%eax
   14b60:	85 c0                	test   %eax,%eax
   14b62:	75 0a                	jne    14b6e <_namei+0x40>
		return NULL;
   14b64:	b8 00 00 00 00       	mov    $0x0,%eax
   14b69:	e9 16 01 00 00       	jmp    14c84 <_namei+0x156>
	if (!namelen)										/* special case: '/usr/' etc */
   14b6e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14b72:	85 c0                	test   %eax,%eax
   14b74:	75 09                	jne    14b7f <_namei+0x51>
		return base;									/* 对应于'/usr/'等情况 */
   14b76:	8b 44 24 34          	mov    0x34(%esp),%eax
   14b7a:	e9 05 01 00 00       	jmp    14c84 <_namei+0x156>
	// 然后在返回的顶层目录中寻找指定文件名目录项的i节点.注意!因为如果最后也是一个目录名,但其后没有加'/',则不会返回该最后目录的i节点!例如:/usr/src/linux,
	// 将只返回src/目录名的i节点.因为函数dir_namei()将不以'/'结束的最后一个名字当作一个文件名来看待,因此这里需要单独对这种情况使用寻找目录项i节点函数
	// find_entry()进行处理.此时de中含有寻找到的目录项指针,而base是包含该目录项的目录的i节点指针.
	bh = find_entry(&base, basename, namelen, &de);
   14b7f:	8b 54 24 0c          	mov    0xc(%esp),%edx
   14b83:	8b 44 24 10          	mov    0x10(%esp),%eax
   14b87:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   14b8b:	51                   	push   %ecx
   14b8c:	52                   	push   %edx
   14b8d:	50                   	push   %eax
   14b8e:	8d 44 24 40          	lea    0x40(%esp),%eax
   14b92:	50                   	push   %eax
   14b93:	e8 35 f7 ff ff       	call   142cd <find_entry>
   14b98:	83 c4 10             	add    $0x10,%esp
   14b9b:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!bh) {
   14b9f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   14ba4:	75 1a                	jne    14bc0 <_namei+0x92>
		iput(base);
   14ba6:	8b 44 24 34          	mov    0x34(%esp),%eax
   14baa:	83 ec 0c             	sub    $0xc,%esp
   14bad:	50                   	push   %eax
   14bae:	e8 ef ac ff ff       	call   f8a2 <iput>
   14bb3:	83 c4 10             	add    $0x10,%esp
		return NULL;
   14bb6:	b8 00 00 00 00       	mov    $0x0,%eax
   14bbb:	e9 c4 00 00 00       	jmp    14c84 <_namei+0x156>
	}
	// 接着取该目录项的i节点号,并释放包含该目录项的高速缓冲块并放回目录i节点.然后取对应节点号的i节点,修改其被访问时间为当前时间,并置已修改标志.最后返回
	// 该i节点指针inode.如果当前处理的目录项是一个符号链接名,则使用follow_link()得到其指向的目录项名的i节点.
	inr = de->inode;
   14bc0:	8b 44 24 08          	mov    0x8(%esp),%eax
   14bc4:	0f b7 00             	movzwl (%eax),%eax
   14bc7:	0f b7 c0             	movzwl %ax,%eax
   14bca:	89 44 24 14          	mov    %eax,0x14(%esp)
	brelse(bh);
   14bce:	83 ec 0c             	sub    $0xc,%esp
   14bd1:	ff 74 24 24          	pushl  0x24(%esp)
   14bd5:	e8 91 bd ff ff       	call   1096b <brelse>
   14bda:	83 c4 10             	add    $0x10,%esp
	if (!(inode = iget(base->i_dev, inr))) {
   14bdd:	8b 44 24 34          	mov    0x34(%esp),%eax
   14be1:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   14be5:	0f b7 c0             	movzwl %ax,%eax
   14be8:	83 ec 08             	sub    $0x8,%esp
   14beb:	ff 74 24 1c          	pushl  0x1c(%esp)
   14bef:	50                   	push   %eax
   14bf0:	e8 71 b0 ff ff       	call   fc66 <iget>
   14bf5:	83 c4 10             	add    $0x10,%esp
   14bf8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   14bfc:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   14c01:	75 17                	jne    14c1a <_namei+0xec>
		iput(base);
   14c03:	8b 44 24 34          	mov    0x34(%esp),%eax
   14c07:	83 ec 0c             	sub    $0xc,%esp
   14c0a:	50                   	push   %eax
   14c0b:	e8 92 ac ff ff       	call   f8a2 <iput>
   14c10:	83 c4 10             	add    $0x10,%esp
		return NULL;
   14c13:	b8 00 00 00 00       	mov    $0x0,%eax
   14c18:	eb 6a                	jmp    14c84 <_namei+0x156>
	}
	if (follow_links)
   14c1a:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   14c1f:	74 1a                	je     14c3b <_namei+0x10d>
		inode = follow_link(base, inode);
   14c21:	8b 44 24 34          	mov    0x34(%esp),%eax
   14c25:	83 ec 08             	sub    $0x8,%esp
   14c28:	ff 74 24 24          	pushl  0x24(%esp)
   14c2c:	50                   	push   %eax
   14c2d:	e8 34 fb ff ff       	call   14766 <follow_link>
   14c32:	83 c4 10             	add    $0x10,%esp
   14c35:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   14c39:	eb 10                	jmp    14c4b <_namei+0x11d>
	else
		iput(base);
   14c3b:	8b 44 24 34          	mov    0x34(%esp),%eax
   14c3f:	83 ec 0c             	sub    $0xc,%esp
   14c42:	50                   	push   %eax
   14c43:	e8 5a ac ff ff       	call   f8a2 <iput>
   14c48:	83 c4 10             	add    $0x10,%esp
	inode->i_atime = CURRENT_TIME;
   14c4b:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   14c51:	8b 10                	mov    (%eax),%edx
   14c53:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   14c59:	8b 00                	mov    (%eax),%eax
   14c5b:	01 d0                	add    %edx,%eax
   14c5d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   14c62:	f7 e2                	mul    %edx
   14c64:	c1 ea 05             	shr    $0x5,%edx
   14c67:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   14c6d:	8b 00                	mov    (%eax),%eax
   14c6f:	01 c2                	add    %eax,%edx
   14c71:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   14c75:	89 50 28             	mov    %edx,0x28(%eax)
	inode->i_dirt = 1;
   14c78:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   14c7c:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	return inode;
   14c80:	8b 44 24 1c          	mov    0x1c(%esp),%eax
}
   14c84:	83 c4 28             	add    $0x28,%esp
   14c87:	5b                   	pop    %ebx
   14c88:	c3                   	ret    

00014c89 <lnamei>:

// 取指定路径名的i节点，不跟随符号链接。
// 参数：pathname - 路径名。
// 返回：对应的i节点。
struct m_inode * lnamei(const char * pathname)
{
   14c89:	83 ec 0c             	sub    $0xc,%esp
   14c8c:	e8 61 20 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   14c91:	05 6f d3 01 00       	add    $0x1d36f,%eax
	return _namei(pathname, NULL, 0);
   14c96:	83 ec 04             	sub    $0x4,%esp
   14c99:	6a 00                	push   $0x0
   14c9b:	6a 00                	push   $0x0
   14c9d:	ff 74 24 1c          	pushl  0x1c(%esp)
   14ca1:	e8 88 fe ff ff       	call   14b2e <_namei>
   14ca6:	83 c4 10             	add    $0x10,%esp
}
   14ca9:	83 c4 0c             	add    $0xc,%esp
   14cac:	c3                   	ret    

00014cad <namei>:
 */
// 取指定路径名的i节点,跟随符号链接.
// 参数:pathname - 路径名.
// 返回:对应的i节点.
struct m_inode * namei(const char * pathname)
{
   14cad:	83 ec 0c             	sub    $0xc,%esp
   14cb0:	e8 3d 20 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   14cb5:	05 4b d3 01 00       	add    $0x1d34b,%eax
	return _namei(pathname, NULL, 1);
   14cba:	83 ec 04             	sub    $0x4,%esp
   14cbd:	6a 01                	push   $0x1
   14cbf:	6a 00                	push   $0x0
   14cc1:	ff 74 24 1c          	pushl  0x1c(%esp)
   14cc5:	e8 64 fe ff ff       	call   14b2e <_namei>
   14cca:	83 c4 10             	add    $0x10,%esp
}
   14ccd:	83 c4 0c             	add    $0xc,%esp
   14cd0:	c3                   	ret    

00014cd1 <open_namei>:
// 执行)等等.对于新创建的文件,这些属性只应用于将来对文件的访问,创建了只读文件的打开调用也将返回一个读写的文件句柄.如果调用
// 操作成功,则返回文件句柄(文件描述符),否则返回出错码.参见sys/stat.h,fcntl.h.
// 返回:成功返回0,否则返回出错码;res_inode - 返回对应文件路径名的i节点指针.
int open_namei(const char * pathname, int flag, int mode,
	struct m_inode ** res_inode)
{
   14cd1:	56                   	push   %esi
   14cd2:	53                   	push   %ebx
   14cd3:	83 ec 24             	sub    $0x24,%esp
   14cd6:	e8 1f 20 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   14cdb:	81 c3 25 d3 01 00    	add    $0x1d325,%ebx
	struct buffer_head * bh;
	struct dir_entry * de;

	// 首先对函数参数进行合理的处理.如果文件访问模式标志是只读(O),但是文件截零标志O_TRUNC却置位了,则在文件打开标志中添加只写标志
	// O_WRONLY.这样做的原因是由于截零标志O_TRUNC必须在文件可写情况下有效.
	if ((flag & O_TRUNC) && !(flag & O_ACCMODE))
   14ce1:	8b 44 24 34          	mov    0x34(%esp),%eax
   14ce5:	25 00 02 00 00       	and    $0x200,%eax
   14cea:	85 c0                	test   %eax,%eax
   14cec:	74 10                	je     14cfe <open_namei+0x2d>
   14cee:	8b 44 24 34          	mov    0x34(%esp),%eax
   14cf2:	83 e0 03             	and    $0x3,%eax
   14cf5:	85 c0                	test   %eax,%eax
   14cf7:	75 05                	jne    14cfe <open_namei+0x2d>
		flag |= O_WRONLY;
   14cf9:	83 4c 24 34 01       	orl    $0x1,0x34(%esp)
	// 使用当前进程的文件访问许可屏蔽码,屏蔽掉给定模式中的相应位,并添上普通文件标志I_REGULAR.
	// 该标志将用于打开的文件不存在而需要创建文件时,作为新文件的默认属性
	mode &= 0777 & ~current->umask;
   14cfe:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   14d04:	8b 00                	mov    (%eax),%eax
   14d06:	0f b7 80 30 03 00 00 	movzwl 0x330(%eax),%eax
   14d0d:	0f b7 c0             	movzwl %ax,%eax
   14d10:	f7 d0                	not    %eax
   14d12:	25 ff 01 00 00       	and    $0x1ff,%eax
   14d17:	21 44 24 38          	and    %eax,0x38(%esp)
	mode |= I_REGULAR;													// 常规文件标志.见参见include/const.h文件.
   14d1b:	81 4c 24 38 00 80 00 	orl    $0x8000,0x38(%esp)
   14d22:	00 
	// 然后根据指定的路径名寻找到对应的i节点,以及最顶端目录名及其长度.此时如果最顶端目录名长度为0(例如'/usr/'这种路径名的情况),那么
	// 若操作不是读写,创建和文件长度截0,则表示是在打开一个目录名文件操作.于是直接返回该目录的i节点并返回0退出.否则说明进程操作非法,于是
	// 放回该i节点,返回出错码.
	if (!(dir = dir_namei(pathname, &namelen, &basename, NULL)))
   14d23:	6a 00                	push   $0x0
   14d25:	8d 44 24 10          	lea    0x10(%esp),%eax
   14d29:	50                   	push   %eax
   14d2a:	8d 44 24 10          	lea    0x10(%esp),%eax
   14d2e:	50                   	push   %eax
   14d2f:	ff 74 24 3c          	pushl  0x3c(%esp)
   14d33:	e8 62 fd ff ff       	call   14a9a <dir_namei>
   14d38:	83 c4 10             	add    $0x10,%esp
   14d3b:	89 44 24 04          	mov    %eax,0x4(%esp)
   14d3f:	8b 44 24 04          	mov    0x4(%esp),%eax
   14d43:	85 c0                	test   %eax,%eax
   14d45:	75 0a                	jne    14d51 <open_namei+0x80>
		return -ENOENT;
   14d47:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   14d4c:	e9 14 03 00 00       	jmp    15065 <open_namei+0x394>
	// 文件名字为空，则返回
	if (!namelen) {														/* special case: '/usr/' etc */
   14d51:	8b 44 24 08          	mov    0x8(%esp),%eax
   14d55:	85 c0                	test   %eax,%eax
   14d57:	75 3b                	jne    14d94 <open_namei+0xc3>
		if (!(flag & (O_ACCMODE | O_CREAT | O_TRUNC))) {
   14d59:	8b 44 24 34          	mov    0x34(%esp),%eax
   14d5d:	25 43 02 00 00       	and    $0x243,%eax
   14d62:	85 c0                	test   %eax,%eax
   14d64:	75 14                	jne    14d7a <open_namei+0xa9>
			*res_inode = dir;
   14d66:	8b 54 24 04          	mov    0x4(%esp),%edx
   14d6a:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   14d6e:	89 10                	mov    %edx,(%eax)
			return 0;
   14d70:	b8 00 00 00 00       	mov    $0x0,%eax
   14d75:	e9 eb 02 00 00       	jmp    15065 <open_namei+0x394>
		}
		iput(dir);
   14d7a:	8b 44 24 04          	mov    0x4(%esp),%eax
   14d7e:	83 ec 0c             	sub    $0xc,%esp
   14d81:	50                   	push   %eax
   14d82:	e8 1b ab ff ff       	call   f8a2 <iput>
   14d87:	83 c4 10             	add    $0x10,%esp
		return -EISDIR;
   14d8a:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
   14d8f:	e9 d1 02 00 00       	jmp    15065 <open_namei+0x394>
	}
	// 接着根据上面得到的最顶层目录名的i节点dir,在其中查找取得路径名字符串中最后的文件名对应的目录项结构de,并同时得到该目录项所在的高速缓冲
	// 区指针.如果该高速缓冲指针为NULL,则表示没有找到对应文件名的目录项,因此只可能是创建文件操作.此时如果不是创建文件,则放回该目录的i节点,返回
	// 出错号退出.如果用户在该目录没有写的权力,则放回该目录的i节点,返回出错号退出.
	bh = find_entry(&dir, basename, namelen, &de);
   14d94:	8b 54 24 08          	mov    0x8(%esp),%edx
   14d98:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14d9c:	89 e1                	mov    %esp,%ecx
   14d9e:	51                   	push   %ecx
   14d9f:	52                   	push   %edx
   14da0:	50                   	push   %eax
   14da1:	8d 44 24 10          	lea    0x10(%esp),%eax
   14da5:	50                   	push   %eax
   14da6:	e8 22 f5 ff ff       	call   142cd <find_entry>
   14dab:	83 c4 10             	add    $0x10,%esp
   14dae:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   14db2:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   14db7:	0f 85 66 01 00 00    	jne    14f23 <open_namei+0x252>
		if (!(flag & O_CREAT)) {                						// 不是创建文件，放回i节点
   14dbd:	8b 44 24 34          	mov    0x34(%esp),%eax
   14dc1:	83 e0 40             	and    $0x40,%eax
   14dc4:	85 c0                	test   %eax,%eax
   14dc6:	75 1a                	jne    14de2 <open_namei+0x111>
			iput(dir);
   14dc8:	8b 44 24 04          	mov    0x4(%esp),%eax
   14dcc:	83 ec 0c             	sub    $0xc,%esp
   14dcf:	50                   	push   %eax
   14dd0:	e8 cd aa ff ff       	call   f8a2 <iput>
   14dd5:	83 c4 10             	add    $0x10,%esp
			return -ENOENT;
   14dd8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   14ddd:	e9 83 02 00 00       	jmp    15065 <open_namei+0x394>
		}
		if (!permission(dir, MAY_WRITE)) {       						// 没有写权限，放回i节点
   14de2:	8b 44 24 04          	mov    0x4(%esp),%eax
   14de6:	83 ec 08             	sub    $0x8,%esp
   14de9:	6a 02                	push   $0x2
   14deb:	50                   	push   %eax
   14dec:	e8 8b f3 ff ff       	call   1417c <permission>
   14df1:	83 c4 10             	add    $0x10,%esp
   14df4:	85 c0                	test   %eax,%eax
   14df6:	75 1a                	jne    14e12 <open_namei+0x141>
			iput(dir);
   14df8:	8b 44 24 04          	mov    0x4(%esp),%eax
   14dfc:	83 ec 0c             	sub    $0xc,%esp
   14dff:	50                   	push   %eax
   14e00:	e8 9d aa ff ff       	call   f8a2 <iput>
   14e05:	83 c4 10             	add    $0x10,%esp
			return -EACCES;
   14e08:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   14e0d:	e9 53 02 00 00       	jmp    15065 <open_namei+0x394>
		}
		// 现在我们确定了是创建操作并且有写操作许可。因此我们就在目录i节点对应设备上申请一个新的i节点给路径名上指定的文件使用。
		// 若失败则放回目录的i节点，并返回没有空间出错码。否则使用该新i节点，对其进行初始设置：置节点的用户id；对应节点访问模式；
		// 置已修改标志。然后并在指定目录dir中添加一个新目录项。
		inode = new_inode(dir->i_dev);
   14e12:	8b 44 24 04          	mov    0x4(%esp),%eax
   14e16:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   14e1a:	0f b7 c0             	movzwl %ax,%eax
   14e1d:	83 ec 0c             	sub    $0xc,%esp
   14e20:	50                   	push   %eax
   14e21:	e8 21 1c 00 00       	call   16a47 <new_inode>
   14e26:	83 c4 10             	add    $0x10,%esp
   14e29:	89 44 24 10          	mov    %eax,0x10(%esp)
		if (!inode) {
   14e2d:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   14e32:	75 1a                	jne    14e4e <open_namei+0x17d>
			iput(dir);
   14e34:	8b 44 24 04          	mov    0x4(%esp),%eax
   14e38:	83 ec 0c             	sub    $0xc,%esp
   14e3b:	50                   	push   %eax
   14e3c:	e8 61 aa ff ff       	call   f8a2 <iput>
   14e41:	83 c4 10             	add    $0x10,%esp
			return -ENOSPC;
   14e44:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   14e49:	e9 17 02 00 00       	jmp    15065 <open_namei+0x394>
		}
		inode->i_uid = current->euid;
   14e4e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   14e54:	8b 00                	mov    (%eax),%eax
   14e56:	0f b7 90 ce 02 00 00 	movzwl 0x2ce(%eax),%edx
   14e5d:	8b 44 24 10          	mov    0x10(%esp),%eax
   14e61:	66 89 50 02          	mov    %dx,0x2(%eax)
		inode->i_mode = mode;
   14e65:	8b 44 24 38          	mov    0x38(%esp),%eax
   14e69:	89 c2                	mov    %eax,%edx
   14e6b:	8b 44 24 10          	mov    0x10(%esp),%eax
   14e6f:	66 89 10             	mov    %dx,(%eax)
		inode->i_dirt = 1;
   14e72:	8b 44 24 10          	mov    0x10(%esp),%eax
   14e76:	c6 40 37 01          	movb   $0x1,0x37(%eax)
		bh = add_entry(dir, basename, namelen, &de);
   14e7a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   14e7e:	8b 54 24 0c          	mov    0xc(%esp),%edx
   14e82:	8b 44 24 04          	mov    0x4(%esp),%eax
   14e86:	89 e6                	mov    %esp,%esi
   14e88:	56                   	push   %esi
   14e89:	51                   	push   %ecx
   14e8a:	52                   	push   %edx
   14e8b:	50                   	push   %eax
   14e8c:	e8 8a f6 ff ff       	call   1451b <add_entry>
   14e91:	83 c4 10             	add    $0x10,%esp
   14e94:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		// 如果返回的应该含有新目录项的调整缓冲区指针为NULL，则表示添加目录项操作失败。于是将该新i节点的引用连接计数减1,放回该
		// i节点与目录的i节点并返回出错码退出。否则说明添加目录项操作成功。于是我们来设置该新目录项的一些初始值：置i节点号为新申
		// 请到的i节点的号码；并置高速缓冲区修改标志。然后释放该高速缓冲区，放回目录的i节点。返回新目录项的i节点指针，并成功退出。
		if (!bh) {
   14e98:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   14e9d:	75 3b                	jne    14eda <open_namei+0x209>
			inode->i_nlinks--;
   14e9f:	8b 44 24 10          	mov    0x10(%esp),%eax
   14ea3:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   14ea7:	8d 50 ff             	lea    -0x1(%eax),%edx
   14eaa:	8b 44 24 10          	mov    0x10(%esp),%eax
   14eae:	88 50 0d             	mov    %dl,0xd(%eax)
			iput(inode);
   14eb1:	83 ec 0c             	sub    $0xc,%esp
   14eb4:	ff 74 24 1c          	pushl  0x1c(%esp)
   14eb8:	e8 e5 a9 ff ff       	call   f8a2 <iput>
   14ebd:	83 c4 10             	add    $0x10,%esp
			iput(dir);
   14ec0:	8b 44 24 04          	mov    0x4(%esp),%eax
   14ec4:	83 ec 0c             	sub    $0xc,%esp
   14ec7:	50                   	push   %eax
   14ec8:	e8 d5 a9 ff ff       	call   f8a2 <iput>
   14ecd:	83 c4 10             	add    $0x10,%esp
			return -ENOSPC;
   14ed0:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   14ed5:	e9 8b 01 00 00       	jmp    15065 <open_namei+0x394>
		}
		de->inode = inode->i_num;
   14eda:	8b 04 24             	mov    (%esp),%eax
   14edd:	8b 54 24 10          	mov    0x10(%esp),%edx
   14ee1:	0f b7 52 32          	movzwl 0x32(%edx),%edx
   14ee5:	66 89 10             	mov    %dx,(%eax)
		bh->b_dirt = 1;
   14ee8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   14eec:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
   14ef0:	83 ec 0c             	sub    $0xc,%esp
   14ef3:	ff 74 24 28          	pushl  0x28(%esp)
   14ef7:	e8 6f ba ff ff       	call   1096b <brelse>
   14efc:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   14eff:	8b 44 24 04          	mov    0x4(%esp),%eax
   14f03:	83 ec 0c             	sub    $0xc,%esp
   14f06:	50                   	push   %eax
   14f07:	e8 96 a9 ff ff       	call   f8a2 <iput>
   14f0c:	83 c4 10             	add    $0x10,%esp
		*res_inode = inode;
   14f0f:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   14f13:	8b 54 24 10          	mov    0x10(%esp),%edx
   14f17:	89 10                	mov    %edx,(%eax)
		return 0;
   14f19:	b8 00 00 00 00       	mov    $0x0,%eax
   14f1e:	e9 42 01 00 00       	jmp    15065 <open_namei+0x394>
    }
	// 若上面(411行)在目录中取文件名对应目录项结构的操作成功(即bh不为NULL),则说明指定打开的文件已经存在.于是取出该目录项的i节点和其所在设备号,并释放
	// 该高速缓冲区以及放回目录的i节点.如果此时独占操作标志O_EXCL置位,但现在文件已经存在,则返回文件已存在出错码退出.
	inr = de->inode;
   14f23:	8b 04 24             	mov    (%esp),%eax
   14f26:	0f b7 00             	movzwl (%eax),%eax
   14f29:	0f b7 c0             	movzwl %ax,%eax
   14f2c:	89 44 24 18          	mov    %eax,0x18(%esp)
	dev = dir->i_dev;
   14f30:	8b 44 24 04          	mov    0x4(%esp),%eax
   14f34:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   14f38:	0f b7 c0             	movzwl %ax,%eax
   14f3b:	89 44 24 14          	mov    %eax,0x14(%esp)
	brelse(bh);
   14f3f:	83 ec 0c             	sub    $0xc,%esp
   14f42:	ff 74 24 28          	pushl  0x28(%esp)
   14f46:	e8 20 ba ff ff       	call   1096b <brelse>
   14f4b:	83 c4 10             	add    $0x10,%esp
	if (flag & O_EXCL) {
   14f4e:	8b 44 24 34          	mov    0x34(%esp),%eax
   14f52:	25 80 00 00 00       	and    $0x80,%eax
   14f57:	85 c0                	test   %eax,%eax
   14f59:	74 1a                	je     14f75 <open_namei+0x2a4>
		iput(dir);
   14f5b:	8b 44 24 04          	mov    0x4(%esp),%eax
   14f5f:	83 ec 0c             	sub    $0xc,%esp
   14f62:	50                   	push   %eax
   14f63:	e8 3a a9 ff ff       	call   f8a2 <iput>
   14f68:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   14f6b:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   14f70:	e9 f0 00 00 00       	jmp    15065 <open_namei+0x394>
	}
	// 然后我们读取该目录项的i节点内容.若该i节点是一个目录的i节点并且访问模式是只写或读写,或者没有访问的许可权限,则放回该i节点,返回访问权限出错码退出.
	if (!(inode = follow_link(dir, iget(dev, inr))))
   14f75:	83 ec 08             	sub    $0x8,%esp
   14f78:	ff 74 24 20          	pushl  0x20(%esp)
   14f7c:	ff 74 24 20          	pushl  0x20(%esp)
   14f80:	e8 e1 ac ff ff       	call   fc66 <iget>
   14f85:	83 c4 10             	add    $0x10,%esp
   14f88:	89 c2                	mov    %eax,%edx
   14f8a:	8b 44 24 04          	mov    0x4(%esp),%eax
   14f8e:	83 ec 08             	sub    $0x8,%esp
   14f91:	52                   	push   %edx
   14f92:	50                   	push   %eax
   14f93:	e8 ce f7 ff ff       	call   14766 <follow_link>
   14f98:	83 c4 10             	add    $0x10,%esp
   14f9b:	89 44 24 10          	mov    %eax,0x10(%esp)
   14f9f:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   14fa4:	75 0a                	jne    14fb0 <open_namei+0x2df>
		return -EACCES;
   14fa6:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   14fab:	e9 b5 00 00 00       	jmp    15065 <open_namei+0x394>
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
   14fb0:	8b 44 24 10          	mov    0x10(%esp),%eax
   14fb4:	0f b7 00             	movzwl (%eax),%eax
   14fb7:	0f b7 c0             	movzwl %ax,%eax
   14fba:	25 00 f0 00 00       	and    $0xf000,%eax
   14fbf:	3d 00 40 00 00       	cmp    $0x4000,%eax
   14fc4:	75 0b                	jne    14fd1 <open_namei+0x300>
   14fc6:	8b 44 24 34          	mov    0x34(%esp),%eax
   14fca:	83 e0 03             	and    $0x3,%eax
   14fcd:	85 c0                	test   %eax,%eax
   14fcf:	75 26                	jne    14ff7 <open_namei+0x326>
	    !permission(inode, ACC_MODE(flag))) {
   14fd1:	8b 44 24 34          	mov    0x34(%esp),%eax
   14fd5:	83 e0 03             	and    $0x3,%eax
   14fd8:	0f b6 84 03 e0 51 ff 	movzbl -0xae20(%ebx,%eax,1),%eax
   14fdf:	ff 
   14fe0:	0f be c0             	movsbl %al,%eax
   14fe3:	83 ec 08             	sub    $0x8,%esp
   14fe6:	50                   	push   %eax
   14fe7:	ff 74 24 1c          	pushl  0x1c(%esp)
   14feb:	e8 8c f1 ff ff       	call   1417c <permission>
   14ff0:	83 c4 10             	add    $0x10,%esp
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
   14ff3:	85 c0                	test   %eax,%eax
   14ff5:	75 16                	jne    1500d <open_namei+0x33c>
		iput(inode);
   14ff7:	83 ec 0c             	sub    $0xc,%esp
   14ffa:	ff 74 24 1c          	pushl  0x1c(%esp)
   14ffe:	e8 9f a8 ff ff       	call   f8a2 <iput>
   15003:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15006:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1500b:	eb 58                	jmp    15065 <open_namei+0x394>
	}
	// 接着我们更新该i节点的访问时间字段值为当前时间.如果设立了截0标志,则将该i节点的文件长度截为0.最后返回该目录项i节点的指针.并返回0(成功).
	inode->i_atime = CURRENT_TIME;
   1500d:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   15013:	8b 10                	mov    (%eax),%edx
   15015:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   1501b:	8b 00                	mov    (%eax),%eax
   1501d:	01 d0                	add    %edx,%eax
   1501f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   15024:	f7 e2                	mul    %edx
   15026:	c1 ea 05             	shr    $0x5,%edx
   15029:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   1502f:	8b 00                	mov    (%eax),%eax
   15031:	01 c2                	add    %eax,%edx
   15033:	8b 44 24 10          	mov    0x10(%esp),%eax
   15037:	89 50 28             	mov    %edx,0x28(%eax)
	if (flag & O_TRUNC)
   1503a:	8b 44 24 34          	mov    0x34(%esp),%eax
   1503e:	25 00 02 00 00       	and    $0x200,%eax
   15043:	85 c0                	test   %eax,%eax
   15045:	74 0f                	je     15056 <open_namei+0x385>
		truncate(inode);
   15047:	83 ec 0c             	sub    $0xc,%esp
   1504a:	ff 74 24 1c          	pushl  0x1c(%esp)
   1504e:	e8 98 21 00 00       	call   171eb <truncate>
   15053:	83 c4 10             	add    $0x10,%esp
	*res_inode = inode;
   15056:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   1505a:	8b 54 24 10          	mov    0x10(%esp),%edx
   1505e:	89 10                	mov    %edx,(%eax)
	return 0;
   15060:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15065:	83 c4 24             	add    $0x24,%esp
   15068:	5b                   	pop    %ebx
   15069:	5e                   	pop    %esi
   1506a:	c3                   	ret    

0001506b <sys_mknod>:

// 创建一个设备特殊文件或普通文件节点（node）。
// 该函数创建名称为filename，由mode和dev指定的文件系统节点（普通文件、设备特殊文件或命名管道）。
// 参数：filename - 路径名；mode - 指定使用许可以及所创建节点的类型；dev - 设备号。
int sys_mknod(const char * filename, int mode, int dev)
{
   1506b:	56                   	push   %esi
   1506c:	53                   	push   %ebx
   1506d:	83 ec 24             	sub    $0x24,%esp
   15070:	e8 85 1c ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   15075:	81 c3 8b cf 01 00    	add    $0x1cf8b,%ebx
	struct buffer_head * bh;
	struct dir_entry * de;

	// 首先检查操作许可和参数的有效性并取路径名中顶层目录的i节点。如果不是超级用户，则返回访问许可出错码。
	// 如果不是超级用户，则返回访问许可出错码。
	if (!suser())
   1507b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   15081:	8b 00                	mov    (%eax),%eax
   15083:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
   1508a:	66 85 c0             	test   %ax,%ax
   1508d:	74 0a                	je     15099 <sys_mknod+0x2e>
		return -EPERM;
   1508f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15094:	e9 29 02 00 00       	jmp    152c2 <sys_mknod+0x257>
	// 如果找不到对应路径名中顶层目录的i节点，则返回出错码。
	if (!(dir = dir_namei(filename, &namelen, &basename, NULL)))
   15099:	6a 00                	push   $0x0
   1509b:	8d 44 24 18          	lea    0x18(%esp),%eax
   1509f:	50                   	push   %eax
   150a0:	8d 44 24 18          	lea    0x18(%esp),%eax
   150a4:	50                   	push   %eax
   150a5:	ff 74 24 3c          	pushl  0x3c(%esp)
   150a9:	e8 ec f9 ff ff       	call   14a9a <dir_namei>
   150ae:	83 c4 10             	add    $0x10,%esp
   150b1:	89 44 24 0c          	mov    %eax,0xc(%esp)
   150b5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   150b9:	85 c0                	test   %eax,%eax
   150bb:	75 0a                	jne    150c7 <sys_mknod+0x5c>
		return -ENOENT;
   150bd:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   150c2:	e9 fb 01 00 00       	jmp    152c2 <sys_mknod+0x257>
	// 如果最顶端的文件名长度为0，则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。
	if (!namelen) {
   150c7:	8b 44 24 10          	mov    0x10(%esp),%eax
   150cb:	85 c0                	test   %eax,%eax
   150cd:	75 1a                	jne    150e9 <sys_mknod+0x7e>
		iput(dir);
   150cf:	8b 44 24 0c          	mov    0xc(%esp),%eax
   150d3:	83 ec 0c             	sub    $0xc,%esp
   150d6:	50                   	push   %eax
   150d7:	e8 c6 a7 ff ff       	call   f8a2 <iput>
   150dc:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   150df:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   150e4:	e9 d9 01 00 00       	jmp    152c2 <sys_mknod+0x257>
	}
	// 如果在该目录中没有写的权限，则放回该目录的i节点，返回访问许可出错码退出。
	if (!permission(dir, MAY_WRITE)) {
   150e9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   150ed:	83 ec 08             	sub    $0x8,%esp
   150f0:	6a 02                	push   $0x2
   150f2:	50                   	push   %eax
   150f3:	e8 84 f0 ff ff       	call   1417c <permission>
   150f8:	83 c4 10             	add    $0x10,%esp
   150fb:	85 c0                	test   %eax,%eax
   150fd:	75 1a                	jne    15119 <sys_mknod+0xae>
		iput(dir);
   150ff:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15103:	83 ec 0c             	sub    $0xc,%esp
   15106:	50                   	push   %eax
   15107:	e8 96 a7 ff ff       	call   f8a2 <iput>
   1510c:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   1510f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15114:	e9 a9 01 00 00       	jmp    152c2 <sys_mknod+0x257>
	}
	// 然后我们搜索一下路径名指定的文件是否已经存在。若已经存在则不能创建同名文件节点。如果对应路径名上最后的文件名的
	// 目录项已经存在，则释放包含该目录项的缓冲区块并放回目录的i节点，返回文件已经存在的出错退出。
	bh = find_entry(&dir, basename, namelen, &de);
   15119:	8b 54 24 10          	mov    0x10(%esp),%edx
   1511d:	8b 44 24 14          	mov    0x14(%esp),%eax
   15121:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   15125:	51                   	push   %ecx
   15126:	52                   	push   %edx
   15127:	50                   	push   %eax
   15128:	8d 44 24 18          	lea    0x18(%esp),%eax
   1512c:	50                   	push   %eax
   1512d:	e8 9b f1 ff ff       	call   142cd <find_entry>
   15132:	83 c4 10             	add    $0x10,%esp
   15135:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (bh) {
   15139:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   1513e:	74 29                	je     15169 <sys_mknod+0xfe>
		brelse(bh);
   15140:	83 ec 0c             	sub    $0xc,%esp
   15143:	ff 74 24 28          	pushl  0x28(%esp)
   15147:	e8 1f b8 ff ff       	call   1096b <brelse>
   1514c:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   1514f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15153:	83 ec 0c             	sub    $0xc,%esp
   15156:	50                   	push   %eax
   15157:	e8 46 a7 ff ff       	call   f8a2 <iput>
   1515c:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   1515f:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   15164:	e9 59 01 00 00       	jmp    152c2 <sys_mknod+0x257>
	}
	// 否则我们就申请一个新的i节点，并设置该i节点的属性模式。
	inode = new_inode(dir->i_dev);
   15169:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1516d:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   15171:	0f b7 c0             	movzwl %ax,%eax
   15174:	83 ec 0c             	sub    $0xc,%esp
   15177:	50                   	push   %eax
   15178:	e8 ca 18 00 00       	call   16a47 <new_inode>
   1517d:	83 c4 10             	add    $0x10,%esp
   15180:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!inode) {
   15184:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   15189:	75 1a                	jne    151a5 <sys_mknod+0x13a>
		iput(dir);
   1518b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1518f:	83 ec 0c             	sub    $0xc,%esp
   15192:	50                   	push   %eax
   15193:	e8 0a a7 ff ff       	call   f8a2 <iput>
   15198:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   1519b:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   151a0:	e9 1d 01 00 00       	jmp    152c2 <sys_mknod+0x257>
	}
	inode->i_mode = mode;
   151a5:	8b 44 24 34          	mov    0x34(%esp),%eax
   151a9:	89 c2                	mov    %eax,%edx
   151ab:	8b 44 24 18          	mov    0x18(%esp),%eax
   151af:	66 89 10             	mov    %dx,(%eax)
	// 如果要创建的是块设备文件或者是字符设备文件，则令i节点的直接逻辑块指针0等于设备号。即对于设备文件来说，
	// 其i节点的i_zone[0]中存放的是该设备文件所定义设备的设备号。
	if (S_ISBLK(mode) || S_ISCHR(mode))
   151b2:	8b 44 24 34          	mov    0x34(%esp),%eax
   151b6:	25 00 f0 00 00       	and    $0xf000,%eax
   151bb:	3d 00 60 00 00       	cmp    $0x6000,%eax
   151c0:	74 10                	je     151d2 <sys_mknod+0x167>
   151c2:	8b 44 24 34          	mov    0x34(%esp),%eax
   151c6:	25 00 f0 00 00       	and    $0xf000,%eax
   151cb:	3d 00 20 00 00       	cmp    $0x2000,%eax
   151d0:	75 0e                	jne    151e0 <sys_mknod+0x175>
		inode->i_zone[0] = dev;
   151d2:	8b 44 24 38          	mov    0x38(%esp),%eax
   151d6:	89 c2                	mov    %eax,%edx
   151d8:	8b 44 24 18          	mov    0x18(%esp),%eax
   151dc:	66 89 50 0e          	mov    %dx,0xe(%eax)
	// 设置该i节点的修改时间、访问时间为当前时间，并设置i节点已修改标志。
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
   151e0:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   151e6:	8b 10                	mov    (%eax),%edx
   151e8:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   151ee:	8b 00                	mov    (%eax),%eax
   151f0:	01 d0                	add    %edx,%eax
   151f2:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   151f7:	f7 e2                	mul    %edx
   151f9:	c1 ea 05             	shr    $0x5,%edx
   151fc:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   15202:	8b 00                	mov    (%eax),%eax
   15204:	01 c2                	add    %eax,%edx
   15206:	8b 44 24 18          	mov    0x18(%esp),%eax
   1520a:	89 50 28             	mov    %edx,0x28(%eax)
   1520d:	8b 44 24 18          	mov    0x18(%esp),%eax
   15211:	8b 50 28             	mov    0x28(%eax),%edx
   15214:	8b 44 24 18          	mov    0x18(%esp),%eax
   15218:	89 50 08             	mov    %edx,0x8(%eax)
	inode->i_dirt = 1;
   1521b:	8b 44 24 18          	mov    0x18(%esp),%eax
   1521f:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	// 接着为这个新的i节点在目录中新添加一个目录项。如果失败（包含该目录项的高速缓冲块指针为NULL），则放回目录的i节点；
	// 把所申请的i节点引用连接计数复位，并放回该i节点，返回出错码退出。
	bh = add_entry(dir, basename, namelen, &de);
   15223:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   15227:	8b 54 24 14          	mov    0x14(%esp),%edx
   1522b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1522f:	8d 74 24 08          	lea    0x8(%esp),%esi
   15233:	56                   	push   %esi
   15234:	51                   	push   %ecx
   15235:	52                   	push   %edx
   15236:	50                   	push   %eax
   15237:	e8 df f2 ff ff       	call   1451b <add_entry>
   1523c:	83 c4 10             	add    $0x10,%esp
   1523f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   15243:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   15248:	75 2e                	jne    15278 <sys_mknod+0x20d>
		iput(dir);
   1524a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1524e:	83 ec 0c             	sub    $0xc,%esp
   15251:	50                   	push   %eax
   15252:	e8 4b a6 ff ff       	call   f8a2 <iput>
   15257:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks = 0;
   1525a:	8b 44 24 18          	mov    0x18(%esp),%eax
   1525e:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		iput(inode);
   15262:	83 ec 0c             	sub    $0xc,%esp
   15265:	ff 74 24 24          	pushl  0x24(%esp)
   15269:	e8 34 a6 ff ff       	call   f8a2 <iput>
   1526e:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   15271:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   15276:	eb 4a                	jmp    152c2 <sys_mknod+0x257>
	}
	// 现在添加目录项操作也成功了，于是我们来设置这个目录项内容。令该目录项的i节点字段等于新i节点号，并置高速缓冲区已修
	// 改标志，放回目录和新的i节点，释放高速缓冲区，最后返回0（成功）。
	de->inode = inode->i_num;
   15278:	8b 44 24 08          	mov    0x8(%esp),%eax
   1527c:	8b 54 24 18          	mov    0x18(%esp),%edx
   15280:	0f b7 52 32          	movzwl 0x32(%edx),%edx
   15284:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
   15287:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1528b:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	iput(dir);
   1528f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15293:	83 ec 0c             	sub    $0xc,%esp
   15296:	50                   	push   %eax
   15297:	e8 06 a6 ff ff       	call   f8a2 <iput>
   1529c:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   1529f:	83 ec 0c             	sub    $0xc,%esp
   152a2:	ff 74 24 24          	pushl  0x24(%esp)
   152a6:	e8 f7 a5 ff ff       	call   f8a2 <iput>
   152ab:	83 c4 10             	add    $0x10,%esp
	brelse(bh);
   152ae:	83 ec 0c             	sub    $0xc,%esp
   152b1:	ff 74 24 28          	pushl  0x28(%esp)
   152b5:	e8 b1 b6 ff ff       	call   1096b <brelse>
   152ba:	83 c4 10             	add    $0x10,%esp
	return 0;
   152bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   152c2:	83 c4 24             	add    $0x24,%esp
   152c5:	5b                   	pop    %ebx
   152c6:	5e                   	pop    %esi
   152c7:	c3                   	ret    

000152c8 <sys_mkdir>:

// 创建一个目录。
// 参数：pathname - 路径名；mode - 目录使用的权限属性。
// 返回：成功则返回0,否则返回出错码。
int sys_mkdir(const char * pathname, int mode)
{
   152c8:	56                   	push   %esi
   152c9:	53                   	push   %ebx
   152ca:	83 ec 24             	sub    $0x24,%esp
   152cd:	e8 28 1a ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   152d2:	81 c3 2e cd 01 00    	add    $0x1cd2e,%ebx
	struct m_inode * dir, * inode;
	struct buffer_head * bh, *dir_block;
	struct dir_entry * de;

	// 首先检查参数的有效性并取路径名中顶层目录的i节点。如果找不到对应路径名中顶层目录的i节点，则返回出错码。
	if (!(dir = dir_namei(pathname,&namelen,&basename, NULL)))
   152d8:	6a 00                	push   $0x0
   152da:	8d 44 24 14          	lea    0x14(%esp),%eax
   152de:	50                   	push   %eax
   152df:	8d 44 24 14          	lea    0x14(%esp),%eax
   152e3:	50                   	push   %eax
   152e4:	ff 74 24 3c          	pushl  0x3c(%esp)
   152e8:	e8 ad f7 ff ff       	call   14a9a <dir_namei>
   152ed:	83 c4 10             	add    $0x10,%esp
   152f0:	89 44 24 08          	mov    %eax,0x8(%esp)
   152f4:	8b 44 24 08          	mov    0x8(%esp),%eax
   152f8:	85 c0                	test   %eax,%eax
   152fa:	75 0a                	jne    15306 <sys_mkdir+0x3e>
		return -ENOENT;
   152fc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   15301:	e9 72 03 00 00       	jmp    15678 <sys_mkdir+0x3b0>
	// 如果最顶端文件名长度为0,则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。
	if (!namelen) {
   15306:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1530a:	85 c0                	test   %eax,%eax
   1530c:	75 1a                	jne    15328 <sys_mkdir+0x60>
		iput(dir);
   1530e:	8b 44 24 08          	mov    0x8(%esp),%eax
   15312:	83 ec 0c             	sub    $0xc,%esp
   15315:	50                   	push   %eax
   15316:	e8 87 a5 ff ff       	call   f8a2 <iput>
   1531b:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   1531e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   15323:	e9 50 03 00 00       	jmp    15678 <sys_mkdir+0x3b0>
	}
	// 如果在该目录中没有写的权限，则放回该目录i节点，返回访问许可出错码退出。
	// 如果不是超级用户，则返回访问许可出错码。
	if (!permission(dir, MAY_WRITE)) {
   15328:	8b 44 24 08          	mov    0x8(%esp),%eax
   1532c:	83 ec 08             	sub    $0x8,%esp
   1532f:	6a 02                	push   $0x2
   15331:	50                   	push   %eax
   15332:	e8 45 ee ff ff       	call   1417c <permission>
   15337:	83 c4 10             	add    $0x10,%esp
   1533a:	85 c0                	test   %eax,%eax
   1533c:	75 1a                	jne    15358 <sys_mkdir+0x90>
		iput(dir);
   1533e:	8b 44 24 08          	mov    0x8(%esp),%eax
   15342:	83 ec 0c             	sub    $0xc,%esp
   15345:	50                   	push   %eax
   15346:	e8 57 a5 ff ff       	call   f8a2 <iput>
   1534b:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   1534e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15353:	e9 20 03 00 00       	jmp    15678 <sys_mkdir+0x3b0>
	}
	// 然后我们搜索一下路径名指定的目录名是否已经存在。若已经存在则不能创建同名目录节点。如果对应路径名上最后的目录名的目录
	// 项已经存在，则释放包含该目录项的缓冲区块并放回目录的i节点，返回文件已经存在 的出错码退出。否则我们就申请一个新的i节
	// 点，并设置该i节点的属性模式：置该新i节点对应的文件长度为32字节（2个目录项的大小）、置节点已修改标志，以及节点的修改
	// 时间和访问时间。2个目录项分别用于'.'和'..'目录。
	bh = find_entry(&dir, basename, namelen, &de);
   15358:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1535c:	8b 44 24 10          	mov    0x10(%esp),%eax
   15360:	8d 4c 24 04          	lea    0x4(%esp),%ecx
   15364:	51                   	push   %ecx
   15365:	52                   	push   %edx
   15366:	50                   	push   %eax
   15367:	8d 44 24 14          	lea    0x14(%esp),%eax
   1536b:	50                   	push   %eax
   1536c:	e8 5c ef ff ff       	call   142cd <find_entry>
   15371:	83 c4 10             	add    $0x10,%esp
   15374:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (bh) {
   15378:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   1537d:	74 29                	je     153a8 <sys_mkdir+0xe0>
		brelse(bh);
   1537f:	83 ec 0c             	sub    $0xc,%esp
   15382:	ff 74 24 28          	pushl  0x28(%esp)
   15386:	e8 e0 b5 ff ff       	call   1096b <brelse>
   1538b:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   1538e:	8b 44 24 08          	mov    0x8(%esp),%eax
   15392:	83 ec 0c             	sub    $0xc,%esp
   15395:	50                   	push   %eax
   15396:	e8 07 a5 ff ff       	call   f8a2 <iput>
   1539b:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   1539e:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   153a3:	e9 d0 02 00 00       	jmp    15678 <sys_mkdir+0x3b0>
	}
	inode = new_inode(dir->i_dev);
   153a8:	8b 44 24 08          	mov    0x8(%esp),%eax
   153ac:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   153b0:	0f b7 c0             	movzwl %ax,%eax
   153b3:	83 ec 0c             	sub    $0xc,%esp
   153b6:	50                   	push   %eax
   153b7:	e8 8b 16 00 00       	call   16a47 <new_inode>
   153bc:	83 c4 10             	add    $0x10,%esp
   153bf:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!inode) {           						// 若不成功则放回目录的i节点，返回无空间出错码。
   153c3:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   153c8:	75 1a                	jne    153e4 <sys_mkdir+0x11c>
		iput(dir);
   153ca:	8b 44 24 08          	mov    0x8(%esp),%eax
   153ce:	83 ec 0c             	sub    $0xc,%esp
   153d1:	50                   	push   %eax
   153d2:	e8 cb a4 ff ff       	call   f8a2 <iput>
   153d7:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   153da:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   153df:	e9 94 02 00 00       	jmp    15678 <sys_mkdir+0x3b0>
	}
	inode->i_size = 32;
   153e4:	8b 44 24 18          	mov    0x18(%esp),%eax
   153e8:	c7 40 04 20 00 00 00 	movl   $0x20,0x4(%eax)
	inode->i_dirt = 1;
   153ef:	8b 44 24 18          	mov    0x18(%esp),%eax
   153f3:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
   153f7:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   153fd:	8b 10                	mov    (%eax),%edx
   153ff:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   15405:	8b 00                	mov    (%eax),%eax
   15407:	01 d0                	add    %edx,%eax
   15409:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   1540e:	f7 e2                	mul    %edx
   15410:	c1 ea 05             	shr    $0x5,%edx
   15413:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   15419:	8b 00                	mov    (%eax),%eax
   1541b:	01 c2                	add    %eax,%edx
   1541d:	8b 44 24 18          	mov    0x18(%esp),%eax
   15421:	89 50 28             	mov    %edx,0x28(%eax)
   15424:	8b 44 24 18          	mov    0x18(%esp),%eax
   15428:	8b 50 28             	mov    0x28(%eax),%edx
   1542b:	8b 44 24 18          	mov    0x18(%esp),%eax
   1542f:	89 50 08             	mov    %edx,0x8(%eax)
	// 接着为该新i节点申请一用于保存目录项数据的磁盘块，并令i节点的第一个直接块指针等于该块号。如果申请失败则放回对应目录
	// 的i节点；复位新申请的i节点连接计数；放回该新的i节点，返回没有空间出错码退出。否则置该新的i节点已修改标志。
	if (!(inode->i_zone[0] = new_block(inode->i_dev))) {
   15432:	8b 44 24 18          	mov    0x18(%esp),%eax
   15436:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1543a:	0f b7 c0             	movzwl %ax,%eax
   1543d:	83 ec 0c             	sub    $0xc,%esp
   15440:	50                   	push   %eax
   15441:	e8 a0 12 00 00       	call   166e6 <new_block>
   15446:	83 c4 10             	add    $0x10,%esp
   15449:	89 c2                	mov    %eax,%edx
   1544b:	8b 44 24 18          	mov    0x18(%esp),%eax
   1544f:	66 89 50 0e          	mov    %dx,0xe(%eax)
   15453:	8b 44 24 18          	mov    0x18(%esp),%eax
   15457:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1545b:	66 85 c0             	test   %ax,%ax
   1545e:	75 3b                	jne    1549b <sys_mkdir+0x1d3>
		iput(dir);
   15460:	8b 44 24 08          	mov    0x8(%esp),%eax
   15464:	83 ec 0c             	sub    $0xc,%esp
   15467:	50                   	push   %eax
   15468:	e8 35 a4 ff ff       	call   f8a2 <iput>
   1546d:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   15470:	8b 44 24 18          	mov    0x18(%esp),%eax
   15474:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   15478:	8d 50 ff             	lea    -0x1(%eax),%edx
   1547b:	8b 44 24 18          	mov    0x18(%esp),%eax
   1547f:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   15482:	83 ec 0c             	sub    $0xc,%esp
   15485:	ff 74 24 24          	pushl  0x24(%esp)
   15489:	e8 14 a4 ff ff       	call   f8a2 <iput>
   1548e:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   15491:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   15496:	e9 dd 01 00 00       	jmp    15678 <sys_mkdir+0x3b0>
	}
	inode->i_dirt = 1;
   1549b:	8b 44 24 18          	mov    0x18(%esp),%eax
   1549f:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	// 从设备上读取新申请的磁盘块（目的是把对应块放到高速缓冲区中）。若出错，则放回对应目录的i节点；释放申请的磁盘块；复位新
	// 申请的i节点连接计数；放回该新的i节点，返回没有空间出错码退出。
	if (!(dir_block = bread(inode->i_dev, inode->i_zone[0]))) {
   154a3:	8b 44 24 18          	mov    0x18(%esp),%eax
   154a7:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   154ab:	0f b7 d0             	movzwl %ax,%edx
   154ae:	8b 44 24 18          	mov    0x18(%esp),%eax
   154b2:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   154b6:	0f b7 c0             	movzwl %ax,%eax
   154b9:	83 ec 08             	sub    $0x8,%esp
   154bc:	52                   	push   %edx
   154bd:	50                   	push   %eax
   154be:	e8 0f b5 ff ff       	call   109d2 <bread>
   154c3:	83 c4 10             	add    $0x10,%esp
   154c6:	89 44 24 14          	mov    %eax,0x14(%esp)
   154ca:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   154cf:	75 3b                	jne    1550c <sys_mkdir+0x244>
		iput(dir);
   154d1:	8b 44 24 08          	mov    0x8(%esp),%eax
   154d5:	83 ec 0c             	sub    $0xc,%esp
   154d8:	50                   	push   %eax
   154d9:	e8 c4 a3 ff ff       	call   f8a2 <iput>
   154de:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   154e1:	8b 44 24 18          	mov    0x18(%esp),%eax
   154e5:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   154e9:	8d 50 ff             	lea    -0x1(%eax),%edx
   154ec:	8b 44 24 18          	mov    0x18(%esp),%eax
   154f0:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   154f3:	83 ec 0c             	sub    $0xc,%esp
   154f6:	ff 74 24 24          	pushl  0x24(%esp)
   154fa:	e8 a3 a3 ff ff       	call   f8a2 <iput>
   154ff:	83 c4 10             	add    $0x10,%esp
		return -ERROR;
   15502:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
   15507:	e9 6c 01 00 00       	jmp    15678 <sys_mkdir+0x3b0>
	}
	// 然后我们在缓冲块中建立起所创建目录文件中的2个默认的新目录项（'.'和'..'）结构数据。首先令de指向存放目录项的数据块，然
	// 后置该目录项的i节点号字段等于新申请的i节点号，名字字段等于“.”。然后de指向下一个目录项结构，并在该结构中存放上级目录的
	// i节点号和名字“..”。然后设置该高速缓冲块已修改标志，并释放该缓冲区块。再初始化设置新i节点的模式字段，并置该i节点已修改
	// 标志。
	de = (struct dir_entry *) dir_block->b_data;
   1550c:	8b 44 24 14          	mov    0x14(%esp),%eax
   15510:	8b 00                	mov    (%eax),%eax
   15512:	89 44 24 04          	mov    %eax,0x4(%esp)
	de->inode = inode->i_num;         				// 设置'.'目录项。
   15516:	8b 44 24 04          	mov    0x4(%esp),%eax
   1551a:	8b 54 24 18          	mov    0x18(%esp),%edx
   1551e:	0f b7 52 32          	movzwl 0x32(%edx),%edx
   15522:	66 89 10             	mov    %dx,(%eax)
	strcpy(de->name, ".");
   15525:	8b 44 24 04          	mov    0x4(%esp),%eax
   15529:	8d 50 02             	lea    0x2(%eax),%edx
   1552c:	83 ec 08             	sub    $0x8,%esp
   1552f:	8d 83 e5 51 ff ff    	lea    -0xae1b(%ebx),%eax
   15535:	50                   	push   %eax
   15536:	52                   	push   %edx
   15537:	e8 e9 eb ff ff       	call   14125 <strcpy>
   1553c:	83 c4 10             	add    $0x10,%esp
	de++;
   1553f:	8b 44 24 04          	mov    0x4(%esp),%eax
   15543:	83 c0 10             	add    $0x10,%eax
   15546:	89 44 24 04          	mov    %eax,0x4(%esp)
	de->inode = dir->i_num;         				// 设置'..'目录项。
   1554a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1554e:	8b 44 24 04          	mov    0x4(%esp),%eax
   15552:	0f b7 52 32          	movzwl 0x32(%edx),%edx
   15556:	66 89 10             	mov    %dx,(%eax)
	strcpy(de->name, "..");
   15559:	8b 44 24 04          	mov    0x4(%esp),%eax
   1555d:	8d 50 02             	lea    0x2(%eax),%edx
   15560:	83 ec 08             	sub    $0x8,%esp
   15563:	8d 83 e7 51 ff ff    	lea    -0xae19(%ebx),%eax
   15569:	50                   	push   %eax
   1556a:	52                   	push   %edx
   1556b:	e8 b5 eb ff ff       	call   14125 <strcpy>
   15570:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks = 2;
   15573:	8b 44 24 18          	mov    0x18(%esp),%eax
   15577:	c6 40 0d 02          	movb   $0x2,0xd(%eax)
	dir_block->b_dirt = 1;
   1557b:	8b 44 24 14          	mov    0x14(%esp),%eax
   1557f:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(dir_block);
   15583:	83 ec 0c             	sub    $0xc,%esp
   15586:	ff 74 24 20          	pushl  0x20(%esp)
   1558a:	e8 dc b3 ff ff       	call   1096b <brelse>
   1558f:	83 c4 10             	add    $0x10,%esp
	inode->i_mode = I_DIRECTORY | (mode & 0777 & ~current->umask);
   15592:	8b 44 24 34          	mov    0x34(%esp),%eax
   15596:	66 25 ff 01          	and    $0x1ff,%ax
   1559a:	89 c2                	mov    %eax,%edx
   1559c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   155a2:	8b 00                	mov    (%eax),%eax
   155a4:	0f b7 80 30 03 00 00 	movzwl 0x330(%eax),%eax
   155ab:	f7 d0                	not    %eax
   155ad:	21 d0                	and    %edx,%eax
   155af:	80 cc 40             	or     $0x40,%ah
   155b2:	89 c2                	mov    %eax,%edx
   155b4:	8b 44 24 18          	mov    0x18(%esp),%eax
   155b8:	66 89 10             	mov    %dx,(%eax)
	inode->i_dirt = 1;
   155bb:	8b 44 24 18          	mov    0x18(%esp),%eax
   155bf:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	// 现在我们在指定目录中新添加一个目录项，用于存放新建目录的i节点和目录名。如果失败（包含该目录项的高速缓冲区指针为NULL），
	// 则放回目录的i节点；所申请的i节点引用连接计数复位，并放回该i节点。返回出错码退出。
	bh = add_entry(dir, basename, namelen, &de);
   155c3:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   155c7:	8b 54 24 10          	mov    0x10(%esp),%edx
   155cb:	8b 44 24 08          	mov    0x8(%esp),%eax
   155cf:	8d 74 24 04          	lea    0x4(%esp),%esi
   155d3:	56                   	push   %esi
   155d4:	51                   	push   %ecx
   155d5:	52                   	push   %edx
   155d6:	50                   	push   %eax
   155d7:	e8 3f ef ff ff       	call   1451b <add_entry>
   155dc:	83 c4 10             	add    $0x10,%esp
   155df:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   155e3:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   155e8:	75 2e                	jne    15618 <sys_mkdir+0x350>
		iput(dir);
   155ea:	8b 44 24 08          	mov    0x8(%esp),%eax
   155ee:	83 ec 0c             	sub    $0xc,%esp
   155f1:	50                   	push   %eax
   155f2:	e8 ab a2 ff ff       	call   f8a2 <iput>
   155f7:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks = 0;
   155fa:	8b 44 24 18          	mov    0x18(%esp),%eax
   155fe:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		iput(inode);
   15602:	83 ec 0c             	sub    $0xc,%esp
   15605:	ff 74 24 24          	pushl  0x24(%esp)
   15609:	e8 94 a2 ff ff       	call   f8a2 <iput>
   1560e:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   15611:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   15616:	eb 60                	jmp    15678 <sys_mkdir+0x3b0>
	}
	// 最后令该新目录项的i节点字段等于新i节点号，并置高速缓冲块已修改标志，放回目录和新的i节点，释放高速缓冲区，最后返回0（成功）。
	de->inode = inode->i_num;
   15618:	8b 44 24 04          	mov    0x4(%esp),%eax
   1561c:	8b 54 24 18          	mov    0x18(%esp),%edx
   15620:	0f b7 52 32          	movzwl 0x32(%edx),%edx
   15624:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
   15627:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1562b:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	dir->i_nlinks++;
   1562f:	8b 44 24 08          	mov    0x8(%esp),%eax
   15633:	0f b6 50 0d          	movzbl 0xd(%eax),%edx
   15637:	83 c2 01             	add    $0x1,%edx
   1563a:	88 50 0d             	mov    %dl,0xd(%eax)
	dir->i_dirt = 1;
   1563d:	8b 44 24 08          	mov    0x8(%esp),%eax
   15641:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	iput(dir);
   15645:	8b 44 24 08          	mov    0x8(%esp),%eax
   15649:	83 ec 0c             	sub    $0xc,%esp
   1564c:	50                   	push   %eax
   1564d:	e8 50 a2 ff ff       	call   f8a2 <iput>
   15652:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   15655:	83 ec 0c             	sub    $0xc,%esp
   15658:	ff 74 24 24          	pushl  0x24(%esp)
   1565c:	e8 41 a2 ff ff       	call   f8a2 <iput>
   15661:	83 c4 10             	add    $0x10,%esp
	brelse(bh);
   15664:	83 ec 0c             	sub    $0xc,%esp
   15667:	ff 74 24 28          	pushl  0x28(%esp)
   1566b:	e8 fb b2 ff ff       	call   1096b <brelse>
   15670:	83 c4 10             	add    $0x10,%esp
	return 0;
   15673:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15678:	83 c4 24             	add    $0x24,%esp
   1567b:	5b                   	pop    %ebx
   1567c:	5e                   	pop    %esi
   1567d:	c3                   	ret    

0001567e <empty_dir>:
 */
// 检查指定目录是否为空。
// 参数：inode - 指定目录的i节点指针。
// 返回：1 - 目录中是空的；0 - 不空。
static int empty_dir(struct m_inode * inode)
{
   1567e:	53                   	push   %ebx
   1567f:	83 ec 28             	sub    $0x28,%esp
   15682:	e8 73 16 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   15687:	81 c3 79 c9 01 00    	add    $0x1c979,%ebx
	struct dir_entry * de;

	// 首先计算指定目录中现有目录项个数并检查开始两个特定目录项中信息是否正确。一个目录中应该起码有2个目录项：即“.”和“..”。
	// 如果目录项个数少于2个或者该目录i节点的第1个直接块没有指向任何磁盘块号，或者该直接块读不出，则显示警告信息“设备dev上
	// 目录错”，返回0（失败）。
	len = inode->i_size / sizeof (struct dir_entry);        		// 目录中目录项个数。
   1568d:	8b 44 24 30          	mov    0x30(%esp),%eax
   15691:	8b 40 04             	mov    0x4(%eax),%eax
   15694:	c1 e8 04             	shr    $0x4,%eax
   15697:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (len < 2 || !inode->i_zone[0] ||
   1569b:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
   156a0:	7e 3b                	jle    156dd <empty_dir+0x5f>
   156a2:	8b 44 24 30          	mov    0x30(%esp),%eax
   156a6:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   156aa:	66 85 c0             	test   %ax,%ax
   156ad:	74 2e                	je     156dd <empty_dir+0x5f>
	    !(bh = bread(inode->i_dev, inode->i_zone[0]))) {
   156af:	8b 44 24 30          	mov    0x30(%esp),%eax
   156b3:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   156b7:	0f b7 d0             	movzwl %ax,%edx
   156ba:	8b 44 24 30          	mov    0x30(%esp),%eax
   156be:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   156c2:	0f b7 c0             	movzwl %ax,%eax
	if (len < 2 || !inode->i_zone[0] ||
   156c5:	83 ec 08             	sub    $0x8,%esp
   156c8:	52                   	push   %edx
   156c9:	50                   	push   %eax
   156ca:	e8 03 b3 ff ff       	call   109d2 <bread>
   156cf:	83 c4 10             	add    $0x10,%esp
   156d2:	89 44 24 18          	mov    %eax,0x18(%esp)
   156d6:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   156db:	75 28                	jne    15705 <empty_dir+0x87>
	    	printk("warning - bad directory on dev %04x\n", inode->i_dev);
   156dd:	8b 44 24 30          	mov    0x30(%esp),%eax
   156e1:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   156e5:	0f b7 c0             	movzwl %ax,%eax
   156e8:	83 ec 08             	sub    $0x8,%esp
   156eb:	50                   	push   %eax
   156ec:	8d 83 ec 51 ff ff    	lea    -0xae14(%ebx),%eax
   156f2:	50                   	push   %eax
   156f3:	e8 3a 3c ff ff       	call   9332 <printk>
   156f8:	83 c4 10             	add    $0x10,%esp
		return 0;
   156fb:	b8 00 00 00 00       	mov    $0x0,%eax
   15700:	e9 7a 01 00 00       	jmp    1587f <empty_dir+0x201>
	}
	// 此时bh所指缓冲块中含有目录项数据。我们让目录项指针de指向缓冲块中第1个目录项。对于第1个目录项（“.”），它的i节点号字段
	// inode应该等于当前目录的i节点号。对于第2个目录项（“..”），节点号字段inode应该等于上一层目录的i节点号，不会为0.因此，
	// 如果第1个目录项的i节点号字段值不等于该目录的i节点号，或者第2个目录项的i节点号字段为零，或者两个目录项的名字字段不分别
	// 等于“.”和“..”，则显示出错警告信息“设备dev上目录错”，并返回0。
	de = (struct dir_entry *) bh->b_data;
   15705:	8b 44 24 18          	mov    0x18(%esp),%eax
   15709:	8b 00                	mov    (%eax),%eax
   1570b:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (de[0].inode != inode->i_num || !de[1].inode ||
   1570f:	8b 44 24 14          	mov    0x14(%esp),%eax
   15713:	0f b7 10             	movzwl (%eax),%edx
   15716:	8b 44 24 30          	mov    0x30(%esp),%eax
   1571a:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   1571e:	66 39 c2             	cmp    %ax,%dx
   15721:	75 4e                	jne    15771 <empty_dir+0xf3>
   15723:	8b 44 24 14          	mov    0x14(%esp),%eax
   15727:	83 c0 10             	add    $0x10,%eax
   1572a:	0f b7 00             	movzwl (%eax),%eax
   1572d:	66 85 c0             	test   %ax,%ax
   15730:	74 3f                	je     15771 <empty_dir+0xf3>
	    strcmp(".", de[0].name) || strcmp("..", de[1].name)) {
   15732:	8b 44 24 14          	mov    0x14(%esp),%eax
   15736:	83 c0 02             	add    $0x2,%eax
   15739:	83 ec 08             	sub    $0x8,%esp
   1573c:	50                   	push   %eax
   1573d:	8d 83 e5 51 ff ff    	lea    -0xae1b(%ebx),%eax
   15743:	50                   	push   %eax
   15744:	e8 02 ea ff ff       	call   1414b <strcmp>
   15749:	83 c4 10             	add    $0x10,%esp
	if (de[0].inode != inode->i_num || !de[1].inode ||
   1574c:	85 c0                	test   %eax,%eax
   1574e:	75 21                	jne    15771 <empty_dir+0xf3>
	    strcmp(".", de[0].name) || strcmp("..", de[1].name)) {
   15750:	8b 44 24 14          	mov    0x14(%esp),%eax
   15754:	83 c0 10             	add    $0x10,%eax
   15757:	83 c0 02             	add    $0x2,%eax
   1575a:	83 ec 08             	sub    $0x8,%esp
   1575d:	50                   	push   %eax
   1575e:	8d 83 e7 51 ff ff    	lea    -0xae19(%ebx),%eax
   15764:	50                   	push   %eax
   15765:	e8 e1 e9 ff ff       	call   1414b <strcmp>
   1576a:	83 c4 10             	add    $0x10,%esp
   1576d:	85 c0                	test   %eax,%eax
   1576f:	74 28                	je     15799 <empty_dir+0x11b>
	    	printk("warning - bad directory on dev %04x\n", inode->i_dev);
   15771:	8b 44 24 30          	mov    0x30(%esp),%eax
   15775:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   15779:	0f b7 c0             	movzwl %ax,%eax
   1577c:	83 ec 08             	sub    $0x8,%esp
   1577f:	50                   	push   %eax
   15780:	8d 83 ec 51 ff ff    	lea    -0xae14(%ebx),%eax
   15786:	50                   	push   %eax
   15787:	e8 a6 3b ff ff       	call   9332 <printk>
   1578c:	83 c4 10             	add    $0x10,%esp
		return 0;
   1578f:	b8 00 00 00 00       	mov    $0x0,%eax
   15794:	e9 e6 00 00 00       	jmp    1587f <empty_dir+0x201>
	}
	// 然后我们令nr等于目录项序号（从0开始计）；de指向第三个目录项。并循环检测该目录中其余所有的（len - 2）个目录项，看有没有
	// 目录项的i节点号字段不为0（被使用）。
	nr = 2;
   15799:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
   157a0:	00 
	de += 2;
   157a1:	83 44 24 14 20       	addl   $0x20,0x14(%esp)
	while (nr < len) {
   157a6:	e9 b2 00 00 00       	jmp    1585d <empty_dir+0x1df>
		// 如果该块磁盘块中的目录项已经全部检测完毕，则释放该磁盘块的缓冲块，并读取目录数据文件中下一块含有目录项的磁盘块。读取的方
		// 法是根据当前检测的目录项序号nr计算出对应目录项在目录数据文件中的数据块号（nr/DIR_ENTRIES_PER_BLOCK），然后使用bmap()
		// 函数取得对应的盘块号block，再使用读设备块函数bread()把相应盘块读入缓冲块中，并返回该缓冲块的指针。若所读取的相应盘块没有
		// 使用（或已经不用，如文件已经删除等），则继续读下一块，若读不出，则出错返回0.否则让de指向读出块的第1个目录项。
		if ((void *) de >= (void *) (bh->b_data + BLOCK_SIZE)) {
   157ab:	8b 44 24 18          	mov    0x18(%esp),%eax
   157af:	8b 00                	mov    (%eax),%eax
   157b1:	05 00 04 00 00       	add    $0x400,%eax
   157b6:	39 44 24 14          	cmp    %eax,0x14(%esp)
   157ba:	72 75                	jb     15831 <empty_dir+0x1b3>
			brelse(bh);
   157bc:	83 ec 0c             	sub    $0xc,%esp
   157bf:	ff 74 24 24          	pushl  0x24(%esp)
   157c3:	e8 a3 b1 ff ff       	call   1096b <brelse>
   157c8:	83 c4 10             	add    $0x10,%esp
			block = bmap(inode, nr / DIR_ENTRIES_PER_BLOCK);
   157cb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   157cf:	c1 e8 06             	shr    $0x6,%eax
   157d2:	83 ec 08             	sub    $0x8,%esp
   157d5:	50                   	push   %eax
   157d6:	ff 74 24 3c          	pushl  0x3c(%esp)
   157da:	e8 77 a0 ff ff       	call   f856 <bmap>
   157df:	83 c4 10             	add    $0x10,%esp
   157e2:	89 44 24 0c          	mov    %eax,0xc(%esp)
			if (!block) {
   157e6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   157eb:	75 0d                	jne    157fa <empty_dir+0x17c>
				nr += DIR_ENTRIES_PER_BLOCK;
   157ed:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   157f1:	83 c0 40             	add    $0x40,%eax
   157f4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
				continue;
   157f8:	eb 63                	jmp    1585d <empty_dir+0x1df>
			}
			if (!(bh = bread(inode->i_dev, block)))
   157fa:	8b 44 24 30          	mov    0x30(%esp),%eax
   157fe:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   15802:	0f b7 c0             	movzwl %ax,%eax
   15805:	83 ec 08             	sub    $0x8,%esp
   15808:	ff 74 24 14          	pushl  0x14(%esp)
   1580c:	50                   	push   %eax
   1580d:	e8 c0 b1 ff ff       	call   109d2 <bread>
   15812:	83 c4 10             	add    $0x10,%esp
   15815:	89 44 24 18          	mov    %eax,0x18(%esp)
   15819:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1581e:	75 07                	jne    15827 <empty_dir+0x1a9>
				return 0;
   15820:	b8 00 00 00 00       	mov    $0x0,%eax
   15825:	eb 58                	jmp    1587f <empty_dir+0x201>
			de = (struct dir_entry *) bh->b_data;
   15827:	8b 44 24 18          	mov    0x18(%esp),%eax
   1582b:	8b 00                	mov    (%eax),%eax
   1582d:	89 44 24 14          	mov    %eax,0x14(%esp)
		}
		// 对于de指向的当前目录项，如果该目录项的i节点号字段不等于0,则表示该目录项目前正被使用，则释放该高速缓冲区，返回0退出。否则，
		// 若还没有查询完该目录中的所有目录项，则把目录项序号nr增1、de指向下一个目录项，继续检测。
		if (de->inode) {
   15831:	8b 44 24 14          	mov    0x14(%esp),%eax
   15835:	0f b7 00             	movzwl (%eax),%eax
   15838:	66 85 c0             	test   %ax,%ax
   1583b:	74 16                	je     15853 <empty_dir+0x1d5>
			brelse(bh);
   1583d:	83 ec 0c             	sub    $0xc,%esp
   15840:	ff 74 24 24          	pushl  0x24(%esp)
   15844:	e8 22 b1 ff ff       	call   1096b <brelse>
   15849:	83 c4 10             	add    $0x10,%esp
			return 0;
   1584c:	b8 00 00 00 00       	mov    $0x0,%eax
   15851:	eb 2c                	jmp    1587f <empty_dir+0x201>
		}
		de++;
   15853:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
		nr++;
   15858:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
	while (nr < len) {
   1585d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   15861:	3b 44 24 10          	cmp    0x10(%esp),%eax
   15865:	0f 8c 40 ff ff ff    	jl     157ab <empty_dir+0x12d>
	}
	// 执行到这里说明该目录中没有找到已用的目录项（当然除了头两个以外），则释放缓冲块返回1。
	brelse(bh);
   1586b:	83 ec 0c             	sub    $0xc,%esp
   1586e:	ff 74 24 24          	pushl  0x24(%esp)
   15872:	e8 f4 b0 ff ff       	call   1096b <brelse>
   15877:	83 c4 10             	add    $0x10,%esp
	return 1;
   1587a:	b8 01 00 00 00       	mov    $0x1,%eax
}
   1587f:	83 c4 28             	add    $0x28,%esp
   15882:	5b                   	pop    %ebx
   15883:	c3                   	ret    

00015884 <sys_rmdir>:

// 删除目录。
// 参数：name - 目录名（路径名）。
// 返回：返回0表示成功，否则返回出错号。
int sys_rmdir(const char * name)
{
   15884:	53                   	push   %ebx
   15885:	83 ec 28             	sub    $0x28,%esp
   15888:	e8 6d 14 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1588d:	81 c3 73 c7 01 00    	add    $0x1c773,%ebx
	struct dir_entry * de;

	// 首先检查参数的有效性并取路径名中顶层目录的i节点。如果找不到对应路径名中顶层目录的i节点，则返回出错码。如果最顶端
	// 文件名长度为0,则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。如果在该目录中没有写的权限，
	// 则放回该目录i节点，返回访问许可出错码退出。如果不是超级用户，则返回访问许可出错码。
	if (!(dir = dir_namei(name, &namelen, &basename, NULL)))
   15893:	6a 00                	push   $0x0
   15895:	8d 44 24 18          	lea    0x18(%esp),%eax
   15899:	50                   	push   %eax
   1589a:	8d 44 24 18          	lea    0x18(%esp),%eax
   1589e:	50                   	push   %eax
   1589f:	ff 74 24 3c          	pushl  0x3c(%esp)
   158a3:	e8 f2 f1 ff ff       	call   14a9a <dir_namei>
   158a8:	83 c4 10             	add    $0x10,%esp
   158ab:	89 44 24 0c          	mov    %eax,0xc(%esp)
   158af:	8b 44 24 0c          	mov    0xc(%esp),%eax
   158b3:	85 c0                	test   %eax,%eax
   158b5:	75 0a                	jne    158c1 <sys_rmdir+0x3d>
		return -ENOENT;
   158b7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   158bc:	e9 67 03 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	if (!namelen) {
   158c1:	8b 44 24 10          	mov    0x10(%esp),%eax
   158c5:	85 c0                	test   %eax,%eax
   158c7:	75 1a                	jne    158e3 <sys_rmdir+0x5f>
		iput(dir);
   158c9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   158cd:	83 ec 0c             	sub    $0xc,%esp
   158d0:	50                   	push   %eax
   158d1:	e8 cc 9f ff ff       	call   f8a2 <iput>
   158d6:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   158d9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   158de:	e9 45 03 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	if (!permission(dir,MAY_WRITE)) {
   158e3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   158e7:	83 ec 08             	sub    $0x8,%esp
   158ea:	6a 02                	push   $0x2
   158ec:	50                   	push   %eax
   158ed:	e8 8a e8 ff ff       	call   1417c <permission>
   158f2:	83 c4 10             	add    $0x10,%esp
   158f5:	85 c0                	test   %eax,%eax
   158f7:	75 1a                	jne    15913 <sys_rmdir+0x8f>
		iput(dir);
   158f9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   158fd:	83 ec 0c             	sub    $0xc,%esp
   15900:	50                   	push   %eax
   15901:	e8 9c 9f ff ff       	call   f8a2 <iput>
   15906:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15909:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1590e:	e9 15 03 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	// 然后根据指定目录的i节点和目录名利用函数find_entry()寻找对应目录项，并返回包含该目录项的缓冲块指针bh、包含该目录
	// 项的目录的i节点指针dir和该目录项指针de。再根据该目录项de中的i节点号利用iget()函数得到对应的i节点inode。如果对应
	// 路径名上最后目录的名的目录项不存在，则释放包含该目录项的高速缓冲区，放回目录的i节点，返回文件不存在出错码，并退出。
	// 如果取目录项的i节点出错，则放回目录的i节点，并释放含有目录项的高速缓冲区，返回出错号。
	bh = find_entry(&dir, basename, namelen, &de);
   15913:	8b 54 24 10          	mov    0x10(%esp),%edx
   15917:	8b 44 24 14          	mov    0x14(%esp),%eax
   1591b:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   1591f:	51                   	push   %ecx
   15920:	52                   	push   %edx
   15921:	50                   	push   %eax
   15922:	8d 44 24 18          	lea    0x18(%esp),%eax
   15926:	50                   	push   %eax
   15927:	e8 a1 e9 ff ff       	call   142cd <find_entry>
   1592c:	83 c4 10             	add    $0x10,%esp
   1592f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   15933:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   15938:	75 1a                	jne    15954 <sys_rmdir+0xd0>
		iput(dir);
   1593a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1593e:	83 ec 0c             	sub    $0xc,%esp
   15941:	50                   	push   %eax
   15942:	e8 5b 9f ff ff       	call   f8a2 <iput>
   15947:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   1594a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1594f:	e9 d4 02 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
   15954:	8b 44 24 08          	mov    0x8(%esp),%eax
   15958:	0f b7 00             	movzwl (%eax),%eax
   1595b:	0f b7 d0             	movzwl %ax,%edx
   1595e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15962:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   15966:	0f b7 c0             	movzwl %ax,%eax
   15969:	83 ec 08             	sub    $0x8,%esp
   1596c:	52                   	push   %edx
   1596d:	50                   	push   %eax
   1596e:	e8 f3 a2 ff ff       	call   fc66 <iget>
   15973:	83 c4 10             	add    $0x10,%esp
   15976:	89 44 24 18          	mov    %eax,0x18(%esp)
   1597a:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1597f:	75 29                	jne    159aa <sys_rmdir+0x126>
		iput(dir);
   15981:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15985:	83 ec 0c             	sub    $0xc,%esp
   15988:	50                   	push   %eax
   15989:	e8 14 9f ff ff       	call   f8a2 <iput>
   1598e:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15991:	83 ec 0c             	sub    $0xc,%esp
   15994:	ff 74 24 28          	pushl  0x28(%esp)
   15998:	e8 ce af ff ff       	call   1096b <brelse>
   1599d:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   159a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   159a5:	e9 7e 02 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	// 此时我们已有包含要被删除目录项的目录i节点dir、要被删除目录项的i节点inode和要被删除目录项指针de。下面我们通过对这3
	// 个对象中信息的检查来验证删除操作的可行性。
	// 若该目录设置了受限删除标志并且进程的有效用户id（euid）不是root，并且进程的有效用户id（euid）不等于该i节点的用户
	// id，则表示当前进程没有权限删除该目录，于是放回包含要删除目录名的目录i节点和该要删除目录的i节点，然后释放高速缓冲区，
	// 返回出错码。
	if ((dir->i_mode & S_ISVTX) && current->euid &&
   159aa:	8b 44 24 0c          	mov    0xc(%esp),%eax
   159ae:	0f b7 00             	movzwl (%eax),%eax
   159b1:	0f b7 c0             	movzwl %ax,%eax
   159b4:	25 00 02 00 00       	and    $0x200,%eax
   159b9:	85 c0                	test   %eax,%eax
   159bb:	74 68                	je     15a25 <sys_rmdir+0x1a1>
   159bd:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   159c3:	8b 00                	mov    (%eax),%eax
   159c5:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
   159cc:	66 85 c0             	test   %ax,%ax
   159cf:	74 54                	je     15a25 <sys_rmdir+0x1a1>
	    inode->i_uid != current->euid) {
   159d1:	8b 44 24 18          	mov    0x18(%esp),%eax
   159d5:	0f b7 50 02          	movzwl 0x2(%eax),%edx
   159d9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   159df:	8b 00                	mov    (%eax),%eax
   159e1:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
	if ((dir->i_mode & S_ISVTX) && current->euid &&
   159e8:	66 39 c2             	cmp    %ax,%dx
   159eb:	74 38                	je     15a25 <sys_rmdir+0x1a1>
		iput(dir);
   159ed:	8b 44 24 0c          	mov    0xc(%esp),%eax
   159f1:	83 ec 0c             	sub    $0xc,%esp
   159f4:	50                   	push   %eax
   159f5:	e8 a8 9e ff ff       	call   f8a2 <iput>
   159fa:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   159fd:	83 ec 0c             	sub    $0xc,%esp
   15a00:	ff 74 24 24          	pushl  0x24(%esp)
   15a04:	e8 99 9e ff ff       	call   f8a2 <iput>
   15a09:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15a0c:	83 ec 0c             	sub    $0xc,%esp
   15a0f:	ff 74 24 28          	pushl  0x28(%esp)
   15a13:	e8 53 af ff ff       	call   1096b <brelse>
   15a18:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15a1b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15a20:	e9 03 02 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	// 如果要被删除的目录项i节点的设备号不等于包含该目录项的目录的设备号，或者该被删除目录的引用连接计数大于1（表示有符号连
	// 接等），则不能删除该目录。于是释放包含要删除目录名的目录i节点和该要删除目录的i节点，释放高速缓冲块，返回出错码。
	if (inode->i_dev != dir->i_dev || inode->i_count > 1) {
   15a25:	8b 44 24 18          	mov    0x18(%esp),%eax
   15a29:	0f b7 50 30          	movzwl 0x30(%eax),%edx
   15a2d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15a31:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   15a35:	66 39 c2             	cmp    %ax,%dx
   15a38:	75 0e                	jne    15a48 <sys_rmdir+0x1c4>
   15a3a:	8b 44 24 18          	mov    0x18(%esp),%eax
   15a3e:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   15a42:	66 83 f8 01          	cmp    $0x1,%ax
   15a46:	76 38                	jbe    15a80 <sys_rmdir+0x1fc>
		iput(dir);
   15a48:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15a4c:	83 ec 0c             	sub    $0xc,%esp
   15a4f:	50                   	push   %eax
   15a50:	e8 4d 9e ff ff       	call   f8a2 <iput>
   15a55:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   15a58:	83 ec 0c             	sub    $0xc,%esp
   15a5b:	ff 74 24 24          	pushl  0x24(%esp)
   15a5f:	e8 3e 9e ff ff       	call   f8a2 <iput>
   15a64:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15a67:	83 ec 0c             	sub    $0xc,%esp
   15a6a:	ff 74 24 28          	pushl  0x28(%esp)
   15a6e:	e8 f8 ae ff ff       	call   1096b <brelse>
   15a73:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15a76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15a7b:	e9 a8 01 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	// 如果要被删除目录的目录项i节点就等于包含该需删除目录的目录i节点，则表示试图删除“.”目录，这是不允许的。于是放回包含要删
	// 除目录名的目录i节点和要删除目录的i节点，释放高速缓冲块，返回出错码。
	if (inode == dir) {						/* we may not delete ".", but "../dir" is ok */
   15a80:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15a84:	39 44 24 18          	cmp    %eax,0x18(%esp)
   15a88:	75 38                	jne    15ac2 <sys_rmdir+0x23e>
		iput(inode);
   15a8a:	83 ec 0c             	sub    $0xc,%esp
   15a8d:	ff 74 24 24          	pushl  0x24(%esp)
   15a91:	e8 0c 9e ff ff       	call   f8a2 <iput>
   15a96:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   15a99:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15a9d:	83 ec 0c             	sub    $0xc,%esp
   15aa0:	50                   	push   %eax
   15aa1:	e8 fc 9d ff ff       	call   f8a2 <iput>
   15aa6:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15aa9:	83 ec 0c             	sub    $0xc,%esp
   15aac:	ff 74 24 28          	pushl  0x28(%esp)
   15ab0:	e8 b6 ae ff ff       	call   1096b <brelse>
   15ab5:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15ab8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15abd:	e9 66 01 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	// 若要被删除目录i节点的属性表明这不是一个目录，则本删除操作的前提完全不存在。于是放回包含删除目录名的目录i节点和该要删除
	// 目录的i节点，释放高速缓冲块，返回出错码。
	if (!S_ISDIR(inode->i_mode)) {
   15ac2:	8b 44 24 18          	mov    0x18(%esp),%eax
   15ac6:	0f b7 00             	movzwl (%eax),%eax
   15ac9:	0f b7 c0             	movzwl %ax,%eax
   15acc:	25 00 f0 00 00       	and    $0xf000,%eax
   15ad1:	3d 00 40 00 00       	cmp    $0x4000,%eax
   15ad6:	74 38                	je     15b10 <sys_rmdir+0x28c>
		iput(inode);
   15ad8:	83 ec 0c             	sub    $0xc,%esp
   15adb:	ff 74 24 24          	pushl  0x24(%esp)
   15adf:	e8 be 9d ff ff       	call   f8a2 <iput>
   15ae4:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   15ae7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15aeb:	83 ec 0c             	sub    $0xc,%esp
   15aee:	50                   	push   %eax
   15aef:	e8 ae 9d ff ff       	call   f8a2 <iput>
   15af4:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15af7:	83 ec 0c             	sub    $0xc,%esp
   15afa:	ff 74 24 28          	pushl  0x28(%esp)
   15afe:	e8 68 ae ff ff       	call   1096b <brelse>
   15b03:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
   15b06:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
   15b0b:	e9 18 01 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	// 若该需要被删除的目录不空，则也不能删除。于是放回包含要删除目录名的目录i节点和该要删除目录的i节点，释放高速缓冲块，返回
	// 出错码。
	if (!empty_dir(inode)) {
   15b10:	83 ec 0c             	sub    $0xc,%esp
   15b13:	ff 74 24 24          	pushl  0x24(%esp)
   15b17:	e8 62 fb ff ff       	call   1567e <empty_dir>
   15b1c:	83 c4 10             	add    $0x10,%esp
   15b1f:	85 c0                	test   %eax,%eax
   15b21:	75 38                	jne    15b5b <sys_rmdir+0x2d7>
		iput(inode);
   15b23:	83 ec 0c             	sub    $0xc,%esp
   15b26:	ff 74 24 24          	pushl  0x24(%esp)
   15b2a:	e8 73 9d ff ff       	call   f8a2 <iput>
   15b2f:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   15b32:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15b36:	83 ec 0c             	sub    $0xc,%esp
   15b39:	50                   	push   %eax
   15b3a:	e8 63 9d ff ff       	call   f8a2 <iput>
   15b3f:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15b42:	83 ec 0c             	sub    $0xc,%esp
   15b45:	ff 74 24 28          	pushl  0x28(%esp)
   15b49:	e8 1d ae ff ff       	call   1096b <brelse>
   15b4e:	83 c4 10             	add    $0x10,%esp
		return -ENOTEMPTY;
   15b51:	b8 d9 ff ff ff       	mov    $0xffffffd9,%eax
   15b56:	e9 cd 00 00 00       	jmp    15c28 <sys_rmdir+0x3a4>
	}
	// 对于一个空目录，其目录项链接数应该为2（链接到上层目录和本目录）。若该需被删除目录的i节点的连接数不等于2,则显示警告信息，
	// 但删除操作仍然执行。于是置该需删除目录的目录项的i节点号字段为0,表示该目录项不再使用，并置含有该目录项的调整缓冲块已修改
	// 标志，并释放该缓冲块。然后再置被删除目录i节点的链接数为0（表示空闲），并置i节点已修改标志。
	if (inode->i_nlinks != 2)
   15b5b:	8b 44 24 18          	mov    0x18(%esp),%eax
   15b5f:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   15b63:	3c 02                	cmp    $0x2,%al
   15b65:	74 1e                	je     15b85 <sys_rmdir+0x301>
		printk("empty directory has nlink!=2 (%d)", inode->i_nlinks);
   15b67:	8b 44 24 18          	mov    0x18(%esp),%eax
   15b6b:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   15b6f:	0f b6 c0             	movzbl %al,%eax
   15b72:	83 ec 08             	sub    $0x8,%esp
   15b75:	50                   	push   %eax
   15b76:	8d 83 14 52 ff ff    	lea    -0xadec(%ebx),%eax
   15b7c:	50                   	push   %eax
   15b7d:	e8 b0 37 ff ff       	call   9332 <printk>
   15b82:	83 c4 10             	add    $0x10,%esp
	de->inode = 0;
   15b85:	8b 44 24 08          	mov    0x8(%esp),%eax
   15b89:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
   15b8e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   15b92:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   15b96:	83 ec 0c             	sub    $0xc,%esp
   15b99:	ff 74 24 28          	pushl  0x28(%esp)
   15b9d:	e8 c9 ad ff ff       	call   1096b <brelse>
   15ba2:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks = 0;
   15ba5:	8b 44 24 18          	mov    0x18(%esp),%eax
   15ba9:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	inode->i_dirt = 1;
   15bad:	8b 44 24 18          	mov    0x18(%esp),%eax
   15bb1:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	// 再将包含被删除目录名的目录的i节点链接计数减1,修改其改变时间和修改时间为当前时间，并置该节点已修改标志。最后放回包含要删除
	// 目录名的目录i节点和该要删除目录的i节点，返回0（删除操作成功）。
	dir->i_nlinks--;
   15bb5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15bb9:	0f b6 50 0d          	movzbl 0xd(%eax),%edx
   15bbd:	83 ea 01             	sub    $0x1,%edx
   15bc0:	88 50 0d             	mov    %dl,0xd(%eax)
	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
   15bc3:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   15bc9:	8b 10                	mov    (%eax),%edx
   15bcb:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   15bd1:	8b 00                	mov    (%eax),%eax
   15bd3:	01 d0                	add    %edx,%eax
   15bd5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   15bda:	f7 e2                	mul    %edx
   15bdc:	89 d1                	mov    %edx,%ecx
   15bde:	c1 e9 05             	shr    $0x5,%ecx
   15be1:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   15be7:	8b 10                	mov    (%eax),%edx
   15be9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15bed:	01 ca                	add    %ecx,%edx
   15bef:	89 50 08             	mov    %edx,0x8(%eax)
   15bf2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   15bf6:	8b 40 08             	mov    0x8(%eax),%eax
   15bf9:	89 42 2c             	mov    %eax,0x2c(%edx)
	dir->i_dirt = 1;
   15bfc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15c00:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	iput(dir);
   15c04:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15c08:	83 ec 0c             	sub    $0xc,%esp
   15c0b:	50                   	push   %eax
   15c0c:	e8 91 9c ff ff       	call   f8a2 <iput>
   15c11:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   15c14:	83 ec 0c             	sub    $0xc,%esp
   15c17:	ff 74 24 24          	pushl  0x24(%esp)
   15c1b:	e8 82 9c ff ff       	call   f8a2 <iput>
   15c20:	83 c4 10             	add    $0x10,%esp
	return 0;
   15c23:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15c28:	83 c4 28             	add    $0x28,%esp
   15c2b:	5b                   	pop    %ebx
   15c2c:	c3                   	ret    

00015c2d <sys_unlink>:
// 删除（释放）文件名对应的目录项。
// 从文件系统删除一个名字。如果是文件的最后一个链接，并且没有进程正打开该文件，则该文件也将被删除，并释放所占用的设备空间。
// 参数：name - 文件名（路径名）。
// 返回：成功则返回0,否则返回出错号。
int sys_unlink(const char * name)
{
   15c2d:	53                   	push   %ebx
   15c2e:	83 ec 28             	sub    $0x28,%esp
   15c31:	e8 c4 10 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   15c36:	81 c3 ca c3 01 00    	add    $0x1c3ca,%ebx
	struct dir_entry * de;

	// 首先检查参数的有效性并取路径名中顶层目录的i节点。如果找不到对应路径名中顶层目录的i节点，则返回出错码。如果最顶端
	// 文件名长度为0,则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。如果在该目录中没有写的权限，
	// 则放回该目录i节点，返回访问许可出错码退出。如果不是超级用户，则返回访问许可出错码。
	if (!(dir = dir_namei(name, &namelen, &basename, NULL)))
   15c3c:	6a 00                	push   $0x0
   15c3e:	8d 44 24 18          	lea    0x18(%esp),%eax
   15c42:	50                   	push   %eax
   15c43:	8d 44 24 18          	lea    0x18(%esp),%eax
   15c47:	50                   	push   %eax
   15c48:	ff 74 24 3c          	pushl  0x3c(%esp)
   15c4c:	e8 49 ee ff ff       	call   14a9a <dir_namei>
   15c51:	83 c4 10             	add    $0x10,%esp
   15c54:	89 44 24 0c          	mov    %eax,0xc(%esp)
   15c58:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15c5c:	85 c0                	test   %eax,%eax
   15c5e:	75 0a                	jne    15c6a <sys_unlink+0x3d>
		return -ENOENT;
   15c60:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   15c65:	e9 a4 02 00 00       	jmp    15f0e <sys_unlink+0x2e1>
	if (!namelen) {
   15c6a:	8b 44 24 10          	mov    0x10(%esp),%eax
   15c6e:	85 c0                	test   %eax,%eax
   15c70:	75 1a                	jne    15c8c <sys_unlink+0x5f>
		iput(dir);
   15c72:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15c76:	83 ec 0c             	sub    $0xc,%esp
   15c79:	50                   	push   %eax
   15c7a:	e8 23 9c ff ff       	call   f8a2 <iput>
   15c7f:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   15c82:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   15c87:	e9 82 02 00 00       	jmp    15f0e <sys_unlink+0x2e1>
	}
	if (!permission(dir, MAY_WRITE)) {
   15c8c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15c90:	83 ec 08             	sub    $0x8,%esp
   15c93:	6a 02                	push   $0x2
   15c95:	50                   	push   %eax
   15c96:	e8 e1 e4 ff ff       	call   1417c <permission>
   15c9b:	83 c4 10             	add    $0x10,%esp
   15c9e:	85 c0                	test   %eax,%eax
   15ca0:	75 1a                	jne    15cbc <sys_unlink+0x8f>
		iput(dir);
   15ca2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15ca6:	83 ec 0c             	sub    $0xc,%esp
   15ca9:	50                   	push   %eax
   15caa:	e8 f3 9b ff ff       	call   f8a2 <iput>
   15caf:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15cb2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15cb7:	e9 52 02 00 00       	jmp    15f0e <sys_unlink+0x2e1>
	}
	// 然后根据指定目录的i节点和目录名利用函数find_entry()寻找对应目录项，并返回包含该目录项的缓冲块指针bh、包含该目录
	// 项的目录的i节点指针dir和该目录项指针de。再根据该目录项de中的i节点号利用iget()函数得到对应的i节点inode。如果对应
	// 路径名上最后目录的名的目录项不存在，则释放包含该目录项的高速缓冲区，放回目录的i节点，返回文件不存在出错码，并退出。
	// 如果取目录项的i节点出错，则放回目录的i节点，并释放含有目录项的高速缓冲区，返回出错号。
	bh = find_entry(&dir, basename, namelen, &de);
   15cbc:	8b 54 24 10          	mov    0x10(%esp),%edx
   15cc0:	8b 44 24 14          	mov    0x14(%esp),%eax
   15cc4:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   15cc8:	51                   	push   %ecx
   15cc9:	52                   	push   %edx
   15cca:	50                   	push   %eax
   15ccb:	8d 44 24 18          	lea    0x18(%esp),%eax
   15ccf:	50                   	push   %eax
   15cd0:	e8 f8 e5 ff ff       	call   142cd <find_entry>
   15cd5:	83 c4 10             	add    $0x10,%esp
   15cd8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   15cdc:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   15ce1:	75 1a                	jne    15cfd <sys_unlink+0xd0>
		iput(dir);
   15ce3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15ce7:	83 ec 0c             	sub    $0xc,%esp
   15cea:	50                   	push   %eax
   15ceb:	e8 b2 9b ff ff       	call   f8a2 <iput>
   15cf0:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   15cf3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   15cf8:	e9 11 02 00 00       	jmp    15f0e <sys_unlink+0x2e1>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
   15cfd:	8b 44 24 08          	mov    0x8(%esp),%eax
   15d01:	0f b7 00             	movzwl (%eax),%eax
   15d04:	0f b7 d0             	movzwl %ax,%edx
   15d07:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15d0b:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   15d0f:	0f b7 c0             	movzwl %ax,%eax
   15d12:	83 ec 08             	sub    $0x8,%esp
   15d15:	52                   	push   %edx
   15d16:	50                   	push   %eax
   15d17:	e8 4a 9f ff ff       	call   fc66 <iget>
   15d1c:	83 c4 10             	add    $0x10,%esp
   15d1f:	89 44 24 18          	mov    %eax,0x18(%esp)
   15d23:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   15d28:	75 29                	jne    15d53 <sys_unlink+0x126>
		iput(dir);
   15d2a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15d2e:	83 ec 0c             	sub    $0xc,%esp
   15d31:	50                   	push   %eax
   15d32:	e8 6b 9b ff ff       	call   f8a2 <iput>
   15d37:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15d3a:	83 ec 0c             	sub    $0xc,%esp
   15d3d:	ff 74 24 28          	pushl  0x28(%esp)
   15d41:	e8 25 ac ff ff       	call   1096b <brelse>
   15d46:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   15d49:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   15d4e:	e9 bb 01 00 00       	jmp    15f0e <sys_unlink+0x2e1>
	// 此时我们已有包含要被删除目录项的目录i节点dir、要被删除目录项的i节点inode和要被删除目录项指针de。下面我们通过对这3
	// 个对象中信息的检查来验证删除操作的可行性。
	// 若该目录设置了受限删除标志并且进程的有效用户id（euid）不是root，并且进程的有效用户id（euid）不等于该i节点的用户
	// id，并且进程的euid也不等于目录i节点的用户id，则表示当前进程没有权限删除该目录，于是放回包含要删除目录名的目录i节点
	// 和该要删除目录的i节点，然后释放高速缓冲区，返回出错码。
	if ((dir->i_mode & S_ISVTX) && !suser() &&
   15d53:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15d57:	0f b7 00             	movzwl (%eax),%eax
   15d5a:	0f b7 c0             	movzwl %ax,%eax
   15d5d:	25 00 02 00 00       	and    $0x200,%eax
   15d62:	85 c0                	test   %eax,%eax
   15d64:	0f 84 84 00 00 00    	je     15dee <sys_unlink+0x1c1>
   15d6a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   15d70:	8b 00                	mov    (%eax),%eax
   15d72:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
   15d79:	66 85 c0             	test   %ax,%ax
   15d7c:	74 70                	je     15dee <sys_unlink+0x1c1>
	    current->euid != inode->i_uid &&
   15d7e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   15d84:	8b 00                	mov    (%eax),%eax
   15d86:	0f b7 90 ce 02 00 00 	movzwl 0x2ce(%eax),%edx
   15d8d:	8b 44 24 18          	mov    0x18(%esp),%eax
   15d91:	0f b7 40 02          	movzwl 0x2(%eax),%eax
	if ((dir->i_mode & S_ISVTX) && !suser() &&
   15d95:	66 39 c2             	cmp    %ax,%dx
   15d98:	74 54                	je     15dee <sys_unlink+0x1c1>
	    current->euid != dir->i_uid) {
   15d9a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   15da0:	8b 00                	mov    (%eax),%eax
   15da2:	0f b7 90 ce 02 00 00 	movzwl 0x2ce(%eax),%edx
   15da9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15dad:	0f b7 40 02          	movzwl 0x2(%eax),%eax
	    current->euid != inode->i_uid &&
   15db1:	66 39 c2             	cmp    %ax,%dx
   15db4:	74 38                	je     15dee <sys_unlink+0x1c1>
		iput(dir);
   15db6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15dba:	83 ec 0c             	sub    $0xc,%esp
   15dbd:	50                   	push   %eax
   15dbe:	e8 df 9a ff ff       	call   f8a2 <iput>
   15dc3:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   15dc6:	83 ec 0c             	sub    $0xc,%esp
   15dc9:	ff 74 24 24          	pushl  0x24(%esp)
   15dcd:	e8 d0 9a ff ff       	call   f8a2 <iput>
   15dd2:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15dd5:	83 ec 0c             	sub    $0xc,%esp
   15dd8:	ff 74 24 28          	pushl  0x28(%esp)
   15ddc:	e8 8a ab ff ff       	call   1096b <brelse>
   15de1:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15de4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15de9:	e9 20 01 00 00       	jmp    15f0e <sys_unlink+0x2e1>
	}
	// 如果该指定文件名是一个目录，则也不能删除。放回该目录i节点和该文件名目录项的i节点，释放包含该目录项的缓冲块，返回出错号。
	if (S_ISDIR(inode->i_mode)) {
   15dee:	8b 44 24 18          	mov    0x18(%esp),%eax
   15df2:	0f b7 00             	movzwl (%eax),%eax
   15df5:	0f b7 c0             	movzwl %ax,%eax
   15df8:	25 00 f0 00 00       	and    $0xf000,%eax
   15dfd:	3d 00 40 00 00       	cmp    $0x4000,%eax
   15e02:	75 38                	jne    15e3c <sys_unlink+0x20f>
		iput(inode);
   15e04:	83 ec 0c             	sub    $0xc,%esp
   15e07:	ff 74 24 24          	pushl  0x24(%esp)
   15e0b:	e8 92 9a ff ff       	call   f8a2 <iput>
   15e10:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   15e13:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15e17:	83 ec 0c             	sub    $0xc,%esp
   15e1a:	50                   	push   %eax
   15e1b:	e8 82 9a ff ff       	call   f8a2 <iput>
   15e20:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   15e23:	83 ec 0c             	sub    $0xc,%esp
   15e26:	ff 74 24 28          	pushl  0x28(%esp)
   15e2a:	e8 3c ab ff ff       	call   1096b <brelse>
   15e2f:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15e32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15e37:	e9 d2 00 00 00       	jmp    15f0e <sys_unlink+0x2e1>
	}
	// 如果该i节点的链接计数值已经为0,则显示警告信息，并修正其为1。
	if (!inode->i_nlinks) {
   15e3c:	8b 44 24 18          	mov    0x18(%esp),%eax
   15e40:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   15e44:	84 c0                	test   %al,%al
   15e46:	75 3b                	jne    15e83 <sys_unlink+0x256>
		printk("Deleting nonexistent file (%04x:%d), %d\n",
			inode->i_dev, inode->i_num, inode->i_nlinks);
   15e48:	8b 44 24 18          	mov    0x18(%esp),%eax
   15e4c:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
		printk("Deleting nonexistent file (%04x:%d), %d\n",
   15e50:	0f b6 c8             	movzbl %al,%ecx
			inode->i_dev, inode->i_num, inode->i_nlinks);
   15e53:	8b 44 24 18          	mov    0x18(%esp),%eax
   15e57:	0f b7 40 32          	movzwl 0x32(%eax),%eax
		printk("Deleting nonexistent file (%04x:%d), %d\n",
   15e5b:	0f b7 d0             	movzwl %ax,%edx
			inode->i_dev, inode->i_num, inode->i_nlinks);
   15e5e:	8b 44 24 18          	mov    0x18(%esp),%eax
   15e62:	0f b7 40 30          	movzwl 0x30(%eax),%eax
		printk("Deleting nonexistent file (%04x:%d), %d\n",
   15e66:	0f b7 c0             	movzwl %ax,%eax
   15e69:	51                   	push   %ecx
   15e6a:	52                   	push   %edx
   15e6b:	50                   	push   %eax
   15e6c:	8d 83 38 52 ff ff    	lea    -0xadc8(%ebx),%eax
   15e72:	50                   	push   %eax
   15e73:	e8 ba 34 ff ff       	call   9332 <printk>
   15e78:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks = 1;
   15e7b:	8b 44 24 18          	mov    0x18(%esp),%eax
   15e7f:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	}
	// 现在我们可以删除文件名对应的目录项了。于是将该文件名目录项中的i节点号字段置为0,表示释放该目录项，并设置包含该目录项的缓
	// 冲块已修改标志，释放该高速缓冲块。
	de->inode = 0;
   15e83:	8b 44 24 08          	mov    0x8(%esp),%eax
   15e87:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
   15e8c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   15e90:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   15e94:	83 ec 0c             	sub    $0xc,%esp
   15e97:	ff 74 24 28          	pushl  0x28(%esp)
   15e9b:	e8 cb aa ff ff       	call   1096b <brelse>
   15ea0:	83 c4 10             	add    $0x10,%esp
	// 然后把文件名对应i节点的链接数减1,置已修改标志，更新改变时间为当前时间。最后放回该i节点和目录的i节点，返回0（成功）。如果
	// 是文件的最后一个链接，即i节点链接数减1后等于0,并且此时没有进程正打开该文件，那么在调用iput()放回i节点时，该文件也将被删除
	// 并释放所占用的设备空间。参见fs/inode.c。
	inode->i_nlinks--;
   15ea3:	8b 44 24 18          	mov    0x18(%esp),%eax
   15ea7:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   15eab:	8d 50 ff             	lea    -0x1(%eax),%edx
   15eae:	8b 44 24 18          	mov    0x18(%esp),%eax
   15eb2:	88 50 0d             	mov    %dl,0xd(%eax)
	inode->i_dirt = 1;
   15eb5:	8b 44 24 18          	mov    0x18(%esp),%eax
   15eb9:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	inode->i_ctime = CURRENT_TIME;
   15ebd:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   15ec3:	8b 10                	mov    (%eax),%edx
   15ec5:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   15ecb:	8b 00                	mov    (%eax),%eax
   15ecd:	01 d0                	add    %edx,%eax
   15ecf:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   15ed4:	f7 e2                	mul    %edx
   15ed6:	c1 ea 05             	shr    $0x5,%edx
   15ed9:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   15edf:	8b 00                	mov    (%eax),%eax
   15ee1:	01 c2                	add    %eax,%edx
   15ee3:	8b 44 24 18          	mov    0x18(%esp),%eax
   15ee7:	89 50 2c             	mov    %edx,0x2c(%eax)
	iput(inode);
   15eea:	83 ec 0c             	sub    $0xc,%esp
   15eed:	ff 74 24 24          	pushl  0x24(%esp)
   15ef1:	e8 ac 99 ff ff       	call   f8a2 <iput>
   15ef6:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   15ef9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15efd:	83 ec 0c             	sub    $0xc,%esp
   15f00:	50                   	push   %eax
   15f01:	e8 9c 99 ff ff       	call   f8a2 <iput>
   15f06:	83 c4 10             	add    $0x10,%esp
	return 0;
   15f09:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15f0e:	83 c4 28             	add    $0x28,%esp
   15f11:	5b                   	pop    %ebx
   15f12:	c3                   	ret    

00015f13 <sys_symlink>:
// 建立符号链接。
// 为一个已存在文件创建一个符号链接（也称为软连接 - hard link）。
// 参数：oldname - 原路径名；newname - 新的路径名。
// 返回：若成功则返回0，否则返回出错号。
int sys_symlink(const char * oldname, const char * newname)
{
   15f13:	56                   	push   %esi
   15f14:	53                   	push   %ebx
   15f15:	83 ec 34             	sub    $0x34,%esp
   15f18:	e8 dd 0d ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   15f1d:	81 c3 e3 c0 01 00    	add    $0x1c0e3,%ebx
	char c;

	// 首先查找新路径名的最顶层目录的i节点dir，并返回最后的文件名及其长度。如果目录的i节点没有找到，则返回出错号。如果新路径名
	// 中不包括文件名，则放回新路径名目录的i节点，返回出错号。另外，如果用户没有在新目录中写的权限，则也不能建立连接，于是放回
	// 新路径名目录的i节点，返回出错号。
	dir = dir_namei(newname, &namelen, &basename, NULL);
   15f23:	6a 00                	push   $0x0
   15f25:	8d 44 24 14          	lea    0x14(%esp),%eax
   15f29:	50                   	push   %eax
   15f2a:	8d 44 24 14          	lea    0x14(%esp),%eax
   15f2e:	50                   	push   %eax
   15f2f:	ff 74 24 50          	pushl  0x50(%esp)
   15f33:	e8 62 eb ff ff       	call   14a9a <dir_namei>
   15f38:	83 c4 10             	add    $0x10,%esp
   15f3b:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (!dir)
   15f3f:	8b 44 24 14          	mov    0x14(%esp),%eax
   15f43:	85 c0                	test   %eax,%eax
   15f45:	75 0a                	jne    15f51 <sys_symlink+0x3e>
		return -EACCES;
   15f47:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   15f4c:	e9 36 03 00 00       	jmp    16287 <sys_symlink+0x374>
	if (!namelen) {
   15f51:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15f55:	85 c0                	test   %eax,%eax
   15f57:	75 1a                	jne    15f73 <sys_symlink+0x60>
		iput(dir);
   15f59:	8b 44 24 14          	mov    0x14(%esp),%eax
   15f5d:	83 ec 0c             	sub    $0xc,%esp
   15f60:	50                   	push   %eax
   15f61:	e8 3c 99 ff ff       	call   f8a2 <iput>
   15f66:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   15f69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15f6e:	e9 14 03 00 00       	jmp    16287 <sys_symlink+0x374>
	}
	if (!permission(dir, MAY_WRITE)) {
   15f73:	8b 44 24 14          	mov    0x14(%esp),%eax
   15f77:	83 ec 08             	sub    $0x8,%esp
   15f7a:	6a 02                	push   $0x2
   15f7c:	50                   	push   %eax
   15f7d:	e8 fa e1 ff ff       	call   1417c <permission>
   15f82:	83 c4 10             	add    $0x10,%esp
   15f85:	85 c0                	test   %eax,%eax
   15f87:	75 1a                	jne    15fa3 <sys_symlink+0x90>
		iput(dir);
   15f89:	8b 44 24 14          	mov    0x14(%esp),%eax
   15f8d:	83 ec 0c             	sub    $0xc,%esp
   15f90:	50                   	push   %eax
   15f91:	e8 0c 99 ff ff       	call   f8a2 <iput>
   15f96:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
   15f99:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   15f9e:	e9 e4 02 00 00       	jmp    16287 <sys_symlink+0x374>
	}
	// 现在我们在目录指定设备上申请一个新的i节点，并设置该i节点模式为符号链接类型以及进程规定的模式屏蔽码。并且设置该i节点已修
	// 改标志。
	if (!(inode = new_inode(dir->i_dev))) {
   15fa3:	8b 44 24 14          	mov    0x14(%esp),%eax
   15fa7:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   15fab:	0f b7 c0             	movzwl %ax,%eax
   15fae:	83 ec 0c             	sub    $0xc,%esp
   15fb1:	50                   	push   %eax
   15fb2:	e8 90 0a 00 00       	call   16a47 <new_inode>
   15fb7:	83 c4 10             	add    $0x10,%esp
   15fba:	89 44 24 28          	mov    %eax,0x28(%esp)
   15fbe:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   15fc3:	75 1a                	jne    15fdf <sys_symlink+0xcc>
		iput(dir);
   15fc5:	8b 44 24 14          	mov    0x14(%esp),%eax
   15fc9:	83 ec 0c             	sub    $0xc,%esp
   15fcc:	50                   	push   %eax
   15fcd:	e8 d0 98 ff ff       	call   f8a2 <iput>
   15fd2:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   15fd5:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   15fda:	e9 a8 02 00 00       	jmp    16287 <sys_symlink+0x374>
	}
	inode->i_mode = S_IFLNK | (0777 & ~current->umask);
   15fdf:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   15fe5:	8b 00                	mov    (%eax),%eax
   15fe7:	0f b7 80 30 03 00 00 	movzwl 0x330(%eax),%eax
   15fee:	f7 d0                	not    %eax
   15ff0:	66 25 ff 01          	and    $0x1ff,%ax
   15ff4:	66 0d 00 a0          	or     $0xa000,%ax
   15ff8:	89 c2                	mov    %eax,%edx
   15ffa:	8b 44 24 28          	mov    0x28(%esp),%eax
   15ffe:	66 89 10             	mov    %dx,(%eax)
	inode->i_dirt = 1;
   16001:	8b 44 24 28          	mov    0x28(%esp),%eax
   16005:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	// 为了保存符号链接路径名字符串信息，我们需要为该i节点申请一个磁盘块，并让i节点的第1个直接块号i_zone[0]等于得到的逻辑块号。
	// 然后置i节点已修改标志。如果申请失败则放回对应目录的i节点；复位新申请的i节点链接计数；放回该新的i节点，返回没有空间出错码
	// 退出。
	if (!(inode->i_zone[0] = new_block(inode->i_dev))) {
   16009:	8b 44 24 28          	mov    0x28(%esp),%eax
   1600d:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   16011:	0f b7 c0             	movzwl %ax,%eax
   16014:	83 ec 0c             	sub    $0xc,%esp
   16017:	50                   	push   %eax
   16018:	e8 c9 06 00 00       	call   166e6 <new_block>
   1601d:	83 c4 10             	add    $0x10,%esp
   16020:	89 c2                	mov    %eax,%edx
   16022:	8b 44 24 28          	mov    0x28(%esp),%eax
   16026:	66 89 50 0e          	mov    %dx,0xe(%eax)
   1602a:	8b 44 24 28          	mov    0x28(%esp),%eax
   1602e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   16032:	66 85 c0             	test   %ax,%ax
   16035:	75 3b                	jne    16072 <sys_symlink+0x15f>
		iput(dir);
   16037:	8b 44 24 14          	mov    0x14(%esp),%eax
   1603b:	83 ec 0c             	sub    $0xc,%esp
   1603e:	50                   	push   %eax
   1603f:	e8 5e 98 ff ff       	call   f8a2 <iput>
   16044:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   16047:	8b 44 24 28          	mov    0x28(%esp),%eax
   1604b:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1604f:	8d 50 ff             	lea    -0x1(%eax),%edx
   16052:	8b 44 24 28          	mov    0x28(%esp),%eax
   16056:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   16059:	83 ec 0c             	sub    $0xc,%esp
   1605c:	ff 74 24 34          	pushl  0x34(%esp)
   16060:	e8 3d 98 ff ff       	call   f8a2 <iput>
   16065:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   16068:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   1606d:	e9 15 02 00 00       	jmp    16287 <sys_symlink+0x374>
	}
	inode->i_dirt = 1;
   16072:	8b 44 24 28          	mov    0x28(%esp),%eax
   16076:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	// 然后从设备上读取新申请的磁盘块（目的是把对应块放到高速缓冲区中）。若出错，则放回对应目录的i节点；复位新申请的i节点链接计数；
	// 放回该新的i节点，返回没有空间出错码退出。
	if (!(name_block = bread(inode->i_dev, inode->i_zone[0]))) {
   1607a:	8b 44 24 28          	mov    0x28(%esp),%eax
   1607e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   16082:	0f b7 d0             	movzwl %ax,%edx
   16085:	8b 44 24 28          	mov    0x28(%esp),%eax
   16089:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1608d:	0f b7 c0             	movzwl %ax,%eax
   16090:	83 ec 08             	sub    $0x8,%esp
   16093:	52                   	push   %edx
   16094:	50                   	push   %eax
   16095:	e8 38 a9 ff ff       	call   109d2 <bread>
   1609a:	83 c4 10             	add    $0x10,%esp
   1609d:	89 44 24 24          	mov    %eax,0x24(%esp)
   160a1:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   160a6:	75 3b                	jne    160e3 <sys_symlink+0x1d0>
		iput(dir);
   160a8:	8b 44 24 14          	mov    0x14(%esp),%eax
   160ac:	83 ec 0c             	sub    $0xc,%esp
   160af:	50                   	push   %eax
   160b0:	e8 ed 97 ff ff       	call   f8a2 <iput>
   160b5:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   160b8:	8b 44 24 28          	mov    0x28(%esp),%eax
   160bc:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   160c0:	8d 50 ff             	lea    -0x1(%eax),%edx
   160c3:	8b 44 24 28          	mov    0x28(%esp),%eax
   160c7:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   160ca:	83 ec 0c             	sub    $0xc,%esp
   160cd:	ff 74 24 34          	pushl  0x34(%esp)
   160d1:	e8 cc 97 ff ff       	call   f8a2 <iput>
   160d6:	83 c4 10             	add    $0x10,%esp
		return -ERROR;
   160d9:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
   160de:	e9 a4 01 00 00       	jmp    16287 <sys_symlink+0x374>
	}
	// 现在我们可以把符号链接名字字符串放入这个盘块中了。盘块长度为1024字节，因此默认符号链接名长度最大也只能是1024字节。我们把用
	// 户空间中的符号链接名字符串复制到盘块所在的缓冲块中，并置缓冲块已修改标志。为防止用户提供的字符串没有以NULL结尾，我们在缓冲块
	// 数据区最后一个字节处放上一个NULL。然后释放该缓冲块，并设置i节点对应文件中数据长度等于符号链接名字符串长度，并置i节点已修改
	// 标志。
	i = 0;
   160e3:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   160ea:	00 
	while (i < 1023 && (c = get_fs_byte(oldname++)))
   160eb:	eb 1b                	jmp    16108 <sys_symlink+0x1f5>
		name_block->b_data[i++] = c;
   160ed:	8b 44 24 24          	mov    0x24(%esp),%eax
   160f1:	8b 08                	mov    (%eax),%ecx
   160f3:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   160f7:	8d 50 01             	lea    0x1(%eax),%edx
   160fa:	89 54 24 2c          	mov    %edx,0x2c(%esp)
   160fe:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   16101:	0f b6 44 24 23       	movzbl 0x23(%esp),%eax
   16106:	88 02                	mov    %al,(%edx)
	while (i < 1023 && (c = get_fs_byte(oldname++)))
   16108:	81 7c 24 2c fe 03 00 	cmpl   $0x3fe,0x2c(%esp)
   1610f:	00 
   16110:	7f 22                	jg     16134 <sys_symlink+0x221>
   16112:	8b 44 24 40          	mov    0x40(%esp),%eax
   16116:	8d 50 01             	lea    0x1(%eax),%edx
   16119:	89 54 24 40          	mov    %edx,0x40(%esp)
   1611d:	83 ec 0c             	sub    $0xc,%esp
   16120:	50                   	push   %eax
   16121:	e8 e7 df ff ff       	call   1410d <get_fs_byte>
   16126:	83 c4 10             	add    $0x10,%esp
   16129:	88 44 24 23          	mov    %al,0x23(%esp)
   1612d:	80 7c 24 23 00       	cmpb   $0x0,0x23(%esp)
   16132:	75 b9                	jne    160ed <sys_symlink+0x1da>
	name_block->b_data[i] = 0;
   16134:	8b 44 24 24          	mov    0x24(%esp),%eax
   16138:	8b 10                	mov    (%eax),%edx
   1613a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   1613e:	01 d0                	add    %edx,%eax
   16140:	c6 00 00             	movb   $0x0,(%eax)
	name_block->b_dirt = 1;
   16143:	8b 44 24 24          	mov    0x24(%esp),%eax
   16147:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(name_block);
   1614b:	83 ec 0c             	sub    $0xc,%esp
   1614e:	ff 74 24 30          	pushl  0x30(%esp)
   16152:	e8 14 a8 ff ff       	call   1096b <brelse>
   16157:	83 c4 10             	add    $0x10,%esp
	inode->i_size = i;
   1615a:	8b 54 24 2c          	mov    0x2c(%esp),%edx
   1615e:	8b 44 24 28          	mov    0x28(%esp),%eax
   16162:	89 50 04             	mov    %edx,0x4(%eax)
	inode->i_dirt = 1;
   16165:	8b 44 24 28          	mov    0x28(%esp),%eax
   16169:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	// 然后我们搜索一下路径名指定的符号链接名是否已经存在。若已经存在则不能创建同名目录项i节点。如果对应符号链接文件名已经存在，则
	// 释放包含该目录项的缓冲区块，复位新申请的i节点连接计数，并施加目录的i节点，返回文件已经存在的出错码退出。
	bh = find_entry(&dir, basename, namelen, &de);
   1616d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16171:	8b 44 24 10          	mov    0x10(%esp),%eax
   16175:	8d 4c 24 18          	lea    0x18(%esp),%ecx
   16179:	51                   	push   %ecx
   1617a:	52                   	push   %edx
   1617b:	50                   	push   %eax
   1617c:	8d 44 24 20          	lea    0x20(%esp),%eax
   16180:	50                   	push   %eax
   16181:	e8 47 e1 ff ff       	call   142cd <find_entry>
   16186:	83 c4 10             	add    $0x10,%esp
   16189:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (bh) {
   1618d:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   16192:	74 4a                	je     161de <sys_symlink+0x2cb>
		inode->i_nlinks--;
   16194:	8b 44 24 28          	mov    0x28(%esp),%eax
   16198:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1619c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1619f:	8b 44 24 28          	mov    0x28(%esp),%eax
   161a3:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   161a6:	83 ec 0c             	sub    $0xc,%esp
   161a9:	ff 74 24 34          	pushl  0x34(%esp)
   161ad:	e8 f0 96 ff ff       	call   f8a2 <iput>
   161b2:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   161b5:	83 ec 0c             	sub    $0xc,%esp
   161b8:	ff 74 24 28          	pushl  0x28(%esp)
   161bc:	e8 aa a7 ff ff       	call   1096b <brelse>
   161c1:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   161c4:	8b 44 24 14          	mov    0x14(%esp),%eax
   161c8:	83 ec 0c             	sub    $0xc,%esp
   161cb:	50                   	push   %eax
   161cc:	e8 d1 96 ff ff       	call   f8a2 <iput>
   161d1:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   161d4:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   161d9:	e9 a9 00 00 00       	jmp    16287 <sys_symlink+0x374>
	}
	// 现在我们在指定目录中新添加一个目录项，用于存放新建符号链接文件名的i节点号和目录名。如果失败（包含该目录项的高速缓冲区指针为
	// NULL），则放回目录的i节点；所申请的i节点引用链接计数复位，并放回该i节点。返回出错码退出。
	bh = add_entry(dir, basename, namelen, &de);
   161de:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   161e2:	8b 54 24 10          	mov    0x10(%esp),%edx
   161e6:	8b 44 24 14          	mov    0x14(%esp),%eax
   161ea:	8d 74 24 18          	lea    0x18(%esp),%esi
   161ee:	56                   	push   %esi
   161ef:	51                   	push   %ecx
   161f0:	52                   	push   %edx
   161f1:	50                   	push   %eax
   161f2:	e8 24 e3 ff ff       	call   1451b <add_entry>
   161f7:	83 c4 10             	add    $0x10,%esp
   161fa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   161fe:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   16203:	75 38                	jne    1623d <sys_symlink+0x32a>
		inode->i_nlinks--;
   16205:	8b 44 24 28          	mov    0x28(%esp),%eax
   16209:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1620d:	8d 50 ff             	lea    -0x1(%eax),%edx
   16210:	8b 44 24 28          	mov    0x28(%esp),%eax
   16214:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   16217:	83 ec 0c             	sub    $0xc,%esp
   1621a:	ff 74 24 34          	pushl  0x34(%esp)
   1621e:	e8 7f 96 ff ff       	call   f8a2 <iput>
   16223:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   16226:	8b 44 24 14          	mov    0x14(%esp),%eax
   1622a:	83 ec 0c             	sub    $0xc,%esp
   1622d:	50                   	push   %eax
   1622e:	e8 6f 96 ff ff       	call   f8a2 <iput>
   16233:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   16236:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   1623b:	eb 4a                	jmp    16287 <sys_symlink+0x374>
	}
	// 最后令该新目录项的i节点字段等于新i节点号，并置高速缓冲块已修改标志，释放高速缓冲块，放回目录和新的i节点，最后返回0（成功）。
	de->inode = inode->i_num;
   1623d:	8b 44 24 18          	mov    0x18(%esp),%eax
   16241:	8b 54 24 28          	mov    0x28(%esp),%edx
   16245:	0f b7 52 32          	movzwl 0x32(%edx),%edx
   16249:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
   1624c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16250:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   16254:	83 ec 0c             	sub    $0xc,%esp
   16257:	ff 74 24 28          	pushl  0x28(%esp)
   1625b:	e8 0b a7 ff ff       	call   1096b <brelse>
   16260:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   16263:	8b 44 24 14          	mov    0x14(%esp),%eax
   16267:	83 ec 0c             	sub    $0xc,%esp
   1626a:	50                   	push   %eax
   1626b:	e8 32 96 ff ff       	call   f8a2 <iput>
   16270:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   16273:	83 ec 0c             	sub    $0xc,%esp
   16276:	ff 74 24 34          	pushl  0x34(%esp)
   1627a:	e8 23 96 ff ff       	call   f8a2 <iput>
   1627f:	83 c4 10             	add    $0x10,%esp
	return 0;
   16282:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16287:	83 c4 34             	add    $0x34,%esp
   1628a:	5b                   	pop    %ebx
   1628b:	5e                   	pop    %esi
   1628c:	c3                   	ret    

0001628d <sys_link>:
// 为文件建立一个文件名目录项。
// 为一个已存在的文件创建一个新链接（也称为硬连接 - hard link）。
// 参数：oldname - 原路径名；newname - 新的路径名。
// 返回：若成功则返回0,否则返回出错号。
int sys_link(const char * oldname, const char * newname)
{
   1628d:	56                   	push   %esi
   1628e:	53                   	push   %ebx
   1628f:	83 ec 24             	sub    $0x24,%esp
   16292:	e8 63 0a ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   16297:	81 c3 69 bd 01 00    	add    $0x1bd69,%ebx
	const char * basename;
	int namelen;

	// 首先对原文件名进行有效性验证，它应该存在并且不是一个目录名。所以我们先取原文件路径名对应的i节点oldinode。如果为0，则
	// 表示出错，返回出错号。如果原路径名对应的是一个目录名，则放回该i节点，也返回出错号。
	oldinode = namei(oldname);
   1629d:	83 ec 0c             	sub    $0xc,%esp
   162a0:	ff 74 24 3c          	pushl  0x3c(%esp)
   162a4:	e8 04 ea ff ff       	call   14cad <namei>
   162a9:	83 c4 10             	add    $0x10,%esp
   162ac:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!oldinode)
   162b0:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   162b5:	75 0a                	jne    162c1 <sys_link+0x34>
		return -ENOENT;
   162b7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   162bc:	e9 5a 02 00 00       	jmp    1651b <sys_link+0x28e>
	if (S_ISDIR(oldinode->i_mode)) {
   162c1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   162c5:	0f b7 00             	movzwl (%eax),%eax
   162c8:	0f b7 c0             	movzwl %ax,%eax
   162cb:	25 00 f0 00 00       	and    $0xf000,%eax
   162d0:	3d 00 40 00 00       	cmp    $0x4000,%eax
   162d5:	75 19                	jne    162f0 <sys_link+0x63>
		iput(oldinode);
   162d7:	83 ec 0c             	sub    $0xc,%esp
   162da:	ff 74 24 28          	pushl  0x28(%esp)
   162de:	e8 bf 95 ff ff       	call   f8a2 <iput>
   162e3:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   162e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   162eb:	e9 2b 02 00 00       	jmp    1651b <sys_link+0x28e>
	}
	// 然后查找新路径名的最顶层目录的i节点dir，并返回最后的文件名及其长度。如果目录的i节点没有找到，则放回原路径名的i节点，返
	// 回出错号。如果新路径名中不包括文件名，则放回原路径名i节点和新路径名目录的i节点，返回出错号。
	dir = dir_namei(newname, &namelen, &basename, NULL);
   162f0:	6a 00                	push   $0x0
   162f2:	8d 44 24 10          	lea    0x10(%esp),%eax
   162f6:	50                   	push   %eax
   162f7:	8d 44 24 10          	lea    0x10(%esp),%eax
   162fb:	50                   	push   %eax
   162fc:	ff 74 24 40          	pushl  0x40(%esp)
   16300:	e8 95 e7 ff ff       	call   14a9a <dir_namei>
   16305:	83 c4 10             	add    $0x10,%esp
   16308:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!dir) {
   1630c:	8b 44 24 10          	mov    0x10(%esp),%eax
   16310:	85 c0                	test   %eax,%eax
   16312:	75 19                	jne    1632d <sys_link+0xa0>
		iput(oldinode);
   16314:	83 ec 0c             	sub    $0xc,%esp
   16317:	ff 74 24 28          	pushl  0x28(%esp)
   1631b:	e8 82 95 ff ff       	call   f8a2 <iput>
   16320:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
   16323:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   16328:	e9 ee 01 00 00       	jmp    1651b <sys_link+0x28e>
	}
	if (!namelen) {
   1632d:	8b 44 24 08          	mov    0x8(%esp),%eax
   16331:	85 c0                	test   %eax,%eax
   16333:	75 29                	jne    1635e <sys_link+0xd1>
		iput(oldinode);
   16335:	83 ec 0c             	sub    $0xc,%esp
   16338:	ff 74 24 28          	pushl  0x28(%esp)
   1633c:	e8 61 95 ff ff       	call   f8a2 <iput>
   16341:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   16344:	8b 44 24 10          	mov    0x10(%esp),%eax
   16348:	83 ec 0c             	sub    $0xc,%esp
   1634b:	50                   	push   %eax
   1634c:	e8 51 95 ff ff       	call   f8a2 <iput>
   16351:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   16354:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16359:	e9 bd 01 00 00       	jmp    1651b <sys_link+0x28e>
	}
	// 我们不能跨设备建立硬链接。因此如果新路径名顶层目录的设备号与原路径名的设备号不一样，则放回新路径名目录的i节点和原路径名
	// 的i节点，返回出错号。另外，如果用户没有在新目录中写的权限，则也不能建立连接，于是放回新路径名目录的i节点和原路径名的i节点
	// 返回出错号。
	if (dir->i_dev != oldinode->i_dev) {
   1635e:	8b 44 24 10          	mov    0x10(%esp),%eax
   16362:	0f b7 50 30          	movzwl 0x30(%eax),%edx
   16366:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1636a:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1636e:	66 39 c2             	cmp    %ax,%dx
   16371:	74 29                	je     1639c <sys_link+0x10f>
		iput(dir);
   16373:	8b 44 24 10          	mov    0x10(%esp),%eax
   16377:	83 ec 0c             	sub    $0xc,%esp
   1637a:	50                   	push   %eax
   1637b:	e8 22 95 ff ff       	call   f8a2 <iput>
   16380:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   16383:	83 ec 0c             	sub    $0xc,%esp
   16386:	ff 74 24 28          	pushl  0x28(%esp)
   1638a:	e8 13 95 ff ff       	call   f8a2 <iput>
   1638f:	83 c4 10             	add    $0x10,%esp
		return -EXDEV;
   16392:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
   16397:	e9 7f 01 00 00       	jmp    1651b <sys_link+0x28e>
	}
	if (!permission(dir, MAY_WRITE)) {
   1639c:	8b 44 24 10          	mov    0x10(%esp),%eax
   163a0:	83 ec 08             	sub    $0x8,%esp
   163a3:	6a 02                	push   $0x2
   163a5:	50                   	push   %eax
   163a6:	e8 d1 dd ff ff       	call   1417c <permission>
   163ab:	83 c4 10             	add    $0x10,%esp
   163ae:	85 c0                	test   %eax,%eax
   163b0:	75 29                	jne    163db <sys_link+0x14e>
		iput(dir);
   163b2:	8b 44 24 10          	mov    0x10(%esp),%eax
   163b6:	83 ec 0c             	sub    $0xc,%esp
   163b9:	50                   	push   %eax
   163ba:	e8 e3 94 ff ff       	call   f8a2 <iput>
   163bf:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   163c2:	83 ec 0c             	sub    $0xc,%esp
   163c5:	ff 74 24 28          	pushl  0x28(%esp)
   163c9:	e8 d4 94 ff ff       	call   f8a2 <iput>
   163ce:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
   163d1:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   163d6:	e9 40 01 00 00       	jmp    1651b <sys_link+0x28e>
	}
	// 现在查询该新路径名是否已经存在，如果存在则也不能建立链接。于是释放包含该已存在目录项的高速缓冲块，放回新路径名目录的i节点
	// 和原路径名的i节点，返回出错号。
	bh = find_entry(&dir, basename, namelen, &de);
   163db:	8b 54 24 08          	mov    0x8(%esp),%edx
   163df:	8b 44 24 0c          	mov    0xc(%esp),%eax
   163e3:	8d 4c 24 14          	lea    0x14(%esp),%ecx
   163e7:	51                   	push   %ecx
   163e8:	52                   	push   %edx
   163e9:	50                   	push   %eax
   163ea:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   163ee:	50                   	push   %eax
   163ef:	e8 d9 de ff ff       	call   142cd <find_entry>
   163f4:	83 c4 10             	add    $0x10,%esp
   163f7:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (bh) {
   163fb:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   16400:	74 38                	je     1643a <sys_link+0x1ad>
		brelse(bh);
   16402:	83 ec 0c             	sub    $0xc,%esp
   16405:	ff 74 24 24          	pushl  0x24(%esp)
   16409:	e8 5d a5 ff ff       	call   1096b <brelse>
   1640e:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   16411:	8b 44 24 10          	mov    0x10(%esp),%eax
   16415:	83 ec 0c             	sub    $0xc,%esp
   16418:	50                   	push   %eax
   16419:	e8 84 94 ff ff       	call   f8a2 <iput>
   1641e:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   16421:	83 ec 0c             	sub    $0xc,%esp
   16424:	ff 74 24 28          	pushl  0x28(%esp)
   16428:	e8 75 94 ff ff       	call   f8a2 <iput>
   1642d:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   16430:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   16435:	e9 e1 00 00 00       	jmp    1651b <sys_link+0x28e>
	}
	// 现在所有条件都满足了，于是我们在新目录中添加一个目录项。若失败则放回该目录的i节点和原路径名的i节点，返回出错号。否则初始
	// 设置该目录项的i节点号等于原路径名的i节点号，并置包含该新添目录的缓冲块已修改标志，释放该缓冲块，放回目录的i节点。
	bh = add_entry(dir, basename, namelen, &de);
   1643a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1643e:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16442:	8b 44 24 10          	mov    0x10(%esp),%eax
   16446:	8d 74 24 14          	lea    0x14(%esp),%esi
   1644a:	56                   	push   %esi
   1644b:	51                   	push   %ecx
   1644c:	52                   	push   %edx
   1644d:	50                   	push   %eax
   1644e:	e8 c8 e0 ff ff       	call   1451b <add_entry>
   16453:	83 c4 10             	add    $0x10,%esp
   16456:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!bh) {
   1645a:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1645f:	75 29                	jne    1648a <sys_link+0x1fd>
		iput(dir);
   16461:	8b 44 24 10          	mov    0x10(%esp),%eax
   16465:	83 ec 0c             	sub    $0xc,%esp
   16468:	50                   	push   %eax
   16469:	e8 34 94 ff ff       	call   f8a2 <iput>
   1646e:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   16471:	83 ec 0c             	sub    $0xc,%esp
   16474:	ff 74 24 28          	pushl  0x28(%esp)
   16478:	e8 25 94 ff ff       	call   f8a2 <iput>
   1647d:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   16480:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   16485:	e9 91 00 00 00       	jmp    1651b <sys_link+0x28e>
	}
	de->inode = oldinode->i_num;
   1648a:	8b 44 24 14          	mov    0x14(%esp),%eax
   1648e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   16492:	0f b7 52 32          	movzwl 0x32(%edx),%edx
   16496:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
   16499:	8b 44 24 18          	mov    0x18(%esp),%eax
   1649d:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   164a1:	83 ec 0c             	sub    $0xc,%esp
   164a4:	ff 74 24 24          	pushl  0x24(%esp)
   164a8:	e8 be a4 ff ff       	call   1096b <brelse>
   164ad:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   164b0:	8b 44 24 10          	mov    0x10(%esp),%eax
   164b4:	83 ec 0c             	sub    $0xc,%esp
   164b7:	50                   	push   %eax
   164b8:	e8 e5 93 ff ff       	call   f8a2 <iput>
   164bd:	83 c4 10             	add    $0x10,%esp
	// 再将原节点的链接计数加1,修改其改变时间为当前时间，并设置i节点已修改标志。最后放回原路径名的i节点，并返回0（成功）。
	oldinode->i_nlinks++;
   164c0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   164c4:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   164c8:	8d 50 01             	lea    0x1(%eax),%edx
   164cb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   164cf:	88 50 0d             	mov    %dl,0xd(%eax)
	oldinode->i_ctime = CURRENT_TIME;
   164d2:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   164d8:	8b 10                	mov    (%eax),%edx
   164da:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   164e0:	8b 00                	mov    (%eax),%eax
   164e2:	01 d0                	add    %edx,%eax
   164e4:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   164e9:	f7 e2                	mul    %edx
   164eb:	c1 ea 05             	shr    $0x5,%edx
   164ee:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   164f4:	8b 00                	mov    (%eax),%eax
   164f6:	01 c2                	add    %eax,%edx
   164f8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   164fc:	89 50 2c             	mov    %edx,0x2c(%eax)
	oldinode->i_dirt = 1;
   164ff:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16503:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	iput(oldinode);
   16507:	83 ec 0c             	sub    $0xc,%esp
   1650a:	ff 74 24 28          	pushl  0x28(%esp)
   1650e:	e8 8f 93 ff ff       	call   f8a2 <iput>
   16513:	83 c4 10             	add    $0x10,%esp
	return 0;
   16516:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1651b:	83 c4 24             	add    $0x24,%esp
   1651e:	5b                   	pop    %ebx
   1651f:	5e                   	pop    %esi
   16520:	c3                   	ret    

00016521 <memset>:
{
   16521:	57                   	push   %edi
   16522:	83 ec 04             	sub    $0x4,%esp
   16525:	e8 c8 07 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1652a:	05 d6 ba 01 00       	add    $0x1bad6,%eax
   1652f:	8b 44 24 10          	mov    0x10(%esp),%eax
   16533:	88 04 24             	mov    %al,(%esp)
__asm__(
   16536:	0f b6 04 24          	movzbl (%esp),%eax
   1653a:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1653e:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   16542:	89 d7                	mov    %edx,%edi
   16544:	fc                   	cld    
   16545:	57                   	push   %edi
   16546:	f3 aa                	rep stos %al,%es:(%edi)
   16548:	5f                   	pop    %edi
return s;
   16549:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   1654d:	83 c4 04             	add    $0x4,%esp
   16550:	5f                   	pop    %edi
   16551:	c3                   	ret    

00016552 <free_block>:

// 释放设备dev上数据区中的逻辑块block。
// 复位指定逻辑块block对应的逻辑块位图位。成功则返回1,否则返回0.
// 参数：dev是设备号，block是逻辑块号（盘块号）。
int free_block(int dev, int block)
{
   16552:	53                   	push   %ebx
   16553:	83 ec 18             	sub    $0x18,%esp
   16556:	e8 9f 07 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1655b:	81 c3 a5 ba 01 00    	add    $0x1baa5,%ebx
	struct buffer_head * bh;

	// 首先取设备dev上文件系统的超级块信息，根据其中数据区开始逻辑块号和文件系统中逻辑块总数信息判断参数block的有效
	// 性。如果指定设备超级块不存在，则出错停机。若逻辑块号小于盘上数据区第1个逻辑块号或者大于设备上总逻辑块数，也出
	// 错停机。
	if (!(sb = get_super(dev)))             						// fs/super.c
   16561:	83 ec 0c             	sub    $0xc,%esp
   16564:	ff 74 24 2c          	pushl  0x2c(%esp)
   16568:	e8 39 a9 ff ff       	call   10ea6 <get_super>
   1656d:	83 c4 10             	add    $0x10,%esp
   16570:	89 44 24 0c          	mov    %eax,0xc(%esp)
   16574:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   16579:	75 12                	jne    1658d <free_block+0x3b>
		panic("trying to free block on nonexistent device");
   1657b:	83 ec 0c             	sub    $0xc,%esp
   1657e:	8d 83 64 52 ff ff    	lea    -0xad9c(%ebx),%eax
   16584:	50                   	push   %eax
   16585:	e8 54 2d ff ff       	call   92de <panic>
   1658a:	83 c4 10             	add    $0x10,%esp
	if (block < sb->s_firstdatazone || block >= sb->s_nzones)
   1658d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16591:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   16595:	0f b7 c0             	movzwl %ax,%eax
   16598:	39 44 24 24          	cmp    %eax,0x24(%esp)
   1659c:	7c 11                	jl     165af <free_block+0x5d>
   1659e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   165a2:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   165a6:	0f b7 c0             	movzwl %ax,%eax
   165a9:	39 44 24 24          	cmp    %eax,0x24(%esp)
   165ad:	7c 12                	jl     165c1 <free_block+0x6f>
		panic("trying to free block not in datazone");
   165af:	83 ec 0c             	sub    $0xc,%esp
   165b2:	8d 83 90 52 ff ff    	lea    -0xad70(%ebx),%eax
   165b8:	50                   	push   %eax
   165b9:	e8 20 2d ff ff       	call   92de <panic>
   165be:	83 c4 10             	add    $0x10,%esp
	bh = get_hash_table(dev, block);
   165c1:	83 ec 08             	sub    $0x8,%esp
   165c4:	ff 74 24 2c          	pushl  0x2c(%esp)
   165c8:	ff 74 24 2c          	pushl  0x2c(%esp)
   165cc:	e8 42 a1 ff ff       	call   10713 <get_hash_table>
   165d1:	83 c4 10             	add    $0x10,%esp
   165d4:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 然后从hash表中寻找该块数据。若找到了则判断其有效性，并清已修改和更新标志，释放该数据块。该段代码的主要用途是如果
	// 该逻辑块目前存在于高速缓冲区中，就释放对应的缓冲块。
	if (bh) {
   165d8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   165dd:	74 50                	je     1662f <free_block+0xdd>
		if (bh->b_count > 1) {          							// 如果引用次数大于1,则调用brelse()。
   165df:	8b 44 24 08          	mov    0x8(%esp),%eax
   165e3:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   165e7:	3c 01                	cmp    $0x1,%al
   165e9:	76 19                	jbe    16604 <free_block+0xb2>
			brelse(bh);             								// b_count--后退出，该块还有人用。
   165eb:	83 ec 0c             	sub    $0xc,%esp
   165ee:	ff 74 24 14          	pushl  0x14(%esp)
   165f2:	e8 74 a3 ff ff       	call   1096b <brelse>
   165f7:	83 c4 10             	add    $0x10,%esp
			return 0;
   165fa:	b8 00 00 00 00       	mov    $0x0,%eax
   165ff:	e9 dd 00 00 00       	jmp    166e1 <free_block+0x18f>
		}
		bh->b_dirt = 0;                   							// 否则复位已修改和已更新标志。
   16604:	8b 44 24 08          	mov    0x8(%esp),%eax
   16608:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
		bh->b_uptodate = 0;
   1660c:	8b 44 24 08          	mov    0x8(%esp),%eax
   16610:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
		if (bh->b_count)                							// 若此时b_count为1,则调用brelse()释放之。
   16614:	8b 44 24 08          	mov    0x8(%esp),%eax
   16618:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   1661c:	84 c0                	test   %al,%al
   1661e:	74 0f                	je     1662f <free_block+0xdd>
			brelse(bh);
   16620:	83 ec 0c             	sub    $0xc,%esp
   16623:	ff 74 24 14          	pushl  0x14(%esp)
   16627:	e8 3f a3 ff ff       	call   1096b <brelse>
   1662c:	83 c4 10             	add    $0x10,%esp
	}
	// 接着我们复位block在逻辑块位图中的位（置0）。先计算block在数据区开始算起的数据逻辑块号（从1开始计数）。然后对逻辑
	// 块（区块）位图进行操作，复位对应的位。如果对应位原来就是0,则出错停机。由于1个缓冲块有1024字节，即8192位，因此
	// block/8192即可计算出指定块block在逻辑位图中的哪个块上。而block&8191可以得到block在逻辑块位图当前块中的位偏移
	// 位置。
	block -= sb->s_firstdatazone - 1 ;
   1662f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16633:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   16637:	0f b7 c0             	movzwl %ax,%eax
   1663a:	83 e8 01             	sub    $0x1,%eax
   1663d:	29 44 24 24          	sub    %eax,0x24(%esp)
	if (clear_bit(block & 8191, sb->s_zmap[block / 8192]->b_data)) {
   16641:	8b 44 24 24          	mov    0x24(%esp),%eax
   16645:	25 ff 1f 00 00       	and    $0x1fff,%eax
   1664a:	89 c1                	mov    %eax,%ecx
   1664c:	8b 44 24 24          	mov    0x24(%esp),%eax
   16650:	8d 90 ff 1f 00 00    	lea    0x1fff(%eax),%edx
   16656:	85 c0                	test   %eax,%eax
   16658:	0f 48 c2             	cmovs  %edx,%eax
   1665b:	c1 f8 0d             	sar    $0xd,%eax
   1665e:	89 c2                	mov    %eax,%edx
   16660:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16664:	83 c2 0c             	add    $0xc,%edx
   16667:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   1666b:	8b 10                	mov    (%eax),%edx
   1666d:	b8 00 00 00 00       	mov    $0x0,%eax
   16672:	0f b3 0a             	btr    %ecx,(%edx)
   16675:	0f 93 c0             	setae  %al
   16678:	85 c0                	test   %eax,%eax
   1667a:	74 3d                	je     166b9 <free_block+0x167>
		printk("block (%04x:%d) ", dev, block + sb->s_firstdatazone - 1);
   1667c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16680:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   16684:	0f b7 d0             	movzwl %ax,%edx
   16687:	8b 44 24 24          	mov    0x24(%esp),%eax
   1668b:	01 d0                	add    %edx,%eax
   1668d:	83 e8 01             	sub    $0x1,%eax
   16690:	83 ec 04             	sub    $0x4,%esp
   16693:	50                   	push   %eax
   16694:	ff 74 24 28          	pushl  0x28(%esp)
   16698:	8d 83 b5 52 ff ff    	lea    -0xad4b(%ebx),%eax
   1669e:	50                   	push   %eax
   1669f:	e8 8e 2c ff ff       	call   9332 <printk>
   166a4:	83 c4 10             	add    $0x10,%esp
		printk("free_block: bit already cleared\n");
   166a7:	83 ec 0c             	sub    $0xc,%esp
   166aa:	8d 83 c8 52 ff ff    	lea    -0xad38(%ebx),%eax
   166b0:	50                   	push   %eax
   166b1:	e8 7c 2c ff ff       	call   9332 <printk>
   166b6:	83 c4 10             	add    $0x10,%esp
	}
	// 最后置相应逻辑块位图所在缓冲区已修改标志。
	sb->s_zmap[block / 8192]->b_dirt = 1;
   166b9:	8b 44 24 24          	mov    0x24(%esp),%eax
   166bd:	8d 90 ff 1f 00 00    	lea    0x1fff(%eax),%edx
   166c3:	85 c0                	test   %eax,%eax
   166c5:	0f 48 c2             	cmovs  %edx,%eax
   166c8:	c1 f8 0d             	sar    $0xd,%eax
   166cb:	89 c2                	mov    %eax,%edx
   166cd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   166d1:	83 c2 0c             	add    $0xc,%edx
   166d4:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   166d8:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	return 1;
   166dc:	b8 01 00 00 00       	mov    $0x1,%eax
}
   166e1:	83 c4 18             	add    $0x18,%esp
   166e4:	5b                   	pop    %ebx
   166e5:	c3                   	ret    

000166e6 <new_block>:
// 向设备申请一个逻辑块(盘块,区块).
// 函数首先取得设备的超级块,并在超级块中的逻辑块位图中寻找第一个0值位(代表一个空闲逻辑块).然后置位对应逻辑块在逻辑位图
// 中的位.接着为该逻辑块在缓冲区中取得一块对应缓冲块.最后将该缓冲块清零,并设置其已更新标志和已修改标志.并返回逻辑块号.
// 函数执行成功则返回逻辑块号(盘块号),否则返回0.
int new_block(int dev)
{
   166e6:	57                   	push   %edi
   166e7:	56                   	push   %esi
   166e8:	53                   	push   %ebx
   166e9:	83 ec 20             	sub    $0x20,%esp
   166ec:	e8 09 06 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   166f1:	81 c3 0f b9 01 00    	add    $0x1b90f,%ebx
	int i,j;

	// 首先获取设备dev的超级块.如果指定设备的超级块不存在,则出错停机.然后扫描文件系统的8块逻辑块位图,寻找首个0值位,以寻找
	// 空闲逻辑块,获取设置该逻辑块的块号.如果全部扫描完8块逻辑块位图的所有位(i >=8 或 j >= 8192)还没有找到0值位或者位图
	// 所在的缓冲块指针无效(bn = NULL)则返回0退出(没有空闲逻辑块).
	if (!(sb = get_super(dev)))
   166f7:	83 ec 0c             	sub    $0xc,%esp
   166fa:	ff 74 24 3c          	pushl  0x3c(%esp)
   166fe:	e8 a3 a7 ff ff       	call   10ea6 <get_super>
   16703:	83 c4 10             	add    $0x10,%esp
   16706:	89 44 24 10          	mov    %eax,0x10(%esp)
   1670a:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1670f:	75 12                	jne    16723 <new_block+0x3d>
		panic("trying to get new block from nonexistant device");
   16711:	83 ec 0c             	sub    $0xc,%esp
   16714:	8d 83 ec 52 ff ff    	lea    -0xad14(%ebx),%eax
   1671a:	50                   	push   %eax
   1671b:	e8 be 2b ff ff       	call   92de <panic>
   16720:	83 c4 10             	add    $0x10,%esp
	j = 8192;
   16723:	c7 44 24 14 00 20 00 	movl   $0x2000,0x14(%esp)
   1672a:	00 
	for (i = 0 ; i < 8 ; i++)
   1672b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   16732:	00 
   16733:	eb 58                	jmp    1678d <new_block+0xa7>
		if (bh = sb->s_zmap[i])
   16735:	8b 44 24 10          	mov    0x10(%esp),%eax
   16739:	8b 54 24 18          	mov    0x18(%esp),%edx
   1673d:	83 c2 0c             	add    $0xc,%edx
   16740:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   16744:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   16748:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   1674d:	74 39                	je     16788 <new_block+0xa2>
			if ((j = find_first_zero(bh->b_data)) < 8192)
   1674f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16753:	8b 30                	mov    (%eax),%esi
   16755:	b9 00 00 00 00       	mov    $0x0,%ecx
   1675a:	fc                   	cld    
   1675b:	ad                   	lods   %ds:(%esi),%eax
   1675c:	f7 d0                	not    %eax
   1675e:	0f bc d0             	bsf    %eax,%edx
   16761:	74 04                	je     16767 <new_block+0x81>
   16763:	01 d1                	add    %edx,%ecx
   16765:	eb 0b                	jmp    16772 <new_block+0x8c>
   16767:	83 c1 20             	add    $0x20,%ecx
   1676a:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
   16770:	7c e9                	jl     1675b <new_block+0x75>
   16772:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
   16776:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1677a:	89 44 24 14          	mov    %eax,0x14(%esp)
   1677e:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   16785:	00 
   16786:	7e 0e                	jle    16796 <new_block+0xb0>
	for (i = 0 ; i < 8 ; i++)
   16788:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   1678d:	83 7c 24 18 07       	cmpl   $0x7,0x18(%esp)
   16792:	7e a1                	jle    16735 <new_block+0x4f>
   16794:	eb 01                	jmp    16797 <new_block+0xb1>
				break;
   16796:	90                   	nop
	if (i >= 8 || !bh || j >= 8192)
   16797:	83 7c 24 18 07       	cmpl   $0x7,0x18(%esp)
   1679c:	7f 11                	jg     167af <new_block+0xc9>
   1679e:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   167a3:	74 0a                	je     167af <new_block+0xc9>
   167a5:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   167ac:	00 
   167ad:	7e 0a                	jle    167b9 <new_block+0xd3>
		return 0;
   167af:	b8 00 00 00 00       	mov    $0x0,%eax
   167b4:	e9 f5 00 00 00       	jmp    168ae <new_block+0x1c8>
	// 接着设置找到的新逻辑块j对应逻辑块位图中的位.若对应位已经置位,则出错停机.否则置存在位图的对应缓冲区块已修改标志.因为
	// 逻辑块位图仅表示盘上数据区中逻辑块的占用情况,即逻辑块位图中位偏移值表示从数据区开始处算起的块号,因此这里需要加上数据
	// 区第1个逻辑块的块号,把j转换成逻辑块号.此时如果新逻辑块大于该设备上的总逻辑块数,则说明指定逻辑块在对应设备上不存在.
	// 申请失败,返回0退出.
	if (set_bit(j, bh->b_data))
   167b9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   167bd:	8b 08                	mov    (%eax),%ecx
   167bf:	b8 00 00 00 00       	mov    $0x0,%eax
   167c4:	8b 54 24 14          	mov    0x14(%esp),%edx
   167c8:	0f ab 11             	bts    %edx,(%ecx)
   167cb:	0f 92 c0             	setb   %al
   167ce:	85 c0                	test   %eax,%eax
   167d0:	74 12                	je     167e4 <new_block+0xfe>
		panic("new_block: bit already set");
   167d2:	83 ec 0c             	sub    $0xc,%esp
   167d5:	8d 83 1c 53 ff ff    	lea    -0xace4(%ebx),%eax
   167db:	50                   	push   %eax
   167dc:	e8 fd 2a ff ff       	call   92de <panic>
   167e1:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   167e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   167e8:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	j += i * 8192 + sb->s_firstdatazone - 1;
   167ec:	8b 44 24 18          	mov    0x18(%esp),%eax
   167f0:	c1 e0 0d             	shl    $0xd,%eax
   167f3:	89 c2                	mov    %eax,%edx
   167f5:	8b 44 24 10          	mov    0x10(%esp),%eax
   167f9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   167fd:	0f b7 c0             	movzwl %ax,%eax
   16800:	01 d0                	add    %edx,%eax
   16802:	83 e8 01             	sub    $0x1,%eax
   16805:	01 44 24 14          	add    %eax,0x14(%esp)
	if (j >= sb->s_nzones)
   16809:	8b 44 24 10          	mov    0x10(%esp),%eax
   1680d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   16811:	0f b7 c0             	movzwl %ax,%eax
   16814:	39 44 24 14          	cmp    %eax,0x14(%esp)
   16818:	7c 0a                	jl     16824 <new_block+0x13e>
		return 0;
   1681a:	b8 00 00 00 00       	mov    $0x0,%eax
   1681f:	e9 8a 00 00 00       	jmp    168ae <new_block+0x1c8>
	// 然后在高速缓冲区中为该设备上指定的逻辑块号取得一个缓冲块,并返回缓冲块头指针.
	// 因为刚取得的逻辑块其引用次数一定为1(getblk()中会设置),因此若不为1则停机.最后将新逻辑块清零,并设置其已更新标志和已
	// 修改标志.然后释放对应缓冲块,返回逻辑块号.
	if (!(bh = getblk(dev, j)))
   16824:	83 ec 08             	sub    $0x8,%esp
   16827:	ff 74 24 1c          	pushl  0x1c(%esp)
   1682b:	ff 74 24 3c          	pushl  0x3c(%esp)
   1682f:	e8 6d 9f ff ff       	call   107a1 <getblk>
   16834:	83 c4 10             	add    $0x10,%esp
   16837:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1683b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   16840:	75 12                	jne    16854 <new_block+0x16e>
		panic("new_block: cannot get block");
   16842:	83 ec 0c             	sub    $0xc,%esp
   16845:	8d 83 37 53 ff ff    	lea    -0xacc9(%ebx),%eax
   1684b:	50                   	push   %eax
   1684c:	e8 8d 2a ff ff       	call   92de <panic>
   16851:	83 c4 10             	add    $0x10,%esp
	if (bh->b_count != 1)
   16854:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16858:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   1685c:	3c 01                	cmp    $0x1,%al
   1685e:	74 12                	je     16872 <new_block+0x18c>
		panic("new block: count is != 1");
   16860:	83 ec 0c             	sub    $0xc,%esp
   16863:	8d 83 53 53 ff ff    	lea    -0xacad(%ebx),%eax
   16869:	50                   	push   %eax
   1686a:	e8 6f 2a ff ff       	call   92de <panic>
   1686f:	83 c4 10             	add    $0x10,%esp
	clear_block(bh->b_data);
   16872:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16876:	8b 00                	mov    (%eax),%eax
   16878:	89 c6                	mov    %eax,%esi
   1687a:	b8 00 00 00 00       	mov    $0x0,%eax
   1687f:	ba 00 01 00 00       	mov    $0x100,%edx
   16884:	89 d1                	mov    %edx,%ecx
   16886:	89 f7                	mov    %esi,%edi
   16888:	fc                   	cld    
   16889:	f3 ab                	rep stos %eax,%es:(%edi)
	bh->b_uptodate = 1;
   1688b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1688f:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
	bh->b_dirt = 1;
   16893:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16897:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   1689b:	83 ec 0c             	sub    $0xc,%esp
   1689e:	ff 74 24 28          	pushl  0x28(%esp)
   168a2:	e8 c4 a0 ff ff       	call   1096b <brelse>
   168a7:	83 c4 10             	add    $0x10,%esp
	return j;
   168aa:	8b 44 24 14          	mov    0x14(%esp),%eax
}
   168ae:	83 c4 20             	add    $0x20,%esp
   168b1:	5b                   	pop    %ebx
   168b2:	5e                   	pop    %esi
   168b3:	5f                   	pop    %edi
   168b4:	c3                   	ret    

000168b5 <free_inode>:

// 释放指定的i节点。
// 该函数首先判断参数给出的i节点号的有效性和可释放性。若i节点仍然在使用中则不能被释放。然后利用超级块信息对i节点位图进行
// 操作，复位i节点号对应的i节点位图中位，并清空i节点结构。
void free_inode(struct m_inode * inode)
{
   168b5:	53                   	push   %ebx
   168b6:	83 ec 18             	sub    $0x18,%esp
   168b9:	e8 3c 04 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   168be:	81 c3 42 b7 01 00    	add    $0x1b742,%ebx
	struct buffer_head * bh;

	// 首先判断参数给出的需要释放的i节点有效性或合法性。如果i节点指针=NULL，则退出。
	// 如果i节点上的设备号字段为0,说明该节点没有使用。于是用0清空对应i节点所占内存区并返回memset()定义在include/string.h
	// 处。这里表示用0填写inode指针指定处、长度是sizeof(*inode)的内存块。
	if (!inode)
   168c4:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   168c9:	0f 84 72 01 00 00    	je     16a41 <free_inode+0x18c>
		return;
	if (!inode->i_dev) {
   168cf:	8b 44 24 20          	mov    0x20(%esp),%eax
   168d3:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   168d7:	66 85 c0             	test   %ax,%ax
   168da:	75 15                	jne    168f1 <free_inode+0x3c>
		memset(inode, 0, sizeof(*inode));
   168dc:	6a 3c                	push   $0x3c
   168de:	6a 00                	push   $0x0
   168e0:	ff 74 24 28          	pushl  0x28(%esp)
   168e4:	e8 38 fc ff ff       	call   16521 <memset>
   168e9:	83 c4 0c             	add    $0xc,%esp
		return;
   168ec:	e9 51 01 00 00       	jmp    16a42 <free_inode+0x18d>
	}
	// 如果此i节点还有其他程序引用，则不释放，说明内核有问题，停机。如果文件连接数不为0,则表示还有其他文件目录项在使用该节点，
	// 因此也不应释放，而应该放回等。
	if (inode->i_count > 1) {
   168f1:	8b 44 24 20          	mov    0x20(%esp),%eax
   168f5:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   168f9:	66 83 f8 01          	cmp    $0x1,%ax
   168fd:	76 30                	jbe    1692f <free_inode+0x7a>
		printk("trying to free inode with count=%d\n", inode->i_count);
   168ff:	8b 44 24 20          	mov    0x20(%esp),%eax
   16903:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   16907:	0f b7 c0             	movzwl %ax,%eax
   1690a:	83 ec 08             	sub    $0x8,%esp
   1690d:	50                   	push   %eax
   1690e:	8d 83 6c 53 ff ff    	lea    -0xac94(%ebx),%eax
   16914:	50                   	push   %eax
   16915:	e8 18 2a ff ff       	call   9332 <printk>
   1691a:	83 c4 10             	add    $0x10,%esp
		panic("free_inode");
   1691d:	83 ec 0c             	sub    $0xc,%esp
   16920:	8d 83 90 53 ff ff    	lea    -0xac70(%ebx),%eax
   16926:	50                   	push   %eax
   16927:	e8 b2 29 ff ff       	call   92de <panic>
   1692c:	83 c4 10             	add    $0x10,%esp
	}
	if (inode->i_nlinks)
   1692f:	8b 44 24 20          	mov    0x20(%esp),%eax
   16933:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   16937:	84 c0                	test   %al,%al
   16939:	74 12                	je     1694d <free_inode+0x98>
		panic("trying to free inode with links");
   1693b:	83 ec 0c             	sub    $0xc,%esp
   1693e:	8d 83 9c 53 ff ff    	lea    -0xac64(%ebx),%eax
   16944:	50                   	push   %eax
   16945:	e8 94 29 ff ff       	call   92de <panic>
   1694a:	83 c4 10             	add    $0x10,%esp
	// 在判断完i节点的合理性之后，我们开始利用其超级块信息对其i节点位图进行操作。首先取i节点所在设备的超级块，测试设备是否存在。
	// 然后判断i节点号的范围是否正确，如果i节点号等于0或大于该设备上i节点总数，则出错（0号i节点保留没有使用）。如果该i节点对应
	// 的节点位图不存在，则出错。因为一个缓冲块的i节点位图有8192比特位。因此i_num>>13（即i_num/8192）可以得到当前i节点号所
	// 在的s_imap[]项，即所在盘块。
	if (!(sb = get_super(inode->i_dev)))
   1694d:	8b 44 24 20          	mov    0x20(%esp),%eax
   16951:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   16955:	0f b7 c0             	movzwl %ax,%eax
   16958:	83 ec 0c             	sub    $0xc,%esp
   1695b:	50                   	push   %eax
   1695c:	e8 45 a5 ff ff       	call   10ea6 <get_super>
   16961:	83 c4 10             	add    $0x10,%esp
   16964:	89 44 24 0c          	mov    %eax,0xc(%esp)
   16968:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1696d:	75 12                	jne    16981 <free_inode+0xcc>
		panic("trying to free inode on nonexistent device");
   1696f:	83 ec 0c             	sub    $0xc,%esp
   16972:	8d 83 bc 53 ff ff    	lea    -0xac44(%ebx),%eax
   16978:	50                   	push   %eax
   16979:	e8 60 29 ff ff       	call   92de <panic>
   1697e:	83 c4 10             	add    $0x10,%esp
	if (inode->i_num < 1 || inode->i_num > sb->s_ninodes)
   16981:	8b 44 24 20          	mov    0x20(%esp),%eax
   16985:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   16989:	66 85 c0             	test   %ax,%ax
   1698c:	74 14                	je     169a2 <free_inode+0xed>
   1698e:	8b 44 24 20          	mov    0x20(%esp),%eax
   16992:	0f b7 50 32          	movzwl 0x32(%eax),%edx
   16996:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1699a:	0f b7 00             	movzwl (%eax),%eax
   1699d:	66 39 c2             	cmp    %ax,%dx
   169a0:	76 12                	jbe    169b4 <free_inode+0xff>
		panic("trying to free inode 0 or nonexistant inode");
   169a2:	83 ec 0c             	sub    $0xc,%esp
   169a5:	8d 83 e8 53 ff ff    	lea    -0xac18(%ebx),%eax
   169ab:	50                   	push   %eax
   169ac:	e8 2d 29 ff ff       	call   92de <panic>
   169b1:	83 c4 10             	add    $0x10,%esp
	if (!(bh = sb->s_imap[inode->i_num >> 13]))
   169b4:	8b 44 24 20          	mov    0x20(%esp),%eax
   169b8:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   169bc:	66 c1 e8 0d          	shr    $0xd,%ax
   169c0:	0f b7 d0             	movzwl %ax,%edx
   169c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   169c7:	83 c2 04             	add    $0x4,%edx
   169ca:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   169ce:	89 44 24 08          	mov    %eax,0x8(%esp)
   169d2:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   169d7:	75 12                	jne    169eb <free_inode+0x136>
		panic("nonexistent imap in superblock");
   169d9:	83 ec 0c             	sub    $0xc,%esp
   169dc:	8d 83 14 54 ff ff    	lea    -0xabec(%ebx),%eax
   169e2:	50                   	push   %eax
   169e3:	e8 f6 28 ff ff       	call   92de <panic>
   169e8:	83 c4 10             	add    $0x10,%esp
	// 现在我们复位i节点对应的节点位图中的位。如果该位已经等于0,则显示出错警告信息。最后置i节点位图所在缓冲区已修改标志，并清空
	// 该i节点结构所占内存区。
	if (clear_bit(inode->i_num & 8191, bh->b_data))
   169eb:	8b 44 24 20          	mov    0x20(%esp),%eax
   169ef:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   169f3:	0f b7 c0             	movzwl %ax,%eax
   169f6:	25 ff 1f 00 00       	and    $0x1fff,%eax
   169fb:	89 c1                	mov    %eax,%ecx
   169fd:	8b 44 24 08          	mov    0x8(%esp),%eax
   16a01:	8b 10                	mov    (%eax),%edx
   16a03:	b8 00 00 00 00       	mov    $0x0,%eax
   16a08:	0f b3 0a             	btr    %ecx,(%edx)
   16a0b:	0f 93 c0             	setae  %al
   16a0e:	85 c0                	test   %eax,%eax
   16a10:	74 12                	je     16a24 <free_inode+0x16f>
		printk("free_inode: bit already cleared.\n\r");
   16a12:	83 ec 0c             	sub    $0xc,%esp
   16a15:	8d 83 34 54 ff ff    	lea    -0xabcc(%ebx),%eax
   16a1b:	50                   	push   %eax
   16a1c:	e8 11 29 ff ff       	call   9332 <printk>
   16a21:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   16a24:	8b 44 24 08          	mov    0x8(%esp),%eax
   16a28:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	memset(inode, 0, sizeof(*inode));
   16a2c:	83 ec 04             	sub    $0x4,%esp
   16a2f:	6a 3c                	push   $0x3c
   16a31:	6a 00                	push   $0x0
   16a33:	ff 74 24 2c          	pushl  0x2c(%esp)
   16a37:	e8 e5 fa ff ff       	call   16521 <memset>
   16a3c:	83 c4 10             	add    $0x10,%esp
   16a3f:	eb 01                	jmp    16a42 <free_inode+0x18d>
		return;
   16a41:	90                   	nop
}
   16a42:	83 c4 18             	add    $0x18,%esp
   16a45:	5b                   	pop    %ebx
   16a46:	c3                   	ret    

00016a47 <new_inode>:

// 为设备dev建立一个新i节点。初始化并返回该新i节点的指针。
// 在内存i节点表中获取一个空闲i节点表项，并从i节点位图中找一个空闲i节点。
struct m_inode * new_inode(int dev)
{
   16a47:	56                   	push   %esi
   16a48:	53                   	push   %ebx
   16a49:	83 ec 24             	sub    $0x24,%esp
   16a4c:	e8 a9 02 ff ff       	call   6cfa <__x86.get_pc_thunk.bx>
   16a51:	81 c3 af b5 01 00    	add    $0x1b5af,%ebx
	int i, j;

	// 首先从内在i节点表（inode_table）中获取一个空闲i节点项，并读取指定设备的超级块结构。然后扫描超级块中8块i节点位图，
	// 寻找第1个0位，寻找空闲节点，获取放置该i节点的节点号。如果全部扫描完还没找到，或者位图所在的缓冲块无效（bh = NULL）
	// 则放回先前申请的i节点表中的i节点，并返回空指针退出（没有空闲i节点）。
	if (!(inode = get_empty_inode()))
   16a57:	e8 14 90 ff ff       	call   fa70 <get_empty_inode>
   16a5c:	89 44 24 10          	mov    %eax,0x10(%esp)
   16a60:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   16a65:	75 0a                	jne    16a71 <new_inode+0x2a>
		return NULL;
   16a67:	b8 00 00 00 00       	mov    $0x0,%eax
   16a6c:	e9 d5 01 00 00       	jmp    16c46 <new_inode+0x1ff>
	if (!(sb = get_super(dev)))
   16a71:	83 ec 0c             	sub    $0xc,%esp
   16a74:	ff 74 24 3c          	pushl  0x3c(%esp)
   16a78:	e8 29 a4 ff ff       	call   10ea6 <get_super>
   16a7d:	83 c4 10             	add    $0x10,%esp
   16a80:	89 44 24 0c          	mov    %eax,0xc(%esp)
   16a84:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   16a89:	75 12                	jne    16a9d <new_inode+0x56>
		panic("new_inode with unknown device");
   16a8b:	83 ec 0c             	sub    $0xc,%esp
   16a8e:	8d 83 57 54 ff ff    	lea    -0xaba9(%ebx),%eax
   16a94:	50                   	push   %eax
   16a95:	e8 44 28 ff ff       	call   92de <panic>
   16a9a:	83 c4 10             	add    $0x10,%esp
	j = 8192;
   16a9d:	c7 44 24 14 00 20 00 	movl   $0x2000,0x14(%esp)
   16aa4:	00 
	for (i = 0 ; i < 8 ; i++)
   16aa5:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   16aac:	00 
   16aad:	eb 58                	jmp    16b07 <new_inode+0xc0>
		if (bh = sb->s_imap[i])
   16aaf:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16ab3:	8b 54 24 18          	mov    0x18(%esp),%edx
   16ab7:	83 c2 04             	add    $0x4,%edx
   16aba:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   16abe:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   16ac2:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   16ac7:	74 39                	je     16b02 <new_inode+0xbb>
			if ((j = find_first_zero(bh->b_data)) < 8192)
   16ac9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16acd:	8b 30                	mov    (%eax),%esi
   16acf:	b9 00 00 00 00       	mov    $0x0,%ecx
   16ad4:	fc                   	cld    
   16ad5:	ad                   	lods   %ds:(%esi),%eax
   16ad6:	f7 d0                	not    %eax
   16ad8:	0f bc d0             	bsf    %eax,%edx
   16adb:	74 04                	je     16ae1 <new_inode+0x9a>
   16add:	01 d1                	add    %edx,%ecx
   16adf:	eb 0b                	jmp    16aec <new_inode+0xa5>
   16ae1:	83 c1 20             	add    $0x20,%ecx
   16ae4:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
   16aea:	7c e9                	jl     16ad5 <new_inode+0x8e>
   16aec:	89 4c 24 08          	mov    %ecx,0x8(%esp)
   16af0:	8b 44 24 08          	mov    0x8(%esp),%eax
   16af4:	89 44 24 14          	mov    %eax,0x14(%esp)
   16af8:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   16aff:	00 
   16b00:	7e 0e                	jle    16b10 <new_inode+0xc9>
	for (i = 0 ; i < 8 ; i++)
   16b02:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   16b07:	83 7c 24 18 07       	cmpl   $0x7,0x18(%esp)
   16b0c:	7e a1                	jle    16aaf <new_inode+0x68>
   16b0e:	eb 01                	jmp    16b11 <new_inode+0xca>
				break;
   16b10:	90                   	nop
	if (!bh || j >= 8192 || j + i * 8192 > sb->s_ninodes) {
   16b11:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   16b16:	74 27                	je     16b3f <new_inode+0xf8>
   16b18:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   16b1f:	00 
   16b20:	7f 1d                	jg     16b3f <new_inode+0xf8>
   16b22:	8b 44 24 18          	mov    0x18(%esp),%eax
   16b26:	c1 e0 0d             	shl    $0xd,%eax
   16b29:	89 c2                	mov    %eax,%edx
   16b2b:	8b 44 24 14          	mov    0x14(%esp),%eax
   16b2f:	01 c2                	add    %eax,%edx
   16b31:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16b35:	0f b7 00             	movzwl (%eax),%eax
   16b38:	0f b7 c0             	movzwl %ax,%eax
   16b3b:	39 c2                	cmp    %eax,%edx
   16b3d:	7e 19                	jle    16b58 <new_inode+0x111>
		iput(inode);
   16b3f:	83 ec 0c             	sub    $0xc,%esp
   16b42:	ff 74 24 1c          	pushl  0x1c(%esp)
   16b46:	e8 57 8d ff ff       	call   f8a2 <iput>
   16b4b:	83 c4 10             	add    $0x10,%esp
		return NULL;
   16b4e:	b8 00 00 00 00       	mov    $0x0,%eax
   16b53:	e9 ee 00 00 00       	jmp    16c46 <new_inode+0x1ff>
	}
	// 现在我们已经找到了还未使用的i节点号j。于是置位i节点j对应的i节点位图相应比特位（如果已经置位，则出错）。然后置i节点
	// 位图所在缓冲块已修改标志。最后初始化该i节点结构（i_ctime是i节点内容改变时间）。
	if (set_bit(j, bh->b_data))
   16b58:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16b5c:	8b 08                	mov    (%eax),%ecx
   16b5e:	b8 00 00 00 00       	mov    $0x0,%eax
   16b63:	8b 54 24 14          	mov    0x14(%esp),%edx
   16b67:	0f ab 11             	bts    %edx,(%ecx)
   16b6a:	0f 92 c0             	setb   %al
   16b6d:	85 c0                	test   %eax,%eax
   16b6f:	74 12                	je     16b83 <new_inode+0x13c>
		panic("new_inode: bit already set");
   16b71:	83 ec 0c             	sub    $0xc,%esp
   16b74:	8d 83 75 54 ff ff    	lea    -0xab8b(%ebx),%eax
   16b7a:	50                   	push   %eax
   16b7b:	e8 5e 27 ff ff       	call   92de <panic>
   16b80:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   16b83:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16b87:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	inode->i_count = 1;               										// 引用计数。
   16b8b:	8b 44 24 10          	mov    0x10(%esp),%eax
   16b8f:	66 c7 40 34 01 00    	movw   $0x1,0x34(%eax)
	inode->i_nlinks = 1;              										// 文件目录项链接数。
   16b95:	8b 44 24 10          	mov    0x10(%esp),%eax
   16b99:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	inode->i_dev = dev;               										// i节点所在的设备号。
   16b9d:	8b 44 24 30          	mov    0x30(%esp),%eax
   16ba1:	89 c2                	mov    %eax,%edx
   16ba3:	8b 44 24 10          	mov    0x10(%esp),%eax
   16ba7:	66 89 50 30          	mov    %dx,0x30(%eax)
	inode->i_uid = current->euid;     										// i节点所属用户id。
   16bab:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   16bb1:	8b 00                	mov    (%eax),%eax
   16bb3:	0f b7 90 ce 02 00 00 	movzwl 0x2ce(%eax),%edx
   16bba:	8b 44 24 10          	mov    0x10(%esp),%eax
   16bbe:	66 89 50 02          	mov    %dx,0x2(%eax)
	inode->i_gid = current->egid;     										// 组id。
   16bc2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   16bc8:	8b 00                	mov    (%eax),%eax
   16bca:	0f b7 80 d4 02 00 00 	movzwl 0x2d4(%eax),%eax
   16bd1:	89 c2                	mov    %eax,%edx
   16bd3:	8b 44 24 10          	mov    0x10(%esp),%eax
   16bd7:	88 50 0c             	mov    %dl,0xc(%eax)
	inode->i_dirt = 1;                										// 已修改标志置位。
   16bda:	8b 44 24 10          	mov    0x10(%esp),%eax
   16bde:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	inode->i_num = j + i * 8192;      										// 对应设备中的i节点号。
   16be2:	8b 44 24 18          	mov    0x18(%esp),%eax
   16be6:	c1 e0 0d             	shl    $0xd,%eax
   16be9:	89 c2                	mov    %eax,%edx
   16beb:	8b 44 24 14          	mov    0x14(%esp),%eax
   16bef:	01 c2                	add    %eax,%edx
   16bf1:	8b 44 24 10          	mov    0x10(%esp),%eax
   16bf5:	66 89 50 32          	mov    %dx,0x32(%eax)
	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;        // 设置时间。
   16bf9:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   16bff:	8b 10                	mov    (%eax),%edx
   16c01:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   16c07:	8b 00                	mov    (%eax),%eax
   16c09:	01 d0                	add    %edx,%eax
   16c0b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   16c10:	f7 e2                	mul    %edx
   16c12:	c1 ea 05             	shr    $0x5,%edx
   16c15:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   16c1b:	8b 00                	mov    (%eax),%eax
   16c1d:	01 c2                	add    %eax,%edx
   16c1f:	8b 44 24 10          	mov    0x10(%esp),%eax
   16c23:	89 50 2c             	mov    %edx,0x2c(%eax)
   16c26:	8b 44 24 10          	mov    0x10(%esp),%eax
   16c2a:	8b 50 2c             	mov    0x2c(%eax),%edx
   16c2d:	8b 44 24 10          	mov    0x10(%esp),%eax
   16c31:	89 50 28             	mov    %edx,0x28(%eax)
   16c34:	8b 44 24 10          	mov    0x10(%esp),%eax
   16c38:	8b 50 28             	mov    0x28(%eax),%edx
   16c3b:	8b 44 24 10          	mov    0x10(%esp),%eax
   16c3f:	89 50 08             	mov    %edx,0x8(%eax)
	return inode;                   										// 返回该i节点指针。
   16c42:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   16c46:	83 c4 24             	add    $0x24,%esp
   16c49:	5b                   	pop    %ebx
   16c4a:	5e                   	pop    %esi
   16c4b:	c3                   	ret    

00016c4c <dupfd>:

// 复制文件句柄(文件描述符).
// 参数fd是欲复制的文件句柄,arg指定新文件句柄的最小数值.
// 返回新文件句柄或出错码.
static int dupfd(unsigned int fd, unsigned int arg)
{
   16c4c:	56                   	push   %esi
   16c4d:	53                   	push   %ebx
   16c4e:	e8 9f 00 ff ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   16c53:	05 ad b3 01 00       	add    $0x1b3ad,%eax
	// 首先检查函数参数的有效性.如果文件句柄值大于一个程序最多打开文件数NR_OPEN,或者该句柄的文件结构不存在,则返回出错码并退出.如果指定的新
	// 句柄值arg大于最多打开文件数,也返回出错码并退出.注意,实际上文件句柄就是进程文件结构指针数组项索引号.
	if (fd >= NR_OPEN || !current->filp[fd])
   16c58:	83 7c 24 0c 13       	cmpl   $0x13,0xc(%esp)
   16c5d:	77 1a                	ja     16c79 <dupfd+0x2d>
   16c5f:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16c65:	8b 12                	mov    (%edx),%edx
   16c67:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   16c6b:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
   16c71:	8b 54 8a 08          	mov    0x8(%edx,%ecx,4),%edx
   16c75:	85 d2                	test   %edx,%edx
   16c77:	75 0a                	jne    16c83 <dupfd+0x37>
		return -EBADF;
   16c79:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   16c7e:	e9 c2 00 00 00       	jmp    16d45 <dupfd+0xf9>
	if (arg >= NR_OPEN)
   16c83:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   16c88:	76 29                	jbe    16cb3 <dupfd+0x67>
		return -EINVAL;
   16c8a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   16c8f:	e9 b1 00 00 00       	jmp    16d45 <dupfd+0xf9>
	// 然后在当前进程的文件结构指针数组中寻找索引号等于或大于arg,但还没有使用的项.若找到的新句柄值arg大于最多打开文件数(即没有空闲项),则返回
	// 出错码并退出.
	while (arg < NR_OPEN)
		if (current->filp[arg])
   16c94:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16c9a:	8b 12                	mov    (%edx),%edx
   16c9c:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   16ca0:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
   16ca6:	8b 54 8a 08          	mov    0x8(%edx,%ecx,4),%edx
   16caa:	85 d2                	test   %edx,%edx
   16cac:	74 0e                	je     16cbc <dupfd+0x70>
			arg++;
   16cae:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
	while (arg < NR_OPEN)
   16cb3:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   16cb8:	76 da                	jbe    16c94 <dupfd+0x48>
   16cba:	eb 01                	jmp    16cbd <dupfd+0x71>
		else
			break;
   16cbc:	90                   	nop
	if (arg >= NR_OPEN)
   16cbd:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   16cc2:	76 07                	jbe    16ccb <dupfd+0x7f>
		return -EMFILE;
   16cc4:	b8 e8 ff ff ff       	mov    $0xffffffe8,%eax
   16cc9:	eb 7a                	jmp    16d45 <dupfd+0xf9>
	// 否则针对找到的空闲项(句柄),在执行时关闭标志位图close_on_exec中复位该句柄位.即在运行exec()类函数时,不会关闭用dup()创建的的句柄.并令该
	// 文件结构指针等于原句柄fd的指针,并且将文件引用数增1.最后返回新的文件句柄arg.
	current->close_on_exec &= ~(1 << arg);
   16ccb:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16cd1:	8b 12                	mov    (%edx),%edx
   16cd3:	8b 9a 44 03 00 00    	mov    0x344(%edx),%ebx
   16cd9:	8b 54 24 10          	mov    0x10(%esp),%edx
   16cdd:	be 01 00 00 00       	mov    $0x1,%esi
   16ce2:	89 d1                	mov    %edx,%ecx
   16ce4:	d3 e6                	shl    %cl,%esi
   16ce6:	89 f2                	mov    %esi,%edx
   16ce8:	f7 d2                	not    %edx
   16cea:	89 d1                	mov    %edx,%ecx
   16cec:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16cf2:	8b 12                	mov    (%edx),%edx
   16cf4:	21 d9                	and    %ebx,%ecx
   16cf6:	89 8a 44 03 00 00    	mov    %ecx,0x344(%edx)
	(current->filp[arg] = current->filp[fd])->f_count++;
   16cfc:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16d02:	8b 12                	mov    (%edx),%edx
   16d04:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   16d0a:	8b 00                	mov    (%eax),%eax
   16d0c:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   16d10:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
   16d16:	8b 54 8a 08          	mov    0x8(%edx,%ecx,4),%edx
   16d1a:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   16d1e:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
   16d24:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
   16d28:	8b 54 24 10          	mov    0x10(%esp),%edx
   16d2c:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   16d32:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   16d36:	0f b7 50 04          	movzwl 0x4(%eax),%edx
   16d3a:	83 c2 01             	add    $0x1,%edx
   16d3d:	66 89 50 04          	mov    %dx,0x4(%eax)
	return arg;
   16d41:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   16d45:	5b                   	pop    %ebx
   16d46:	5e                   	pop    %esi
   16d47:	c3                   	ret    

00016d48 <sys_dup2>:
// 复制文件句柄系统调用。
// 复制指定文件句柄oldfd，新文件句柄值等于newfd。如果newfd已打开，则首先关闭之。
// 参数：oldfd -- 原文件句柄；newfd - 新文件句柄。
// 返回新文件句柄值。
int sys_dup2(unsigned int oldfd, unsigned int newfd)
{
   16d48:	53                   	push   %ebx
   16d49:	83 ec 08             	sub    $0x8,%esp
   16d4c:	e8 a1 ff fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   16d51:	05 af b2 01 00       	add    $0x1b2af,%eax
	sys_close(newfd);               						// 若句柄newfd已经打开，则首先关闭之。
   16d56:	8b 54 24 14          	mov    0x14(%esp),%edx
   16d5a:	83 ec 0c             	sub    $0xc,%esp
   16d5d:	52                   	push   %edx
   16d5e:	89 c3                	mov    %eax,%ebx
   16d60:	e8 38 7f ff ff       	call   ec9d <sys_close>
   16d65:	83 c4 10             	add    $0x10,%esp
	return dupfd(oldfd, newfd);      						// 复制并返回新句柄。
   16d68:	83 ec 08             	sub    $0x8,%esp
   16d6b:	ff 74 24 1c          	pushl  0x1c(%esp)
   16d6f:	ff 74 24 1c          	pushl  0x1c(%esp)
   16d73:	e8 d4 fe ff ff       	call   16c4c <dupfd>
   16d78:	83 c4 10             	add    $0x10,%esp
}
   16d7b:	83 c4 08             	add    $0x8,%esp
   16d7e:	5b                   	pop    %ebx
   16d7f:	c3                   	ret    

00016d80 <sys_dup>:
// 复制文件句柄系统调用.
// 复制指定文件句柄oldfd,新句柄的值是当前最小的未用句柄值.
// 参数:fildes -- 被复制的文件句柄.
// 返回新文件句柄值.
int sys_dup(unsigned int fildes)
{
   16d80:	e8 6d ff fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   16d85:	05 7b b2 01 00       	add    $0x1b27b,%eax
	return dupfd(fildes, 0);
   16d8a:	6a 00                	push   $0x0
   16d8c:	ff 74 24 08          	pushl  0x8(%esp)
   16d90:	e8 b7 fe ff ff       	call   16c4c <dupfd>
   16d95:	83 c4 08             	add    $0x8,%esp
}
   16d98:	c3                   	ret    

00016d99 <sys_fcntl>:
// arg是新文件句可取的最小值；对于设置文件操作和访问标志命令F_SETFL，arg是新的文件操作和访问模式。对于文件上锁命令
// F_GETLK、F_SETLK和F_SETLKW，arg是指向flock结构的指针。但本内核中没有实现文件上锁功能。
// 返回：若出错，则所有操作都返回-1.若成功，那么F_DUPFD返回新文件句柄；F_GETFD返回文件句柄的当前执行时关闭标志
// close_on_exec；F_GETFL返回文件操作和访问标志。
int sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg)
{
   16d99:	56                   	push   %esi
   16d9a:	53                   	push   %ebx
   16d9b:	83 ec 10             	sub    $0x10,%esp
   16d9e:	e8 4f ff fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   16da3:	05 5d b2 01 00       	add    $0x1b25d,%eax
	struct file * filp;

	// 首先检查给出的文件句柄有效性。然后根据不同命令cmd进行分别处理。如果文件句柄值大于一个进程最多打开文件数NR_OPEN，或者
	// 该句柄的文件结构指针为空，则返回出错码并退出。
	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
   16da8:	83 7c 24 1c 13       	cmpl   $0x13,0x1c(%esp)
   16dad:	77 21                	ja     16dd0 <sys_fcntl+0x37>
   16daf:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16db5:	8b 12                	mov    (%edx),%edx
   16db7:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   16dbb:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
   16dc1:	8b 54 8a 08          	mov    0x8(%edx,%ecx,4),%edx
   16dc5:	89 54 24 0c          	mov    %edx,0xc(%esp)
   16dc9:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   16dce:	75 0a                	jne    16dda <sys_fcntl+0x41>
		return -EBADF;
   16dd0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   16dd5:	e9 12 01 00 00       	jmp    16eec <.L27+0xc>
	switch (cmd) {
   16dda:	83 7c 24 20 07       	cmpl   $0x7,0x20(%esp)
   16ddf:	0f 87 02 01 00 00    	ja     16ee7 <.L27+0x7>
   16de5:	8b 54 24 20          	mov    0x20(%esp),%edx
   16de9:	c1 e2 02             	shl    $0x2,%edx
   16dec:	8b 94 02 90 54 ff ff 	mov    -0xab70(%edx,%eax,1),%edx
   16df3:	01 c2                	add    %eax,%edx
   16df5:	ff e2                	jmp    *%edx

00016df7 <.L21>:
		case F_DUPFD:   										// 复制文件句柄。
			return dupfd(fd,arg);
   16df7:	ff 74 24 24          	pushl  0x24(%esp)
   16dfb:	ff 74 24 20          	pushl  0x20(%esp)
   16dff:	e8 48 fe ff ff       	call   16c4c <dupfd>
   16e04:	83 c4 08             	add    $0x8,%esp
   16e07:	e9 e0 00 00 00       	jmp    16eec <.L27+0xc>

00016e0c <.L23>:
		case F_GETFD:   										// 取文件句柄的执行时关闭标志。
			return (current->close_on_exec >> fd) & 1;
   16e0c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   16e12:	8b 00                	mov    (%eax),%eax
   16e14:	8b 90 44 03 00 00    	mov    0x344(%eax),%edx
   16e1a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16e1e:	89 c1                	mov    %eax,%ecx
   16e20:	d3 ea                	shr    %cl,%edx
   16e22:	89 d0                	mov    %edx,%eax
   16e24:	83 e0 01             	and    $0x1,%eax
   16e27:	e9 c0 00 00 00       	jmp    16eec <.L27+0xc>

00016e2c <.L24>:
		case F_SETFD:   										// 设置执行时关闭标志。arg位0置位是设置，否则关闭。
			if (arg & 1)
   16e2c:	8b 54 24 24          	mov    0x24(%esp),%edx
   16e30:	83 e2 01             	and    $0x1,%edx
   16e33:	85 d2                	test   %edx,%edx
   16e35:	74 2f                	je     16e66 <.L24+0x3a>
				current->close_on_exec |= (1 << fd);
   16e37:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16e3d:	8b 12                	mov    (%edx),%edx
   16e3f:	8b 9a 44 03 00 00    	mov    0x344(%edx),%ebx
   16e45:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   16e49:	be 01 00 00 00       	mov    $0x1,%esi
   16e4e:	89 d1                	mov    %edx,%ecx
   16e50:	d3 e6                	shl    %cl,%esi
   16e52:	89 f2                	mov    %esi,%edx
   16e54:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   16e5a:	8b 00                	mov    (%eax),%eax
   16e5c:	09 da                	or     %ebx,%edx
   16e5e:	89 90 44 03 00 00    	mov    %edx,0x344(%eax)
   16e64:	eb 2f                	jmp    16e95 <.L24+0x69>
			else
				current->close_on_exec &= ~(1 << fd);
   16e66:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16e6c:	8b 12                	mov    (%edx),%edx
   16e6e:	8b 9a 44 03 00 00    	mov    0x344(%edx),%ebx
   16e74:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   16e78:	be 01 00 00 00       	mov    $0x1,%esi
   16e7d:	89 d1                	mov    %edx,%ecx
   16e7f:	d3 e6                	shl    %cl,%esi
   16e81:	89 f2                	mov    %esi,%edx
   16e83:	f7 d2                	not    %edx
   16e85:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   16e8b:	8b 00                	mov    (%eax),%eax
   16e8d:	21 da                	and    %ebx,%edx
   16e8f:	89 90 44 03 00 00    	mov    %edx,0x344(%eax)
			return 0;
   16e95:	b8 00 00 00 00       	mov    $0x0,%eax
   16e9a:	eb 50                	jmp    16eec <.L27+0xc>

00016e9c <.L25>:
		case F_GETFL:   										// 取文件状态标志和访问模式。
			return filp->f_flags;
   16e9c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16ea0:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   16ea4:	0f b7 c0             	movzwl %ax,%eax
   16ea7:	eb 43                	jmp    16eec <.L27+0xc>

00016ea9 <.L26>:
		case F_SETFL:   										// 设置文件状态和访问模式（根据arg设置添加、非阻塞标志）。
			filp->f_flags &= ~(O_APPEND | O_NONBLOCK);
   16ea9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16ead:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   16eb1:	80 e4 f3             	and    $0xf3,%ah
   16eb4:	89 c2                	mov    %eax,%edx
   16eb6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16eba:	66 89 50 02          	mov    %dx,0x2(%eax)
			filp->f_flags |= arg & (O_APPEND | O_NONBLOCK);
   16ebe:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16ec2:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   16ec6:	8b 54 24 24          	mov    0x24(%esp),%edx
   16eca:	66 81 e2 00 0c       	and    $0xc00,%dx
   16ecf:	09 c2                	or     %eax,%edx
   16ed1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16ed5:	66 89 50 02          	mov    %dx,0x2(%eax)
			return 0;
   16ed9:	b8 00 00 00 00       	mov    $0x0,%eax
   16ede:	eb 0c                	jmp    16eec <.L27+0xc>

00016ee0 <.L27>:
		case F_GETLK:	case F_SETLK:	case F_SETLKW:  		// 未实现。
			return -1;
   16ee0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16ee5:	eb 05                	jmp    16eec <.L27+0xc>
		default:
			return -1;
   16ee7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
   16eec:	83 c4 10             	add    $0x10,%esp
   16eef:	5b                   	pop    %ebx
   16ef0:	5e                   	pop    %esi
   16ef1:	c3                   	ret    

00016ef2 <sys_ioctl>:
// 该函数首先判断参数给出的文件描述符是否有效。然后根据对应i节点中文件属性判断文件类型，并根据具体文件类型调用相关
// 的处理函数。
// 参数：fd - 文件描述符； cmd - 命令码； arg - 参数。
// 返回：成功则返回0,否则返回出错码。
int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
{
   16ef2:	53                   	push   %ebx
   16ef3:	83 ec 18             	sub    $0x18,%esp
   16ef6:	e8 f7 fd fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   16efb:	05 05 b1 01 00       	add    $0x1b105,%eax
	struct file * filp;
	int dev, mode;

	// 首先判断给出的文件描述符的有效性。如果文件描述符超出可打开的文件数，或者对应描述符的文件结构指针为空，则返回出错
	// 码退出。
	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
   16f00:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
   16f05:	77 21                	ja     16f28 <sys_ioctl+0x36>
   16f07:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   16f0d:	8b 12                	mov    (%edx),%edx
   16f0f:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   16f13:	81 c1 d0 00 00 00    	add    $0xd0,%ecx
   16f19:	8b 54 8a 08          	mov    0x8(%edx,%ecx,4),%edx
   16f1d:	89 54 24 0c          	mov    %edx,0xc(%esp)
   16f21:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   16f26:	75 0a                	jne    16f32 <sys_ioctl+0x40>
		return -EBADF;
   16f28:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   16f2d:	e9 ec 00 00 00       	jmp    1701e <sys_ioctl+0x12c>
	// 如果文件结构对应的是管道i节点，则根据进程是否有权操作该管道确定是否执行管道IO控制操作。若有权执行则调用pipe_ioctl()，
	// 否则返回无效文件错误码。
	if (filp->f_inode->i_pipe)
   16f32:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16f36:	8b 52 08             	mov    0x8(%edx),%edx
   16f39:	0f b6 52 38          	movzbl 0x38(%edx),%edx
   16f3d:	84 d2                	test   %dl,%dl
   16f3f:	74 3f                	je     16f80 <sys_ioctl+0x8e>
		return (filp->f_mode & 1) ? pipe_ioctl(filp->f_inode, cmd, arg) : -EBADF;
   16f41:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16f45:	0f b7 12             	movzwl (%edx),%edx
   16f48:	0f b7 d2             	movzwl %dx,%edx
   16f4b:	83 e2 01             	and    $0x1,%edx
   16f4e:	85 d2                	test   %edx,%edx
   16f50:	74 24                	je     16f76 <sys_ioctl+0x84>
   16f52:	8b 5c 24 28          	mov    0x28(%esp),%ebx
   16f56:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   16f5a:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16f5e:	8b 52 08             	mov    0x8(%edx),%edx
   16f61:	83 ec 04             	sub    $0x4,%esp
   16f64:	53                   	push   %ebx
   16f65:	51                   	push   %ecx
   16f66:	52                   	push   %edx
   16f67:	89 c3                	mov    %eax,%ebx
   16f69:	e8 32 d1 ff ff       	call   140a0 <pipe_ioctl>
   16f6e:	83 c4 10             	add    $0x10,%esp
   16f71:	e9 a8 00 00 00       	jmp    1701e <sys_ioctl+0x12c>
   16f76:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   16f7b:	e9 9e 00 00 00       	jmp    1701e <sys_ioctl+0x12c>
	// 对于其他类型文件，取对应文件的属性，并据此判断文件的类型。如果该文件即不是字符设备文件，也不是块设备文件，则返回
	// 出错码退出。若是字符或块设备文件，则从文件的i节点中取设备号。如果设备号大于系统现有的设备数，则返回出错号。
	mode = filp->f_inode->i_mode;
   16f80:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16f84:	8b 52 08             	mov    0x8(%edx),%edx
   16f87:	0f b7 12             	movzwl (%edx),%edx
   16f8a:	0f b7 d2             	movzwl %dx,%edx
   16f8d:	89 54 24 08          	mov    %edx,0x8(%esp)
	if (!S_ISCHR(mode) && !S_ISBLK(mode))
   16f91:	8b 54 24 08          	mov    0x8(%esp),%edx
   16f95:	81 e2 00 f0 00 00    	and    $0xf000,%edx
   16f9b:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
   16fa1:	74 19                	je     16fbc <sys_ioctl+0xca>
   16fa3:	8b 54 24 08          	mov    0x8(%esp),%edx
   16fa7:	81 e2 00 f0 00 00    	and    $0xf000,%edx
   16fad:	81 fa 00 60 00 00    	cmp    $0x6000,%edx
   16fb3:	74 07                	je     16fbc <sys_ioctl+0xca>
		return -EINVAL;
   16fb5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   16fba:	eb 62                	jmp    1701e <sys_ioctl+0x12c>
	dev = filp->f_inode->i_zone[0];
   16fbc:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16fc0:	8b 52 08             	mov    0x8(%edx),%edx
   16fc3:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
   16fc7:	0f b7 d2             	movzwl %dx,%edx
   16fca:	89 54 24 04          	mov    %edx,0x4(%esp)
	if (MAJOR(dev) >= NRDEVS)
   16fce:	8b 54 24 04          	mov    0x4(%esp),%edx
   16fd2:	c1 ea 08             	shr    $0x8,%edx
   16fd5:	83 fa 07             	cmp    $0x7,%edx
   16fd8:	76 07                	jbe    16fe1 <sys_ioctl+0xef>
		return -ENODEV;
   16fda:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   16fdf:	eb 3d                	jmp    1701e <sys_ioctl+0x12c>
	// 然后根据IO控制表ioctl_table查得对应设备的ioctl函数指针，并调用该函数。如果该设备在ioctl函数指针表中没有对应函数，
	// 则返回出错码。
	if (!ioctl_table[MAJOR(dev)])
   16fe1:	8b 54 24 04          	mov    0x4(%esp),%edx
   16fe5:	c1 ea 08             	shr    $0x8,%edx
   16fe8:	8b 94 90 20 14 00 00 	mov    0x1420(%eax,%edx,4),%edx
   16fef:	85 d2                	test   %edx,%edx
   16ff1:	75 07                	jne    16ffa <sys_ioctl+0x108>
		return -ENOTTY;
   16ff3:	b8 e7 ff ff ff       	mov    $0xffffffe7,%eax
   16ff8:	eb 24                	jmp    1701e <sys_ioctl+0x12c>
	return ioctl_table[MAJOR(dev)](dev, cmd, arg);
   16ffa:	8b 54 24 04          	mov    0x4(%esp),%edx
   16ffe:	c1 ea 08             	shr    $0x8,%edx
   17001:	8b 84 90 20 14 00 00 	mov    0x1420(%eax,%edx,4),%eax
   17008:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   1700c:	8b 54 24 24          	mov    0x24(%esp),%edx
   17010:	83 ec 04             	sub    $0x4,%esp
   17013:	51                   	push   %ecx
   17014:	52                   	push   %edx
   17015:	ff 74 24 10          	pushl  0x10(%esp)
   17019:	ff d0                	call   *%eax
   1701b:	83 c4 10             	add    $0x10,%esp
}
   1701e:	83 c4 18             	add    $0x18,%esp
   17021:	5b                   	pop    %ebx
   17022:	c3                   	ret    

00017023 <free_ind>:
#include <sys/stat.h>           								// 文件状态头文件。含有文件或文件系统状态结构stat{}和常量。

// 释放所有一次间接块。（内部函数）
// 参数dev是文件系统所有设备的设备号；block是逻辑块号。成功则返回1，否则返回0。
static int free_ind(int dev, int block)
{
   17023:	53                   	push   %ebx
   17024:	83 ec 18             	sub    $0x18,%esp
   17027:	e8 ce fc fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1702c:	81 c3 d4 af 01 00    	add    $0x1afd4,%ebx
	int i;
	int block_busy;

	// 首先判断参数的有效性。如果逻辑块号为0,则返回。然后读取一次间接块，并释放其上表明使用的所有逻辑块，然后
	// 释放该一次间接块的缓冲块。函数free_block()用于释放设备上指定逻辑块号的磁盘块（fs/bitmap.c）。
	if (!block)
   17032:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   17037:	75 0a                	jne    17043 <free_ind+0x20>
		return 1;
   17039:	b8 01 00 00 00       	mov    $0x1,%eax
   1703e:	e9 bf 00 00 00       	jmp    17102 <free_ind+0xdf>
	block_busy = 0;
   17043:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   1704a:	00 
	if (bh = bread(dev, block)) {
   1704b:	83 ec 08             	sub    $0x8,%esp
   1704e:	ff 74 24 2c          	pushl  0x2c(%esp)
   17052:	ff 74 24 2c          	pushl  0x2c(%esp)
   17056:	e8 77 99 ff ff       	call   109d2 <bread>
   1705b:	83 c4 10             	add    $0x10,%esp
   1705e:	89 04 24             	mov    %eax,(%esp)
   17061:	83 3c 24 00          	cmpl   $0x0,(%esp)
   17065:	74 7a                	je     170e1 <free_ind+0xbe>
		p = (unsigned short *) bh->b_data;              		// 指向缓冲块数据区。
   17067:	8b 04 24             	mov    (%esp),%eax
   1706a:	8b 00                	mov    (%eax),%eax
   1706c:	89 44 24 0c          	mov    %eax,0xc(%esp)
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可有512个块号。
   17070:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   17077:	00 
   17078:	eb 4e                	jmp    170c8 <free_ind+0xa5>
			if (*p)
   1707a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1707e:	0f b7 00             	movzwl (%eax),%eax
   17081:	66 85 c0             	test   %ax,%ax
   17084:	74 38                	je     170be <free_ind+0x9b>
				if (free_block(dev, *p)) {       				// 释放指定的设备逻辑块。
   17086:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1708a:	0f b7 00             	movzwl (%eax),%eax
   1708d:	0f b7 c0             	movzwl %ax,%eax
   17090:	83 ec 08             	sub    $0x8,%esp
   17093:	50                   	push   %eax
   17094:	ff 74 24 2c          	pushl  0x2c(%esp)
   17098:	e8 b5 f4 ff ff       	call   16552 <free_block>
   1709d:	83 c4 10             	add    $0x10,%esp
   170a0:	85 c0                	test   %eax,%eax
   170a2:	74 12                	je     170b6 <free_ind+0x93>
					*p = 0;                 					// 清零。
   170a4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   170a8:	66 c7 00 00 00       	movw   $0x0,(%eax)
					bh->b_dirt = 1;         					// 设置已修改标志。
   170ad:	8b 04 24             	mov    (%esp),%eax
   170b0:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
   170b4:	eb 08                	jmp    170be <free_ind+0x9b>
				} else
					block_busy = 1;         					// 设置逻辑块没有释放标志。
   170b6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   170bd:	00 
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可有512个块号。
   170be:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   170c3:	83 44 24 0c 02       	addl   $0x2,0xc(%esp)
   170c8:	81 7c 24 08 ff 01 00 	cmpl   $0x1ff,0x8(%esp)
   170cf:	00 
   170d0:	7e a8                	jle    1707a <free_ind+0x57>
		brelse(bh);                                     		// 然后释放间接块占用的缓冲块。
   170d2:	83 ec 0c             	sub    $0xc,%esp
   170d5:	ff 74 24 0c          	pushl  0xc(%esp)
   170d9:	e8 8d 98 ff ff       	call   1096b <brelse>
   170de:	83 c4 10             	add    $0x10,%esp
	}
	// 最后释放设备上的一次间接块。但如果其中有逻辑块没有被释放，则返回0（失败）。
	if (block_busy)
   170e1:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   170e6:	74 07                	je     170ef <free_ind+0xcc>
		return 0;
   170e8:	b8 00 00 00 00       	mov    $0x0,%eax
   170ed:	eb 13                	jmp    17102 <free_ind+0xdf>
	else
		return free_block(dev, block);                   		// 成功则返回1,否则返回0.
   170ef:	83 ec 08             	sub    $0x8,%esp
   170f2:	ff 74 24 2c          	pushl  0x2c(%esp)
   170f6:	ff 74 24 2c          	pushl  0x2c(%esp)
   170fa:	e8 53 f4 ff ff       	call   16552 <free_block>
   170ff:	83 c4 10             	add    $0x10,%esp
}
   17102:	83 c4 18             	add    $0x18,%esp
   17105:	5b                   	pop    %ebx
   17106:	c3                   	ret    

00017107 <free_dind>:

// 释放所有二次间接块。
// 参数dev是文件系统所在设备的设备号；block是逻辑块号。
static int free_dind(int dev, int block)
{
   17107:	53                   	push   %ebx
   17108:	83 ec 18             	sub    $0x18,%esp
   1710b:	e8 ea fb fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   17110:	81 c3 f0 ae 01 00    	add    $0x1aef0,%ebx
	int i;
	int block_busy;                                         	// 在逻辑块没有被释放的标志。

	// 首先判断参数的有效性。如果逻辑块号为0,则返回。然后读取二次间接块的一级块，并释放其上表明使用的所有逻辑块，
	// 然后释放该一级块的缓冲块。
	if (!block)
   17116:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   1711b:	75 0a                	jne    17127 <free_dind+0x20>
		return 1;
   1711d:	b8 01 00 00 00       	mov    $0x1,%eax
   17122:	e9 bf 00 00 00       	jmp    171e6 <free_dind+0xdf>
	block_busy = 0;
   17127:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   1712e:	00 
	if (bh = bread(dev, block)) {
   1712f:	83 ec 08             	sub    $0x8,%esp
   17132:	ff 74 24 2c          	pushl  0x2c(%esp)
   17136:	ff 74 24 2c          	pushl  0x2c(%esp)
   1713a:	e8 93 98 ff ff       	call   109d2 <bread>
   1713f:	83 c4 10             	add    $0x10,%esp
   17142:	89 04 24             	mov    %eax,(%esp)
   17145:	83 3c 24 00          	cmpl   $0x0,(%esp)
   17149:	74 7a                	je     171c5 <free_dind+0xbe>
		p = (unsigned short *) bh->b_data;              		// 指向缓冲块数据区。
   1714b:	8b 04 24             	mov    (%esp),%eax
   1714e:	8b 00                	mov    (%eax),%eax
   17150:	89 44 24 0c          	mov    %eax,0xc(%esp)
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可连接512个二级块。
   17154:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   1715b:	00 
   1715c:	eb 4e                	jmp    171ac <free_dind+0xa5>
			if (*p)
   1715e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17162:	0f b7 00             	movzwl (%eax),%eax
   17165:	66 85 c0             	test   %ax,%ax
   17168:	74 38                	je     171a2 <free_dind+0x9b>
				if (free_ind(dev, *p)) {         				// 释放所有一次间接块。
   1716a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1716e:	0f b7 00             	movzwl (%eax),%eax
   17171:	0f b7 c0             	movzwl %ax,%eax
   17174:	83 ec 08             	sub    $0x8,%esp
   17177:	50                   	push   %eax
   17178:	ff 74 24 2c          	pushl  0x2c(%esp)
   1717c:	e8 a2 fe ff ff       	call   17023 <free_ind>
   17181:	83 c4 10             	add    $0x10,%esp
   17184:	85 c0                	test   %eax,%eax
   17186:	74 12                	je     1719a <free_dind+0x93>
					*p = 0;                 					// 清零。
   17188:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1718c:	66 c7 00 00 00       	movw   $0x0,(%eax)
					bh->b_dirt = 1;         					// 设置已修改标志。
   17191:	8b 04 24             	mov    (%esp),%eax
   17194:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
   17198:	eb 08                	jmp    171a2 <free_dind+0x9b>
				} else
					block_busy = 1;         					// 设置逻辑块没有释放标志。
   1719a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   171a1:	00 
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可连接512个二级块。
   171a2:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   171a7:	83 44 24 0c 02       	addl   $0x2,0xc(%esp)
   171ac:	81 7c 24 08 ff 01 00 	cmpl   $0x1ff,0x8(%esp)
   171b3:	00 
   171b4:	7e a8                	jle    1715e <free_dind+0x57>
		brelse(bh);                                     		// 释放二次间接块占用的缓冲块。
   171b6:	83 ec 0c             	sub    $0xc,%esp
   171b9:	ff 74 24 0c          	pushl  0xc(%esp)
   171bd:	e8 a9 97 ff ff       	call   1096b <brelse>
   171c2:	83 c4 10             	add    $0x10,%esp
	}
	// 最后释放设备上的二次间接块。但如果其中有逻辑块没有被释放，则返回0（失败）。
	if (block_busy)
   171c5:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   171ca:	74 07                	je     171d3 <free_dind+0xcc>
		return 0;
   171cc:	b8 00 00 00 00       	mov    $0x0,%eax
   171d1:	eb 13                	jmp    171e6 <free_dind+0xdf>
	else
		return free_block(dev, block);							// 最后释放存放第一间接块的逻辑块
   171d3:	83 ec 08             	sub    $0x8,%esp
   171d6:	ff 74 24 2c          	pushl  0x2c(%esp)
   171da:	ff 74 24 2c          	pushl  0x2c(%esp)
   171de:	e8 6f f3 ff ff       	call   16552 <free_block>
   171e3:	83 c4 10             	add    $0x10,%esp
}
   171e6:	83 c4 18             	add    $0x18,%esp
   171e9:	5b                   	pop    %ebx
   171ea:	c3                   	ret    

000171eb <truncate>:

// 截断文件数据函数。
// 将节点对应的文件长度减0,并释放战胜的设备空间。
void truncate(struct m_inode * inode)
{
   171eb:	53                   	push   %ebx
   171ec:	83 ec 18             	sub    $0x18,%esp
   171ef:	e8 06 fb fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   171f4:	81 c3 0c ae 01 00    	add    $0x1ae0c,%ebx
	int i;
	int block_busy;                 							// 有逻辑块没有被释放的标志。

	// 首先判断指定i节点有效性。如果不是常规文件、目录文件或链接项，则返回。
	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
   171fa:	8b 44 24 20          	mov    0x20(%esp),%eax
   171fe:	0f b7 00             	movzwl (%eax),%eax
   17201:	0f b7 c0             	movzwl %ax,%eax
   17204:	25 00 f0 00 00       	and    $0xf000,%eax
   17209:	3d 00 80 00 00       	cmp    $0x8000,%eax
   1720e:	74 30                	je     17240 <truncate+0x55>
   17210:	8b 44 24 20          	mov    0x20(%esp),%eax
   17214:	0f b7 00             	movzwl (%eax),%eax
   17217:	0f b7 c0             	movzwl %ax,%eax
   1721a:	25 00 f0 00 00       	and    $0xf000,%eax
   1721f:	3d 00 40 00 00       	cmp    $0x4000,%eax
   17224:	74 1a                	je     17240 <truncate+0x55>
	     S_ISLNK(inode->i_mode)))
   17226:	8b 44 24 20          	mov    0x20(%esp),%eax
   1722a:	0f b7 00             	movzwl (%eax),%eax
   1722d:	0f b7 c0             	movzwl %ax,%eax
   17230:	25 00 f0 00 00       	and    $0xf000,%eax
	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
   17235:	3d 00 a0 00 00       	cmp    $0xa000,%eax
   1723a:	0f 85 5c 01 00 00    	jne    1739c <truncate+0x1b1>
		return;
	// 然后释放i节点的7个直接逻辑块，并将这7个逻辑块项全置零。函数free_block()用于释放设备上指定逻辑块的磁盘块
	// （fs/bitmap.c）。若有逻辑块忙而没有被释放则置块忙标志block_busy。
repeat:
   17240:	90                   	nop
	block_busy = 0;
   17241:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   17248:	00 
	for (i = 0; i < 7; i++)
   17249:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   17250:	00 
   17251:	eb 5c                	jmp    172af <truncate+0xc4>
		if (inode->i_zone[i]) {                 				// 如果块号不为0，则释放之。
   17253:	8b 44 24 20          	mov    0x20(%esp),%eax
   17257:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1725b:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
   17260:	66 85 c0             	test   %ax,%ax
   17263:	74 45                	je     172aa <truncate+0xbf>
			if (free_block(inode->i_dev, inode->i_zone[i]))
   17265:	8b 44 24 20          	mov    0x20(%esp),%eax
   17269:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1726d:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
   17272:	0f b7 d0             	movzwl %ax,%edx
   17275:	8b 44 24 20          	mov    0x20(%esp),%eax
   17279:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   1727d:	0f b7 c0             	movzwl %ax,%eax
   17280:	83 ec 08             	sub    $0x8,%esp
   17283:	52                   	push   %edx
   17284:	50                   	push   %eax
   17285:	e8 c8 f2 ff ff       	call   16552 <free_block>
   1728a:	83 c4 10             	add    $0x10,%esp
   1728d:	85 c0                	test   %eax,%eax
   1728f:	74 11                	je     172a2 <truncate+0xb7>
				inode->i_zone[i] = 0;     						// 块指针置0。
   17291:	8b 44 24 20          	mov    0x20(%esp),%eax
   17295:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17299:	66 c7 44 50 0e 00 00 	movw   $0x0,0xe(%eax,%edx,2)
   172a0:	eb 08                	jmp    172aa <truncate+0xbf>
			else
				block_busy = 1;         						// 若没有释放掉则置标志。
   172a2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   172a9:	00 
	for (i = 0; i < 7; i++)
   172aa:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   172af:	83 7c 24 0c 06       	cmpl   $0x6,0xc(%esp)
   172b4:	7e 9d                	jle    17253 <truncate+0x68>
		}
	if (free_ind(inode->i_dev, inode->i_zone[7]))    			// 释放所有一次间接块。
   172b6:	8b 44 24 20          	mov    0x20(%esp),%eax
   172ba:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   172be:	0f b7 d0             	movzwl %ax,%edx
   172c1:	8b 44 24 20          	mov    0x20(%esp),%eax
   172c5:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   172c9:	0f b7 c0             	movzwl %ax,%eax
   172cc:	83 ec 08             	sub    $0x8,%esp
   172cf:	52                   	push   %edx
   172d0:	50                   	push   %eax
   172d1:	e8 4d fd ff ff       	call   17023 <free_ind>
   172d6:	83 c4 10             	add    $0x10,%esp
   172d9:	85 c0                	test   %eax,%eax
   172db:	74 0c                	je     172e9 <truncate+0xfe>
		inode->i_zone[7] = 0;                   				// 块指针置0。
   172dd:	8b 44 24 20          	mov    0x20(%esp),%eax
   172e1:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%eax)
   172e7:	eb 08                	jmp    172f1 <truncate+0x106>
	else
		block_busy = 1;                         				// 若没有释放掉则置标志。
   172e9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   172f0:	00 
	if (free_dind(inode->i_dev, inode->i_zone[8]))   			// 释放所有二次间接块。
   172f1:	8b 44 24 20          	mov    0x20(%esp),%eax
   172f5:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
   172f9:	0f b7 d0             	movzwl %ax,%edx
   172fc:	8b 44 24 20          	mov    0x20(%esp),%eax
   17300:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   17304:	0f b7 c0             	movzwl %ax,%eax
   17307:	83 ec 08             	sub    $0x8,%esp
   1730a:	52                   	push   %edx
   1730b:	50                   	push   %eax
   1730c:	e8 f6 fd ff ff       	call   17107 <free_dind>
   17311:	83 c4 10             	add    $0x10,%esp
   17314:	85 c0                	test   %eax,%eax
   17316:	74 0c                	je     17324 <truncate+0x139>
		inode->i_zone[8] = 0;                   				// 块指针置0。
   17318:	8b 44 24 20          	mov    0x20(%esp),%eax
   1731c:	66 c7 40 1e 00 00    	movw   $0x0,0x1e(%eax)
   17322:	eb 08                	jmp    1732c <truncate+0x141>
	else
		block_busy = 1;                         				// 若没有释放掉则置标志。
   17324:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   1732b:	00 
	// 此后设置i节点已修改标志，并且如果还有逻辑块由于 “忙”而没有被释放，则把当前进程运行时间片置0,以让当前进程先被
	// 切换去运行其他进程，稍等一会再重新执行释放操作。
	inode->i_dirt = 1;
   1732c:	8b 44 24 20          	mov    0x20(%esp),%eax
   17330:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	if (block_busy) {
   17334:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   17339:	74 19                	je     17354 <truncate+0x169>
		current->counter = 0;           						// 当前进程时间片置0。
   1733b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17341:	8b 00                	mov    (%eax),%eax
   17343:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		schedule();
   1734a:	e8 fc fb fe ff       	call   6f4b <schedule>
		goto repeat;
   1734f:	e9 ed fe ff ff       	jmp    17241 <truncate+0x56>
	}
	inode->i_size = 0;                      					// 文件大小置零。
   17354:	8b 44 24 20          	mov    0x20(%esp),%eax
   17358:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	// 最后重新置文件修改时间和i节点改变时间为当前时间。宏CURRENT_TIME定义在头文件include/linux/sched.h中，定义
	// 为（startup_time+jiffies/HZ）。用于取得从1970:0:0:0开始到现在为止经过的秒数。
	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
   1735f:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   17365:	8b 10                	mov    (%eax),%edx
   17367:	c7 c0 88 3b 03 00    	mov    $0x33b88,%eax
   1736d:	8b 00                	mov    (%eax),%eax
   1736f:	01 d0                	add    %edx,%eax
   17371:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   17376:	f7 e2                	mul    %edx
   17378:	c1 ea 05             	shr    $0x5,%edx
   1737b:	c7 c0 84 3b 03 00    	mov    $0x33b84,%eax
   17381:	8b 00                	mov    (%eax),%eax
   17383:	01 c2                	add    %eax,%edx
   17385:	8b 44 24 20          	mov    0x20(%esp),%eax
   17389:	89 50 2c             	mov    %edx,0x2c(%eax)
   1738c:	8b 44 24 20          	mov    0x20(%esp),%eax
   17390:	8b 50 2c             	mov    0x2c(%eax),%edx
   17393:	8b 44 24 20          	mov    0x20(%esp),%eax
   17397:	89 50 08             	mov    %edx,0x8(%eax)
   1739a:	eb 01                	jmp    1739d <truncate+0x1b2>
		return;
   1739c:	90                   	nop
}
   1739d:	83 c4 18             	add    $0x18,%esp
   173a0:	5b                   	pop    %ebx
   173a1:	c3                   	ret    

000173a2 <get_fs_long>:
{
   173a2:	83 ec 10             	sub    $0x10,%esp
   173a5:	e8 48 f9 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   173aa:	05 56 ac 01 00       	add    $0x1ac56,%eax
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   173af:	8b 44 24 14          	mov    0x14(%esp),%eax
   173b3:	64 8b 00             	mov    %fs:(%eax),%eax
   173b6:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
   173ba:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   173be:	83 c4 10             	add    $0x10,%esp
   173c1:	c3                   	ret    

000173c2 <put_fs_long>:
{
   173c2:	e8 2b f9 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   173c7:	05 39 ac 01 00       	add    $0x1ac39,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   173cc:	8b 44 24 04          	mov    0x4(%esp),%eax
   173d0:	8b 54 24 08          	mov    0x8(%esp),%edx
   173d4:	64 89 02             	mov    %eax,%fs:(%edx)
}
   173d7:	90                   	nop
   173d8:	c3                   	ret    

000173d9 <add_wait>:
} select_table;

// 把未准备好描述符的等待队列指针加入等待表wait_table中。参数*wait_address是与描述符相关的等待队列头指针。例如tty读缓冲队
// 列secondary的等待队列头指针是proc_list。参数p是do_select()中定义的等待表结构指针。
static void add_wait(struct task_struct ** wait_address, select_table * p)
{
   173d9:	53                   	push   %ebx
   173da:	83 ec 10             	sub    $0x10,%esp
   173dd:	e8 10 f9 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   173e2:	05 1e ac 01 00       	add    $0x1ac1e,%eax
	int i;

	// 首先判断描述符是否有对应的等待队列，若无则返回。然后在等待表中搜索参数指定的等待队列指针是否已经在等待表中设置过，若设置过也
	// 立刻返回。这个判断主要是针对管道文件描述符。例如若一个管道在等待可以进行读操作，那么其必定可以立刻进行写操作。
	if (!wait_address)
   173e7:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   173ec:	74 72                	je     17460 <add_wait+0x87>
		return;
	for (i = 0 ; i < p->nr ; i++)
   173ee:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   173f5:	00 
   173f6:	eb 17                	jmp    1740f <add_wait+0x36>
		if (p->entry[i].wait_address == wait_address)
   173f8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   173fc:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   17400:	8b 54 ca 08          	mov    0x8(%edx,%ecx,8),%edx
   17404:	39 54 24 18          	cmp    %edx,0x18(%esp)
   17408:	74 59                	je     17463 <add_wait+0x8a>
	for (i = 0 ; i < p->nr ; i++)
   1740a:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1740f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   17413:	8b 12                	mov    (%edx),%edx
   17415:	39 54 24 0c          	cmp    %edx,0xc(%esp)
   17419:	7c dd                	jl     173f8 <add_wait+0x1f>
			return;
	// 然后我们把描述符对应等待队列的头指针保存在等待表wait_table中，同时让等待表项的old_task字段指向等待队列头指针指向的任务（若
	// 无则为NULL），在让等待队列头指针指向当前任务。最后把等待表有效项计数值nr增1（其在第179行初始化为0）。
	p->entry[p->nr].wait_address = wait_address;
   1741b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1741f:	8b 0a                	mov    (%edx),%ecx
   17421:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   17425:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   17429:	89 5c ca 08          	mov    %ebx,0x8(%edx,%ecx,8)
	p->entry[p->nr].old_task = * wait_address;
   1742d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   17431:	8b 0a                	mov    (%edx),%ecx
   17433:	8b 54 24 18          	mov    0x18(%esp),%edx
   17437:	8b 1a                	mov    (%edx),%ebx
   17439:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1743d:	89 5c ca 04          	mov    %ebx,0x4(%edx,%ecx,8)
	*wait_address = current;
   17441:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17447:	8b 10                	mov    (%eax),%edx
   17449:	8b 44 24 18          	mov    0x18(%esp),%eax
   1744d:	89 10                	mov    %edx,(%eax)
	p->nr++;
   1744f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17453:	8b 00                	mov    (%eax),%eax
   17455:	8d 50 01             	lea    0x1(%eax),%edx
   17458:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1745c:	89 10                	mov    %edx,(%eax)
   1745e:	eb 04                	jmp    17464 <add_wait+0x8b>
		return;
   17460:	90                   	nop
   17461:	eb 01                	jmp    17464 <add_wait+0x8b>
			return;
   17463:	90                   	nop
}
   17464:	83 c4 10             	add    $0x10,%esp
   17467:	5b                   	pop    %ebx
   17468:	c3                   	ret    

00017469 <free_wait>:

// 清空等待表。参数是等待表结构指针。本函数在do_select()函数中睡眠后被唤醒返回时被调用，用于唤醒等待表中处于各个等待队列上的其他
// 任务，它与kernel/sched.c中sleep_on()函数的后半部分代码几乎完全相同，请参考对sleep_on()函数的说明。
static void free_wait(select_table * p)
{
   17469:	53                   	push   %ebx
   1746a:	83 ec 18             	sub    $0x18,%esp
   1746d:	e8 88 f8 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   17472:	81 c3 8e ab 01 00    	add    $0x1ab8e,%ebx
	struct task_struct ** tpp;

	// 如果等待表中各项（共nr个有效项）记录的等待队列头指针表明还有其他后来添加进的等待任务（例如其他进程调用sleep_on()函数而睡眠在该
	// 等待队列上），则此时等待队列头指针指向的不是当前进程，那么我们就需要先唤醒这些任务。操作方法是将等待队列头所指任务先置为就绪状态
	// （state = 0），并把自己设置为不可中断等待状态，即自己要等待这些后续进队列的任务被唤醒而执行时来唤醒本任务。然后重新执行调度程序。
	for (i = 0; i < p->nr ; i++) {
   17478:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1747f:	00 
   17480:	e9 96 00 00 00       	jmp    1751b <free_wait+0xb2>
		tpp = p->entry[i].wait_address;
   17485:	8b 44 24 20          	mov    0x20(%esp),%eax
   17489:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1748d:	8b 44 d0 08          	mov    0x8(%eax,%edx,8),%eax
   17491:	89 44 24 08          	mov    %eax,0x8(%esp)
		while (*tpp && *tpp != current) {
   17495:	eb 1f                	jmp    174b6 <free_wait+0x4d>
			(*tpp)->state = 0;
   17497:	8b 44 24 08          	mov    0x8(%esp),%eax
   1749b:	8b 00                	mov    (%eax),%eax
   1749d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			current->state = TASK_UNINTERRUPTIBLE;
   174a3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   174a9:	8b 00                	mov    (%eax),%eax
   174ab:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			schedule();
   174b1:	e8 95 fa fe ff       	call   6f4b <schedule>
		while (*tpp && *tpp != current) {
   174b6:	8b 44 24 08          	mov    0x8(%esp),%eax
   174ba:	8b 00                	mov    (%eax),%eax
   174bc:	85 c0                	test   %eax,%eax
   174be:	74 12                	je     174d2 <free_wait+0x69>
   174c0:	8b 44 24 08          	mov    0x8(%esp),%eax
   174c4:	8b 10                	mov    (%eax),%edx
   174c6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   174cc:	8b 00                	mov    (%eax),%eax
   174ce:	39 c2                	cmp    %eax,%edx
   174d0:	75 c5                	jne    17497 <free_wait+0x2e>
		}
		// 执行到这里，说明等待表当前处理项中的等待队列头指针字段wait_address指向当前任务，若它为空，则表明调度有问题，于是显示警告信息。
		// 然后我们让等待队列头指针指向在我们前面进入队列的任务（第76行）。若此时该头指针确实指向一个任务而不是NULL，则说明队列中还有任务（
		// *tpp不为空），于是将该任务设置成就绪状态，唤醒之。最后把等待表的有效表项计数字段nr清零。
		if (!*tpp)
   174d2:	8b 44 24 08          	mov    0x8(%esp),%eax
   174d6:	8b 00                	mov    (%eax),%eax
   174d8:	85 c0                	test   %eax,%eax
   174da:	75 12                	jne    174ee <free_wait+0x85>
			printk("free_wait: NULL");
   174dc:	83 ec 0c             	sub    $0xc,%esp
   174df:	8d 83 b0 54 ff ff    	lea    -0xab50(%ebx),%eax
   174e5:	50                   	push   %eax
   174e6:	e8 47 1e ff ff       	call   9332 <printk>
   174eb:	83 c4 10             	add    $0x10,%esp
		if (*tpp = p->entry[i].old_task)
   174ee:	8b 44 24 20          	mov    0x20(%esp),%eax
   174f2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   174f6:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   174fa:	8b 44 24 08          	mov    0x8(%esp),%eax
   174fe:	89 10                	mov    %edx,(%eax)
   17500:	8b 44 24 08          	mov    0x8(%esp),%eax
   17504:	8b 00                	mov    (%eax),%eax
   17506:	85 c0                	test   %eax,%eax
   17508:	74 0c                	je     17516 <free_wait+0xad>
			(**tpp).state = 0;
   1750a:	8b 44 24 08          	mov    0x8(%esp),%eax
   1750e:	8b 00                	mov    (%eax),%eax
   17510:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	for (i = 0; i < p->nr ; i++) {
   17516:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1751b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1751f:	8b 00                	mov    (%eax),%eax
   17521:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   17525:	0f 8c 5a ff ff ff    	jl     17485 <free_wait+0x1c>
	}
	p->nr = 0;
   1752b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1752f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   17535:	90                   	nop
   17536:	83 c4 18             	add    $0x18,%esp
   17539:	5b                   	pop    %ebx
   1753a:	c3                   	ret    

0001753b <get_tty>:

// 根据文件i节点判断文件是不是字符终端设备文件。若是则返回其tty结构指针，否则返回NULL。
static struct tty_struct * get_tty(struct m_inode * inode)
{
   1753b:	83 ec 10             	sub    $0x10,%esp
   1753e:	e8 af f7 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   17543:	05 bd aa 01 00       	add    $0x1aabd,%eax
	int major, minor;

	// 如果不是字符设备文件则返回NULL。如果主设备号不是5（控制终端）或4，则返回NULL。
	if (!S_ISCHR(inode->i_mode))
   17548:	8b 54 24 14          	mov    0x14(%esp),%edx
   1754c:	0f b7 12             	movzwl (%edx),%edx
   1754f:	0f b7 d2             	movzwl %dx,%edx
   17552:	81 e2 00 f0 00 00    	and    $0xf000,%edx
   17558:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
   1755e:	74 0a                	je     1756a <get_tty+0x2f>
		return NULL;
   17560:	b8 00 00 00 00       	mov    $0x0,%eax
   17565:	e9 af 00 00 00       	jmp    17619 <get_tty+0xde>
	if ((major = MAJOR(inode->i_zone[0])) != 5 && major != 4)
   1756a:	8b 54 24 14          	mov    0x14(%esp),%edx
   1756e:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
   17572:	66 c1 ea 08          	shr    $0x8,%dx
   17576:	0f b7 d2             	movzwl %dx,%edx
   17579:	89 54 24 08          	mov    %edx,0x8(%esp)
   1757d:	83 7c 24 08 05       	cmpl   $0x5,0x8(%esp)
   17582:	74 11                	je     17595 <get_tty+0x5a>
   17584:	83 7c 24 08 04       	cmpl   $0x4,0x8(%esp)
   17589:	74 0a                	je     17595 <get_tty+0x5a>
		return NULL;
   1758b:	b8 00 00 00 00       	mov    $0x0,%eax
   17590:	e9 84 00 00 00       	jmp    17619 <get_tty+0xde>
	// 如果主设备号是5，那么其终端设备号等于进程的tty字段值，否则就等于字符设备文件次设备号。如果终端设备号小于0,表示进程没有
	// 控制终端或没有使用终端，于是返回NULL。否则返回对应的tty结构指针。
	if (major == 5)
   17595:	83 7c 24 08 05       	cmpl   $0x5,0x8(%esp)
   1759a:	75 14                	jne    175b0 <get_tty+0x75>
		minor = current->tty;
   1759c:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   175a2:	8b 12                	mov    (%edx),%edx
   175a4:	8b 92 2c 03 00 00    	mov    0x32c(%edx),%edx
   175aa:	89 54 24 0c          	mov    %edx,0xc(%esp)
   175ae:	eb 15                	jmp    175c5 <get_tty+0x8a>
	else
		minor = MINOR(inode->i_zone[0]);
   175b0:	8b 54 24 14          	mov    0x14(%esp),%edx
   175b4:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
   175b8:	0f b7 d2             	movzwl %dx,%edx
   175bb:	81 e2 ff 00 00 00    	and    $0xff,%edx
   175c1:	89 54 24 0c          	mov    %edx,0xc(%esp)
	if (minor < 0)
   175c5:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   175ca:	79 07                	jns    175d3 <get_tty+0x98>
		return NULL;
   175cc:	b8 00 00 00 00       	mov    $0x0,%eax
   175d1:	eb 46                	jmp    17619 <get_tty+0xde>
	return TTY_TABLE(minor);
   175d3:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   175d8:	74 2c                	je     17606 <get_tty+0xcb>
   175da:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
   175df:	7f 14                	jg     175f5 <get_tty+0xba>
   175e1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   175e5:	83 ea 01             	sub    $0x1,%edx
   175e8:	c1 e2 06             	shl    $0x6,%edx
   175eb:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   175f1:	01 d0                	add    %edx,%eax
   175f3:	eb 24                	jmp    17619 <get_tty+0xde>
   175f5:	8b 54 24 0c          	mov    0xc(%esp),%edx
   175f9:	c1 e2 06             	shl    $0x6,%edx
   175fc:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   17602:	01 d0                	add    %edx,%eax
   17604:	eb 13                	jmp    17619 <get_tty+0xde>
   17606:	c7 c2 00 63 03 00    	mov    $0x36300,%edx
   1760c:	8b 12                	mov    (%edx),%edx
   1760e:	c1 e2 06             	shl    $0x6,%edx
   17611:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   17617:	01 d0                	add    %edx,%eax
}
   17619:	83 c4 10             	add    $0x10,%esp
   1761c:	c3                   	ret    

0001761d <check_in>:
 * check_XX函数用于检查一个文件。我们知道该文件要么是管道文件、要么是字符设备文件，或者要么是一个FIFO（FIFO）还未实现。
 */
// 检查读文件操作是否准备好，即终端读缓冲队列secondary是否有字符可读，或者管道文件是否不空。参数wait是等待表指针；inode
// 是文件i节点指针。若描述符可进行读操作则返回1,否则返回0。
static int check_in(select_table * wait, struct m_inode * inode)
{
   1761d:	83 ec 10             	sub    $0x10,%esp
   17620:	e8 cd f6 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   17625:	05 db a9 01 00       	add    $0x1a9db,%eax

	// 首先根据文件i节点调用get_tty()检测文件是不是一个tty终端（字符）设备文件，如果是则检查该终端读缓冲队列secondary中是否有
	// 字符可供读取，若有则返回1，若此时secondary为空则把当前任务添加到secondary的等待队列proc_list上并返回0。如果是管道文件
	// 则判断目前管道中是否有字符可读，若有则返回1，若没有（管道空）则把当前任务添加到管道i节点的等待队列上并返回0。注意，PIPE_-
	// EMPTY()宏使用管道当前头尾指针位置来判断管道是否为空。管道i节点的i_zone[0]和i_zone[1]字段分别存放着管道当前的头尾指针。
	if (tty = get_tty(inode))
   1762a:	ff 74 24 18          	pushl  0x18(%esp)
   1762e:	e8 08 ff ff ff       	call   1753b <get_tty>
   17633:	83 c4 04             	add    $0x4,%esp
   17636:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1763a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1763f:	74 38                	je     17679 <check_in+0x5c>
		if (!EMPTY(tty->secondary))
   17641:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17645:	8b 40 3c             	mov    0x3c(%eax),%eax
   17648:	8b 50 04             	mov    0x4(%eax),%edx
   1764b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1764f:	8b 40 3c             	mov    0x3c(%eax),%eax
   17652:	8b 40 08             	mov    0x8(%eax),%eax
   17655:	39 c2                	cmp    %eax,%edx
   17657:	74 07                	je     17660 <check_in+0x43>
			return 1;
   17659:	b8 01 00 00 00       	mov    $0x1,%eax
   1765e:	eb 5a                	jmp    176ba <check_in+0x9d>
		else
			add_wait(&tty->secondary->proc_list, wait);
   17660:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17664:	8b 40 3c             	mov    0x3c(%eax),%eax
   17667:	83 c0 0c             	add    $0xc,%eax
   1766a:	ff 74 24 14          	pushl  0x14(%esp)
   1766e:	50                   	push   %eax
   1766f:	e8 65 fd ff ff       	call   173d9 <add_wait>
   17674:	83 c4 08             	add    $0x8,%esp
   17677:	eb 3c                	jmp    176b5 <check_in+0x98>
	else if (inode->i_pipe)
   17679:	8b 44 24 18          	mov    0x18(%esp),%eax
   1767d:	0f b6 40 38          	movzbl 0x38(%eax),%eax
   17681:	84 c0                	test   %al,%al
   17683:	74 30                	je     176b5 <check_in+0x98>
		if (!PIPE_EMPTY(*inode))
   17685:	8b 44 24 18          	mov    0x18(%esp),%eax
   17689:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
   1768d:	8b 44 24 18          	mov    0x18(%esp),%eax
   17691:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   17695:	66 39 c2             	cmp    %ax,%dx
   17698:	74 07                	je     176a1 <check_in+0x84>
			return 1;
   1769a:	b8 01 00 00 00       	mov    $0x1,%eax
   1769f:	eb 19                	jmp    176ba <check_in+0x9d>
		else
			add_wait(&inode->i_wait, wait);
   176a1:	8b 44 24 18          	mov    0x18(%esp),%eax
   176a5:	83 c0 20             	add    $0x20,%eax
   176a8:	ff 74 24 14          	pushl  0x14(%esp)
   176ac:	50                   	push   %eax
   176ad:	e8 27 fd ff ff       	call   173d9 <add_wait>
   176b2:	83 c4 08             	add    $0x8,%esp
	return 0;
   176b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   176ba:	83 c4 10             	add    $0x10,%esp
   176bd:	c3                   	ret    

000176be <check_out>:

// 检查文件写操作是否准备好，即终端写缓冲队列write_q中是否还有空闲位置可写，或者此时管道文件是否不满。参数wait是等待表指针；
// inode是文件i节点指针。若描述符可进行写操作则返回1，否则返回0。
static int check_out(select_table * wait, struct m_inode * inode)
{
   176be:	83 ec 10             	sub    $0x10,%esp
   176c1:	e8 2c f6 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   176c6:	05 3a a9 01 00       	add    $0x1a93a,%eax
	struct tty_struct * tty;

	// 首先根据文件i节点调用get_tty()检测文件是不是一个tty终端（字符）设备文件，如果是则检查该终端写缓冲队列write_q中是否有空间
	// 可写入，若有则返回1,若没有空间则把当前任务添加到write_q等待队列proc_list上并返回0。如果是管道文件则判断目前管道中是否有
	// 空闲空间可写入字符，若有则返回1，若没有（管道满）则把当前任务添加到管道i节点的等待队列上并返回0。
	if (tty = get_tty(inode))
   176cb:	ff 74 24 18          	pushl  0x18(%esp)
   176cf:	e8 67 fe ff ff       	call   1753b <get_tty>
   176d4:	83 c4 04             	add    $0x4,%esp
   176d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
   176db:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   176e0:	74 44                	je     17726 <check_out+0x68>
		if (!FULL(tty->write_q))
   176e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   176e6:	8b 40 38             	mov    0x38(%eax),%eax
   176e9:	8b 50 08             	mov    0x8(%eax),%edx
   176ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
   176f0:	8b 40 38             	mov    0x38(%eax),%eax
   176f3:	8b 40 04             	mov    0x4(%eax),%eax
   176f6:	29 c2                	sub    %eax,%edx
   176f8:	89 d0                	mov    %edx,%eax
   176fa:	83 e8 01             	sub    $0x1,%eax
   176fd:	25 ff 03 00 00       	and    $0x3ff,%eax
   17702:	85 c0                	test   %eax,%eax
   17704:	74 07                	je     1770d <check_out+0x4f>
			return 1;
   17706:	b8 01 00 00 00       	mov    $0x1,%eax
   1770b:	eb 68                	jmp    17775 <check_out+0xb7>
		else
			add_wait(&tty->write_q->proc_list, wait);
   1770d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17711:	8b 40 38             	mov    0x38(%eax),%eax
   17714:	83 c0 0c             	add    $0xc,%eax
   17717:	ff 74 24 14          	pushl  0x14(%esp)
   1771b:	50                   	push   %eax
   1771c:	e8 b8 fc ff ff       	call   173d9 <add_wait>
   17721:	83 c4 08             	add    $0x8,%esp
   17724:	eb 4a                	jmp    17770 <check_out+0xb2>
	else if (inode->i_pipe)
   17726:	8b 44 24 18          	mov    0x18(%esp),%eax
   1772a:	0f b6 40 38          	movzbl 0x38(%eax),%eax
   1772e:	84 c0                	test   %al,%al
   17730:	74 3e                	je     17770 <check_out+0xb2>
		if (!PIPE_FULL(*inode))
   17732:	8b 44 24 18          	mov    0x18(%esp),%eax
   17736:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
   1773a:	8b 44 24 18          	mov    0x18(%esp),%eax
   1773e:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   17742:	29 c2                	sub    %eax,%edx
   17744:	89 d0                	mov    %edx,%eax
   17746:	0f b7 c0             	movzwl %ax,%eax
   17749:	25 ff 0f 00 00       	and    $0xfff,%eax
   1774e:	3d ff 0f 00 00       	cmp    $0xfff,%eax
   17753:	74 07                	je     1775c <check_out+0x9e>
			return 1;
   17755:	b8 01 00 00 00       	mov    $0x1,%eax
   1775a:	eb 19                	jmp    17775 <check_out+0xb7>
		else
			add_wait(&inode->i_wait, wait);
   1775c:	8b 44 24 18          	mov    0x18(%esp),%eax
   17760:	83 c0 20             	add    $0x20,%eax
   17763:	ff 74 24 14          	pushl  0x14(%esp)
   17767:	50                   	push   %eax
   17768:	e8 6c fc ff ff       	call   173d9 <add_wait>
   1776d:	83 c4 08             	add    $0x8,%esp
	return 0;
   17770:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17775:	83 c4 10             	add    $0x10,%esp
   17778:	c3                   	ret    

00017779 <check_ex>:

// 检查文件是否处于异常状态。对于终端设备文件，目前内核总是返回0。对于管道文件，如果此时两个管道描述符中有一个或都已被关闭，则
// 返回1，否则就把当前任务添加到管道i节点的等待队列上并返回0。返回0。参数wait等待表指针；inode是文件i节点指针。若出现异常条件
// 则返回1，否则返回0。
static int check_ex(select_table * wait, struct m_inode * inode)
{
   17779:	83 ec 10             	sub    $0x10,%esp
   1777c:	e8 71 f5 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   17781:	05 7f a8 01 00       	add    $0x1a87f,%eax
	struct tty_struct * tty;

	if (tty = get_tty(inode))
   17786:	ff 74 24 18          	pushl  0x18(%esp)
   1778a:	e8 ac fd ff ff       	call   1753b <get_tty>
   1778f:	83 c4 04             	add    $0x4,%esp
   17792:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17796:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1779b:	74 32                	je     177cf <check_ex+0x56>
		if (!FULL(tty->write_q))
   1779d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   177a1:	8b 40 38             	mov    0x38(%eax),%eax
   177a4:	8b 50 08             	mov    0x8(%eax),%edx
   177a7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   177ab:	8b 40 38             	mov    0x38(%eax),%eax
   177ae:	8b 40 04             	mov    0x4(%eax),%eax
   177b1:	29 c2                	sub    %eax,%edx
   177b3:	89 d0                	mov    %edx,%eax
   177b5:	83 e8 01             	sub    $0x1,%eax
   177b8:	25 ff 03 00 00       	and    $0x3ff,%eax
   177bd:	85 c0                	test   %eax,%eax
   177bf:	74 07                	je     177c8 <check_ex+0x4f>
			return 0;
   177c1:	b8 00 00 00 00       	mov    $0x0,%eax
   177c6:	eb 41                	jmp    17809 <check_ex+0x90>
		else
			return 0;
   177c8:	b8 00 00 00 00       	mov    $0x0,%eax
   177cd:	eb 3a                	jmp    17809 <check_ex+0x90>
	else if (inode->i_pipe)
   177cf:	8b 44 24 18          	mov    0x18(%esp),%eax
   177d3:	0f b6 40 38          	movzbl 0x38(%eax),%eax
   177d7:	84 c0                	test   %al,%al
   177d9:	74 29                	je     17804 <check_ex+0x8b>
		if (inode->i_count < 2)
   177db:	8b 44 24 18          	mov    0x18(%esp),%eax
   177df:	0f b7 40 34          	movzwl 0x34(%eax),%eax
   177e3:	66 83 f8 01          	cmp    $0x1,%ax
   177e7:	77 07                	ja     177f0 <check_ex+0x77>
			return 1;
   177e9:	b8 01 00 00 00       	mov    $0x1,%eax
   177ee:	eb 19                	jmp    17809 <check_ex+0x90>
		else
			add_wait(&inode->i_wait, wait);
   177f0:	8b 44 24 18          	mov    0x18(%esp),%eax
   177f4:	83 c0 20             	add    $0x20,%eax
   177f7:	ff 74 24 14          	pushl  0x14(%esp)
   177fb:	50                   	push   %eax
   177fc:	e8 d8 fb ff ff       	call   173d9 <add_wait>
   17801:	83 c4 08             	add    $0x8,%esp
	return 0;
   17804:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17809:	83 c4 10             	add    $0x10,%esp
   1780c:	c3                   	ret    

0001780d <do_select>:
// 集描述符检查函数check_XX()对每个描述符进行检查，同时统计描述符集中当前已经准备好的描述符个数。若有任何一个描述符已经准备好，
// 本函数就会立刻返回，否则进程就会在本函数中进入睡眠状态，并在过了超时时间或者由于某个描述符所在等待队列上的进程被唤醒而使本
// 进程继续运行。
int do_select(fd_set in, fd_set out, fd_set ex,
	fd_set *inp, fd_set *outp, fd_set *exp)
{
   1780d:	53                   	push   %ebx
   1780e:	81 ec f8 01 00 00    	sub    $0x1f8,%esp
   17814:	e8 e1 f4 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   17819:	81 c3 e7 a7 01 00    	add    $0x1a7e7,%ebx

	// 首先把3个描述符集进行或操作，在mask中得到描述符集中有效符位屏蔽码。然后循环判断当前进程各个描述符是否有效并且包含在描述符集内。
	// 在循环中，每判断完一个描述符就会把mask右移1位，因此根据mask的最低有效位我们就可以判断相应描述符是否在用户给定的描述符集中。有
	// 效的描述符应该是一个管道文件描述符，或者是一个字符设备文件描述符，或者是一个FIFO描述符，其余类型的都作为无效描述符而返回EBADF
	// 错误。
	mask = in | out | ex;
   1781f:	8b 84 24 00 02 00 00 	mov    0x200(%esp),%eax
   17826:	0b 84 24 04 02 00 00 	or     0x204(%esp),%eax
   1782d:	0b 84 24 08 02 00 00 	or     0x208(%esp),%eax
   17834:	89 84 24 e4 01 00 00 	mov    %eax,0x1e4(%esp)
	for (i = 0 ; i < NR_OPEN ; i++, mask >>= 1) {
   1783b:	c7 84 24 e8 01 00 00 	movl   $0x0,0x1e8(%esp)
   17842:	00 00 00 00 
   17846:	e9 06 01 00 00       	jmp    17951 <do_select+0x144>
		if (!(mask & 1))                                        // 若不在描述符集中则继续判断下一个。
   1784b:	8b 84 24 e4 01 00 00 	mov    0x1e4(%esp),%eax
   17852:	83 e0 01             	and    $0x1,%eax
   17855:	85 c0                	test   %eax,%eax
   17857:	0f 84 db 00 00 00    	je     17938 <do_select+0x12b>
			continue;
		if (!current->filp[i])                                  // 若文件未打开，则返回描述符值。
   1785d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17863:	8b 00                	mov    (%eax),%eax
   17865:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   1786c:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   17872:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   17876:	85 c0                	test   %eax,%eax
   17878:	75 0a                	jne    17884 <do_select+0x77>
			return -EBADF;
   1787a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   1787f:	e9 03 03 00 00       	jmp    17b87 <do_select+0x37a>
		if (!current->filp[i]->f_inode)                         // 若文件i节点指针为空，则返回错误号。
   17884:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1788a:	8b 00                	mov    (%eax),%eax
   1788c:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   17893:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   17899:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   1789d:	8b 40 08             	mov    0x8(%eax),%eax
   178a0:	85 c0                	test   %eax,%eax
   178a2:	75 0a                	jne    178ae <do_select+0xa1>
			return -EBADF;
   178a4:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   178a9:	e9 d9 02 00 00       	jmp    17b87 <do_select+0x37a>
		if (current->filp[i]->f_inode->i_pipe)                  // 若是管道文件描述符，则有效。
   178ae:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   178b4:	8b 00                	mov    (%eax),%eax
   178b6:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   178bd:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   178c3:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   178c7:	8b 40 08             	mov    0x8(%eax),%eax
   178ca:	0f b6 40 38          	movzbl 0x38(%eax),%eax
   178ce:	84 c0                	test   %al,%al
   178d0:	75 69                	jne    1793b <do_select+0x12e>
			continue;
		if (S_ISCHR(current->filp[i]->f_inode->i_mode))         // 字符设备文件有效。
   178d2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   178d8:	8b 00                	mov    (%eax),%eax
   178da:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   178e1:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   178e7:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   178eb:	8b 40 08             	mov    0x8(%eax),%eax
   178ee:	0f b7 00             	movzwl (%eax),%eax
   178f1:	0f b7 c0             	movzwl %ax,%eax
   178f4:	25 00 f0 00 00       	and    $0xf000,%eax
   178f9:	3d 00 20 00 00       	cmp    $0x2000,%eax
   178fe:	74 3e                	je     1793e <do_select+0x131>
			continue;
		if (S_ISFIFO(current->filp[i]->f_inode->i_mode))        // FIFO也有效。
   17900:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17906:	8b 00                	mov    (%eax),%eax
   17908:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   1790f:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   17915:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   17919:	8b 40 08             	mov    0x8(%eax),%eax
   1791c:	0f b7 00             	movzwl (%eax),%eax
   1791f:	0f b7 c0             	movzwl %ax,%eax
   17922:	25 00 f0 00 00       	and    $0xf000,%eax
   17927:	3d 00 10 00 00       	cmp    $0x1000,%eax
   1792c:	74 13                	je     17941 <do_select+0x134>
			continue;
		return -EBADF;                  						// 其余都作为无效描述符而返回。
   1792e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   17933:	e9 4f 02 00 00       	jmp    17b87 <do_select+0x37a>
			continue;
   17938:	90                   	nop
   17939:	eb 07                	jmp    17942 <do_select+0x135>
			continue;
   1793b:	90                   	nop
   1793c:	eb 04                	jmp    17942 <do_select+0x135>
			continue;
   1793e:	90                   	nop
   1793f:	eb 01                	jmp    17942 <do_select+0x135>
			continue;
   17941:	90                   	nop
	for (i = 0 ; i < NR_OPEN ; i++, mask >>= 1) {
   17942:	83 84 24 e8 01 00 00 	addl   $0x1,0x1e8(%esp)
   17949:	01 
   1794a:	d1 ac 24 e4 01 00 00 	shrl   0x1e4(%esp)
   17951:	83 bc 24 e8 01 00 00 	cmpl   $0x13,0x1e8(%esp)
   17958:	13 
   17959:	0f 8e ec fe ff ff    	jle    1784b <do_select+0x3e>
	}
	// 下面循环检查3个描述符集中的各个描述符是否准备好（可以操作）。此时mask用作当前正在处理描述符的屏蔽码。循环中的3个函数check_in()、
	// check_out()和check_ex()分别用来判断描述符是否已经准备好。若一个描述符已经准备好，则在相关描述符集中设置对应位，并且把已准备
	// 好描述符个数计数值count增1。第186行for循环语句中的mask+= mask行将于mask<<1。
repeat:
   1795f:	90                   	nop
	wait_table.nr = 0;
   17960:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	*inp = *outp = *exp = 0;
   17967:	8b 84 24 14 02 00 00 	mov    0x214(%esp),%eax
   1796e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   17974:	8b 84 24 14 02 00 00 	mov    0x214(%esp),%eax
   1797b:	8b 10                	mov    (%eax),%edx
   1797d:	8b 84 24 10 02 00 00 	mov    0x210(%esp),%eax
   17984:	89 10                	mov    %edx,(%eax)
   17986:	8b 84 24 10 02 00 00 	mov    0x210(%esp),%eax
   1798d:	8b 10                	mov    (%eax),%edx
   1798f:	8b 84 24 0c 02 00 00 	mov    0x20c(%esp),%eax
   17996:	89 10                	mov    %edx,(%eax)
	count = 0;
   17998:	c7 84 24 ec 01 00 00 	movl   $0x0,0x1ec(%esp)
   1799f:	00 00 00 00 
	mask = 1;
   179a3:	c7 84 24 e4 01 00 00 	movl   $0x1,0x1e4(%esp)
   179aa:	01 00 00 00 
	for (i = 0 ; i < NR_OPEN ; i++, mask += mask) {
   179ae:	c7 84 24 e8 01 00 00 	movl   $0x0,0x1e8(%esp)
   179b5:	00 00 00 00 
   179b9:	e9 38 01 00 00       	jmp    17af6 <do_select+0x2e9>
		// 如果此时判断的描述符在读操作描述符集中，并且该描述符已经准备好可以进行读操作，则把该描述符在描述符集in中对应位置为1,同时把已准备
		// 好描述符个数计数值count增1。
		if (mask & in)
   179be:	8b 84 24 e4 01 00 00 	mov    0x1e4(%esp),%eax
   179c5:	23 84 24 00 02 00 00 	and    0x200(%esp),%eax
   179cc:	85 c0                	test   %eax,%eax
   179ce:	74 51                	je     17a21 <do_select+0x214>
			if (check_in(&wait_table, current->filp[i]->f_inode)) {
   179d0:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   179d6:	8b 00                	mov    (%eax),%eax
   179d8:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   179df:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   179e5:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   179e9:	8b 40 08             	mov    0x8(%eax),%eax
   179ec:	50                   	push   %eax
   179ed:	8d 44 24 04          	lea    0x4(%esp),%eax
   179f1:	50                   	push   %eax
   179f2:	e8 26 fc ff ff       	call   1761d <check_in>
   179f7:	83 c4 08             	add    $0x8,%esp
   179fa:	85 c0                	test   %eax,%eax
   179fc:	74 23                	je     17a21 <do_select+0x214>
				*inp |= mask;   								// 描述符集中设置对应位。
   179fe:	8b 84 24 0c 02 00 00 	mov    0x20c(%esp),%eax
   17a05:	8b 00                	mov    (%eax),%eax
   17a07:	0b 84 24 e4 01 00 00 	or     0x1e4(%esp),%eax
   17a0e:	89 c2                	mov    %eax,%edx
   17a10:	8b 84 24 0c 02 00 00 	mov    0x20c(%esp),%eax
   17a17:	89 10                	mov    %edx,(%eax)
				count++;        								// 已准备好描述符个数计数。
   17a19:	83 84 24 ec 01 00 00 	addl   $0x1,0x1ec(%esp)
   17a20:	01 
			}
		// 如果此时判断的描述符在写操作描述符集中，并且该描述符已经准备好可以进行写操作，则把该描述符在描述符集out中对应位置为1,同时把已准备
		// 好描述符个数计数值count增1。
		if (mask & out)
   17a21:	8b 84 24 e4 01 00 00 	mov    0x1e4(%esp),%eax
   17a28:	23 84 24 04 02 00 00 	and    0x204(%esp),%eax
   17a2f:	85 c0                	test   %eax,%eax
   17a31:	74 51                	je     17a84 <do_select+0x277>
			if (check_out(&wait_table, current->filp[i]->f_inode)) {
   17a33:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17a39:	8b 00                	mov    (%eax),%eax
   17a3b:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   17a42:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   17a48:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   17a4c:	8b 40 08             	mov    0x8(%eax),%eax
   17a4f:	50                   	push   %eax
   17a50:	8d 44 24 04          	lea    0x4(%esp),%eax
   17a54:	50                   	push   %eax
   17a55:	e8 64 fc ff ff       	call   176be <check_out>
   17a5a:	83 c4 08             	add    $0x8,%esp
   17a5d:	85 c0                	test   %eax,%eax
   17a5f:	74 23                	je     17a84 <do_select+0x277>
				*outp |= mask;
   17a61:	8b 84 24 10 02 00 00 	mov    0x210(%esp),%eax
   17a68:	8b 00                	mov    (%eax),%eax
   17a6a:	0b 84 24 e4 01 00 00 	or     0x1e4(%esp),%eax
   17a71:	89 c2                	mov    %eax,%edx
   17a73:	8b 84 24 10 02 00 00 	mov    0x210(%esp),%eax
   17a7a:	89 10                	mov    %edx,(%eax)
				count++;
   17a7c:	83 84 24 ec 01 00 00 	addl   $0x1,0x1ec(%esp)
   17a83:	01 
			}
		// 如果此时判断的描述符在异常描述符集中，并且该描述符已经有异常出现，则把该描述符在描述符集ex中对应位置为1,同时把已准备好描述符个数计
		// 数值count增1。
		if (mask & ex)
   17a84:	8b 84 24 e4 01 00 00 	mov    0x1e4(%esp),%eax
   17a8b:	23 84 24 08 02 00 00 	and    0x208(%esp),%eax
   17a92:	85 c0                	test   %eax,%eax
   17a94:	74 51                	je     17ae7 <do_select+0x2da>
			if (check_ex(&wait_table, current->filp[i]->f_inode)) {
   17a96:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17a9c:	8b 00                	mov    (%eax),%eax
   17a9e:	8b 94 24 e8 01 00 00 	mov    0x1e8(%esp),%edx
   17aa5:	81 c2 d0 00 00 00    	add    $0xd0,%edx
   17aab:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   17aaf:	8b 40 08             	mov    0x8(%eax),%eax
   17ab2:	50                   	push   %eax
   17ab3:	8d 44 24 04          	lea    0x4(%esp),%eax
   17ab7:	50                   	push   %eax
   17ab8:	e8 bc fc ff ff       	call   17779 <check_ex>
   17abd:	83 c4 08             	add    $0x8,%esp
   17ac0:	85 c0                	test   %eax,%eax
   17ac2:	74 23                	je     17ae7 <do_select+0x2da>
				*exp |= mask;
   17ac4:	8b 84 24 14 02 00 00 	mov    0x214(%esp),%eax
   17acb:	8b 00                	mov    (%eax),%eax
   17acd:	0b 84 24 e4 01 00 00 	or     0x1e4(%esp),%eax
   17ad4:	89 c2                	mov    %eax,%edx
   17ad6:	8b 84 24 14 02 00 00 	mov    0x214(%esp),%eax
   17add:	89 10                	mov    %edx,(%eax)
				count++;
   17adf:	83 84 24 ec 01 00 00 	addl   $0x1,0x1ec(%esp)
   17ae6:	01 
	for (i = 0 ; i < NR_OPEN ; i++, mask += mask) {
   17ae7:	83 84 24 e8 01 00 00 	addl   $0x1,0x1e8(%esp)
   17aee:	01 
   17aef:	d1 a4 24 e4 01 00 00 	shll   0x1e4(%esp)
   17af6:	83 bc 24 e8 01 00 00 	cmpl   $0x13,0x1e8(%esp)
   17afd:	13 
   17afe:	0f 8e ba fe ff ff    	jle    179be <do_select+0x1b1>
	}
	// 在对进程所有描述符判断处理后，若没有发现有已准备好的描述符（count==0），并且此时进程没有收到任何非阻塞信号，并且此时有等待着描述符
	// 或者等待时间还没有超时，那么我们就把当前进程状态设置成可中断睡眠状态，然后执行调度函数去执行其他任务。当内核又一次调度执行本任务时就
	// 调用free_wait()唤醒相关等待队列上本任务前后的任务,然后跳转到repeat标号处再次重新检测是否有我们关心的（描述符集中的）描述符已准备
	// 好。
	if (!(current->signal & ~current->blocked) &&
   17b04:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17b0a:	8b 00                	mov    (%eax),%eax
   17b0c:	8b 50 0c             	mov    0xc(%eax),%edx
   17b0f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17b15:	8b 00                	mov    (%eax),%eax
   17b17:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   17b1d:	f7 d0                	not    %eax
   17b1f:	21 d0                	and    %edx,%eax
   17b21:	85 c0                	test   %eax,%eax
   17b23:	75 4b                	jne    17b70 <do_select+0x363>
	    (wait_table.nr || current->timeout) && !count) {
   17b25:	8b 04 24             	mov    (%esp),%eax
	if (!(current->signal & ~current->blocked) &&
   17b28:	85 c0                	test   %eax,%eax
   17b2a:	75 12                	jne    17b3e <do_select+0x331>
	    (wait_table.nr || current->timeout) && !count) {
   17b2c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17b32:	8b 00                	mov    (%eax),%eax
   17b34:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
   17b3a:	85 c0                	test   %eax,%eax
   17b3c:	74 32                	je     17b70 <do_select+0x363>
   17b3e:	83 bc 24 ec 01 00 00 	cmpl   $0x0,0x1ec(%esp)
   17b45:	00 
   17b46:	75 28                	jne    17b70 <do_select+0x363>
		current->state = TASK_INTERRUPTIBLE;
   17b48:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17b4e:	8b 00                	mov    (%eax),%eax
   17b50:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		schedule();
   17b56:	e8 f0 f3 fe ff       	call   6f4b <schedule>
		free_wait(&wait_table);         						// 本任务被唤醒返回后从这里开始执行。
   17b5b:	83 ec 0c             	sub    $0xc,%esp
   17b5e:	8d 44 24 0c          	lea    0xc(%esp),%eax
   17b62:	50                   	push   %eax
   17b63:	e8 01 f9 ff ff       	call   17469 <free_wait>
   17b68:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   17b6b:	e9 f0 fd ff ff       	jmp    17960 <do_select+0x153>
	}
	// 如果此时count不等于0，或者接收到了信号，或者等待时间到并且没有需要等待的描述符，那么我们就调用free_wait()唤醒等待队列上
	// 的任务，然后返回已准备好的描述符个数。
	free_wait(&wait_table);
   17b70:	83 ec 0c             	sub    $0xc,%esp
   17b73:	8d 44 24 0c          	lea    0xc(%esp),%eax
   17b77:	50                   	push   %eax
   17b78:	e8 ec f8 ff ff       	call   17469 <free_wait>
   17b7d:	83 c4 10             	add    $0x10,%esp
	return count;
   17b80:	8b 84 24 ec 01 00 00 	mov    0x1ec(%esp),%eax
}
   17b87:	81 c4 f8 01 00 00    	add    $0x1f8,%esp
   17b8d:	5b                   	pop    %ebx
   17b8e:	c3                   	ret    

00017b8f <sys_select>:
// 函数来完成。sys_select()会首先根据参数传递来的缓冲区指针从用户数据空间把select()函数调用的参数分解复制到内核空间，然后
// 设置需要等待的超时时间值timeout，接着调用do_select()执行select功能，返回后就把处理结果再复制回用户空间中。
// 参数buffer指向用户数据区中select()函数的第1个参数处。如果返回值小于0表示执行时出现错误；如果返回值等于0,则表示在规定等
// 待时间内没有描述符准备好操作；如果返回值大于0,则表示已准备好的描述符数量。
int sys_select( unsigned long *buffer )
{
   17b8f:	53                   	push   %ebx
   17b90:	83 ec 48             	sub    $0x48,%esp
   17b93:	e8 62 f1 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   17b98:	81 c3 68 a4 01 00    	add    $0x1a468,%ebx
	/* Perform the select(nd, in, out, ex, tv) system call. */
	/* 执行select(nd, in, out, ex, tv)系统调用 */
	// 首先定义几个局部变量，用于把指针参数传递来的select()函数参数分解开来。
	int i;
	fd_set res_in, in = 0, *inp;            						// 读操作描述符集。
   17b9e:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
   17ba5:	00 
	fd_set res_out, out = 0, *outp;         						// 写操作描述符集。
   17ba6:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
   17bad:	00 
	fd_set res_ex, ex = 0, *exp;            						// 异常条件描述符集。
   17bae:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
   17bb5:	00 
	unsigned long timeout;

	// 然后从用户数据区把参数分别隔离复制到局部指针变量中，并根据描述符集指针是否有效分别取得3个描述符集in（读）、out（写）和ex
	// （异常）。其中mask也是一个描述符集变量，根据3个描述符集中最大描述符值+1（即第1个参数nd的值），它被设置成用户程序关心的所有
	// 描述符的屏蔽码。例如，若nd = 4,则mask = 0b00001111（共32位）。
	mask = ~((~0) << get_fs_long(buffer++));
   17bb6:	8b 44 24 50          	mov    0x50(%esp),%eax
   17bba:	8d 50 04             	lea    0x4(%eax),%edx
   17bbd:	89 54 24 50          	mov    %edx,0x50(%esp)
   17bc1:	50                   	push   %eax
   17bc2:	e8 db f7 ff ff       	call   173a2 <get_fs_long>
   17bc7:	83 c4 04             	add    $0x4,%esp
   17bca:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   17bcf:	89 c1                	mov    %eax,%ecx
   17bd1:	d3 e2                	shl    %cl,%edx
   17bd3:	89 d0                	mov    %edx,%eax
   17bd5:	f7 d0                	not    %eax
   17bd7:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	inp = (fd_set *) get_fs_long(buffer++);
   17bdb:	8b 44 24 50          	mov    0x50(%esp),%eax
   17bdf:	8d 50 04             	lea    0x4(%eax),%edx
   17be2:	89 54 24 50          	mov    %edx,0x50(%esp)
   17be6:	50                   	push   %eax
   17be7:	e8 b6 f7 ff ff       	call   173a2 <get_fs_long>
   17bec:	83 c4 04             	add    $0x4,%esp
   17bef:	89 44 24 28          	mov    %eax,0x28(%esp)
	outp = (fd_set *) get_fs_long(buffer++);
   17bf3:	8b 44 24 50          	mov    0x50(%esp),%eax
   17bf7:	8d 50 04             	lea    0x4(%eax),%edx
   17bfa:	89 54 24 50          	mov    %edx,0x50(%esp)
   17bfe:	50                   	push   %eax
   17bff:	e8 9e f7 ff ff       	call   173a2 <get_fs_long>
   17c04:	83 c4 04             	add    $0x4,%esp
   17c07:	89 44 24 24          	mov    %eax,0x24(%esp)
	exp = (fd_set *) get_fs_long(buffer++);
   17c0b:	8b 44 24 50          	mov    0x50(%esp),%eax
   17c0f:	8d 50 04             	lea    0x4(%eax),%edx
   17c12:	89 54 24 50          	mov    %edx,0x50(%esp)
   17c16:	50                   	push   %eax
   17c17:	e8 86 f7 ff ff       	call   173a2 <get_fs_long>
   17c1c:	83 c4 04             	add    $0x4,%esp
   17c1f:	89 44 24 20          	mov    %eax,0x20(%esp)
	tvp = (struct timeval *) get_fs_long(buffer);
   17c23:	ff 74 24 50          	pushl  0x50(%esp)
   17c27:	e8 76 f7 ff ff       	call   173a2 <get_fs_long>
   17c2c:	83 c4 04             	add    $0x4,%esp
   17c2f:	89 44 24 1c          	mov    %eax,0x1c(%esp)

	if (inp)                                						// 若指针有效，则取读操作描述符集。
   17c33:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   17c38:	74 14                	je     17c4e <sys_select+0xbf>
		in = mask & get_fs_long(inp);
   17c3a:	ff 74 24 28          	pushl  0x28(%esp)
   17c3e:	e8 5f f7 ff ff       	call   173a2 <get_fs_long>
   17c43:	83 c4 04             	add    $0x4,%esp
   17c46:	23 44 24 2c          	and    0x2c(%esp),%eax
   17c4a:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if (outp)                               						// 若指针有效，则取写操作描述符集。
   17c4e:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   17c53:	74 14                	je     17c69 <sys_select+0xda>
		out = mask & get_fs_long(outp);
   17c55:	ff 74 24 24          	pushl  0x24(%esp)
   17c59:	e8 44 f7 ff ff       	call   173a2 <get_fs_long>
   17c5e:	83 c4 04             	add    $0x4,%esp
   17c61:	23 44 24 2c          	and    0x2c(%esp),%eax
   17c65:	89 44 24 38          	mov    %eax,0x38(%esp)
	if (exp)                                						// 若指针有效，则取异常描述符集。
   17c69:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   17c6e:	74 14                	je     17c84 <sys_select+0xf5>
		ex = mask & get_fs_long(exp);
   17c70:	ff 74 24 20          	pushl  0x20(%esp)
   17c74:	e8 29 f7 ff ff       	call   173a2 <get_fs_long>
   17c79:	83 c4 04             	add    $0x4,%esp
   17c7c:	23 44 24 2c          	and    0x2c(%esp),%eax
   17c80:	89 44 24 34          	mov    %eax,0x34(%esp)
	// 接下来我们尝试从时间结构中取出等待（睡眠）时间值timeout。首先把timeout初始化成最大（无限）值，然后从用户数据空间取得该时间
	// 结构中设置的时间值，经转换和加上系统当前嘀嗒值jiffies，最后得到需要等待的时间嘀嗒数值timeout。我们用此值来设置当前进程应该
	// 等待的延时。另外，第241行上tv_usec字段是微秒值，把它除以1000000后可得到对应秒数，再乘以系统每秒嘀嗒数HZ，即把tv_usec转换
	// 成嘀嗒值。
	timeout = 0xffffffff;
   17c84:	c7 44 24 30 ff ff ff 	movl   $0xffffffff,0x30(%esp)
   17c8b:	ff 
	if (tvp) {
   17c8c:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   17c91:	74 40                	je     17cd3 <sys_select+0x144>
		timeout = get_fs_long((unsigned long *) & tvp->tv_usec) / (1000000 / HZ);
   17c93:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17c97:	83 c0 04             	add    $0x4,%eax
   17c9a:	50                   	push   %eax
   17c9b:	e8 02 f7 ff ff       	call   173a2 <get_fs_long>
   17ca0:	83 c4 04             	add    $0x4,%esp
   17ca3:	ba 59 17 b7 d1       	mov    $0xd1b71759,%edx
   17ca8:	f7 e2                	mul    %edx
   17caa:	89 d0                	mov    %edx,%eax
   17cac:	c1 e8 0d             	shr    $0xd,%eax
   17caf:	89 44 24 30          	mov    %eax,0x30(%esp)
		timeout += get_fs_long((unsigned long *) & tvp->tv_sec) * HZ;
   17cb3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17cb7:	50                   	push   %eax
   17cb8:	e8 e5 f6 ff ff       	call   173a2 <get_fs_long>
   17cbd:	83 c4 04             	add    $0x4,%esp
   17cc0:	6b c0 64             	imul   $0x64,%eax,%eax
   17cc3:	01 44 24 30          	add    %eax,0x30(%esp)
		timeout += jiffies;
   17cc7:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   17ccd:	8b 00                	mov    (%eax),%eax
   17ccf:	01 44 24 30          	add    %eax,0x30(%esp)
	}
	current->timeout = timeout;             						// 设置当前进程应该延时的嘀嗒值。
   17cd3:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17cd9:	8b 00                	mov    (%eax),%eax
   17cdb:	8b 54 24 30          	mov    0x30(%esp),%edx
   17cdf:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%eax)
	// select()函数的主要工作在do_select()中完成。在调用该函数之后的代码用于把处理结果复制到用户数据区中，返回给用户。为了避免出现
	// 竞争条件，在调用do_select()前需要禁止中断，并在该函数返回后再开启中断。
	// 如果在do_select()返回之后进程的等待延时字段timeout还大于当前系统计时嘀嗒值jiffies，说明在超时之前已经有描述准备好，于是这里
	// 我们先记下到超时还剩余的时间值，随后我们会把这个值返回给用户。如果进程的等待延时字段timeout已经小于或等于当前系统jiffies，表示
	// do_select()可能是由于超时而返回，因此把剩余时间值设置为0。
	cli();                  										// 禁止响应中断。
   17ce5:	fa                   	cli    
	i = do_select(in, out, ex, &res_in, &res_out, &res_ex);
   17ce6:	83 ec 08             	sub    $0x8,%esp
   17ce9:	8d 44 24 14          	lea    0x14(%esp),%eax
   17ced:	50                   	push   %eax
   17cee:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   17cf2:	50                   	push   %eax
   17cf3:	8d 44 24 24          	lea    0x24(%esp),%eax
   17cf7:	50                   	push   %eax
   17cf8:	ff 74 24 48          	pushl  0x48(%esp)
   17cfc:	ff 74 24 50          	pushl  0x50(%esp)
   17d00:	ff 74 24 58          	pushl  0x58(%esp)
   17d04:	e8 04 fb ff ff       	call   1780d <do_select>
   17d09:	83 c4 20             	add    $0x20,%esp
   17d0c:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (current->timeout > jiffies)
   17d10:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17d16:	8b 00                	mov    (%eax),%eax
   17d18:	8b 90 d8 02 00 00    	mov    0x2d8(%eax),%edx
   17d1e:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   17d24:	8b 00                	mov    (%eax),%eax
   17d26:	39 c2                	cmp    %eax,%edx
   17d28:	76 20                	jbe    17d4a <sys_select+0x1bb>
		timeout = current->timeout - jiffies;
   17d2a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17d30:	8b 00                	mov    (%eax),%eax
   17d32:	8b 90 d8 02 00 00    	mov    0x2d8(%eax),%edx
   17d38:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   17d3e:	8b 00                	mov    (%eax),%eax
   17d40:	29 c2                	sub    %eax,%edx
   17d42:	89 d0                	mov    %edx,%eax
   17d44:	89 44 24 30          	mov    %eax,0x30(%esp)
   17d48:	eb 08                	jmp    17d52 <sys_select+0x1c3>
	else
		timeout = 0;
   17d4a:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
   17d51:	00 
	sti();                  										// 开启中断响应。
   17d52:	fb                   	sti    
	// 接下来我们把进程的超时字段清零。如果do_select()返回的已准备好描述符个数小于0，表示执行出错，于是返回这个错误号。然后我们把处理过
	// 的描述符集内容和延迟时间结构内容写回到用户数据缓冲空间。在时间结构内容时还需要先将嘀嗒时间单位表示的剩余延迟时间转换成秒和微秒值。
	current->timeout = 0;
   17d53:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17d59:	8b 00                	mov    (%eax),%eax
   17d5b:	c7 80 d8 02 00 00 00 	movl   $0x0,0x2d8(%eax)
   17d62:	00 00 00 
	if (i < 0)
   17d65:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   17d6a:	79 09                	jns    17d75 <sys_select+0x1e6>
		return i;
   17d6c:	8b 44 24 18          	mov    0x18(%esp),%eax
   17d70:	e9 32 01 00 00       	jmp    17ea7 <sys_select+0x318>
	if (inp) {
   17d75:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   17d7a:	74 25                	je     17da1 <sys_select+0x212>
		verify_area(inp, 4);
   17d7c:	83 ec 08             	sub    $0x8,%esp
   17d7f:	6a 04                	push   $0x4
   17d81:	ff 74 24 34          	pushl  0x34(%esp)
   17d85:	e8 71 0b ff ff       	call   88fb <verify_area>
   17d8a:	83 c4 10             	add    $0x10,%esp
		put_fs_long(res_in, inp);        							// 可读描述符值。
   17d8d:	8b 44 24 14          	mov    0x14(%esp),%eax
   17d91:	83 ec 08             	sub    $0x8,%esp
   17d94:	ff 74 24 30          	pushl  0x30(%esp)
   17d98:	50                   	push   %eax
   17d99:	e8 24 f6 ff ff       	call   173c2 <put_fs_long>
   17d9e:	83 c4 10             	add    $0x10,%esp
	}
	if (outp) {
   17da1:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   17da6:	74 25                	je     17dcd <sys_select+0x23e>
		verify_area(outp, 4);
   17da8:	83 ec 08             	sub    $0x8,%esp
   17dab:	6a 04                	push   $0x4
   17dad:	ff 74 24 30          	pushl  0x30(%esp)
   17db1:	e8 45 0b ff ff       	call   88fb <verify_area>
   17db6:	83 c4 10             	add    $0x10,%esp
		put_fs_long(res_out, outp);      							// 可写描述符值。
   17db9:	8b 44 24 10          	mov    0x10(%esp),%eax
   17dbd:	83 ec 08             	sub    $0x8,%esp
   17dc0:	ff 74 24 2c          	pushl  0x2c(%esp)
   17dc4:	50                   	push   %eax
   17dc5:	e8 f8 f5 ff ff       	call   173c2 <put_fs_long>
   17dca:	83 c4 10             	add    $0x10,%esp
	}
	if (exp) {
   17dcd:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   17dd2:	74 25                	je     17df9 <sys_select+0x26a>
		verify_area(exp, 4);
   17dd4:	83 ec 08             	sub    $0x8,%esp
   17dd7:	6a 04                	push   $0x4
   17dd9:	ff 74 24 2c          	pushl  0x2c(%esp)
   17ddd:	e8 19 0b ff ff       	call   88fb <verify_area>
   17de2:	83 c4 10             	add    $0x10,%esp
		put_fs_long(res_ex, exp);        							// 出现异常条件描述符集。
   17de5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17de9:	83 ec 08             	sub    $0x8,%esp
   17dec:	ff 74 24 28          	pushl  0x28(%esp)
   17df0:	50                   	push   %eax
   17df1:	e8 cc f5 ff ff       	call   173c2 <put_fs_long>
   17df6:	83 c4 10             	add    $0x10,%esp
	}
	if (tvp) {
   17df9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   17dfe:	74 74                	je     17e74 <sys_select+0x2e5>
		verify_area(tvp, sizeof(*tvp));
   17e00:	83 ec 08             	sub    $0x8,%esp
   17e03:	6a 08                	push   $0x8
   17e05:	ff 74 24 28          	pushl  0x28(%esp)
   17e09:	e8 ed 0a ff ff       	call   88fb <verify_area>
   17e0e:	83 c4 10             	add    $0x10,%esp
		put_fs_long(timeout / HZ, (unsigned long *) &tvp->tv_sec);  // 秒。
   17e11:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   17e15:	8b 44 24 30          	mov    0x30(%esp),%eax
   17e19:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   17e1e:	f7 e2                	mul    %edx
   17e20:	89 d0                	mov    %edx,%eax
   17e22:	c1 e8 05             	shr    $0x5,%eax
   17e25:	83 ec 08             	sub    $0x8,%esp
   17e28:	51                   	push   %ecx
   17e29:	50                   	push   %eax
   17e2a:	e8 93 f5 ff ff       	call   173c2 <put_fs_long>
   17e2f:	83 c4 10             	add    $0x10,%esp
		timeout %= HZ;
   17e32:	8b 4c 24 30          	mov    0x30(%esp),%ecx
   17e36:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   17e3b:	89 c8                	mov    %ecx,%eax
   17e3d:	f7 e2                	mul    %edx
   17e3f:	89 d0                	mov    %edx,%eax
   17e41:	c1 e8 05             	shr    $0x5,%eax
   17e44:	6b c0 64             	imul   $0x64,%eax,%eax
   17e47:	29 c1                	sub    %eax,%ecx
   17e49:	89 c8                	mov    %ecx,%eax
   17e4b:	89 44 24 30          	mov    %eax,0x30(%esp)
		timeout *= (1000000 / HZ);
   17e4f:	8b 44 24 30          	mov    0x30(%esp),%eax
   17e53:	69 c0 10 27 00 00    	imul   $0x2710,%eax,%eax
   17e59:	89 44 24 30          	mov    %eax,0x30(%esp)
		put_fs_long(timeout, (unsigned long *) &tvp->tv_usec);      // 微秒。
   17e5d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17e61:	83 c0 04             	add    $0x4,%eax
   17e64:	83 ec 08             	sub    $0x8,%esp
   17e67:	50                   	push   %eax
   17e68:	ff 74 24 3c          	pushl  0x3c(%esp)
   17e6c:	e8 51 f5 ff ff       	call   173c2 <put_fs_long>
   17e71:	83 c4 10             	add    $0x10,%esp
	}
	// 如果此时并没有已准备好的描述符，并且收到了某个非阻塞信号，则返回被中断错误号。否则返回已准备好的描述符个数值。
	if (!i && (current->signal & ~current->blocked))
   17e74:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   17e79:	75 28                	jne    17ea3 <sys_select+0x314>
   17e7b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17e81:	8b 00                	mov    (%eax),%eax
   17e83:	8b 50 0c             	mov    0xc(%eax),%edx
   17e86:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   17e8c:	8b 00                	mov    (%eax),%eax
   17e8e:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   17e94:	f7 d0                	not    %eax
   17e96:	21 d0                	and    %edx,%eax
   17e98:	85 c0                	test   %eax,%eax
   17e9a:	74 07                	je     17ea3 <sys_select+0x314>
		return -EINTR;
   17e9c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   17ea1:	eb 04                	jmp    17ea7 <sys_select+0x318>
	return i;
   17ea3:	8b 44 24 18          	mov    0x18(%esp),%eax
}
   17ea7:	83 c4 48             	add    $0x48,%esp
   17eaa:	5b                   	pop    %ebx
   17eab:	c3                   	ret    

00017eac <lock_buffer>:
int * blk_size[NR_BLK_DEV] = { NULL, NULL, };

// 锁定指定缓冲块.
// 如果指定的缓冲块已经被其他任务锁定,则使自己睡眠(不可中断的等待),直到被执行解锁缓冲块的任务明确地唤醒
static inline void lock_buffer(struct buffer_head * bh)
{
   17eac:	53                   	push   %ebx
   17ead:	83 ec 08             	sub    $0x8,%esp
   17eb0:	e8 45 ee fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   17eb5:	81 c3 4b a1 01 00    	add    $0x1a14b,%ebx
	cli();							// 清中断许可.
   17ebb:	fa                   	cli    
	while (bh->b_lock)				// 如果缓冲区已被锁定则睡眠,直到缓冲区解锁.
   17ebc:	eb 13                	jmp    17ed1 <lock_buffer+0x25>
		sleep_on(&bh->b_wait);
   17ebe:	8b 44 24 10          	mov    0x10(%esp),%eax
   17ec2:	83 c0 10             	add    $0x10,%eax
   17ec5:	83 ec 0c             	sub    $0xc,%esp
   17ec8:	50                   	push   %eax
   17ec9:	e8 b6 f3 fe ff       	call   7284 <sleep_on>
   17ece:	83 c4 10             	add    $0x10,%esp
	while (bh->b_lock)				// 如果缓冲区已被锁定则睡眠,直到缓冲区解锁.
   17ed1:	8b 44 24 10          	mov    0x10(%esp),%eax
   17ed5:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   17ed9:	84 c0                	test   %al,%al
   17edb:	75 e1                	jne    17ebe <lock_buffer+0x12>
	bh->b_lock = 1;					// 立刻锁定缓冲区.
   17edd:	8b 44 24 10          	mov    0x10(%esp),%eax
   17ee1:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	sti();							// 开中断.
   17ee5:	fb                   	sti    
}
   17ee6:	90                   	nop
   17ee7:	83 c4 08             	add    $0x8,%esp
   17eea:	5b                   	pop    %ebx
   17eeb:	c3                   	ret    

00017eec <unlock_buffer>:

// 释放(解锁)锁定的缓冲区.
// 该函数与hlk.h文件中的同名函数完全一样.
static inline void unlock_buffer(struct buffer_head * bh)
{
   17eec:	53                   	push   %ebx
   17eed:	83 ec 08             	sub    $0x8,%esp
   17ef0:	e8 05 ee fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   17ef5:	81 c3 0b a1 01 00    	add    $0x1a10b,%ebx
	if (!bh->b_lock)				// 如果该缓冲区没有被锁定,则打印出错信息.
   17efb:	8b 44 24 10          	mov    0x10(%esp),%eax
   17eff:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   17f03:	84 c0                	test   %al,%al
   17f05:	75 12                	jne    17f19 <unlock_buffer+0x2d>
		printk("ll_rw_block.c: buffer not locked\n\r");
   17f07:	83 ec 0c             	sub    $0xc,%esp
   17f0a:	8d 83 c0 54 ff ff    	lea    -0xab40(%ebx),%eax
   17f10:	50                   	push   %eax
   17f11:	e8 1c 14 ff ff       	call   9332 <printk>
   17f16:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;					// 清锁定标志.
   17f19:	8b 44 24 10          	mov    0x10(%esp),%eax
   17f1d:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);			// 唤醒等待该缓冲区的任务.
   17f21:	8b 44 24 10          	mov    0x10(%esp),%eax
   17f25:	83 c0 10             	add    $0x10,%eax
   17f28:	83 ec 0c             	sub    $0xc,%esp
   17f2b:	50                   	push   %eax
   17f2c:	e8 76 f3 fe ff       	call   72a7 <wake_up>
   17f31:	83 c4 10             	add    $0x10,%esp
}
   17f34:	90                   	nop
   17f35:	83 c4 08             	add    $0x8,%esp
   17f38:	5b                   	pop    %ebx
   17f39:	c3                   	ret    

00017f3a <add_request>:
// 参数dev是指定块设备结构指针,该结构中有处理请求项函数指针和当前正在请求项指针;
// req是已设置好内容的请求项结构指针.
// 本函数把已经设置好的请求项req添加到指定设备的请求项链表中.如果该设备在当前请求项指针为空,则可以设置req为当前请求项并立刻调用设备请求
// 项处理函数.否则就把req请求项插入到该请求项链表中.
static void add_request(struct blk_dev_struct * dev, struct request * req)
{
   17f3a:	83 ec 1c             	sub    $0x1c,%esp
   17f3d:	e8 b0 ed fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   17f42:	05 be a0 01 00       	add    $0x1a0be,%eax
	// 首先对参数提供的请求项的指针和标志作初始设置.置空请求项中的下一请求项指针,关中断并清除请求项相关缓冲区脏标志.
	struct request * tmp;

	req->next = NULL;
   17f47:	8b 44 24 24          	mov    0x24(%esp),%eax
   17f4b:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	cli();								// 关中断
   17f52:	fa                   	cli    
	if (req->bh)
   17f53:	8b 44 24 24          	mov    0x24(%esp),%eax
   17f57:	8b 40 1c             	mov    0x1c(%eax),%eax
   17f5a:	85 c0                	test   %eax,%eax
   17f5c:	74 0b                	je     17f69 <add_request+0x2f>
		req->bh->b_dirt = 0;			// 清缓冲区"脏"标志.
   17f5e:	8b 44 24 24          	mov    0x24(%esp),%eax
   17f62:	8b 40 1c             	mov    0x1c(%eax),%eax
   17f65:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	// 然后查看指定设备是否有当前请求项,即查看设备是否正忙.如果指定设备dev当前请求项(current_equest)字段为空,则表示目前该设备没有请求项,本次是
	// 第1个请求项,也是唯一的一个.因此可将块设备当前请求指针直接指向该请求项,并立刻执行相应设备的请求函数.
	if (!(tmp = dev->current_request)) {
   17f69:	8b 44 24 20          	mov    0x20(%esp),%eax
   17f6d:	8b 40 04             	mov    0x4(%eax),%eax
   17f70:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17f74:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   17f79:	0f 85 79 01 00 00    	jne    180f8 <add_request+0x1be>
		dev->current_request = req;
   17f7f:	8b 44 24 20          	mov    0x20(%esp),%eax
   17f83:	8b 54 24 24          	mov    0x24(%esp),%edx
   17f87:	89 50 04             	mov    %edx,0x4(%eax)
		sti();							// 开中断.
   17f8a:	fb                   	sti    
		(dev->request_fn)();			// 执行请求函数,对于硬盘是do_hd_request().
   17f8b:	8b 44 24 20          	mov    0x20(%esp),%eax
   17f8f:	8b 00                	mov    (%eax),%eax
   17f91:	ff d0                	call   *%eax
		return;
   17f93:	e9 89 01 00 00       	jmp    18121 <add_request+0x1e7>
	// 如果目前该设备已经有当前请求项在处理,则首先利用电梯算法搜索最佳插入位置,然后将当前请求项插入到请求链表中.在搜索过程中,如果判断出欲插入
	// 请求项的缓冲块头指针空,即没有缓冲块,那么就需要找一个项,其已经有可用的缓冲块.因此若当前插入位置(tmp之后)处的空闲项缓冲块头指针不空,就选择这个位置
	// 于是退出循环并把请求项插入此处.最后开中断并退出函数.电梯算法的作用是让磁盘磁头的移动距离最小,从而改善(减少)硬盘访问时间.
	// 下面for循环中if语句用于把req所指请求项与请求队列(链表)中已有的请求项作比较,找出req插入该队列的正确位置顺序.然后中断循环,并把req插入到该队列正确位置处.
	for ( ; tmp->next ; tmp = tmp->next) {
		if (!req->bh)
   17f98:	8b 44 24 24          	mov    0x24(%esp),%eax
   17f9c:	8b 40 1c             	mov    0x1c(%eax),%eax
   17f9f:	85 c0                	test   %eax,%eax
   17fa1:	75 17                	jne    17fba <add_request+0x80>
			if (tmp->next->bh)
   17fa3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17fa7:	8b 40 20             	mov    0x20(%eax),%eax
   17faa:	8b 40 1c             	mov    0x1c(%eax),%eax
   17fad:	85 c0                	test   %eax,%eax
   17faf:	0f 84 37 01 00 00    	je     180ec <add_request+0x1b2>
				break;
   17fb5:	e9 4d 01 00 00       	jmp    18107 <add_request+0x1cd>
			else
				continue;
		if ((IN_ORDER(tmp, req) ||
   17fba:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17fbe:	8b 50 04             	mov    0x4(%eax),%edx
   17fc1:	8b 44 24 24          	mov    0x24(%esp),%eax
   17fc5:	8b 40 04             	mov    0x4(%eax),%eax
   17fc8:	39 c2                	cmp    %eax,%edx
   17fca:	0f 8c b5 00 00 00    	jl     18085 <add_request+0x14b>
   17fd0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17fd4:	8b 50 04             	mov    0x4(%eax),%edx
   17fd7:	8b 44 24 24          	mov    0x24(%esp),%eax
   17fdb:	8b 40 04             	mov    0x4(%eax),%eax
   17fde:	39 c2                	cmp    %eax,%edx
   17fe0:	75 36                	jne    18018 <add_request+0xde>
   17fe2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17fe6:	8b 10                	mov    (%eax),%edx
   17fe8:	8b 44 24 24          	mov    0x24(%esp),%eax
   17fec:	8b 00                	mov    (%eax),%eax
   17fee:	39 c2                	cmp    %eax,%edx
   17ff0:	0f 8c 8f 00 00 00    	jl     18085 <add_request+0x14b>
   17ff6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17ffa:	8b 10                	mov    (%eax),%edx
   17ffc:	8b 44 24 24          	mov    0x24(%esp),%eax
   18000:	8b 00                	mov    (%eax),%eax
   18002:	39 c2                	cmp    %eax,%edx
   18004:	75 12                	jne    18018 <add_request+0xde>
   18006:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1800a:	8b 50 0c             	mov    0xc(%eax),%edx
   1800d:	8b 44 24 24          	mov    0x24(%esp),%eax
   18011:	8b 40 0c             	mov    0xc(%eax),%eax
   18014:	39 c2                	cmp    %eax,%edx
   18016:	72 6d                	jb     18085 <add_request+0x14b>
		    !IN_ORDER(tmp, tmp->next)) &&
   18018:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1801c:	8b 50 04             	mov    0x4(%eax),%edx
   1801f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18023:	8b 40 20             	mov    0x20(%eax),%eax
   18026:	8b 40 04             	mov    0x4(%eax),%eax
		if ((IN_ORDER(tmp, req) ||
   18029:	39 c2                	cmp    %eax,%edx
   1802b:	0f 8c bc 00 00 00    	jl     180ed <add_request+0x1b3>
		    !IN_ORDER(tmp, tmp->next)) &&
   18031:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18035:	8b 50 04             	mov    0x4(%eax),%edx
   18038:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1803c:	8b 40 20             	mov    0x20(%eax),%eax
   1803f:	8b 40 04             	mov    0x4(%eax),%eax
   18042:	39 c2                	cmp    %eax,%edx
   18044:	75 3f                	jne    18085 <add_request+0x14b>
   18046:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1804a:	8b 10                	mov    (%eax),%edx
   1804c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18050:	8b 40 20             	mov    0x20(%eax),%eax
   18053:	8b 00                	mov    (%eax),%eax
   18055:	39 c2                	cmp    %eax,%edx
   18057:	0f 8c 90 00 00 00    	jl     180ed <add_request+0x1b3>
   1805d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18061:	8b 10                	mov    (%eax),%edx
   18063:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18067:	8b 40 20             	mov    0x20(%eax),%eax
   1806a:	8b 00                	mov    (%eax),%eax
   1806c:	39 c2                	cmp    %eax,%edx
   1806e:	75 15                	jne    18085 <add_request+0x14b>
   18070:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18074:	8b 50 0c             	mov    0xc(%eax),%edx
   18077:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1807b:	8b 40 20             	mov    0x20(%eax),%eax
   1807e:	8b 40 0c             	mov    0xc(%eax),%eax
   18081:	39 c2                	cmp    %eax,%edx
   18083:	72 68                	jb     180ed <add_request+0x1b3>
		    IN_ORDER(req, tmp->next))
   18085:	8b 44 24 24          	mov    0x24(%esp),%eax
   18089:	8b 50 04             	mov    0x4(%eax),%edx
   1808c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18090:	8b 40 20             	mov    0x20(%eax),%eax
   18093:	8b 40 04             	mov    0x4(%eax),%eax
		    !IN_ORDER(tmp, tmp->next)) &&
   18096:	39 c2                	cmp    %eax,%edx
   18098:	7c 6d                	jl     18107 <add_request+0x1cd>
		    IN_ORDER(req, tmp->next))
   1809a:	8b 44 24 24          	mov    0x24(%esp),%eax
   1809e:	8b 50 04             	mov    0x4(%eax),%edx
   180a1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   180a5:	8b 40 20             	mov    0x20(%eax),%eax
   180a8:	8b 40 04             	mov    0x4(%eax),%eax
   180ab:	39 c2                	cmp    %eax,%edx
   180ad:	75 3e                	jne    180ed <add_request+0x1b3>
   180af:	8b 44 24 24          	mov    0x24(%esp),%eax
   180b3:	8b 10                	mov    (%eax),%edx
   180b5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   180b9:	8b 40 20             	mov    0x20(%eax),%eax
   180bc:	8b 00                	mov    (%eax),%eax
   180be:	39 c2                	cmp    %eax,%edx
   180c0:	7c 45                	jl     18107 <add_request+0x1cd>
   180c2:	8b 44 24 24          	mov    0x24(%esp),%eax
   180c6:	8b 10                	mov    (%eax),%edx
   180c8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   180cc:	8b 40 20             	mov    0x20(%eax),%eax
   180cf:	8b 00                	mov    (%eax),%eax
   180d1:	39 c2                	cmp    %eax,%edx
   180d3:	75 18                	jne    180ed <add_request+0x1b3>
   180d5:	8b 44 24 24          	mov    0x24(%esp),%eax
   180d9:	8b 50 0c             	mov    0xc(%eax),%edx
   180dc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   180e0:	8b 40 20             	mov    0x20(%eax),%eax
   180e3:	8b 40 0c             	mov    0xc(%eax),%eax
   180e6:	39 c2                	cmp    %eax,%edx
   180e8:	72 1d                	jb     18107 <add_request+0x1cd>
   180ea:	eb 01                	jmp    180ed <add_request+0x1b3>
				continue;
   180ec:	90                   	nop
	for ( ; tmp->next ; tmp = tmp->next) {
   180ed:	8b 44 24 0c          	mov    0xc(%esp),%eax
   180f1:	8b 40 20             	mov    0x20(%eax),%eax
   180f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
   180f8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   180fc:	8b 40 20             	mov    0x20(%eax),%eax
   180ff:	85 c0                	test   %eax,%eax
   18101:	0f 85 91 fe ff ff    	jne    17f98 <add_request+0x5e>
			break;
	}
	req->next = tmp->next;
   18107:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1810b:	8b 50 20             	mov    0x20(%eax),%edx
   1810e:	8b 44 24 24          	mov    0x24(%esp),%eax
   18112:	89 50 20             	mov    %edx,0x20(%eax)
	tmp->next = req;
   18115:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18119:	8b 54 24 24          	mov    0x24(%esp),%edx
   1811d:	89 50 20             	mov    %edx,0x20(%eax)
	sti();
   18120:	fb                   	sti    
}
   18121:	83 c4 1c             	add    $0x1c,%esp
   18124:	c3                   	ret    

00018125 <make_request>:

// 创建请求项并插入请求队列中.
// 参数major是主设备号;rw是指定命令;bh是存放数据的缓冲区头指针.
static void make_request(int major, int rw, struct buffer_head * bh)
{
   18125:	53                   	push   %ebx
   18126:	83 ec 18             	sub    $0x18,%esp
   18129:	e8 cc eb fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1812e:	81 c3 d2 9e 01 00    	add    $0x19ed2,%ebx
	/* WRITEA/READA是一种特殊情况 - 它们并非必要,所以如果缓冲区已经上锁,我们就不用管它,否则它只是一个一般的读操作. */
	// 这里'READ'和'WRITE'后面的'A'字符代表英文单词Ahead,表示预读/写数据块的意思.
	// 该函数首先对命令READA/WRITEA的情况进行一些处理.对于这两个命令,当指定的缓冲区正在使用而已被上锁时,就放弃预读/写请求.否则就作为普通
	// READ/WRITE命令进行操作.另外,如果参数给出的命令既不是READ也不是WRITE,则表示内核程序有错,显示出错信息并停机.注意,在修改命令之前这里
	// 已为参数是否为预读/写命令设置了标志rw_ahead.
	if (rw_ahead = (rw == READA || rw == WRITEA)) {
   18134:	83 7c 24 24 02       	cmpl   $0x2,0x24(%esp)
   18139:	74 07                	je     18142 <make_request+0x1d>
   1813b:	83 7c 24 24 03       	cmpl   $0x3,0x24(%esp)
   18140:	75 07                	jne    18149 <make_request+0x24>
   18142:	b8 01 00 00 00       	mov    $0x1,%eax
   18147:	eb 05                	jmp    1814e <make_request+0x29>
   18149:	b8 00 00 00 00       	mov    $0x0,%eax
   1814e:	89 44 24 08          	mov    %eax,0x8(%esp)
   18152:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   18157:	74 29                	je     18182 <make_request+0x5d>
		if (bh->b_lock)
   18159:	8b 44 24 28          	mov    0x28(%esp),%eax
   1815d:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   18161:	84 c0                	test   %al,%al
   18163:	0f 85 a0 01 00 00    	jne    18309 <make_request+0x1e4>
			return;
		if (rw == READA)
   18169:	83 7c 24 24 02       	cmpl   $0x2,0x24(%esp)
   1816e:	75 0a                	jne    1817a <make_request+0x55>
			rw = READ;
   18170:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
   18177:	00 
   18178:	eb 08                	jmp    18182 <make_request+0x5d>
		else
			rw = WRITE;
   1817a:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
   18181:	00 
	}
	if (rw != READ && rw != WRITE)
   18182:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   18187:	74 19                	je     181a2 <make_request+0x7d>
   18189:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
   1818e:	74 12                	je     181a2 <make_request+0x7d>
		panic("Bad block dev command, must be R/W/RA/WA");
   18190:	83 ec 0c             	sub    $0xc,%esp
   18193:	8d 83 e4 54 ff ff    	lea    -0xab1c(%ebx),%eax
   18199:	50                   	push   %eax
   1819a:	e8 3f 11 ff ff       	call   92de <panic>
   1819f:	83 c4 10             	add    $0x10,%esp
	lock_buffer(bh);                				// 锁定缓冲块
   181a2:	83 ec 0c             	sub    $0xc,%esp
   181a5:	ff 74 24 34          	pushl  0x34(%esp)
   181a9:	e8 fe fc ff ff       	call   17eac <lock_buffer>
   181ae:	83 c4 10             	add    $0x10,%esp
	// 如果是WRITE操作并且缓冲块未修改，或是READ操作并且缓冲块已更新，则直接返回缓冲区块。
	if ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {
   181b1:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
   181b6:	75 0c                	jne    181c4 <make_request+0x9f>
   181b8:	8b 44 24 28          	mov    0x28(%esp),%eax
   181bc:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   181c0:	84 c0                	test   %al,%al
   181c2:	74 13                	je     181d7 <make_request+0xb2>
   181c4:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   181c9:	75 20                	jne    181eb <make_request+0xc6>
   181cb:	8b 44 24 28          	mov    0x28(%esp),%eax
   181cf:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   181d3:	84 c0                	test   %al,%al
   181d5:	74 14                	je     181eb <make_request+0xc6>
		unlock_buffer(bh);
   181d7:	83 ec 0c             	sub    $0xc,%esp
   181da:	ff 74 24 34          	pushl  0x34(%esp)
   181de:	e8 09 fd ff ff       	call   17eec <unlock_buffer>
   181e3:	83 c4 10             	add    $0x10,%esp
		return;
   181e6:	e9 1f 01 00 00       	jmp    1830a <make_request+0x1e5>
	}
repeat:
   181eb:	90                   	nop
	 */
	// 好,现在我们必须为本函数生成并添加读/写请求项了.首先我们需要在请求数组中寻找到一个空闲项(糟)来存放新请求项.搜索过程从请求数组末端开始.
	// 根据上述要求,对于读命令请求,我们直接从队列末尾开始搜索,而对于写请求就只能从队列2/3处向队列头处搜索空项填入.于是我们开始从后向前搜索,
	// 当请求结构request的设备字段dev值=-1时,表示该项未被占用(空闲).如果没有一项是空闲的(此时请求项数组指针已经搜索越过头部),则查看此次请求
	// 是否是提前读/写(READA或WRITEA),如果是则放弃此次请求操作.否则让本次请求操作先睡眠(以等待请求队列腾出空项),过一会儿再来搜索请求队列.
	if (rw == READ)
   181ec:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   181f1:	75 12                	jne    18205 <make_request+0xe0>
		req = request + NR_REQUEST;						// 对于读请求,将指针指向队列尾部.
   181f3:	c7 c0 00 64 04 00    	mov    $0x46400,%eax
   181f9:	8d 80 80 04 00 00    	lea    0x480(%eax),%eax
   181ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
   18203:	eb 1c                	jmp    18221 <make_request+0xfc>
	else
		req = request + ((NR_REQUEST * 2) / 3);			// 对于写请求,指针指向队列2/3处.
   18205:	c7 c0 00 64 04 00    	mov    $0x46400,%eax
   1820b:	8d 80 f4 02 00 00    	lea    0x2f4(%eax),%eax
   18211:	89 44 24 0c          	mov    %eax,0xc(%esp)
	/* find an empty request */
	/* 搜索一个空请求项 */
	while (--req >= request)
   18215:	eb 0a                	jmp    18221 <make_request+0xfc>
		if (req->dev < 0)
   18217:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1821b:	8b 00                	mov    (%eax),%eax
   1821d:	85 c0                	test   %eax,%eax
   1821f:	78 13                	js     18234 <make_request+0x10f>
	while (--req >= request)
   18221:	83 6c 24 0c 24       	subl   $0x24,0xc(%esp)
   18226:	c7 c0 00 64 04 00    	mov    $0x46400,%eax
   1822c:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   18230:	73 e5                	jae    18217 <make_request+0xf2>
   18232:	eb 01                	jmp    18235 <make_request+0x110>
			break;
   18234:	90                   	nop
	/* if none found, sleep on new requests: check for rw_ahead */
	/* 如果没有找到空闲项,则让该次请求操作睡眠:需检查是否提前读/写 */
	if (req < request) {								// 如果已搜索到头(队列无空项)
   18235:	c7 c0 00 64 04 00    	mov    $0x46400,%eax
   1823b:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   1823f:	73 32                	jae    18273 <make_request+0x14e>
		if (rw_ahead) {									// 则若是提前读/写请求,则退出.
   18241:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   18246:	74 14                	je     1825c <make_request+0x137>
			unlock_buffer(bh);
   18248:	83 ec 0c             	sub    $0xc,%esp
   1824b:	ff 74 24 34          	pushl  0x34(%esp)
   1824f:	e8 98 fc ff ff       	call   17eec <unlock_buffer>
   18254:	83 c4 10             	add    $0x10,%esp
			return;
   18257:	e9 ae 00 00 00       	jmp    1830a <make_request+0x1e5>
		}
		sleep_on(&wait_for_request);					// 否则就睡眠,过会再查看请求队列.
   1825c:	83 ec 0c             	sub    $0xc,%esp
   1825f:	8d 83 60 41 00 00    	lea    0x4160(%ebx),%eax
   18265:	50                   	push   %eax
   18266:	e8 19 f0 fe ff       	call   7284 <sleep_on>
   1826b:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   1826e:	e9 79 ff ff ff       	jmp    181ec <make_request+0xc7>
	}
	/* fill up the request-info, and add it to the queue */
	/* 向空闲请求项中填写请求信息,并将其加入队列中 */
	// OK,程序执行到这里表示已找到一个空闲请求项.于是我们在设置好的新请求项后就调用add_request()把它添加到请求队列中,立刻退出.请求结构请参见blk_drv/blk.h.
	// req->sector是读写操作的起始扇区号,req->buffer是请求项存放数据的缓冲区.
	req->dev = bh->b_dev;								// 设备号.
   18273:	8b 44 24 28          	mov    0x28(%esp),%eax
   18277:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   1827b:	0f b7 d0             	movzwl %ax,%edx
   1827e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18282:	89 10                	mov    %edx,(%eax)
	req->cmd = rw;										// 命令(READ/WRITE).
   18284:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18288:	8b 54 24 24          	mov    0x24(%esp),%edx
   1828c:	89 50 04             	mov    %edx,0x4(%eax)
	req->errors = 0;									// 操作时产生的错误次数.
   1828f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18293:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	req->sector = bh->b_blocknr << 1;					// 起始扇区.块号转换成扇区号(1块=2扇区).
   1829a:	8b 44 24 28          	mov    0x28(%esp),%eax
   1829e:	8b 40 04             	mov    0x4(%eax),%eax
   182a1:	8d 14 00             	lea    (%eax,%eax,1),%edx
   182a4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   182a8:	89 50 0c             	mov    %edx,0xc(%eax)
	req->nr_sectors = 2;								// 本请求项需要读写的扇区数.
   182ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
   182af:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	req->buffer = bh->b_data;							// 请求项缓冲区指针指向需读写的数据缓冲区.
   182b6:	8b 44 24 28          	mov    0x28(%esp),%eax
   182ba:	8b 10                	mov    (%eax),%edx
   182bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   182c0:	89 50 14             	mov    %edx,0x14(%eax)
	req->waiting = NULL;								// 任务等待操作执行完成的地方.
   182c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   182c7:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	req->bh = bh;										// 缓冲块头指针.
   182ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
   182d2:	8b 54 24 28          	mov    0x28(%esp),%edx
   182d6:	89 50 1c             	mov    %edx,0x1c(%eax)
	req->next = NULL;									// 指向下一请求项.
   182d9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   182dd:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	add_request(major + blk_dev, req);					// 将请求项加入队列中(blk_dev[major],reg).
   182e4:	8b 44 24 20          	mov    0x20(%esp),%eax
   182e8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   182ef:	8d 83 80 41 00 00    	lea    0x4180(%ebx),%eax
   182f5:	01 d0                	add    %edx,%eax
   182f7:	83 ec 08             	sub    $0x8,%esp
   182fa:	ff 74 24 14          	pushl  0x14(%esp)
   182fe:	50                   	push   %eax
   182ff:	e8 36 fc ff ff       	call   17f3a <add_request>
   18304:	83 c4 10             	add    $0x10,%esp
   18307:	eb 01                	jmp    1830a <make_request+0x1e5>
			return;
   18309:	90                   	nop
}
   1830a:	83 c4 18             	add    $0x18,%esp
   1830d:	5b                   	pop    %ebx
   1830e:	c3                   	ret    

0001830f <ll_rw_page>:

// 低级页面读写函数(Low Level Read Write Pagk).
// 以页面(4K)为单位访问设备数据,即每次读/写8个扇区.参见下面ll_rw_blk()函数.
void ll_rw_page(int rw, int dev, int page, char * buffer)
{
   1830f:	53                   	push   %ebx
   18310:	83 ec 18             	sub    $0x18,%esp
   18313:	e8 e2 e9 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18318:	81 c3 e8 9c 01 00    	add    $0x19ce8,%ebx
	struct request * req;
	unsigned int major = MAJOR(dev);
   1831e:	8b 44 24 24          	mov    0x24(%esp),%eax
   18322:	c1 e8 08             	shr    $0x8,%eax
   18325:	89 44 24 08          	mov    %eax,0x8(%esp)

	// 首先对函数参数的合法性进行检测.如果设备主设备号不存在或者该设备的请求操作函数不存在,则显示出错信息,并返回.如果参数给出的命令既不是
	// READ也不是WRITE,则表示内核程序有错,显示出错信息并停机.
	if (major >= NR_BLK_DEV || !(blk_dev[major].request_fn)) {
   18329:	83 7c 24 08 06       	cmpl   $0x6,0x8(%esp)
   1832e:	77 0f                	ja     1833f <ll_rw_page+0x30>
   18330:	8b 44 24 08          	mov    0x8(%esp),%eax
   18334:	8b 84 c3 80 41 00 00 	mov    0x4180(%ebx,%eax,8),%eax
   1833b:	85 c0                	test   %eax,%eax
   1833d:	75 17                	jne    18356 <ll_rw_page+0x47>
		printk("Trying to read nonexistent block-device\n\r");
   1833f:	83 ec 0c             	sub    $0xc,%esp
   18342:	8d 83 10 55 ff ff    	lea    -0xaaf0(%ebx),%eax
   18348:	50                   	push   %eax
   18349:	e8 e4 0f ff ff       	call   9332 <printk>
   1834e:	83 c4 10             	add    $0x10,%esp
		return;
   18351:	e9 14 01 00 00       	jmp    1846a <ll_rw_page+0x15b>
	}
	if (rw != READ && rw != WRITE)
   18356:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   1835b:	74 1b                	je     18378 <ll_rw_page+0x69>
   1835d:	83 7c 24 20 01       	cmpl   $0x1,0x20(%esp)
   18362:	74 14                	je     18378 <ll_rw_page+0x69>
		panic("Bad block dev command, must be R/W");
   18364:	83 ec 0c             	sub    $0xc,%esp
   18367:	8d 83 3c 55 ff ff    	lea    -0xaac4(%ebx),%eax
   1836d:	50                   	push   %eax
   1836e:	e8 6b 0f ff ff       	call   92de <panic>
   18373:	83 c4 10             	add    $0x10,%esp
   18376:	eb 01                	jmp    18379 <ll_rw_page+0x6a>
	// 在参数检测操作完成后,我们现在需要为本次操作建立请求项.首先我们需要在请求数组中寻找到一个空闲项(糟)来存放新请求项.搜索过程从请求数组末端
	// 开始.于是我们开始从后向前搜索,当请求结构request的设备字段值<0时,表示该项未被占用(空闲).如果没有一项是空闲的(此时请求项数组指针已经搜索越过
	// 头部),则让本次请求操作先睡眠(以等待请求队列腾出空项),过一会再来搜索请求队列.
repeat:
   18378:	90                   	nop
	req = request + NR_REQUEST;							// 将指针指向队列尾部.
   18379:	c7 c0 00 64 04 00    	mov    $0x46400,%eax
   1837f:	8d 80 80 04 00 00    	lea    0x480(%eax),%eax
   18385:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (--req >= request)
   18389:	eb 0a                	jmp    18395 <ll_rw_page+0x86>
		if (req->dev < 0)
   1838b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1838f:	8b 00                	mov    (%eax),%eax
   18391:	85 c0                	test   %eax,%eax
   18393:	78 13                	js     183a8 <ll_rw_page+0x99>
	while (--req >= request)
   18395:	83 6c 24 0c 24       	subl   $0x24,0xc(%esp)
   1839a:	c7 c0 00 64 04 00    	mov    $0x46400,%eax
   183a0:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   183a4:	73 e5                	jae    1838b <ll_rw_page+0x7c>
   183a6:	eb 01                	jmp    183a9 <ll_rw_page+0x9a>
			break;
   183a8:	90                   	nop
	if (req < request) {
   183a9:	c7 c0 00 64 04 00    	mov    $0x46400,%eax
   183af:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   183b3:	73 14                	jae    183c9 <ll_rw_page+0xba>
		sleep_on(&wait_for_request);					// 睡眠,过会再查看请求队列.
   183b5:	83 ec 0c             	sub    $0xc,%esp
   183b8:	8d 83 60 41 00 00    	lea    0x4160(%ebx),%eax
   183be:	50                   	push   %eax
   183bf:	e8 c0 ee fe ff       	call   7284 <sleep_on>
   183c4:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   183c7:	eb b0                	jmp    18379 <ll_rw_page+0x6a>
	/* 向空闲请求项中填写请求信息,并将其加入队列中 */
	// OK,程序执行到这里表示已找到一个空闲请求项.于是我们设置好新请求项,把当前进程置为不可中断睡眠中断后,就去调用add_request()把它添加到请求队列中,
	// 然后直接调用调度函数让当前进程睡眠等待页面从交换设备中读入.这里不像make_request()函数那样直接退出函数而调用了schedule(),是因为make_request()
	// 函数仅读2个扇区数据.而这里需要对交换设备读/写8个扇区,需要花较长的时间.因此当前进程肯定需要等待而睡眠.因此这里直接就让进程去睡眠了,省得在程序其他地方
	// 还要进行这些判断操作.
	req->dev = dev;										// 设备号
   183c9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   183cd:	8b 54 24 24          	mov    0x24(%esp),%edx
   183d1:	89 10                	mov    %edx,(%eax)
	req->cmd = rw;										// 命令(READ/WRITE)start_code
   183d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   183d7:	8b 54 24 20          	mov    0x20(%esp),%edx
   183db:	89 50 04             	mov    %edx,0x4(%eax)
	req->errors = 0;									// 读写操作错误计数
   183de:	8b 44 24 0c          	mov    0xc(%esp),%eax
   183e2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	req->sector = page << 3;							// 起始读写扇区
   183e9:	8b 44 24 28          	mov    0x28(%esp),%eax
   183ed:	c1 e0 03             	shl    $0x3,%eax
   183f0:	89 c2                	mov    %eax,%edx
   183f2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   183f6:	89 50 0c             	mov    %edx,0xc(%eax)
	req->nr_sectors = 8;								// 读写扇区数
   183f9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   183fd:	c7 40 10 08 00 00 00 	movl   $0x8,0x10(%eax)
	req->buffer = buffer;								// 数据缓冲区
   18404:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18408:	8b 54 24 2c          	mov    0x2c(%esp),%edx
   1840c:	89 50 14             	mov    %edx,0x14(%eax)
	req->waiting = current;								// 当前进程进入该请求等待队列
   1840f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   18415:	8b 10                	mov    (%eax),%edx
   18417:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1841b:	89 50 18             	mov    %edx,0x18(%eax)
	req->bh = NULL;										// 无缓冲块头指针(不用高速缓冲)
   1841e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18422:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	req->next = NULL;									// 下一个请求项指针
   18429:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1842d:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	current->state = TASK_UNINTERRUPTIBLE;				// 置为不可中断状态
   18434:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1843a:	8b 00                	mov    (%eax),%eax
   1843c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	add_request(major + blk_dev, req);					// 将请求项加入队列中.
   18442:	8b 44 24 08          	mov    0x8(%esp),%eax
   18446:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1844d:	8d 83 80 41 00 00    	lea    0x4180(%ebx),%eax
   18453:	01 d0                	add    %edx,%eax
   18455:	83 ec 08             	sub    $0x8,%esp
   18458:	ff 74 24 14          	pushl  0x14(%esp)
   1845c:	50                   	push   %eax
   1845d:	e8 d8 fa ff ff       	call   17f3a <add_request>
   18462:	83 c4 10             	add    $0x10,%esp
	// 当前进程需要读取8个扇区的数据因此需要睡眠，因此调用调度程序选择进程运行
	schedule();
   18465:	e8 e1 ea fe ff       	call   6f4b <schedule>
}
   1846a:	83 c4 18             	add    $0x18,%esp
   1846d:	5b                   	pop    %ebx
   1846e:	c3                   	ret    

0001846f <ll_rw_block>:
// 该函数是块设备驱动程序与系统其他部分的接口函数.通常在fs/buffer.c程序中被调用.
// 主要功能是创建块设备读写请求项并插入到指定块设备请求队列.实际的读写操作则是由设备的request_fn()函数完成.对于硬盘操作,该函数是do_hd_request();对于软盘操作
// 该函数是do_fd_request();对于虚拟盘则是do_rd_request().另外,在调用该函数之前,调用者需要首先把读/写块设备的信息保存在缓冲块头结构中,如设备号,块号.
// 参数:rw - READ,READA,WRITE或WRITEA是命令;bh - 数据缓冲块头指针.
void ll_rw_block(int rw, struct buffer_head * bh)
{
   1846f:	53                   	push   %ebx
   18470:	83 ec 18             	sub    $0x18,%esp
   18473:	e8 7a e8 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   18478:	05 88 9b 01 00       	add    $0x19b88,%eax
	unsigned int major;									// 主设备号(对于硬盘是3)

	// 如果设备主设备号不存在或者该设备的请求操作函数不存在,则显示出错信息,并返回.否则创建请求项并插入请求队列.
	if ((major = MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
   1847d:	8b 54 24 24          	mov    0x24(%esp),%edx
   18481:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   18485:	66 c1 ea 08          	shr    $0x8,%dx
   18489:	0f b7 d2             	movzwl %dx,%edx
   1848c:	89 54 24 0c          	mov    %edx,0xc(%esp)
   18490:	83 7c 24 0c 06       	cmpl   $0x6,0xc(%esp)
   18495:	77 0f                	ja     184a6 <ll_rw_block+0x37>
	!(blk_dev[major].request_fn)) {
   18497:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1849b:	8b 94 d0 80 41 00 00 	mov    0x4180(%eax,%edx,8),%edx
	if ((major = MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
   184a2:	85 d2                	test   %edx,%edx
   184a4:	75 16                	jne    184bc <ll_rw_block+0x4d>
		printk("Trying to read nonexistent block-device\n\r");
   184a6:	83 ec 0c             	sub    $0xc,%esp
   184a9:	8d 90 10 55 ff ff    	lea    -0xaaf0(%eax),%edx
   184af:	52                   	push   %edx
   184b0:	89 c3                	mov    %eax,%ebx
   184b2:	e8 7b 0e ff ff       	call   9332 <printk>
   184b7:	83 c4 10             	add    $0x10,%esp
		return;
   184ba:	eb 18                	jmp    184d4 <ll_rw_block+0x65>
	}
	make_request(major, rw, bh);
   184bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   184c0:	83 ec 04             	sub    $0x4,%esp
   184c3:	ff 74 24 28          	pushl  0x28(%esp)
   184c7:	ff 74 24 28          	pushl  0x28(%esp)
   184cb:	50                   	push   %eax
   184cc:	e8 54 fc ff ff       	call   18125 <make_request>
   184d1:	83 c4 10             	add    $0x10,%esp
}
   184d4:	83 c4 18             	add    $0x18,%esp
   184d7:	5b                   	pop    %ebx
   184d8:	c3                   	ret    

000184d9 <blk_dev_init>:

// 块设备初始化函数,由初始化程序main.c调用.
// 初始化请求数组,将所有请求项置为空闲项(dev = -1).有32项(NR_REQUEST = 32).
void blk_dev_init(void)
{
   184d9:	53                   	push   %ebx
   184da:	83 ec 10             	sub    $0x10,%esp
   184dd:	e8 14 e8 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   184e2:	81 c2 1e 9b 01 00    	add    $0x19b1e,%edx
	int i;

	for (i = 0; i < NR_REQUEST; i++) {
   184e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   184ef:	00 
   184f0:	eb 40                	jmp    18532 <blk_dev_init+0x59>
		request[i].dev = -1;
   184f2:	c7 c3 00 64 04 00    	mov    $0x46400,%ebx
   184f8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   184fc:	89 c8                	mov    %ecx,%eax
   184fe:	c1 e0 03             	shl    $0x3,%eax
   18501:	01 c8                	add    %ecx,%eax
   18503:	c1 e0 02             	shl    $0x2,%eax
   18506:	01 d8                	add    %ebx,%eax
   18508:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
		request[i].next = NULL;
   1850e:	c7 c3 00 64 04 00    	mov    $0x46400,%ebx
   18514:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   18518:	89 c8                	mov    %ecx,%eax
   1851a:	c1 e0 03             	shl    $0x3,%eax
   1851d:	01 c8                	add    %ecx,%eax
   1851f:	c1 e0 02             	shl    $0x2,%eax
   18522:	01 d8                	add    %ebx,%eax
   18524:	83 c0 20             	add    $0x20,%eax
   18527:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	for (i = 0; i < NR_REQUEST; i++) {
   1852d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   18532:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
   18537:	7e b9                	jle    184f2 <blk_dev_init+0x19>
	}
}
   18539:	90                   	nop
   1853a:	83 c4 10             	add    $0x10,%esp
   1853d:	5b                   	pop    %ebx
   1853e:	c3                   	ret    

0001853f <unlock_buffer>:
static void (DEVICE_REQUEST)(void);

// 解锁指定的缓冲块.
// 如果指定缓冲块bh并没有被上锁,则显示警告信息.否则将该缓冲块解锁,并唤醒等待该缓冲块的进程.此为内嵌函数.参数是缓冲块头指针.
static inline void unlock_buffer(struct buffer_head * bh)
{
   1853f:	53                   	push   %ebx
   18540:	83 ec 08             	sub    $0x8,%esp
   18543:	e8 b2 e7 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18548:	81 c3 b8 9a 01 00    	add    $0x19ab8,%ebx
	if (!bh->b_lock)
   1854e:	8b 44 24 10          	mov    0x10(%esp),%eax
   18552:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   18556:	84 c0                	test   %al,%al
   18558:	75 12                	jne    1856c <unlock_buffer+0x2d>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   1855a:	83 ec 0c             	sub    $0xc,%esp
   1855d:	8d 83 60 55 ff ff    	lea    -0xaaa0(%ebx),%eax
   18563:	50                   	push   %eax
   18564:	e8 c9 0d ff ff       	call   9332 <printk>
   18569:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   1856c:	8b 44 24 10          	mov    0x10(%esp),%eax
   18570:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);
   18574:	8b 44 24 10          	mov    0x10(%esp),%eax
   18578:	83 c0 10             	add    $0x10,%eax
   1857b:	83 ec 0c             	sub    $0xc,%esp
   1857e:	50                   	push   %eax
   1857f:	e8 23 ed fe ff       	call   72a7 <wake_up>
   18584:	83 c4 10             	add    $0x10,%esp
}
   18587:	90                   	nop
   18588:	83 c4 08             	add    $0x8,%esp
   1858b:	5b                   	pop    %ebx
   1858c:	c3                   	ret    

0001858d <end_request>:
// 参数uptodate是更新标志.
// 首先关闭指定块设备,然后检查此次读写缓冲区是否有效.如果有效则根据参数值设置缓冲区数据更新标志,并解锁该缓冲区.如果更新标志参数值是0,
// 表示此次请求项的操作失败,因此显示相关块设备IO错误信息.最后,唤醒等待该请求项的进程以及等待空闲请求项出现的进程,释放并从请求链表
// 中删除本请求项,并把当前请求项指针指向下一请求项.
static inline void end_request(int uptodate)
{
   1858d:	53                   	push   %ebx
   1858e:	83 ec 08             	sub    $0x8,%esp
   18591:	e8 64 e7 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18596:	81 c3 6a 9a 01 00    	add    $0x19a6a,%ebx
	DEVICE_OFF(CURRENT->dev);							// 关闭设备
   1859c:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   185a2:	8b 40 14             	mov    0x14(%eax),%eax
   185a5:	8b 00                	mov    (%eax),%eax
   185a7:	83 e0 03             	and    $0x3,%eax
   185aa:	83 ec 0c             	sub    $0xc,%esp
   185ad:	50                   	push   %eax
   185ae:	e8 9a ee fe ff       	call   744d <floppy_off>
   185b3:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->bh) {									// CURRENT为当前请求结构项指针
   185b6:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   185bc:	8b 40 14             	mov    0x14(%eax),%eax
   185bf:	8b 40 1c             	mov    0x1c(%eax),%eax
   185c2:	85 c0                	test   %eax,%eax
   185c4:	74 2b                	je     185f1 <end_request+0x64>
		CURRENT->bh->b_uptodate = uptodate;				// 置更新标志.
   185c6:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   185cc:	8b 40 14             	mov    0x14(%eax),%eax
   185cf:	8b 40 1c             	mov    0x1c(%eax),%eax
   185d2:	8b 54 24 10          	mov    0x10(%esp),%edx
   185d6:	88 50 0a             	mov    %dl,0xa(%eax)
		unlock_buffer(CURRENT->bh);						// 解锁缓冲区.
   185d9:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   185df:	8b 40 14             	mov    0x14(%eax),%eax
   185e2:	8b 40 1c             	mov    0x1c(%eax),%eax
   185e5:	83 ec 0c             	sub    $0xc,%esp
   185e8:	50                   	push   %eax
   185e9:	e8 51 ff ff ff       	call   1853f <unlock_buffer>
   185ee:	83 c4 10             	add    $0x10,%esp
	}
	if (!uptodate) {									// 若更新标志为0则显示出错信息.
   185f1:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   185f6:	75 40                	jne    18638 <end_request+0xab>
		printk(DEVICE_NAME " I/O error\n\r");
   185f8:	83 ec 0c             	sub    $0xc,%esp
   185fb:	8d 83 84 55 ff ff    	lea    -0xaa7c(%ebx),%eax
   18601:	50                   	push   %eax
   18602:	e8 2b 0d ff ff       	call   9332 <printk>
   18607:	83 c4 10             	add    $0x10,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
			CURRENT->bh->b_blocknr);
   1860a:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18610:	8b 40 14             	mov    0x14(%eax),%eax
   18613:	8b 40 1c             	mov    0x1c(%eax),%eax
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   18616:	8b 50 04             	mov    0x4(%eax),%edx
   18619:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1861f:	8b 40 14             	mov    0x14(%eax),%eax
   18622:	8b 00                	mov    (%eax),%eax
   18624:	83 ec 04             	sub    $0x4,%esp
   18627:	52                   	push   %edx
   18628:	50                   	push   %eax
   18629:	8d 83 97 55 ff ff    	lea    -0xaa69(%ebx),%eax
   1862f:	50                   	push   %eax
   18630:	e8 fd 0c ff ff       	call   9332 <printk>
   18635:	83 c4 10             	add    $0x10,%esp
	}
	wake_up(&CURRENT->waiting);							// 唤醒等待该请求项的进程.
   18638:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1863e:	8b 40 14             	mov    0x14(%eax),%eax
   18641:	83 c0 18             	add    $0x18,%eax
   18644:	83 ec 0c             	sub    $0xc,%esp
   18647:	50                   	push   %eax
   18648:	e8 5a ec fe ff       	call   72a7 <wake_up>
   1864d:	83 c4 10             	add    $0x10,%esp
	wake_up(&wait_for_request);							// 唤醒等待空闲请求项的进程.
   18650:	83 ec 0c             	sub    $0xc,%esp
   18653:	c7 c0 60 61 03 00    	mov    $0x36160,%eax
   18659:	50                   	push   %eax
   1865a:	e8 48 ec fe ff       	call   72a7 <wake_up>
   1865f:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;									// 释放该请求项.
   18662:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18668:	8b 40 14             	mov    0x14(%eax),%eax
   1866b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;							// 指向下一请求项.
   18671:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18677:	8b 40 14             	mov    0x14(%eax),%eax
   1867a:	8b 50 20             	mov    0x20(%eax),%edx
   1867d:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18683:	89 50 14             	mov    %edx,0x14(%eax)
}
   18686:	90                   	nop
   18687:	83 c4 08             	add    $0x8,%esp
   1868a:	5b                   	pop    %ebx
   1868b:	c3                   	ret    

0001868c <floppy_deselect>:

// 取消选定软驱.
// 如果函数参数指定的软驱nr当前并没有被选定,则显示警告信息.然后复位软驱已选定标志selected,并唤醒等待选择该软驱的任务.数字输出
// 寄存器(DOR)的低2位用于指定选择的软驱(0-3对应A-D).
void floppy_deselect(unsigned int nr)
{
   1868c:	53                   	push   %ebx
   1868d:	83 ec 08             	sub    $0x8,%esp
   18690:	e8 65 e6 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18695:	81 c3 6b 99 01 00    	add    $0x1996b,%ebx
	if (nr != (current_DOR & 3))
   1869b:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   186a1:	0f b6 00             	movzbl (%eax),%eax
   186a4:	0f b6 c0             	movzbl %al,%eax
   186a7:	83 e0 03             	and    $0x3,%eax
   186aa:	39 44 24 10          	cmp    %eax,0x10(%esp)
   186ae:	74 12                	je     186c2 <floppy_deselect+0x36>
		printk("floppy_deselect: drive not selected\n\r");
   186b0:	83 ec 0c             	sub    $0xc,%esp
   186b3:	8d 83 ac 55 ff ff    	lea    -0xaa54(%ebx),%eax
   186b9:	50                   	push   %eax
   186ba:	e8 73 0c ff ff       	call   9332 <printk>
   186bf:	83 c4 10             	add    $0x10,%esp
	selected = 0;											// 复位软驱已选定标志.
   186c2:	c6 83 d8 41 00 00 00 	movb   $0x0,0x41d8(%ebx)
	wake_up(&wait_on_floppy_select);						// 唤醒等待的任务.
   186c9:	83 ec 0c             	sub    $0xc,%esp
   186cc:	8d 83 dc 41 00 00    	lea    0x41dc(%ebx),%eax
   186d2:	50                   	push   %eax
   186d3:	e8 cf eb fe ff       	call   72a7 <wake_up>
   186d8:	83 c4 10             	add    $0x10,%esp
}
   186db:	90                   	nop
   186dc:	83 c4 08             	add    $0x8,%esp
   186df:	5b                   	pop    %ebx
   186e0:	c3                   	ret    

000186e1 <floppy_change>:
// 检测指定软驱中软盘更换情况.
// 参数nr是软驱号.如果软盘更换了则返回1,否则返回0.
// 该函数首先选定参数指定的软驱nr,然后测试软盘控制器的数字输入寄存器DIR的值,以判断驱动器中的软盘是否被更换过.该函数由程序
// fs/buffer.c中的check_disk_change()函数调用.
int floppy_change(unsigned int nr)
{
   186e1:	53                   	push   %ebx
   186e2:	83 ec 18             	sub    $0x18,%esp
   186e5:	e8 10 e6 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   186ea:	81 c3 16 99 01 00    	add    $0x19916,%ebx
	// 首先要让软驱中软盘旋转起来并达到正常工作转速.这需要花费一定时间.采用的方法是利用kernel/sched.c中软盘定时函数do_floppy_timer()
	// 进行一定的延时处理.floppy_on()函数则用于判断延时是否到(mon_timer[nr]==0?),若没有到则让当前进程继续睡眠等待.若延时到则
	// do_floppy_timer()会唤醒当前进程.
repeat:
	floppy_on(nr);										// 启动并等待指定软驱nr(kernel/sched.c)
   186f0:	83 ec 0c             	sub    $0xc,%esp
   186f3:	ff 74 24 2c          	pushl  0x2c(%esp)
   186f7:	e8 06 ed fe ff       	call   7402 <floppy_on>
   186fc:	83 c4 10             	add    $0x10,%esp
	// 在软盘启动(旋转)之后,我们来查看一下当前选择的软驱是不是函数参数指定的软驱nr.
	// 如果当前选择的软驱不是指定的软驱nr,并且已经选定了其他软驱,则让当前任务进入可中断等待状态,以等待其他软驱被取消选定.参见上面
	// floppy_deselect().如果当前没有选择其他软驱或者其他软驱被取消选定而使当前任务被唤醒时,当前软驱仍然不是指定的软驱nr,则跳转到
	// 函数开始处重新循环等待.
	while ((current_DOR & 3) != nr && selected)
   186ff:	eb 12                	jmp    18713 <floppy_change+0x32>
		sleep_on(&wait_on_floppy_select);
   18701:	83 ec 0c             	sub    $0xc,%esp
   18704:	8d 83 dc 41 00 00    	lea    0x41dc(%ebx),%eax
   1870a:	50                   	push   %eax
   1870b:	e8 74 eb fe ff       	call   7284 <sleep_on>
   18710:	83 c4 10             	add    $0x10,%esp
	while ((current_DOR & 3) != nr && selected)
   18713:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   18719:	0f b6 00             	movzbl (%eax),%eax
   1871c:	0f b6 c0             	movzbl %al,%eax
   1871f:	83 e0 03             	and    $0x3,%eax
   18722:	39 44 24 20          	cmp    %eax,0x20(%esp)
   18726:	74 0b                	je     18733 <floppy_change+0x52>
   18728:	0f b6 83 d8 41 00 00 	movzbl 0x41d8(%ebx),%eax
   1872f:	84 c0                	test   %al,%al
   18731:	75 ce                	jne    18701 <floppy_change+0x20>
	if ((current_DOR & 3) != nr)
   18733:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   18739:	0f b6 00             	movzbl (%eax),%eax
   1873c:	0f b6 c0             	movzbl %al,%eax
   1873f:	83 e0 03             	and    $0x3,%eax
   18742:	39 44 24 20          	cmp    %eax,0x20(%esp)
   18746:	74 02                	je     1874a <floppy_change+0x69>
		goto repeat;
   18748:	eb a6                	jmp    186f0 <floppy_change+0xf>
	// 现在软盘控制器已经选定我们指定的软驱nr.于是取数字输入寄存器DIR的值,如果其最高位(位7)置位,则表示软盘已更换,此时即可关闭马达并
	// 返回1退出.否则关闭马达返回0退出.表示磁盘没有被更换.
	if (inb(FD_DIR) & 0x80) {
   1874a:	b8 f7 03 00 00       	mov    $0x3f7,%eax
   1874f:	89 c2                	mov    %eax,%edx
   18751:	ec                   	in     (%dx),%al
   18752:	88 44 24 0f          	mov    %al,0xf(%esp)
   18756:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1875b:	84 c0                	test   %al,%al
   1875d:	79 16                	jns    18775 <floppy_change+0x94>
		floppy_off(nr);
   1875f:	83 ec 0c             	sub    $0xc,%esp
   18762:	ff 74 24 2c          	pushl  0x2c(%esp)
   18766:	e8 e2 ec fe ff       	call   744d <floppy_off>
   1876b:	83 c4 10             	add    $0x10,%esp
		return 1;
   1876e:	b8 01 00 00 00       	mov    $0x1,%eax
   18773:	eb 14                	jmp    18789 <floppy_change+0xa8>
	}
	floppy_off(nr);
   18775:	83 ec 0c             	sub    $0xc,%esp
   18778:	ff 74 24 2c          	pushl  0x2c(%esp)
   1877c:	e8 cc ec fe ff       	call   744d <floppy_off>
   18781:	83 c4 10             	add    $0x10,%esp
	return 0;
   18784:	b8 00 00 00 00       	mov    $0x0,%eax
}
   18789:	83 c4 18             	add    $0x18,%esp
   1878c:	5b                   	pop    %ebx
   1878d:	c3                   	ret    

0001878e <setup_DMA>:
	:)

// 设置(初始化)软盘DMA通道.
// 软盘中数据读写操作是使用DMA进行的.因此在每次进行数据传输之前需要设置DMA芯片专门上用于软驱的通道2.
static void setup_DMA(void)
{
   1878e:	57                   	push   %edi
   1878f:	56                   	push   %esi
   18790:	53                   	push   %ebx
   18791:	83 ec 10             	sub    $0x10,%esp
   18794:	e8 5d e5 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   18799:	81 c2 67 98 01 00    	add    $0x19867,%edx
	long addr = (long) CURRENT->buffer;				// 当前请求项缓冲区所处内存地址.
   1879f:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   187a5:	8b 40 14             	mov    0x14(%eax),%eax
   187a8:	8b 40 14             	mov    0x14(%eax),%eax
   187ab:	89 44 24 0c          	mov    %eax,0xc(%esp)

	// 首先检测请求项的缓冲区所在位置.如果缓冲区处于内存1MB以上的某个地方,则需要将DMA缓冲区设在临时缓冲区域(tmp_floppy_area)处.因为
	// 8237A芯片只能在1MB地址范围内寻址.如果是写盘命令,则还需要把数据从请求项缓冲区复制到该临时区域.
	cli();
   187af:	fa                   	cli    
	if (addr >= 0x100000) {
   187b0:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
   187b7:	00 
   187b8:	7e 37                	jle    187f1 <setup_DMA+0x63>
		addr = (long) tmp_floppy_area;
   187ba:	c7 c0 00 50 00 00    	mov    $0x5000,%eax
   187c0:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (command == FD_WRITE)
   187c4:	0f b6 82 f8 41 00 00 	movzbl 0x41f8(%edx),%eax
   187cb:	3c c5                	cmp    $0xc5,%al
   187cd:	75 22                	jne    187f1 <setup_DMA+0x63>
			copy_buffer(CURRENT->buffer,tmp_floppy_area);
   187cf:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   187d5:	8b 40 14             	mov    0x14(%eax),%eax
   187d8:	8b 40 14             	mov    0x14(%eax),%eax
   187db:	89 c3                	mov    %eax,%ebx
   187dd:	c7 c0 00 50 00 00    	mov    $0x5000,%eax
   187e3:	89 c7                	mov    %eax,%edi
   187e5:	b8 00 01 00 00       	mov    $0x100,%eax
   187ea:	89 c1                	mov    %eax,%ecx
   187ec:	89 de                	mov    %ebx,%esi
   187ee:	fc                   	cld    
   187ef:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	}
	// 接下来我们开始设置DMA通道2.在开始设置之前需要先屏蔽该通道.单通道屏蔽寄存器端口为0x0A.位0-1指定DMA通道(0--3),位2:1表示屏蔽,0
	// 表示允许请求.然后向DMA控制器端口D12和11写入方式字(读盘是0x46,写盘是0x4A).再写入传输使用缓冲区地址addr和需要传输的字节数0x3ff
	// (0--1023).最后复位对DMA通道2的屏蔽,开放DMA2请求DREQ信号.
	/* mask DMA 2 */	/* 屏蔽DMA通道2 */
	immoutb_p(4 | 2,10);
   187f1:	b8 06 00 00 00       	mov    $0x6,%eax
   187f6:	e6 0a                	out    %al,$0xa
   187f8:	eb 00                	jmp    187fa <setup_DMA+0x6c>
   187fa:	eb 00                	jmp    187fc <setup_DMA+0x6e>
	// 由于各通道的地址和计数寄存器都是16位的,因此在设置他们时都需要分2次进行操作.一次访问低字节,另一次访问高字节.而实际在写哪个字节则
	// 由先后触发器的状态一.当触发器为0时,则访问低字节;当字节触发器为1时,则访问高字节.每访问一次,该触发器的状态就变化一次.而写端口12就可
	// 以将触发顺置成0状态,从而对16位寄存器的设置从低字节开始.
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
	"outb %%al,$11\n\tjmp 1f\n1:\tjmp 1f\n1:"::
	"a" ((char) ((command == FD_READ)?DMA_READ:DMA_WRITE)));
   187fc:	0f b6 82 f8 41 00 00 	movzbl 0x41f8(%edx),%eax
   18803:	3c e6                	cmp    $0xe6,%al
   18805:	75 07                	jne    1880e <setup_DMA+0x80>
   18807:	b8 46 00 00 00       	mov    $0x46,%eax
   1880c:	eb 05                	jmp    18813 <setup_DMA+0x85>
   1880e:	b8 4a 00 00 00       	mov    $0x4a,%eax
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   18813:	e6 0c                	out    %al,$0xc
   18815:	eb 00                	jmp    18817 <setup_DMA+0x89>
   18817:	eb 00                	jmp    18819 <setup_DMA+0x8b>
   18819:	e6 0b                	out    %al,$0xb
   1881b:	eb 00                	jmp    1881d <setup_DMA+0x8f>
   1881d:	eb 00                	jmp    1881f <setup_DMA+0x91>
	/* 8 low bits of addr */	/* 地址氏0-7位 */
	// 向DMA通道2写入基/当前地址寄存器(端口4).
	immoutb_p(addr, 4);
   1881f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18823:	e6 04                	out    %al,$0x4
   18825:	eb 00                	jmp    18827 <setup_DMA+0x99>
   18827:	eb 00                	jmp    18829 <setup_DMA+0x9b>
	addr >>= 8;
   18829:	c1 7c 24 0c 08       	sarl   $0x8,0xc(%esp)
	/* bits 8-15 of addr */		/* 地址高8-15位 */
	immoutb_p(addr, 4);
   1882e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18832:	e6 04                	out    %al,$0x4
   18834:	eb 00                	jmp    18836 <setup_DMA+0xa8>
   18836:	eb 00                	jmp    18838 <setup_DMA+0xaa>
	addr >>= 8;
   18838:	c1 7c 24 0c 08       	sarl   $0x8,0xc(%esp)
	/* bits 16-19 of addr */	/* 地址16-19位 */
	// DMA只可以在1MB内存空间内寻址,基高16-19位地址需放入页面寄存器(端口0x81).
	immoutb_p(addr, 0x81);
   1883d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   18841:	e6 81                	out    %al,$0x81
   18843:	eb 00                	jmp    18845 <setup_DMA+0xb7>
   18845:	eb 00                	jmp    18847 <setup_DMA+0xb9>
	/* low 8 bits of count-1 (1024-1=0x3ff) */	/* 计数器低8位(1024-1 = 0x3ff) */
	// 向DMA通道2写入基/当前字节计数值(端口5).
	immoutb_p(0xff, 5);
   18847:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1884c:	e6 05                	out    %al,$0x5
   1884e:	eb 00                	jmp    18850 <setup_DMA+0xc2>
   18850:	eb 00                	jmp    18852 <setup_DMA+0xc4>
	/* high 8 bits of count-1 */	/* 计数器高8位 */
	// 一次共传输1024字节(两个扇区).
	immoutb_p(3, 5);
   18852:	b8 03 00 00 00       	mov    $0x3,%eax
   18857:	e6 05                	out    %al,$0x5
   18859:	eb 00                	jmp    1885b <setup_DMA+0xcd>
   1885b:	eb 00                	jmp    1885d <setup_DMA+0xcf>
	/* activate DMA 2 */	/* 开启DMA通道2的请求 */
	immoutb_p(0 | 2, 10);
   1885d:	b8 02 00 00 00       	mov    $0x2,%eax
   18862:	e6 0a                	out    %al,$0xa
   18864:	eb 00                	jmp    18866 <setup_DMA+0xd8>
   18866:	eb 00                	jmp    18868 <setup_DMA+0xda>
	sti();
   18868:	fb                   	sti    
}
   18869:	90                   	nop
   1886a:	83 c4 10             	add    $0x10,%esp
   1886d:	5b                   	pop    %ebx
   1886e:	5e                   	pop    %esi
   1886f:	5f                   	pop    %edi
   18870:	c3                   	ret    

00018871 <output_byte>:

// 向软驱控制器输出一个字节命令或参数.
// 在向控制器发送一个字节之前,控制器需要处于准备好状态,并且数据传输方向必须设置成从CPU到FDC,因此函数需要首先读取控制器状态信息.
// 这里使用了循环查询方式,以作适当延时.若出错,则会设置复位标志reset.
static void output_byte(char byte)
{
   18871:	53                   	push   %ebx
   18872:	83 ec 28             	sub    $0x28,%esp
   18875:	e8 bd 41 ff ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1887a:	81 c1 86 97 01 00    	add    $0x19786,%ecx
   18880:	8b 44 24 30          	mov    0x30(%esp),%eax
   18884:	88 44 24 0c          	mov    %al,0xc(%esp)
	int counter;
	unsigned char status;

	// 循环读取主状态控制器FD_STATUS(0x3f4)的状态.如果所读状态是STATUS_READY并且方向位STATUS_DIR = 0(CPU ->FDC),则向数据端口输出
	// 指定字节.
	if (reset)
   18888:	8b 81 e4 41 00 00    	mov    0x41e4(%ecx),%eax
   1888e:	85 c0                	test   %eax,%eax
   18890:	75 69                	jne    188fb <output_byte+0x8a>
		return;
	for(counter = 0 ; counter < 10000 ; counter++) {
   18892:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   18899:	00 
   1889a:	eb 35                	jmp    188d1 <output_byte+0x60>
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1889c:	b8 f4 03 00 00       	mov    $0x3f4,%eax
   188a1:	89 c2                	mov    %eax,%edx
   188a3:	ec                   	in     (%dx),%al
   188a4:	eb 00                	jmp    188a6 <output_byte+0x35>
   188a6:	eb 00                	jmp    188a8 <output_byte+0x37>
   188a8:	88 44 24 1b          	mov    %al,0x1b(%esp)
   188ac:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
   188b1:	83 e0 c0             	and    $0xffffffc0,%eax
   188b4:	88 44 24 1a          	mov    %al,0x1a(%esp)
		if (status == STATUS_READY) {
   188b8:	80 7c 24 1a 80       	cmpb   $0x80,0x1a(%esp)
   188bd:	75 0d                	jne    188cc <output_byte+0x5b>
			outb(byte,FD_DATA);
   188bf:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
   188c4:	ba f5 03 00 00       	mov    $0x3f5,%edx
   188c9:	ee                   	out    %al,(%dx)
			return;
   188ca:	eb 30                	jmp    188fc <output_byte+0x8b>
	for(counter = 0 ; counter < 10000 ; counter++) {
   188cc:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   188d1:	81 7c 24 1c 0f 27 00 	cmpl   $0x270f,0x1c(%esp)
   188d8:	00 
   188d9:	7e c1                	jle    1889c <output_byte+0x2b>
		}
	}
	// 如果到循环1万次结束还不能发送,则置复位标志,并打印出错信息.
	reset = 1;
   188db:	c7 81 e4 41 00 00 01 	movl   $0x1,0x41e4(%ecx)
   188e2:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   188e5:	83 ec 0c             	sub    $0xc,%esp
   188e8:	8d 81 d2 55 ff ff    	lea    -0xaa2e(%ecx),%eax
   188ee:	50                   	push   %eax
   188ef:	89 cb                	mov    %ecx,%ebx
   188f1:	e8 3c 0a ff ff       	call   9332 <printk>
   188f6:	83 c4 10             	add    $0x10,%esp
   188f9:	eb 01                	jmp    188fc <output_byte+0x8b>
		return;
   188fb:	90                   	nop
}
   188fc:	83 c4 28             	add    $0x28,%esp
   188ff:	5b                   	pop    %ebx
   18900:	c3                   	ret    

00018901 <result>:

// 读取FDC执行的结果信息.
// 结果信息最多7个字节,存放在数组reply_buffer[]中.返回读入的结果字节数,若返回值=-1,则表示出错.程序处理方式与上面函数类似.
static int result(void)
{
   18901:	53                   	push   %ebx
   18902:	83 ec 28             	sub    $0x28,%esp
   18905:	e8 2d 41 ff ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1890a:	81 c1 f6 96 01 00    	add    $0x196f6,%ecx
	int i = 0, counter, status;
   18910:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   18917:	00 

	// 若复位标志已置位,则立刻退出.去执行后续程序中的复位操作.否则循环读取主状态控制器FD_STATUS(0x3f4)的状态.如果读取的控制器状态
	// 是READY,表示已经没有数据可取,则返回已读取的字节数i.如果控制器状态是方向标志置位(CPU <-FDC),已准备好,忙,表示有数据可读取.
	// 于是把控制器中的结果数据读入到应答结果数组中.最多读取MAX_REPLIES(7)个字节.
	if (reset)
   18918:	8b 81 e4 41 00 00    	mov    0x41e4(%ecx),%eax
   1891e:	85 c0                	test   %eax,%eax
   18920:	74 0a                	je     1892c <result+0x2b>
		return -1;
   18922:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   18927:	e9 a8 00 00 00       	jmp    189d4 <result+0xd3>
	for (counter = 0 ; counter < 10000 ; counter++) {
   1892c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   18933:	00 
   18934:	eb 6e                	jmp    189a4 <result+0xa3>
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   18936:	b8 f4 03 00 00       	mov    $0x3f4,%eax
   1893b:	89 c2                	mov    %eax,%edx
   1893d:	ec                   	in     (%dx),%al
   1893e:	eb 00                	jmp    18940 <result+0x3f>
   18940:	eb 00                	jmp    18942 <result+0x41>
   18942:	88 44 24 17          	mov    %al,0x17(%esp)
   18946:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
   1894b:	0f b6 c0             	movzbl %al,%eax
   1894e:	25 d0 00 00 00       	and    $0xd0,%eax
   18953:	89 44 24 10          	mov    %eax,0x10(%esp)
		if (status == STATUS_READY)
   18957:	81 7c 24 10 80 00 00 	cmpl   $0x80,0x10(%esp)
   1895e:	00 
   1895f:	75 06                	jne    18967 <result+0x66>
			return i;
   18961:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   18965:	eb 6d                	jmp    189d4 <result+0xd3>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   18967:	81 7c 24 10 d0 00 00 	cmpl   $0xd0,0x10(%esp)
   1896e:	00 
   1896f:	75 2e                	jne    1899f <result+0x9e>
			if (i >= MAX_REPLIES)
   18971:	83 7c 24 1c 06       	cmpl   $0x6,0x1c(%esp)
   18976:	7f 38                	jg     189b0 <result+0xaf>
				break;
			reply_buffer[i++] = inb_p(FD_DATA);
   18978:	b8 f5 03 00 00       	mov    $0x3f5,%eax
   1897d:	89 c2                	mov    %eax,%edx
   1897f:	ec                   	in     (%dx),%al
   18980:	eb 00                	jmp    18982 <result+0x81>
   18982:	eb 00                	jmp    18984 <result+0x83>
   18984:	88 44 24 0f          	mov    %al,0xf(%esp)
   18988:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
   1898d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   18991:	8d 58 01             	lea    0x1(%eax),%ebx
   18994:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
   18998:	88 94 01 ec 41 00 00 	mov    %dl,0x41ec(%ecx,%eax,1)
	for (counter = 0 ; counter < 10000 ; counter++) {
   1899f:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   189a4:	81 7c 24 18 0f 27 00 	cmpl   $0x270f,0x18(%esp)
   189ab:	00 
   189ac:	7e 88                	jle    18936 <result+0x35>
   189ae:	eb 01                	jmp    189b1 <result+0xb0>
				break;
   189b0:	90                   	nop
		}
	}
	// 如果到循环1万次结束还不能发送,则置复位标志,并打印出错信息.
	reset = 1;
   189b1:	c7 81 e4 41 00 00 01 	movl   $0x1,0x41e4(%ecx)
   189b8:	00 00 00 
	printk("Getstatus times out\n\r");
   189bb:	83 ec 0c             	sub    $0xc,%esp
   189be:	8d 81 ef 55 ff ff    	lea    -0xaa11(%ecx),%eax
   189c4:	50                   	push   %eax
   189c5:	89 cb                	mov    %ecx,%ebx
   189c7:	e8 66 09 ff ff       	call   9332 <printk>
   189cc:	83 c4 10             	add    $0x10,%esp
	return -1;
   189cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   189d4:	83 c4 28             	add    $0x28,%esp
   189d7:	5b                   	pop    %ebx
   189d8:	c3                   	ret    

000189d9 <bad_flp_intr>:
// 该函数根据软盘读写出错次数来确定需要采取的进一步行动.如果当前处理的请求项出错次数大于规定的最大出错次数MAX_ERRORS(8次),则
// 不再对当前请求项作进一步的操作尝试.如果读/写出错次数已经超过MAX_ERRORS/2,则需要对软驱作复位处理,于是设置复位标志reset.否则
// 若出错次数还不到最大值的一半,则只需重新校正一下磁头位置,于是设置重新校正标志recalibrate.真正的复位和重新校正处理会在后续的
// 程序中进行.
static void bad_flp_intr(void)
{
   189d9:	53                   	push   %ebx
   189da:	83 ec 08             	sub    $0x8,%esp
   189dd:	e8 18 e3 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   189e2:	81 c3 1e 96 01 00    	add    $0x1961e,%ebx
	// 首先把当前请求项出错次数增1.如果当前请求项出错次数大于最大允许出错次数,则取消选定当前软驱,并结束该请求项(缓冲区内容没有被更新).
	CURRENT->errors++;
   189e8:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   189ee:	8b 40 14             	mov    0x14(%eax),%eax
   189f1:	8b 50 08             	mov    0x8(%eax),%edx
   189f4:	83 c2 01             	add    $0x1,%edx
   189f7:	89 50 08             	mov    %edx,0x8(%eax)
	if (CURRENT->errors > MAX_ERRORS) {
   189fa:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18a00:	8b 40 14             	mov    0x14(%eax),%eax
   18a03:	8b 40 08             	mov    0x8(%eax),%eax
   18a06:	83 f8 08             	cmp    $0x8,%eax
   18a09:	7e 23                	jle    18a2e <bad_flp_intr+0x55>
		floppy_deselect(current_drive);
   18a0b:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18a12:	0f b6 c0             	movzbl %al,%eax
   18a15:	83 ec 0c             	sub    $0xc,%esp
   18a18:	50                   	push   %eax
   18a19:	e8 6e fc ff ff       	call   1868c <floppy_deselect>
   18a1e:	83 c4 10             	add    $0x10,%esp
		end_request(0);
   18a21:	83 ec 0c             	sub    $0xc,%esp
   18a24:	6a 00                	push   $0x0
   18a26:	e8 62 fb ff ff       	call   1858d <end_request>
   18a2b:	83 c4 10             	add    $0x10,%esp
	}
	// 如果当前请求项出错次数大于在允许出错次数的一半,则置复位标志,需对软驱进行复位操作,然后再试.否则软驱需重新校正一下再试.
	if (CURRENT->errors > MAX_ERRORS / 2)
   18a2e:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18a34:	8b 40 14             	mov    0x14(%eax),%eax
   18a37:	8b 40 08             	mov    0x8(%eax),%eax
   18a3a:	83 f8 04             	cmp    $0x4,%eax
   18a3d:	7e 0c                	jle    18a4b <bad_flp_intr+0x72>
		reset = 1;
   18a3f:	c7 83 e4 41 00 00 01 	movl   $0x1,0x41e4(%ebx)
   18a46:	00 00 00 
	else
		recalibrate = 1;
}
   18a49:	eb 0a                	jmp    18a55 <bad_flp_intr+0x7c>
		recalibrate = 1;
   18a4b:	c7 83 e0 41 00 00 01 	movl   $0x1,0x41e0(%ebx)
   18a52:	00 00 00 
}
   18a55:	90                   	nop
   18a56:	83 c4 08             	add    $0x8,%esp
   18a59:	5b                   	pop    %ebx
   18a5a:	c3                   	ret    

00018a5b <rw_interrupt>:
 */
// 软盘读写中断调用函数.
// 该函数在软驱控制器操作结束后引发的中断处理过程中被调用.函数首先读取操作结果状态信息,据此判断操作是否出现问题并作相应处理.如果
// 读/写操作成功,那么若请求项是读操作并且其缓冲区在内存1MB以上位置,则需要把数据从软盘临时缓冲区复制到请求项的缓冲区.
static void rw_interrupt(void)
{
   18a5b:	57                   	push   %edi
   18a5c:	56                   	push   %esi
   18a5d:	53                   	push   %ebx
   18a5e:	e8 97 e2 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18a63:	81 c3 9d 95 01 00    	add    $0x1959d,%ebx
	// 读取FDC执行的结果信息.如果返回字节数不等于7,或者状态字节0,1或2中存在出错标志,那么若是写保护就显示出错信息,释放当前驱动器,并
	// 结束当前请求项.否则就执行出错计数处理.然后继续执行软盘请求项操作.以下状态的含义参见fdreg.h文件.
	if (result() != 7 || (ST0 & 0xd8) || (ST1 & 0xbf) || (ST2 & 0x73)) {    // 把0xf8修改0xd8
   18a69:	e8 93 fe ff ff       	call   18901 <result>
   18a6e:	83 f8 07             	cmp    $0x7,%eax
   18a71:	75 37                	jne    18aaa <rw_interrupt+0x4f>
   18a73:	0f b6 83 ec 41 00 00 	movzbl 0x41ec(%ebx),%eax
   18a7a:	0f b6 c0             	movzbl %al,%eax
   18a7d:	25 d8 00 00 00       	and    $0xd8,%eax
   18a82:	85 c0                	test   %eax,%eax
   18a84:	75 24                	jne    18aaa <rw_interrupt+0x4f>
   18a86:	0f b6 83 ed 41 00 00 	movzbl 0x41ed(%ebx),%eax
   18a8d:	0f b6 c0             	movzbl %al,%eax
   18a90:	25 bf 00 00 00       	and    $0xbf,%eax
   18a95:	85 c0                	test   %eax,%eax
   18a97:	75 11                	jne    18aaa <rw_interrupt+0x4f>
   18a99:	0f b6 83 ee 41 00 00 	movzbl 0x41ee(%ebx),%eax
   18aa0:	0f b6 c0             	movzbl %al,%eax
   18aa3:	83 e0 73             	and    $0x73,%eax
   18aa6:	85 c0                	test   %eax,%eax
   18aa8:	74 5f                	je     18b09 <rw_interrupt+0xae>
		if (ST1 & 0x02) {
   18aaa:	0f b6 83 ed 41 00 00 	movzbl 0x41ed(%ebx),%eax
   18ab1:	0f b6 c0             	movzbl %al,%eax
   18ab4:	83 e0 02             	and    $0x2,%eax
   18ab7:	85 c0                	test   %eax,%eax
   18ab9:	74 42                	je     18afd <rw_interrupt+0xa2>
			printk("Drive %d is write protected\n\r",current_drive);
   18abb:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18ac2:	0f b6 c0             	movzbl %al,%eax
   18ac5:	83 ec 08             	sub    $0x8,%esp
   18ac8:	50                   	push   %eax
   18ac9:	8d 83 05 56 ff ff    	lea    -0xa9fb(%ebx),%eax
   18acf:	50                   	push   %eax
   18ad0:	e8 5d 08 ff ff       	call   9332 <printk>
   18ad5:	83 c4 10             	add    $0x10,%esp
			floppy_deselect(current_drive);
   18ad8:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18adf:	0f b6 c0             	movzbl %al,%eax
   18ae2:	83 ec 0c             	sub    $0xc,%esp
   18ae5:	50                   	push   %eax
   18ae6:	e8 a1 fb ff ff       	call   1868c <floppy_deselect>
   18aeb:	83 c4 10             	add    $0x10,%esp
			end_request(0);
   18aee:	83 ec 0c             	sub    $0xc,%esp
   18af1:	6a 00                	push   $0x0
   18af3:	e8 95 fa ff ff       	call   1858d <end_request>
   18af8:	83 c4 10             	add    $0x10,%esp
   18afb:	eb 05                	jmp    18b02 <rw_interrupt+0xa7>
		} else
			bad_flp_intr();
   18afd:	e8 d7 fe ff ff       	call   189d9 <bad_flp_intr>
		do_fd_request();
   18b02:	e8 03 06 00 00       	call   1910a <do_fd_request>
		return;
   18b07:	eb 68                	jmp    18b71 <rw_interrupt+0x116>
	}
	// 如果当前请求项的缓冲区位于1MB地址以上,则说明此次软盘读操作的内容还放在临时缓冲区内,需要复制到当前请求项的缓冲区中(因为DMA只能在
	// 1MB地址范围寻址).最后释放当前软驱(取消选定),执行当前请求项结束处理:唤醒等待该请求项的进程,唤醒等待空闲请求项的进程(若有的话),从软驱
	// 设备请求项链表中删除本请求项.再继续执行其他软盘请求项操作.
	if (command == FD_READ && (unsigned long)(CURRENT->buffer) >= 0x100000)
   18b09:	0f b6 83 f8 41 00 00 	movzbl 0x41f8(%ebx),%eax
   18b10:	3c e6                	cmp    $0xe6,%al
   18b12:	75 35                	jne    18b49 <rw_interrupt+0xee>
   18b14:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18b1a:	8b 40 14             	mov    0x14(%eax),%eax
   18b1d:	8b 40 14             	mov    0x14(%eax),%eax
   18b20:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
   18b25:	76 22                	jbe    18b49 <rw_interrupt+0xee>
		copy_buffer(tmp_floppy_area,CURRENT->buffer);
   18b27:	c7 c0 00 50 00 00    	mov    $0x5000,%eax
   18b2d:	89 c2                	mov    %eax,%edx
   18b2f:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   18b35:	8b 40 14             	mov    0x14(%eax),%eax
   18b38:	8b 40 14             	mov    0x14(%eax),%eax
   18b3b:	89 c7                	mov    %eax,%edi
   18b3d:	b8 00 01 00 00       	mov    $0x100,%eax
   18b42:	89 c1                	mov    %eax,%ecx
   18b44:	89 d6                	mov    %edx,%esi
   18b46:	fc                   	cld    
   18b47:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	floppy_deselect(current_drive);
   18b49:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18b50:	0f b6 c0             	movzbl %al,%eax
   18b53:	83 ec 0c             	sub    $0xc,%esp
   18b56:	50                   	push   %eax
   18b57:	e8 30 fb ff ff       	call   1868c <floppy_deselect>
   18b5c:	83 c4 10             	add    $0x10,%esp
	end_request(1);
   18b5f:	83 ec 0c             	sub    $0xc,%esp
   18b62:	6a 01                	push   $0x1
   18b64:	e8 24 fa ff ff       	call   1858d <end_request>
   18b69:	83 c4 10             	add    $0x10,%esp
	do_fd_request();
   18b6c:	e8 99 05 00 00       	call   1910a <do_fd_request>
}
   18b71:	5b                   	pop    %ebx
   18b72:	5e                   	pop    %esi
   18b73:	5f                   	pop    %edi
   18b74:	c3                   	ret    

00018b75 <setup_rw_floppy>:

// 设置DMA通道2并向软盘控制器输出命令和参数(输出1字节命令+0~7字节参数).
// 若reset标志没有置位,那么在该函数退出并且软盘控制器执行完相应读/写操作后就会产生一个软盘中断请求,并开始执行软盘中断处理程序.
void setup_rw_floppy(void)
{
   18b75:	53                   	push   %ebx
   18b76:	83 ec 08             	sub    $0x8,%esp
   18b79:	e8 7c e1 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18b7e:	81 c3 82 94 01 00    	add    $0x19482,%ebx
	setup_DMA();										// 初始化软盘DMA通道.
   18b84:	e8 05 fc ff ff       	call   1878e <setup_DMA>
	do_floppy = rw_interrupt;							// 置软盘中断调用函数指针.
   18b89:	8d 83 5b 6a fe ff    	lea    -0x195a5(%ebx),%eax
   18b8f:	89 83 d4 41 00 00    	mov    %eax,0x41d4(%ebx)
	output_byte(command);								// 发送命令字节.
   18b95:	0f b6 83 f8 41 00 00 	movzbl 0x41f8(%ebx),%eax
   18b9c:	0f be c0             	movsbl %al,%eax
   18b9f:	83 ec 0c             	sub    $0xc,%esp
   18ba2:	50                   	push   %eax
   18ba3:	e8 c9 fc ff ff       	call   18871 <output_byte>
   18ba8:	83 c4 10             	add    $0x10,%esp
	output_byte(head<<2 | current_drive);				// 参数:磁头号 + 驱动器号.
   18bab:	0f b6 83 f5 41 00 00 	movzbl 0x41f5(%ebx),%eax
   18bb2:	0f b6 c0             	movzbl %al,%eax
   18bb5:	c1 e0 02             	shl    $0x2,%eax
   18bb8:	89 c2                	mov    %eax,%edx
   18bba:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18bc1:	09 d0                	or     %edx,%eax
   18bc3:	0f be c0             	movsbl %al,%eax
   18bc6:	83 ec 0c             	sub    $0xc,%esp
   18bc9:	50                   	push   %eax
   18bca:	e8 a2 fc ff ff       	call   18871 <output_byte>
   18bcf:	83 c4 10             	add    $0x10,%esp
	output_byte(track);									// 参数:磁道号.
   18bd2:	0f b6 83 f6 41 00 00 	movzbl 0x41f6(%ebx),%eax
   18bd9:	0f be c0             	movsbl %al,%eax
   18bdc:	83 ec 0c             	sub    $0xc,%esp
   18bdf:	50                   	push   %eax
   18be0:	e8 8c fc ff ff       	call   18871 <output_byte>
   18be5:	83 c4 10             	add    $0x10,%esp
	output_byte(head);									// 参数:磁头号.
   18be8:	0f b6 83 f5 41 00 00 	movzbl 0x41f5(%ebx),%eax
   18bef:	0f be c0             	movsbl %al,%eax
   18bf2:	83 ec 0c             	sub    $0xc,%esp
   18bf5:	50                   	push   %eax
   18bf6:	e8 76 fc ff ff       	call   18871 <output_byte>
   18bfb:	83 c4 10             	add    $0x10,%esp
	output_byte(sector);								// 参数:起始扇区号.
   18bfe:	0f b6 83 f4 41 00 00 	movzbl 0x41f4(%ebx),%eax
   18c05:	0f be c0             	movsbl %al,%eax
   18c08:	83 ec 0c             	sub    $0xc,%esp
   18c0b:	50                   	push   %eax
   18c0c:	e8 60 fc ff ff       	call   18871 <output_byte>
   18c11:	83 c4 10             	add    $0x10,%esp
	output_byte(2);										/* sector size = 512 */	// 参数:(N=2)512字节.
   18c14:	83 ec 0c             	sub    $0xc,%esp
   18c17:	6a 02                	push   $0x2
   18c19:	e8 53 fc ff ff       	call   18871 <output_byte>
   18c1e:	83 c4 10             	add    $0x10,%esp
	output_byte(floppy->sect);							// 参数:每磁道扇区数.
   18c21:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   18c27:	8b 40 04             	mov    0x4(%eax),%eax
   18c2a:	0f be c0             	movsbl %al,%eax
   18c2d:	83 ec 0c             	sub    $0xc,%esp
   18c30:	50                   	push   %eax
   18c31:	e8 3b fc ff ff       	call   18871 <output_byte>
   18c36:	83 c4 10             	add    $0x10,%esp
	output_byte(floppy->gap);							// 参数:扇区间隔长度.
   18c39:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   18c3f:	0f b6 40 14          	movzbl 0x14(%eax),%eax
   18c43:	0f be c0             	movsbl %al,%eax
   18c46:	83 ec 0c             	sub    $0xc,%esp
   18c49:	50                   	push   %eax
   18c4a:	e8 22 fc ff ff       	call   18871 <output_byte>
   18c4f:	83 c4 10             	add    $0x10,%esp
	output_byte(0xFF);									/* sector size (0xff when n!=0 ?) */ // 参数:当N=0时,扇区定义的字节长度,这里无用.
   18c52:	83 ec 0c             	sub    $0xc,%esp
   18c55:	6a ff                	push   $0xffffffff
   18c57:	e8 15 fc ff ff       	call   18871 <output_byte>
   18c5c:	83 c4 10             	add    $0x10,%esp
	// 若上述任何一个output_byte()操作出错,则会设置复位标志reset.此时即会立刻去执行do_fd_request()中的复位处理代码.
	if (reset)
   18c5f:	8b 83 e4 41 00 00    	mov    0x41e4(%ebx),%eax
   18c65:	85 c0                	test   %eax,%eax
   18c67:	74 05                	je     18c6e <setup_rw_floppy+0xf9>
		do_fd_request();
   18c69:	e8 9c 04 00 00       	call   1910a <do_fd_request>
}
   18c6e:	90                   	nop
   18c6f:	83 c4 08             	add    $0x8,%esp
   18c72:	5b                   	pop    %ebx
   18c73:	c3                   	ret    

00018c74 <seek_interrupt>:
 */
// 寻道处理结束后中断过程中调用的C函数.
// 首先发送检测中断状态命令,获得状态信息ST0和磁头所在磁道信息.若出错则执行错误计数检测处理或取消本次软盘操作请求项.否则根据
// 状态信息设置当前磁道变量,然后调用函数setup_rw_floppy()设置DMA并输出软盘读写命令和参数.
static void seek_interrupt(void)
{
   18c74:	53                   	push   %ebx
   18c75:	83 ec 08             	sub    $0x8,%esp
   18c78:	e8 7d e0 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18c7d:	81 c3 83 93 01 00    	add    $0x19383,%ebx
	// 首先发送检测中断状态命令,以获取寻道操作执行的结果.该命令不带参数.返回结果信息是两个字节:ST0和磁头当前磁道号.一读取FDC执行的
	// 结果信息.如果返回结果字节数不等于2,或者ST0不为寻道结束,或者磁头所在磁道(ST1)不等于设定磁道,则说明发生了错误.于是执行检测错误
	// 计数处理,然后继续执行软盘请求项或执行复位处理.
	/* sense drive status */	/* 检测驱动器状态 */
	output_byte(FD_SENSEI);
   18c83:	83 ec 0c             	sub    $0xc,%esp
   18c86:	6a 08                	push   $0x8
   18c88:	e8 e4 fb ff ff       	call   18871 <output_byte>
   18c8d:	83 c4 10             	add    $0x10,%esp
	if (result() != 2 || (ST0 & 0xF8) != 0x20 || ST1 != seek_track) {
   18c90:	e8 6c fc ff ff       	call   18901 <result>
   18c95:	83 f8 02             	cmp    $0x2,%eax
   18c98:	75 26                	jne    18cc0 <seek_interrupt+0x4c>
   18c9a:	0f b6 83 ec 41 00 00 	movzbl 0x41ec(%ebx),%eax
   18ca1:	0f b6 c0             	movzbl %al,%eax
   18ca4:	25 f8 00 00 00       	and    $0xf8,%eax
   18ca9:	83 f8 20             	cmp    $0x20,%eax
   18cac:	75 12                	jne    18cc0 <seek_interrupt+0x4c>
   18cae:	0f b6 93 ed 41 00 00 	movzbl 0x41ed(%ebx),%edx
   18cb5:	0f b6 83 f7 41 00 00 	movzbl 0x41f7(%ebx),%eax
   18cbc:	38 c2                	cmp    %al,%dl
   18cbe:	74 0c                	je     18ccc <seek_interrupt+0x58>
		bad_flp_intr();
   18cc0:	e8 14 fd ff ff       	call   189d9 <bad_flp_intr>
		do_fd_request();
   18cc5:	e8 40 04 00 00       	call   1910a <do_fd_request>
		return;
   18cca:	eb 12                	jmp    18cde <seek_interrupt+0x6a>
	}
	// 若寻道操作成功,则继续执行当前请求项的软盘操作,即向软盘控制器发送命令和参数.
	current_track = ST1;							// 设置当前磁道.
   18ccc:	0f b6 83 ed 41 00 00 	movzbl 0x41ed(%ebx),%eax
   18cd3:	88 83 08 15 00 00    	mov    %al,0x1508(%ebx)
	setup_rw_floppy();								// 设置DMA并输出软盘操作命令和参数.
   18cd9:	e8 97 fe ff ff       	call   18b75 <setup_rw_floppy>
}
   18cde:	83 c4 08             	add    $0x8,%esp
   18ce1:	5b                   	pop    %ebx
   18ce2:	c3                   	ret    

00018ce3 <transfer>:
/*
 * 该函数是在传输操作的所有信息都正确设置好后被调用的(即软驱马达已开启并且已选择了正确的软盘(软驱).
 */
// 读写数据传输函数.
static void transfer(void)
{
   18ce3:	53                   	push   %ebx
   18ce4:	83 ec 08             	sub    $0x8,%esp
   18ce7:	e8 0e e0 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18cec:	81 c3 14 93 01 00    	add    $0x19314,%ebx
	// 首先检查当前驱动器参数是否就是指定驱动器的参数.若不是就发送设置驱动器参数命令及相应参数(参数1:高4位步进速率,低4位磁头卸载时间;
	// 参数2:磁头加载时间).然后判断当前数据传输速率是否与指定驱动器的一致,若不是就发送指定软驱的速率值到数据传输速率控制寄存器(FD_DCR).
	if (cur_spec1 != floppy->spec1) {				// 检测当前参数.
   18cf2:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   18cf8:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   18cfc:	0f b6 d0             	movzbl %al,%edx
   18cff:	8b 83 00 15 00 00    	mov    0x1500(%ebx),%eax
   18d05:	39 c2                	cmp    %eax,%edx
   18d07:	74 42                	je     18d4b <transfer+0x68>
		cur_spec1 = floppy->spec1;
   18d09:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   18d0f:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   18d13:	0f b6 c0             	movzbl %al,%eax
   18d16:	89 83 00 15 00 00    	mov    %eax,0x1500(%ebx)
		output_byte(FD_SPECIFY);					// 发送设置磁盘参数命令.
   18d1c:	83 ec 0c             	sub    $0xc,%esp
   18d1f:	6a 03                	push   $0x3
   18d21:	e8 4b fb ff ff       	call   18871 <output_byte>
   18d26:	83 c4 10             	add    $0x10,%esp
		output_byte(cur_spec1);						/* hut etc */	// 发送参数.
   18d29:	8b 83 00 15 00 00    	mov    0x1500(%ebx),%eax
   18d2f:	0f be c0             	movsbl %al,%eax
   18d32:	83 ec 0c             	sub    $0xc,%esp
   18d35:	50                   	push   %eax
   18d36:	e8 36 fb ff ff       	call   18871 <output_byte>
   18d3b:	83 c4 10             	add    $0x10,%esp
		output_byte(6);								/* Head load time =6ms, DMA */
   18d3e:	83 ec 0c             	sub    $0xc,%esp
   18d41:	6a 06                	push   $0x6
   18d43:	e8 29 fb ff ff       	call   18871 <output_byte>
   18d48:	83 c4 10             	add    $0x10,%esp
	}
	if (cur_rate != floppy->rate)					// 检测当前速率.
   18d4b:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   18d51:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   18d55:	0f b6 d0             	movzbl %al,%edx
   18d58:	8b 83 04 15 00 00    	mov    0x1504(%ebx),%eax
   18d5e:	39 c2                	cmp    %eax,%edx
   18d60:	74 23                	je     18d85 <transfer+0xa2>
		outb_p(cur_rate = floppy->rate,FD_DCR);
   18d62:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   18d68:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   18d6c:	0f b6 c0             	movzbl %al,%eax
   18d6f:	89 83 04 15 00 00    	mov    %eax,0x1504(%ebx)
   18d75:	8b 83 04 15 00 00    	mov    0x1504(%ebx),%eax
   18d7b:	ba f7 03 00 00       	mov    $0x3f7,%edx
   18d80:	ee                   	out    %al,(%dx)
   18d81:	eb 00                	jmp    18d83 <transfer+0xa0>
   18d83:	eb 00                	jmp    18d85 <transfer+0xa2>
	// 若上面任何一个output_byte()操作执行出错,则复位标志reset就会被置位.因此这里我们需要检测一下reset标志.若reset真的被置位了,就立刻
	// 去执行do_fd_requst()中的复位处理代码.
	if (reset) {
   18d85:	8b 83 e4 41 00 00    	mov    0x41e4(%ebx),%eax
   18d8b:	85 c0                	test   %eax,%eax
   18d8d:	74 0a                	je     18d99 <transfer+0xb6>
		do_fd_request();
   18d8f:	e8 76 03 00 00       	call   1910a <do_fd_request>
		return;
   18d94:	e9 ba 00 00 00       	jmp    18e53 <transfer+0x170>
	}
	// 如果此时寻道标志为零(即不需要寻道),则设置DMA并向软盘控制器发送相应操作命令和参数后返回.否则就执行寻道处理,于是首先置软盘中断处理
	// 调用函数为寻道中断函数.如果起始磁道号不等于零则发送磁头寻道命令和参数.所使用的参数即是第112-121行上设置的全局变量值.如果起始磁道
	// 号seek_track为0,则执行重新校正命令让磁头归零位.
	if (!seek) {
   18d99:	8b 83 e8 41 00 00    	mov    0x41e8(%ebx),%eax
   18d9f:	85 c0                	test   %eax,%eax
   18da1:	75 0a                	jne    18dad <transfer+0xca>
		setup_rw_floppy();							// 发送命令参数块.
   18da3:	e8 cd fd ff ff       	call   18b75 <setup_rw_floppy>
		return;
   18da8:	e9 a6 00 00 00       	jmp    18e53 <transfer+0x170>
	}
	do_floppy = seek_interrupt;						// 寻道中断调用的C函数.
   18dad:	8d 83 74 6c fe ff    	lea    -0x1938c(%ebx),%eax
   18db3:	89 83 d4 41 00 00    	mov    %eax,0x41d4(%ebx)
	if (seek_track) {								// 起始磁道号.
   18db9:	0f b6 83 f7 41 00 00 	movzbl 0x41f7(%ebx),%eax
   18dc0:	84 c0                	test   %al,%al
   18dc2:	74 4c                	je     18e10 <transfer+0x12d>
		output_byte(FD_SEEK);						// 发送磁头寻道命令.
   18dc4:	83 ec 0c             	sub    $0xc,%esp
   18dc7:	6a 0f                	push   $0xf
   18dc9:	e8 a3 fa ff ff       	call   18871 <output_byte>
   18dce:	83 c4 10             	add    $0x10,%esp
		output_byte(head<<2 | current_drive);		// 发送参数:磁头号+当前软驱号.
   18dd1:	0f b6 83 f5 41 00 00 	movzbl 0x41f5(%ebx),%eax
   18dd8:	0f b6 c0             	movzbl %al,%eax
   18ddb:	c1 e0 02             	shl    $0x2,%eax
   18dde:	89 c2                	mov    %eax,%edx
   18de0:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18de7:	09 d0                	or     %edx,%eax
   18de9:	0f be c0             	movsbl %al,%eax
   18dec:	83 ec 0c             	sub    $0xc,%esp
   18def:	50                   	push   %eax
   18df0:	e8 7c fa ff ff       	call   18871 <output_byte>
   18df5:	83 c4 10             	add    $0x10,%esp
		output_byte(seek_track);					// 发送参数:磁道号.
   18df8:	0f b6 83 f7 41 00 00 	movzbl 0x41f7(%ebx),%eax
   18dff:	0f be c0             	movsbl %al,%eax
   18e02:	83 ec 0c             	sub    $0xc,%esp
   18e05:	50                   	push   %eax
   18e06:	e8 66 fa ff ff       	call   18871 <output_byte>
   18e0b:	83 c4 10             	add    $0x10,%esp
   18e0e:	eb 34                	jmp    18e44 <transfer+0x161>
	} else {
		output_byte(FD_RECALIBRATE);				// 发送重新校正命令(磁头归零).
   18e10:	83 ec 0c             	sub    $0xc,%esp
   18e13:	6a 07                	push   $0x7
   18e15:	e8 57 fa ff ff       	call   18871 <output_byte>
   18e1a:	83 c4 10             	add    $0x10,%esp
		output_byte(head<<2 | current_drive);		// 发送参数:磁头号+当前软驱号.
   18e1d:	0f b6 83 f5 41 00 00 	movzbl 0x41f5(%ebx),%eax
   18e24:	0f b6 c0             	movzbl %al,%eax
   18e27:	c1 e0 02             	shl    $0x2,%eax
   18e2a:	89 c2                	mov    %eax,%edx
   18e2c:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18e33:	09 d0                	or     %edx,%eax
   18e35:	0f be c0             	movsbl %al,%eax
   18e38:	83 ec 0c             	sub    $0xc,%esp
   18e3b:	50                   	push   %eax
   18e3c:	e8 30 fa ff ff       	call   18871 <output_byte>
   18e41:	83 c4 10             	add    $0x10,%esp
	}
	// 同样地,若上面任何一个output_byte()操作执行出错,则复位标志reset就会被置位.若reset真的被置位了,就立刻去执行do_fd_requet()中复位
	// 处理代码.
	if (reset)
   18e44:	8b 83 e4 41 00 00    	mov    0x41e4(%ebx),%eax
   18e4a:	85 c0                	test   %eax,%eax
   18e4c:	74 05                	je     18e53 <transfer+0x170>
		do_fd_request();
   18e4e:	e8 b7 02 00 00       	call   1910a <do_fd_request>
}
   18e53:	83 c4 08             	add    $0x8,%esp
   18e56:	5b                   	pop    %ebx
   18e57:	c3                   	ret    

00018e58 <recal_interrupt>:
 */
// 软驱重新校正中断调用函数.
// 首先发送检测中断状态命令(无参数),如果返回结果表明出错,则置复位标志.否则重新校正标志清零.然后再次执行软盘请求项处理函数
// 作相应操作.
static void recal_interrupt(void)
{
   18e58:	53                   	push   %ebx
   18e59:	83 ec 08             	sub    $0x8,%esp
   18e5c:	e8 99 de fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18e61:	81 c3 9f 91 01 00    	add    $0x1919f,%ebx
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   18e67:	83 ec 0c             	sub    $0xc,%esp
   18e6a:	6a 08                	push   $0x8
   18e6c:	e8 00 fa ff ff       	call   18871 <output_byte>
   18e71:	83 c4 10             	add    $0x10,%esp
	if (result() != 2 || (ST0 & 0xE0) == 0x60)		// 如果返回结果字节数不等于2或命令异常结束,则置复位标志.
   18e74:	e8 88 fa ff ff       	call   18901 <result>
   18e79:	83 f8 02             	cmp    $0x2,%eax
   18e7c:	75 14                	jne    18e92 <recal_interrupt+0x3a>
   18e7e:	0f b6 83 ec 41 00 00 	movzbl 0x41ec(%ebx),%eax
   18e85:	0f b6 c0             	movzbl %al,%eax
   18e88:	25 e0 00 00 00       	and    $0xe0,%eax
   18e8d:	83 f8 60             	cmp    $0x60,%eax
   18e90:	75 0c                	jne    18e9e <recal_interrupt+0x46>
		reset = 1;
   18e92:	c7 83 e4 41 00 00 01 	movl   $0x1,0x41e4(%ebx)
   18e99:	00 00 00 
   18e9c:	eb 0a                	jmp    18ea8 <recal_interrupt+0x50>
	else
		recalibrate = 0;							// 否则复位重新校正标志
   18e9e:	c7 83 e0 41 00 00 00 	movl   $0x0,0x41e0(%ebx)
   18ea5:	00 00 00 
	do_fd_request();								// 作相应处理.
   18ea8:	e8 5d 02 00 00       	call   1910a <do_fd_request>
}
   18ead:	90                   	nop
   18eae:	83 c4 08             	add    $0x8,%esp
   18eb1:	5b                   	pop    %ebx
   18eb2:	c3                   	ret    

00018eb3 <unexpected_floppy_interrupt>:

// 意外软盘中断请求引发的软盘中断处理程序中调用的函数.
// 首先发送检测中断状态命令(无参数),如果返回结果表明出错,则置复位标志,否则置重校正标志.
void unexpected_floppy_interrupt(void)
{
   18eb3:	53                   	push   %ebx
   18eb4:	83 ec 08             	sub    $0x8,%esp
   18eb7:	e8 3e de fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18ebc:	81 c3 44 91 01 00    	add    $0x19144,%ebx
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   18ec2:	83 ec 0c             	sub    $0xc,%esp
   18ec5:	6a 08                	push   $0x8
   18ec7:	e8 a5 f9 ff ff       	call   18871 <output_byte>
   18ecc:	83 c4 10             	add    $0x10,%esp
	if (result()!=2 || (ST0 & 0xE0) == 0x60)		// 如果返回结果字节数不等于2或命令异常结束,则置复位标志.
   18ecf:	e8 2d fa ff ff       	call   18901 <result>
   18ed4:	83 f8 02             	cmp    $0x2,%eax
   18ed7:	75 14                	jne    18eed <unexpected_floppy_interrupt+0x3a>
   18ed9:	0f b6 83 ec 41 00 00 	movzbl 0x41ec(%ebx),%eax
   18ee0:	0f b6 c0             	movzbl %al,%eax
   18ee3:	25 e0 00 00 00       	and    $0xe0,%eax
   18ee8:	83 f8 60             	cmp    $0x60,%eax
   18eeb:	75 0c                	jne    18ef9 <unexpected_floppy_interrupt+0x46>
		reset = 1;
   18eed:	c7 83 e4 41 00 00 01 	movl   $0x1,0x41e4(%ebx)
   18ef4:	00 00 00 
   18ef7:	eb 0a                	jmp    18f03 <unexpected_floppy_interrupt+0x50>
	else
		recalibrate = 1;							// 否则置重新校正标志.
   18ef9:	c7 83 e0 41 00 00 01 	movl   $0x1,0x41e0(%ebx)
   18f00:	00 00 00 
}
   18f03:	90                   	nop
   18f04:	83 c4 08             	add    $0x8,%esp
   18f07:	5b                   	pop    %ebx
   18f08:	c3                   	ret    

00018f09 <recalibrate_floppy>:

// 软盘重新校正处理函数.
// 向软盘控制器FDC发送重新校正命令和参数,并复位重新校正标志.当软盘控制器执行完重新校正命令就会再次引发的软盘中断调用
// recal_interrupt()函数.
static void recalibrate_floppy(void)
{
   18f09:	53                   	push   %ebx
   18f0a:	83 ec 08             	sub    $0x8,%esp
   18f0d:	e8 e8 dd fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18f12:	81 c3 ee 90 01 00    	add    $0x190ee,%ebx
	recalibrate = 0;								// 复位重新校正标志.
   18f18:	c7 83 e0 41 00 00 00 	movl   $0x0,0x41e0(%ebx)
   18f1f:	00 00 00 
	current_track = 0;								// 当前磁道号归零.
   18f22:	c6 83 08 15 00 00 00 	movb   $0x0,0x1508(%ebx)
	do_floppy = recal_interrupt;					// 指向重新校正中断调用的C函数.
   18f29:	8d 83 58 6e fe ff    	lea    -0x191a8(%ebx),%eax
   18f2f:	89 83 d4 41 00 00    	mov    %eax,0x41d4(%ebx)
	output_byte(FD_RECALIBRATE);					// 命令:重新校正.
   18f35:	83 ec 0c             	sub    $0xc,%esp
   18f38:	6a 07                	push   $0x7
   18f3a:	e8 32 f9 ff ff       	call   18871 <output_byte>
   18f3f:	83 c4 10             	add    $0x10,%esp
	output_byte(head<<2 | current_drive);			// 参数:磁头号 + 当前驱动器号.
   18f42:	0f b6 83 f5 41 00 00 	movzbl 0x41f5(%ebx),%eax
   18f49:	0f b6 c0             	movzbl %al,%eax
   18f4c:	c1 e0 02             	shl    $0x2,%eax
   18f4f:	89 c2                	mov    %eax,%edx
   18f51:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   18f58:	09 d0                	or     %edx,%eax
   18f5a:	0f be c0             	movsbl %al,%eax
   18f5d:	83 ec 0c             	sub    $0xc,%esp
   18f60:	50                   	push   %eax
   18f61:	e8 0b f9 ff ff       	call   18871 <output_byte>
   18f66:	83 c4 10             	add    $0x10,%esp
	// 若上任何一个output_byte()操作执行出错,则复位标志reset就会被置位.因此这里我们需要检测一下reset标志.若reset真的被
	// 置位了,就立刻去执行do_fd_requeset()中的复位处理代码.
	if (reset)
   18f69:	8b 83 e4 41 00 00    	mov    0x41e4(%ebx),%eax
   18f6f:	85 c0                	test   %eax,%eax
   18f71:	74 05                	je     18f78 <recalibrate_floppy+0x6f>
		do_fd_request();
   18f73:	e8 92 01 00 00       	call   1910a <do_fd_request>
}
   18f78:	90                   	nop
   18f79:	83 c4 08             	add    $0x8,%esp
   18f7c:	5b                   	pop    %ebx
   18f7d:	c3                   	ret    

00018f7e <reset_interrupt>:
// 软盘控制器FDC复位中断调用函数.
// 该函数会在向控制器发送了复位操作命令后引发的软盘中断处理程序中被调用.
// 首先发送检测中断状态命令(无参数),然后读出返回的结果字节.接着发送设定软驱参数命令和相关参数,最后再次调用请求项处理函数
// do_fd_request()去执行重新校正工作.但由于执行output_byte()操作函数出错时复位标志又会被置位,因此也可能再次去执行复位处理.
static void reset_interrupt(void)
{
   18f7e:	53                   	push   %ebx
   18f7f:	83 ec 08             	sub    $0x8,%esp
   18f82:	e8 73 dd fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18f87:	81 c3 79 90 01 00    	add    $0x19079,%ebx
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   18f8d:	83 ec 0c             	sub    $0xc,%esp
   18f90:	6a 08                	push   $0x8
   18f92:	e8 da f8 ff ff       	call   18871 <output_byte>
   18f97:	83 c4 10             	add    $0x10,%esp
	(void) result();								// 读取命令执行结果字节.
   18f9a:	e8 62 f9 ff ff       	call   18901 <result>
	output_byte(FD_SPECIFY);						// 发送设定软驱参数命令.
   18f9f:	83 ec 0c             	sub    $0xc,%esp
   18fa2:	6a 03                	push   $0x3
   18fa4:	e8 c8 f8 ff ff       	call   18871 <output_byte>
   18fa9:	83 c4 10             	add    $0x10,%esp
	output_byte(cur_spec1);							/* hut etc */	// 发送参数
   18fac:	8b 83 00 15 00 00    	mov    0x1500(%ebx),%eax
   18fb2:	0f be c0             	movsbl %al,%eax
   18fb5:	83 ec 0c             	sub    $0xc,%esp
   18fb8:	50                   	push   %eax
   18fb9:	e8 b3 f8 ff ff       	call   18871 <output_byte>
   18fbe:	83 c4 10             	add    $0x10,%esp
	output_byte(6);									/* Head load time =6ms, DMA */
   18fc1:	83 ec 0c             	sub    $0xc,%esp
   18fc4:	6a 06                	push   $0x6
   18fc6:	e8 a6 f8 ff ff       	call   18871 <output_byte>
   18fcb:	83 c4 10             	add    $0x10,%esp
	do_fd_request();                				// 调用执行软盘请求.
   18fce:	e8 37 01 00 00       	call   1910a <do_fd_request>
}
   18fd3:	90                   	nop
   18fd4:	83 c4 08             	add    $0x8,%esp
   18fd7:	5b                   	pop    %ebx
   18fd8:	c3                   	ret    

00018fd9 <reset_floppy>:
// 复位软盘控制器.
// 该函数首先设置参数和标志,把复位标志清0,然后把软驱变量cur_spec1和cur_rate置为无效.因为复位操作后,这两个参数就需要重新设置.接着
// 需要重新校正标志,并设置FDC执行复位操作后引发的软盘中断中调用的C函数reset_interrupt().最后把DOR寄存器位2置0一会儿以对软驱执行
// 复位操作.当前数字输出寄存器DOR的位2是启动/复位软驱位.
static void reset_floppy(void)
{
   18fd9:	53                   	push   %ebx
   18fda:	83 ec 18             	sub    $0x18,%esp
   18fdd:	e8 18 dd fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   18fe2:	81 c3 1e 90 01 00    	add    $0x1901e,%ebx
	int i;

	reset = 0;										// 复位标志置0.
   18fe8:	c7 83 e4 41 00 00 00 	movl   $0x0,0x41e4(%ebx)
   18fef:	00 00 00 
	cur_spec1 = -1;									// 使无效.
   18ff2:	c7 83 00 15 00 00 ff 	movl   $0xffffffff,0x1500(%ebx)
   18ff9:	ff ff ff 
	cur_rate = -1;
   18ffc:	c7 83 04 15 00 00 ff 	movl   $0xffffffff,0x1504(%ebx)
   19003:	ff ff ff 
	recalibrate = 1;								// 重新校正标志置位.
   19006:	c7 83 e0 41 00 00 01 	movl   $0x1,0x41e0(%ebx)
   1900d:	00 00 00 
	printk("Reset-floppy called\n\r");				// 显示执行软盘复位操作信息.
   19010:	83 ec 0c             	sub    $0xc,%esp
   19013:	8d 83 23 56 ff ff    	lea    -0xa9dd(%ebx),%eax
   19019:	50                   	push   %eax
   1901a:	e8 13 03 ff ff       	call   9332 <printk>
   1901f:	83 c4 10             	add    $0x10,%esp
	cli();											// 关中断.
   19022:	fa                   	cli    
	do_floppy = reset_interrupt;					// 设置在中断处理程序中调用的函数.
   19023:	8d 83 7e 6f fe ff    	lea    -0x19082(%ebx),%eax
   19029:	89 83 d4 41 00 00    	mov    %eax,0x41d4(%ebx)
	outb_p(current_DOR & ~0x04,FD_DOR);				// 对软盘控制器FDC执行复位操作.
   1902f:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   19035:	0f b6 00             	movzbl (%eax),%eax
   19038:	0f b6 c0             	movzbl %al,%eax
   1903b:	83 e0 fb             	and    $0xfffffffb,%eax
   1903e:	ba f2 03 00 00       	mov    $0x3f2,%edx
   19043:	ee                   	out    %al,(%dx)
   19044:	eb 00                	jmp    19046 <reset_floppy+0x6d>
   19046:	eb 00                	jmp    19048 <reset_floppy+0x6f>
	for (i = 0 ; i < 100 ; i++)						// 空操作,延迟.
   19048:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1904f:	00 
   19050:	eb 06                	jmp    19058 <reset_floppy+0x7f>
		__asm__("nop");
   19052:	90                   	nop
	for (i = 0 ; i < 100 ; i++)						// 空操作,延迟.
   19053:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   19058:	83 7c 24 0c 63       	cmpl   $0x63,0xc(%esp)
   1905d:	7e f3                	jle    19052 <reset_floppy+0x79>
	outb(current_DOR,FD_DOR);						// 再启动软盘控制器.
   1905f:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   19065:	0f b6 00             	movzbl (%eax),%eax
   19068:	ba f2 03 00 00       	mov    $0x3f2,%edx
   1906d:	ee                   	out    %al,(%dx)
	sti();											// 开中断.
   1906e:	fb                   	sti    
}
   1906f:	90                   	nop
   19070:	83 c4 18             	add    $0x18,%esp
   19073:	5b                   	pop    %ebx
   19074:	c3                   	ret    

00019075 <floppy_on_interrupt>:

// 软驱启动定时中断调用函数.
// 在执行一个请求项要求的操作之前,为了等待指定软驱马达旋转起来到达正常的工作转速,do_fd_request()函数为准备好的当前请求项添加了一个延时
// 定时器.本函数即是该定时器到期时调用的函数.它首先检查数字输出寄存器(DOR),使其选择当前指定的驱动.然后调用执行软盘读写传输函数transfer().
static void floppy_on_interrupt(void)
{
   19075:	53                   	push   %ebx
   19076:	83 ec 08             	sub    $0x8,%esp
   19079:	e8 b9 39 ff ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1907e:	81 c1 82 8f 01 00    	add    $0x18f82,%ecx
	/* We cannot do a floppy-select, as that might sleep. We just force it */
	/* 我们不能任意设置选择的软驱,因为这可能会引起进程睡眠.我们只能迫使它自己选择 */
	// 如果当前驱动器号与数字输出寄存器DOR中的不同,则需要重新设置DOR为当前驱动器.在向数字输出寄存器输出当前DOR以后,使用定时器延迟2个滴答
	// 时间,以让命令得到执行.然后调用软盘读写传输函数transfer().若当前驱动器与DOR中的相符,那么就可以直接调用软盘读写传输函数.
	selected = 1;									// 置已选定当前驱动器标志.
   19084:	c6 81 d8 41 00 00 01 	movb   $0x1,0x41d8(%ecx)
	if (current_drive != (current_DOR & 3)) {
   1908b:	0f b6 81 f3 41 00 00 	movzbl 0x41f3(%ecx),%eax
   19092:	0f b6 d0             	movzbl %al,%edx
   19095:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   1909b:	0f b6 00             	movzbl (%eax),%eax
   1909e:	0f b6 c0             	movzbl %al,%eax
   190a1:	83 e0 03             	and    $0x3,%eax
   190a4:	39 c2                	cmp    %eax,%edx
   190a6:	74 57                	je     190ff <floppy_on_interrupt+0x8a>
		current_DOR &= 0xFC;
   190a8:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   190ae:	0f b6 00             	movzbl (%eax),%eax
   190b1:	83 e0 fc             	and    $0xfffffffc,%eax
   190b4:	89 c2                	mov    %eax,%edx
   190b6:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   190bc:	88 10                	mov    %dl,(%eax)
		current_DOR |= current_drive;
   190be:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   190c4:	0f b6 10             	movzbl (%eax),%edx
   190c7:	0f b6 81 f3 41 00 00 	movzbl 0x41f3(%ecx),%eax
   190ce:	09 c2                	or     %eax,%edx
   190d0:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   190d6:	88 10                	mov    %dl,(%eax)
		outb(current_DOR,FD_DOR);					// 向数字输出寄存器输出当前DOR.
   190d8:	c7 c0 64 20 03 00    	mov    $0x32064,%eax
   190de:	0f b6 00             	movzbl (%eax),%eax
   190e1:	ba f2 03 00 00       	mov    $0x3f2,%edx
   190e6:	ee                   	out    %al,(%dx)
		add_timer(2,&transfer);						// 添加定时器并执行传输函数.
   190e7:	83 ec 08             	sub    $0x8,%esp
   190ea:	8d 81 e3 6c fe ff    	lea    -0x1931d(%ecx),%eax
   190f0:	50                   	push   %eax
   190f1:	6a 02                	push   $0x2
   190f3:	89 cb                	mov    %ecx,%ebx
   190f5:	e8 66 e4 fe ff       	call   7560 <add_timer>
   190fa:	83 c4 10             	add    $0x10,%esp
	} else
		transfer();									// 执行软盘读写传输函数.
}
   190fd:	eb 05                	jmp    19104 <floppy_on_interrupt+0x8f>
		transfer();									// 执行软盘读写传输函数.
   190ff:	e8 df fb ff ff       	call   18ce3 <transfer>
}
   19104:	90                   	nop
   19105:	83 c4 08             	add    $0x8,%esp
   19108:	5b                   	pop    %ebx
   19109:	c3                   	ret    

0001910a <do_fd_request>:

// 软盘读写请求项处理函数
// 该函数是软盘驱动程序中最主要的函数.主要作用是:1处理有复位标志或重新校正标志置位情况;2利用请求项中的设备号计算取得请求项指定软驱的
// 参数块;3利用内核定时器启动软盘读/写操作.
void do_fd_request(void)
{
   1910a:	53                   	push   %ebx
   1910b:	83 ec 18             	sub    $0x18,%esp
   1910e:	e8 e7 db fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19113:	81 c3 ed 8e 01 00    	add    $0x18eed,%ebx
	unsigned int block;

	// 首先检查是否有复位标志或重校正标志置位,若有则本函数仅执行相关标志的处理功能后就返回.如果复位标志已置位,则执行软盘复位操作并返回.
	// 如果重新校正标志已置位,则执行软盘重新校正操作并返回.
	seek = 0;										// 清寻道标志.
   19119:	c7 83 e8 41 00 00 00 	movl   $0x0,0x41e8(%ebx)
   19120:	00 00 00 
	if (reset) {									// 复位标志已置位.
   19123:	8b 83 e4 41 00 00    	mov    0x41e4(%ebx),%eax
   19129:	85 c0                	test   %eax,%eax
   1912b:	74 0a                	je     19137 <do_fd_request+0x2d>
		reset_floppy();
   1912d:	e8 a7 fe ff ff       	call   18fd9 <reset_floppy>
		return;
   19132:	e9 4c 02 00 00       	jmp    19383 <do_fd_request+0x279>
	}
	if (recalibrate) {								// 重新校正标志已置位.
   19137:	8b 83 e0 41 00 00    	mov    0x41e0(%ebx),%eax
   1913d:	85 c0                	test   %eax,%eax
   1913f:	74 0a                	je     1914b <do_fd_request+0x41>
		recalibrate_floppy();
   19141:	e8 c3 fd ff ff       	call   18f09 <recalibrate_floppy>
		return;
   19146:	e9 38 02 00 00       	jmp    19383 <do_fd_request+0x279>
	}
	// 本函数的真正功能从这里开始.首先利用blk.h文件中的INIT_REQUEST宏来检测请求项的合法性,如果已没有请求项则退出.然后利用请求项中的设备
	// 号取得请求项指定软驱的参数块.这个参数块将在下面用于设置软盘操作使用的全局变量参数块.请求项设备号中的软盘类型(MINOR(CURRENT->dev)>>2)
	// 被用作磁盘类型数组floppy_type[]的索引值来取得指定软驱的参数块.
	INIT_REQUEST;
   1914b:	90                   	nop
   1914c:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19152:	8b 40 14             	mov    0x14(%eax),%eax
   19155:	85 c0                	test   %eax,%eax
   19157:	75 0f                	jne    19168 <do_fd_request+0x5e>
   19159:	c7 83 d4 41 00 00 00 	movl   $0x0,0x41d4(%ebx)
   19160:	00 00 00 
   19163:	e9 1b 02 00 00       	jmp    19383 <do_fd_request+0x279>
   19168:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1916e:	8b 40 14             	mov    0x14(%eax),%eax
   19171:	8b 00                	mov    (%eax),%eax
   19173:	c1 e8 08             	shr    $0x8,%eax
   19176:	83 f8 02             	cmp    $0x2,%eax
   19179:	74 12                	je     1918d <do_fd_request+0x83>
   1917b:	83 ec 0c             	sub    $0xc,%esp
   1917e:	8d 83 3c 56 ff ff    	lea    -0xa9c4(%ebx),%eax
   19184:	50                   	push   %eax
   19185:	e8 54 01 ff ff       	call   92de <panic>
   1918a:	83 c4 10             	add    $0x10,%esp
   1918d:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19193:	8b 40 14             	mov    0x14(%eax),%eax
   19196:	8b 40 1c             	mov    0x1c(%eax),%eax
   19199:	85 c0                	test   %eax,%eax
   1919b:	74 26                	je     191c3 <do_fd_request+0xb9>
   1919d:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   191a3:	8b 40 14             	mov    0x14(%eax),%eax
   191a6:	8b 40 1c             	mov    0x1c(%eax),%eax
   191a9:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   191ad:	84 c0                	test   %al,%al
   191af:	75 12                	jne    191c3 <do_fd_request+0xb9>
   191b1:	83 ec 0c             	sub    $0xc,%esp
   191b4:	8d 83 5b 56 ff ff    	lea    -0xa9a5(%ebx),%eax
   191ba:	50                   	push   %eax
   191bb:	e8 1e 01 ff ff       	call   92de <panic>
   191c0:	83 c4 10             	add    $0x10,%esp
	floppy = (MINOR(CURRENT->dev) >> 2) + floppy_type;
   191c3:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   191c9:	8b 40 14             	mov    0x14(%eax),%eax
   191cc:	8b 00                	mov    (%eax),%eax
   191ce:	c1 f8 02             	sar    $0x2,%eax
   191d1:	83 e0 3f             	and    $0x3f,%eax
   191d4:	89 c2                	mov    %eax,%edx
   191d6:	89 d0                	mov    %edx,%eax
   191d8:	01 c0                	add    %eax,%eax
   191da:	01 d0                	add    %edx,%eax
   191dc:	c1 e0 03             	shl    $0x3,%eax
   191df:	89 c2                	mov    %eax,%edx
   191e1:	8d 83 40 14 00 00    	lea    0x1440(%ebx),%eax
   191e7:	01 d0                	add    %edx,%eax
   191e9:	89 83 a0 15 00 00    	mov    %eax,0x15a0(%ebx)
	// 下面开始设置全局变量值.如果当前驱动器号current_drive不是请求项中指定的驱动器号,则置标志seek,表示在执行读/写操作之前需要先让驱动
	// 器执行寻道处理.然后把当前驱动器号设置为请求项中指定的驱动器号.
	if (current_drive != CURRENT_DEV)				// CURRENT_DEV是请求项中指定的软驱号.
   191ef:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   191f6:	0f b6 d0             	movzbl %al,%edx
   191f9:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   191ff:	8b 40 14             	mov    0x14(%eax),%eax
   19202:	8b 00                	mov    (%eax),%eax
   19204:	83 e0 03             	and    $0x3,%eax
   19207:	39 c2                	cmp    %eax,%edx
   19209:	74 0a                	je     19215 <do_fd_request+0x10b>
		seek = 1;
   1920b:	c7 83 e8 41 00 00 01 	movl   $0x1,0x41e8(%ebx)
   19212:	00 00 00 
	current_drive = CURRENT_DEV;
   19215:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1921b:	8b 40 14             	mov    0x14(%eax),%eax
   1921e:	8b 00                	mov    (%eax),%eax
   19220:	83 e0 03             	and    $0x3,%eax
   19223:	88 83 f3 41 00 00    	mov    %al,0x41f3(%ebx)
	// 设置读写起始扇区block.因为每次读写是以块为单位(1块为2个扇区),所以起始扇区需要起码比磁盘总扇区数小2个扇区.否则说明这个请求 参数无效,
	// 结束该次软盘请求项去执行下一个请求项.
	block = CURRENT->sector;						// 取当前软盘请求项中起始扇区号.
   19229:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1922f:	8b 40 14             	mov    0x14(%eax),%eax
   19232:	8b 40 0c             	mov    0xc(%eax),%eax
   19235:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (block + 2 > floppy->size) {					// 如果block + 2大于磁盘扇区总数,则结束本人软盘请求项.
   19239:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1923d:	8d 50 02             	lea    0x2(%eax),%edx
   19240:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   19246:	8b 00                	mov    (%eax),%eax
   19248:	39 c2                	cmp    %eax,%edx
   1924a:	76 12                	jbe    1925e <do_fd_request+0x154>
		end_request(0);
   1924c:	83 ec 0c             	sub    $0xc,%esp
   1924f:	6a 00                	push   $0x0
   19251:	e8 37 f3 ff ff       	call   1858d <end_request>
   19256:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   19259:	e9 ee fe ff ff       	jmp    1914c <do_fd_request+0x42>
	}
	// 再求对应在磁道上的扇区号,磁头号,磁道号,搜寻磁道号(对于软驱读不同格式的盘).
	sector = block % floppy->sect;					// 起始扇区对每磁道扇区数取模,得磁道上扇区号.
   1925e:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   19264:	8b 48 04             	mov    0x4(%eax),%ecx
   19267:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1926b:	ba 00 00 00 00       	mov    $0x0,%edx
   19270:	f7 f1                	div    %ecx
   19272:	89 d0                	mov    %edx,%eax
   19274:	88 83 f4 41 00 00    	mov    %al,0x41f4(%ebx)
	block /= floppy->sect;							// 起始扇区对每磁道扇区数取整,得起始磁道数.
   1927a:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   19280:	8b 48 04             	mov    0x4(%eax),%ecx
   19283:	8b 44 24 0c          	mov    0xc(%esp),%eax
   19287:	ba 00 00 00 00       	mov    $0x0,%edx
   1928c:	f7 f1                	div    %ecx
   1928e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	head = block % floppy->head;					// 起始磁道数对磁头数取模,得操作的磁头号.
   19292:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   19298:	8b 48 08             	mov    0x8(%eax),%ecx
   1929b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1929f:	ba 00 00 00 00       	mov    $0x0,%edx
   192a4:	f7 f1                	div    %ecx
   192a6:	89 d0                	mov    %edx,%eax
   192a8:	88 83 f5 41 00 00    	mov    %al,0x41f5(%ebx)
	track = block / floppy->head;					// 起始磁道数对磁头数取整,得操作的磁道号.
   192ae:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   192b4:	8b 48 08             	mov    0x8(%eax),%ecx
   192b7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   192bb:	ba 00 00 00 00       	mov    $0x0,%edx
   192c0:	f7 f1                	div    %ecx
   192c2:	88 83 f6 41 00 00    	mov    %al,0x41f6(%ebx)
	seek_track = track << floppy->stretch;			// 相应于软驱中盘类型进行调整,得寻道号.
   192c8:	0f b6 83 f6 41 00 00 	movzbl 0x41f6(%ebx),%eax
   192cf:	0f b6 d0             	movzbl %al,%edx
   192d2:	8b 83 a0 15 00 00    	mov    0x15a0(%ebx),%eax
   192d8:	8b 40 10             	mov    0x10(%eax),%eax
   192db:	89 c1                	mov    %eax,%ecx
   192dd:	d3 e2                	shl    %cl,%edx
   192df:	89 d0                	mov    %edx,%eax
   192e1:	88 83 f7 41 00 00    	mov    %al,0x41f7(%ebx)
	// 再看看是否还需要首先执行寻道操作.如果寻道号与当前磁头所在磁道号不同,则需要进行寻道操作,于是置需要寻道标志seek.最后我们设置执行的软盘
	// 命令command.
	if (seek_track != current_track)
   192e7:	0f b6 93 f7 41 00 00 	movzbl 0x41f7(%ebx),%edx
   192ee:	0f b6 83 08 15 00 00 	movzbl 0x1508(%ebx),%eax
   192f5:	38 c2                	cmp    %al,%dl
   192f7:	74 0a                	je     19303 <do_fd_request+0x1f9>
		seek = 1;
   192f9:	c7 83 e8 41 00 00 01 	movl   $0x1,0x41e8(%ebx)
   19300:	00 00 00 
	sector++;										// 磁盘上实际扇区计数是从1算起.
   19303:	0f b6 83 f4 41 00 00 	movzbl 0x41f4(%ebx),%eax
   1930a:	83 c0 01             	add    $0x1,%eax
   1930d:	88 83 f4 41 00 00    	mov    %al,0x41f4(%ebx)
	if (CURRENT->cmd == READ)						// 如果请求项是读操作,则置读命令码.
   19313:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19319:	8b 40 14             	mov    0x14(%eax),%eax
   1931c:	8b 40 04             	mov    0x4(%eax),%eax
   1931f:	85 c0                	test   %eax,%eax
   19321:	75 09                	jne    1932c <do_fd_request+0x222>
		command = FD_READ;
   19323:	c6 83 f8 41 00 00 e6 	movb   $0xe6,0x41f8(%ebx)
   1932a:	eb 2c                	jmp    19358 <do_fd_request+0x24e>
	else if (CURRENT->cmd == WRITE)					// 如果请求项是写操作,则置写命令码.
   1932c:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19332:	8b 40 14             	mov    0x14(%eax),%eax
   19335:	8b 40 04             	mov    0x4(%eax),%eax
   19338:	83 f8 01             	cmp    $0x1,%eax
   1933b:	75 09                	jne    19346 <do_fd_request+0x23c>
		command = FD_WRITE;
   1933d:	c6 83 f8 41 00 00 c5 	movb   $0xc5,0x41f8(%ebx)
   19344:	eb 12                	jmp    19358 <do_fd_request+0x24e>
	else
		panic("do_fd_request: unknown command");
   19346:	83 ec 0c             	sub    $0xc,%esp
   19349:	8d 83 74 56 ff ff    	lea    -0xa98c(%ebx),%eax
   1934f:	50                   	push   %eax
   19350:	e8 89 ff fe ff       	call   92de <panic>
   19355:	83 c4 10             	add    $0x10,%esp
	// 在上面设置好所有全局变量值之后,我们可以开始执行请求项操作了.该操作利用定时器来启动.因为为了能对软驱进行读写操作,需要首先启动驱动器马达
	// 并达到正常运转速度.而这需要一定的时间.因此这里利用ticks_to_floppy_on()来计算启动延时时间,然后使用该延时设定一个定时器.当时间到时就调用
	// 函数floppy_on_interrupt().
	add_timer(ticks_to_floppy_on(current_drive), &floppy_on_interrupt);
   19358:	0f b6 83 f3 41 00 00 	movzbl 0x41f3(%ebx),%eax
   1935f:	0f b6 c0             	movzbl %al,%eax
   19362:	83 ec 0c             	sub    $0xc,%esp
   19365:	50                   	push   %eax
   19366:	e8 ac df fe ff       	call   7317 <ticks_to_floppy_on>
   1936b:	83 c4 10             	add    $0x10,%esp
   1936e:	89 c2                	mov    %eax,%edx
   19370:	83 ec 08             	sub    $0x8,%esp
   19373:	8d 83 75 70 fe ff    	lea    -0x18f8b(%ebx),%eax
   19379:	50                   	push   %eax
   1937a:	52                   	push   %edx
   1937b:	e8 e0 e1 fe ff       	call   7560 <add_timer>
   19380:	83 c4 10             	add    $0x10,%esp
}
   19383:	83 c4 18             	add    $0x18,%esp
   19386:	5b                   	pop    %ebx
   19387:	c3                   	ret    

00019388 <floppy_init>:

// 软盘系统初始化.
// 设置软盘块设备请求项的处理函数do_fd_request(),并设置软盘中断门(int 0x26,对应硬件中断请求信号IRQ6).然后取消对该中断信号的屏蔽,以
// 允许软盘控制器FDC发送中断请求信号.中断描述符表IDT中陷阱门描述符设置宏set_trap_gate()定义在头文件include/asm/system.h中.
void floppy_init(void)
{
   19388:	53                   	push   %ebx
   19389:	83 ec 10             	sub    $0x10,%esp
   1938c:	e8 61 d9 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   19391:	05 6f 8c 01 00       	add    $0x18c6f,%eax
	// 设置软盘中断门描述符。floppy_interrup(kernel/sys_call.s)是其中断处理过程。
	blk_size[MAJOR_NR] = floppy_sizes;
   19396:	c7 c2 b8 61 03 00    	mov    $0x361b8,%edx
   1939c:	8d 88 20 15 00 00    	lea    0x1520(%eax),%ecx
   193a2:	89 4a 08             	mov    %ecx,0x8(%edx)
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;  						// = do_fd_request()。
   193a5:	c7 c2 80 61 03 00    	mov    $0x36180,%edx
   193ab:	8d 88 0a 71 fe ff    	lea    -0x18ef6(%eax),%ecx
   193b1:	89 4a 10             	mov    %ecx,0x10(%edx)
	set_trap_gate(0x26, &floppy_interrupt);          						// 设置陷阱门描述符。
   193b4:	c7 c2 b8 54 00 00    	mov    $0x54b8,%edx
   193ba:	8d 8a 30 01 00 00    	lea    0x130(%edx),%ecx
   193c0:	c7 c2 b8 54 00 00    	mov    $0x54b8,%edx
   193c6:	8d 9a 34 01 00 00    	lea    0x134(%edx),%ebx
   193cc:	c7 c0 0a 7e 00 00    	mov    $0x7e0a,%eax
   193d2:	89 c2                	mov    %eax,%edx
   193d4:	b8 00 00 08 00       	mov    $0x80000,%eax
   193d9:	66 89 d0             	mov    %dx,%ax
   193dc:	66 ba 00 8f          	mov    $0x8f00,%dx
   193e0:	89 01                	mov    %eax,(%ecx)
   193e2:	89 13                	mov    %edx,(%ebx)
	outb(inb_p(0x21) & ~0x40, 0x21);                   						// 复位软盘中断请求屏蔽位。
   193e4:	b8 21 00 00 00       	mov    $0x21,%eax
   193e9:	89 c2                	mov    %eax,%edx
   193eb:	ec                   	in     (%dx),%al
   193ec:	eb 00                	jmp    193ee <floppy_init+0x66>
   193ee:	eb 00                	jmp    193f0 <floppy_init+0x68>
   193f0:	88 44 24 0f          	mov    %al,0xf(%esp)
   193f4:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   193f9:	0f b6 c0             	movzbl %al,%eax
   193fc:	83 e0 bf             	and    $0xffffffbf,%eax
   193ff:	ba 21 00 00 00       	mov    $0x21,%edx
   19404:	ee                   	out    %al,(%dx)
}
   19405:	90                   	nop
   19406:	83 c4 10             	add    $0x10,%esp
   19409:	5b                   	pop    %ebx
   1940a:	c3                   	ret    

0001940b <unlock_buffer>:
{
   1940b:	53                   	push   %ebx
   1940c:	83 ec 08             	sub    $0x8,%esp
   1940f:	e8 e6 d8 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19414:	81 c3 ec 8b 01 00    	add    $0x18bec,%ebx
	if (!bh->b_lock)
   1941a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1941e:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   19422:	84 c0                	test   %al,%al
   19424:	75 12                	jne    19438 <unlock_buffer+0x2d>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   19426:	83 ec 0c             	sub    $0xc,%esp
   19429:	8d 83 94 56 ff ff    	lea    -0xa96c(%ebx),%eax
   1942f:	50                   	push   %eax
   19430:	e8 fd fe fe ff       	call   9332 <printk>
   19435:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   19438:	8b 44 24 10          	mov    0x10(%esp),%eax
   1943c:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);
   19440:	8b 44 24 10          	mov    0x10(%esp),%eax
   19444:	83 c0 10             	add    $0x10,%eax
   19447:	83 ec 0c             	sub    $0xc,%esp
   1944a:	50                   	push   %eax
   1944b:	e8 57 de fe ff       	call   72a7 <wake_up>
   19450:	83 c4 10             	add    $0x10,%esp
}
   19453:	90                   	nop
   19454:	83 c4 08             	add    $0x8,%esp
   19457:	5b                   	pop    %ebx
   19458:	c3                   	ret    

00019459 <end_request>:
{
   19459:	53                   	push   %ebx
   1945a:	83 ec 08             	sub    $0x8,%esp
   1945d:	e8 98 d8 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19462:	81 c3 9e 8b 01 00    	add    $0x18b9e,%ebx
	if (CURRENT->bh) {									// CURRENT为当前请求结构项指针
   19468:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1946e:	8b 40 1c             	mov    0x1c(%eax),%eax
   19471:	8b 40 1c             	mov    0x1c(%eax),%eax
   19474:	85 c0                	test   %eax,%eax
   19476:	74 2b                	je     194a3 <end_request+0x4a>
		CURRENT->bh->b_uptodate = uptodate;				// 置更新标志.
   19478:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1947e:	8b 40 1c             	mov    0x1c(%eax),%eax
   19481:	8b 40 1c             	mov    0x1c(%eax),%eax
   19484:	8b 54 24 10          	mov    0x10(%esp),%edx
   19488:	88 50 0a             	mov    %dl,0xa(%eax)
		unlock_buffer(CURRENT->bh);						// 解锁缓冲区.
   1948b:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19491:	8b 40 1c             	mov    0x1c(%eax),%eax
   19494:	8b 40 1c             	mov    0x1c(%eax),%eax
   19497:	83 ec 0c             	sub    $0xc,%esp
   1949a:	50                   	push   %eax
   1949b:	e8 6b ff ff ff       	call   1940b <unlock_buffer>
   194a0:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {									// 若更新标志为0则显示出错信息.
   194a3:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   194a8:	75 40                	jne    194ea <end_request+0x91>
		printk(DEVICE_NAME " I/O error\n\r");
   194aa:	83 ec 0c             	sub    $0xc,%esp
   194ad:	8d 83 ba 56 ff ff    	lea    -0xa946(%ebx),%eax
   194b3:	50                   	push   %eax
   194b4:	e8 79 fe fe ff       	call   9332 <printk>
   194b9:	83 c4 10             	add    $0x10,%esp
			CURRENT->bh->b_blocknr);
   194bc:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   194c2:	8b 40 1c             	mov    0x1c(%eax),%eax
   194c5:	8b 40 1c             	mov    0x1c(%eax),%eax
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   194c8:	8b 50 04             	mov    0x4(%eax),%edx
   194cb:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   194d1:	8b 40 1c             	mov    0x1c(%eax),%eax
   194d4:	8b 00                	mov    (%eax),%eax
   194d6:	83 ec 04             	sub    $0x4,%esp
   194d9:	52                   	push   %edx
   194da:	50                   	push   %eax
   194db:	8d 83 cf 56 ff ff    	lea    -0xa931(%ebx),%eax
   194e1:	50                   	push   %eax
   194e2:	e8 4b fe fe ff       	call   9332 <printk>
   194e7:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);							// 唤醒等待该请求项的进程.
   194ea:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   194f0:	8b 40 1c             	mov    0x1c(%eax),%eax
   194f3:	83 c0 18             	add    $0x18,%eax
   194f6:	83 ec 0c             	sub    $0xc,%esp
   194f9:	50                   	push   %eax
   194fa:	e8 a8 dd fe ff       	call   72a7 <wake_up>
   194ff:	83 c4 10             	add    $0x10,%esp
	wake_up(&wait_for_request);							// 唤醒等待空闲请求项的进程.
   19502:	83 ec 0c             	sub    $0xc,%esp
   19505:	c7 c0 60 61 03 00    	mov    $0x36160,%eax
   1950b:	50                   	push   %eax
   1950c:	e8 96 dd fe ff       	call   72a7 <wake_up>
   19511:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;									// 释放该请求项.
   19514:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1951a:	8b 40 1c             	mov    0x1c(%eax),%eax
   1951d:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;							// 指向下一请求项.
   19523:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19529:	8b 40 1c             	mov    0x1c(%eax),%eax
   1952c:	8b 50 20             	mov    0x20(%eax),%edx
   1952f:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19535:	89 50 1c             	mov    %edx,0x1c(%eax)
}
   19538:	90                   	nop
   19539:	83 c4 08             	add    $0x8,%esp
   1953c:	5b                   	pop    %ebx
   1953d:	c3                   	ret    

0001953e <sys_setup>:
// 系统设备函数.
// 函数参数BIOS是由初始化程序init/main.c中init子程序设置为指向硬盘参数表结构的指针.
// 该硬盘参数表结构包含2个硬盘参数表的(共32字节),是从内存0x90080处复制而来.0x90080处的硬盘参数表是由setup.s程序利用ROM BIOS
// 功能取得.本函数主要功能是读取CMOS和硬盘参数表信息,用于设置硬盘分区结构hd,并尝试加载RAM虚拟盘和根文件系统.
int sys_setup(void * BIOS)
{
   1953e:	55                   	push   %ebp
   1953f:	57                   	push   %edi
   19540:	56                   	push   %esi
   19541:	53                   	push   %ebx
   19542:	83 ec 2c             	sub    $0x2c,%esp
   19545:	e8 b0 d7 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1954a:	81 c3 b6 8a 01 00    	add    $0x18ab6,%ebx
	struct buffer_head * bh;

	// 首先设置callable标志,使得本函数只能被调用1次.然后设置硬盘信息数据组hd_info[].如果在include/linux/config.h文件已定义了符号
	// 常数HD_TYPE,那么hd_info[]数组已经在前面第49行上设置好了.否则就需要读取boot/setup.s程序存放在内存0x90080处开始的硬盘参数表.
	// setup.s程序在内存此处连续存放着一到两个硬盘参数表.
	if (!callable)
   19550:	8b 83 a4 15 00 00    	mov    0x15a4(%ebx),%eax
   19556:	85 c0                	test   %eax,%eax
   19558:	75 0a                	jne    19564 <sys_setup+0x26>
		return -1;
   1955a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1955f:	e9 ff 04 00 00       	jmp    19a63 <sys_setup+0x525>
	callable = 0;
   19564:	c7 83 a4 15 00 00 00 	movl   $0x0,0x15a4(%ebx)
   1956b:	00 00 00 
#ifndef HD_TYPE																	// 如果没有定义HD_TYPE,则读取.
	for (drive = 0 ; drive < 2 ; drive++) {
   1956e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   19575:	00 
   19576:	e9 e5 00 00 00       	jmp    19660 <sys_setup+0x122>
		hd_info[drive].cyl = *(unsigned short *) BIOS;							// 柱面数
   1957b:	8b 44 24 40          	mov    0x40(%esp),%eax
   1957f:	0f b7 00             	movzwl (%eax),%eax
   19582:	0f b7 c8             	movzwl %ax,%ecx
   19585:	8b 54 24 18          	mov    0x18(%esp),%edx
   19589:	8d b3 28 42 00 00    	lea    0x4228(%ebx),%esi
   1958f:	89 d0                	mov    %edx,%eax
   19591:	01 c0                	add    %eax,%eax
   19593:	01 d0                	add    %edx,%eax
   19595:	c1 e0 03             	shl    $0x3,%eax
   19598:	01 f0                	add    %esi,%eax
   1959a:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].head = *(unsigned char *) (2 + BIOS);					// 磁头数
   1959c:	8b 44 24 40          	mov    0x40(%esp),%eax
   195a0:	83 c0 02             	add    $0x2,%eax
   195a3:	0f b6 00             	movzbl (%eax),%eax
   195a6:	0f b6 c8             	movzbl %al,%ecx
   195a9:	8b 54 24 18          	mov    0x18(%esp),%edx
   195ad:	8d b3 20 42 00 00    	lea    0x4220(%ebx),%esi
   195b3:	89 d0                	mov    %edx,%eax
   195b5:	01 c0                	add    %eax,%eax
   195b7:	01 d0                	add    %edx,%eax
   195b9:	c1 e0 03             	shl    $0x3,%eax
   195bc:	01 f0                	add    %esi,%eax
   195be:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].wpcom = *(unsigned short *) (5 + BIOS);					// 写前预补偿柱面号
   195c0:	8b 44 24 40          	mov    0x40(%esp),%eax
   195c4:	83 c0 05             	add    $0x5,%eax
   195c7:	0f b7 00             	movzwl (%eax),%eax
   195ca:	0f b7 c8             	movzwl %ax,%ecx
   195cd:	8b 54 24 18          	mov    0x18(%esp),%edx
   195d1:	8d b3 2c 42 00 00    	lea    0x422c(%ebx),%esi
   195d7:	89 d0                	mov    %edx,%eax
   195d9:	01 c0                	add    %eax,%eax
   195db:	01 d0                	add    %edx,%eax
   195dd:	c1 e0 03             	shl    $0x3,%eax
   195e0:	01 f0                	add    %esi,%eax
   195e2:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].ctl = *(unsigned char *) (8 + BIOS);						// 控制字节
   195e4:	8b 44 24 40          	mov    0x40(%esp),%eax
   195e8:	83 c0 08             	add    $0x8,%eax
   195eb:	0f b6 00             	movzbl (%eax),%eax
   195ee:	0f b6 c8             	movzbl %al,%ecx
   195f1:	8b 54 24 18          	mov    0x18(%esp),%edx
   195f5:	8d b3 24 42 00 00    	lea    0x4224(%ebx),%esi
   195fb:	89 d0                	mov    %edx,%eax
   195fd:	01 c0                	add    %eax,%eax
   195ff:	01 d0                	add    %edx,%eax
   19601:	c1 e0 03             	shl    $0x3,%eax
   19604:	01 f0                	add    %esi,%eax
   19606:	83 c0 10             	add    $0x10,%eax
   19609:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].lzone = *(unsigned short *) (12 + BIOS);					// 磁头着陆区柱面号
   1960b:	8b 44 24 40          	mov    0x40(%esp),%eax
   1960f:	83 c0 0c             	add    $0xc,%eax
   19612:	0f b7 00             	movzwl (%eax),%eax
   19615:	0f b7 c8             	movzwl %ax,%ecx
   19618:	8b 54 24 18          	mov    0x18(%esp),%edx
   1961c:	8d b3 20 42 00 00    	lea    0x4220(%ebx),%esi
   19622:	89 d0                	mov    %edx,%eax
   19624:	01 c0                	add    %eax,%eax
   19626:	01 d0                	add    %edx,%eax
   19628:	c1 e0 03             	shl    $0x3,%eax
   1962b:	01 f0                	add    %esi,%eax
   1962d:	83 c0 10             	add    $0x10,%eax
   19630:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].sect = *(unsigned char *) (14 + BIOS);					// 每磁道扇区数
   19632:	8b 44 24 40          	mov    0x40(%esp),%eax
   19636:	83 c0 0e             	add    $0xe,%eax
   19639:	0f b6 00             	movzbl (%eax),%eax
   1963c:	0f b6 c8             	movzbl %al,%ecx
   1963f:	8b 54 24 18          	mov    0x18(%esp),%edx
   19643:	8d b3 24 42 00 00    	lea    0x4224(%ebx),%esi
   19649:	89 d0                	mov    %edx,%eax
   1964b:	01 c0                	add    %eax,%eax
   1964d:	01 d0                	add    %edx,%eax
   1964f:	c1 e0 03             	shl    $0x3,%eax
   19652:	01 f0                	add    %esi,%eax
   19654:	89 08                	mov    %ecx,(%eax)
		BIOS += 16;																// 每个硬盘参数表长16字节,这里BIOS指向下一表.
   19656:	83 44 24 40 10       	addl   $0x10,0x40(%esp)
	for (drive = 0 ; drive < 2 ; drive++) {
   1965b:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   19660:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   19665:	0f 8e 10 ff ff ff    	jle    1957b <sys_setup+0x3d>
	}
	// setup.s程序在取BIOS硬盘参数表信息时,如果系统中只有1个硬盘,就会将对应第2硬盘的16字节全部清零.因此这里只要判断第2个硬盘柱面数是否为0
	// 就可以知道是否有第2个硬盘了.
	if (hd_info[1].cyl)
   1966b:	8b 83 40 42 00 00    	mov    0x4240(%ebx),%eax
   19671:	85 c0                	test   %eax,%eax
   19673:	74 0c                	je     19681 <sys_setup+0x143>
		NR_HD = 2;																// 硬盘数置为2.
   19675:	c7 83 58 42 00 00 02 	movl   $0x2,0x4258(%ebx)
   1967c:	00 00 00 
   1967f:	eb 0a                	jmp    1968b <sys_setup+0x14d>
	else
		NR_HD = 1;
   19681:	c7 83 58 42 00 00 01 	movl   $0x1,0x4258(%ebx)
   19688:	00 00 00 
#endif
	// 到这里,硬盘信息数组hd_info[]已经设置好,并且确定了系统含有的硬盘数NR_HD.现在开始设置硬盘 结构数组hd[].该数组的项0和项5分别表示两个
	// 硬盘的整体参数,而项1-4和6-9分别表示两个硬盘的4个分区参数.因此这里仅设置硬盘整体信息的两项(项0和5).
	for (i = 0 ; i < NR_HD ; i++) {
   1968b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   19692:	00 
   19693:	eb 7c                	jmp    19711 <sys_setup+0x1d3>
		hd[i * 5].start_sect = 0;												// 硬盘起始扇区号
   19695:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   19699:	89 d0                	mov    %edx,%eax
   1969b:	c1 e0 02             	shl    $0x2,%eax
   1969e:	01 d0                	add    %edx,%eax
   196a0:	c7 84 c3 60 42 00 00 	movl   $0x0,0x4260(%ebx,%eax,8)
   196a7:	00 00 00 00 
		hd[i * 5].nr_sects = hd_info[i].head * hd_info[i].sect * hd_info[i].cyl;// 硬盘总扇区数
   196ab:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   196af:	8d 8b 20 42 00 00    	lea    0x4220(%ebx),%ecx
   196b5:	89 d0                	mov    %edx,%eax
   196b7:	01 c0                	add    %eax,%eax
   196b9:	01 d0                	add    %edx,%eax
   196bb:	c1 e0 03             	shl    $0x3,%eax
   196be:	01 c8                	add    %ecx,%eax
   196c0:	8b 08                	mov    (%eax),%ecx
   196c2:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   196c6:	8d b3 24 42 00 00    	lea    0x4224(%ebx),%esi
   196cc:	89 d0                	mov    %edx,%eax
   196ce:	01 c0                	add    %eax,%eax
   196d0:	01 d0                	add    %edx,%eax
   196d2:	c1 e0 03             	shl    $0x3,%eax
   196d5:	01 f0                	add    %esi,%eax
   196d7:	8b 00                	mov    (%eax),%eax
   196d9:	89 ce                	mov    %ecx,%esi
   196db:	0f af f0             	imul   %eax,%esi
   196de:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   196e2:	8d 8b 28 42 00 00    	lea    0x4228(%ebx),%ecx
   196e8:	89 d0                	mov    %edx,%eax
   196ea:	01 c0                	add    %eax,%eax
   196ec:	01 d0                	add    %edx,%eax
   196ee:	c1 e0 03             	shl    $0x3,%eax
   196f1:	01 c8                	add    %ecx,%eax
   196f3:	8b 08                	mov    (%eax),%ecx
   196f5:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   196f9:	89 d0                	mov    %edx,%eax
   196fb:	c1 e0 02             	shl    $0x2,%eax
   196fe:	01 c2                	add    %eax,%edx
   19700:	89 f0                	mov    %esi,%eax
   19702:	0f af c1             	imul   %ecx,%eax
   19705:	89 84 d3 64 42 00 00 	mov    %eax,0x4264(%ebx,%edx,8)
	for (i = 0 ; i < NR_HD ; i++) {
   1970c:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   19711:	8b 83 58 42 00 00    	mov    0x4258(%ebx),%eax
   19717:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
   1971b:	0f 8c 74 ff ff ff    	jl     19695 <sys_setup+0x157>
		总之,一个非零值意味着硬盘是一个AT控制器兼容硬盘.
	*/

	// 根据上述原理,下面代码用来检测硬盘到底是不是AT控制器兼容的.这里从CMOS偏移地址0x12处读出硬盘类型字节.如果低半字节值(存放着第2个硬盘类型
	// 值)不为0,则表示系统有两硬盘,否则表示系统只有1个硬盘.如果0x12处读出的值为0,则表示系统中没有AT兼容硬盘.
	if ((cmos_disks = CMOS_READ(0x12)) & 0xf0)
   19721:	b8 92 00 00 00       	mov    $0x92,%eax
   19726:	ba 70 00 00 00       	mov    $0x70,%edx
   1972b:	ee                   	out    %al,(%dx)
   1972c:	eb 00                	jmp    1972e <sys_setup+0x1f0>
   1972e:	eb 00                	jmp    19730 <sys_setup+0x1f2>
   19730:	b8 71 00 00 00       	mov    $0x71,%eax
   19735:	89 c2                	mov    %eax,%edx
   19737:	ec                   	in     (%dx),%al
   19738:	eb 00                	jmp    1973a <sys_setup+0x1fc>
   1973a:	eb 00                	jmp    1973c <sys_setup+0x1fe>
   1973c:	88 44 24 13          	mov    %al,0x13(%esp)
   19740:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
   19745:	88 44 24 12          	mov    %al,0x12(%esp)
   19749:	0f b6 44 24 12       	movzbl 0x12(%esp),%eax
   1974e:	25 f0 00 00 00       	and    $0xf0,%eax
   19753:	85 c0                	test   %eax,%eax
   19755:	74 24                	je     1977b <sys_setup+0x23d>
		if (cmos_disks & 0x0f)
   19757:	0f b6 44 24 12       	movzbl 0x12(%esp),%eax
   1975c:	83 e0 0f             	and    $0xf,%eax
   1975f:	85 c0                	test   %eax,%eax
   19761:	74 0c                	je     1976f <sys_setup+0x231>
			NR_HD = 2;
   19763:	c7 83 58 42 00 00 02 	movl   $0x2,0x4258(%ebx)
   1976a:	00 00 00 
   1976d:	eb 16                	jmp    19785 <sys_setup+0x247>
		else
			NR_HD = 1;
   1976f:	c7 83 58 42 00 00 01 	movl   $0x1,0x4258(%ebx)
   19776:	00 00 00 
   19779:	eb 0a                	jmp    19785 <sys_setup+0x247>
	else
		NR_HD = 0;
   1977b:	c7 83 58 42 00 00 00 	movl   $0x0,0x4258(%ebx)
   19782:	00 00 00 
	// 若NR_HD = 0,则两个硬盘都不是AT控制器兼容的,两个硬盘数据结构全清零.若NR_HD = 1,则将第2个硬盘的参数清零.
	for (i = NR_HD ; i < 2 ; i++) {
   19785:	8b 83 58 42 00 00    	mov    0x4258(%ebx),%eax
   1978b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1978f:	eb 31                	jmp    197c2 <sys_setup+0x284>
		hd[i * 5].start_sect = 0;
   19791:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   19795:	89 d0                	mov    %edx,%eax
   19797:	c1 e0 02             	shl    $0x2,%eax
   1979a:	01 d0                	add    %edx,%eax
   1979c:	c7 84 c3 60 42 00 00 	movl   $0x0,0x4260(%ebx,%eax,8)
   197a3:	00 00 00 00 
		hd[i * 5].nr_sects = 0;
   197a7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   197ab:	89 d0                	mov    %edx,%eax
   197ad:	c1 e0 02             	shl    $0x2,%eax
   197b0:	01 d0                	add    %edx,%eax
   197b2:	c7 84 c3 64 42 00 00 	movl   $0x0,0x4264(%ebx,%eax,8)
   197b9:	00 00 00 00 
	for (i = NR_HD ; i < 2 ; i++) {
   197bd:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   197c2:	83 7c 24 1c 01       	cmpl   $0x1,0x1c(%esp)
   197c7:	7e c8                	jle    19791 <sys_setup+0x253>
	// 好,到此为止我们已经真正确定了系统中所含的硬盘个数NR_HD.现在我们来读取每个硬盘上第1个扇区中的分区表信息,用来设置分区结构数组hd[]中硬盘
	// 各分区的信息.首先利用读函数bread()读硬盘第1个数据块(fs/buffer.c),第1个参数(0x300,0x305)分别是两个硬盘的设备号,第2个参数(0)是所
	// 需读取的块号.若读操作成功,则数据会被存放在缓冲块bh的数据区中.若缓冲块头指针bh为0,则说明读操作失败,则显示出错信息并停机.否则我们根据硬盘第
	// 1个扇区最后两个字节应该是0xAA55来判断扇区中数据的有效性,从而可以知道扇区中位于偏移0x1BE开始处的分区表是否有效.若有效则将硬盘分区表信息
	// 放入硬盘分区结构数组hd[]中.最后释放bh缓冲区.
	for (drive = 0 ; drive < NR_HD ; drive++) {
   197c9:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   197d0:	00 
   197d1:	e9 1d 01 00 00       	jmp    198f3 <sys_setup+0x3b5>
		if (!(bh = bread(0x300 + drive * 5, 0))) {								// 0x300,0x305是设备号.
   197d6:	8b 54 24 18          	mov    0x18(%esp),%edx
   197da:	89 d0                	mov    %edx,%eax
   197dc:	c1 e0 02             	shl    $0x2,%eax
   197df:	01 d0                	add    %edx,%eax
   197e1:	05 00 03 00 00       	add    $0x300,%eax
   197e6:	83 ec 08             	sub    $0x8,%esp
   197e9:	6a 00                	push   $0x0
   197eb:	50                   	push   %eax
   197ec:	e8 e1 71 ff ff       	call   109d2 <bread>
   197f1:	83 c4 10             	add    $0x10,%esp
   197f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
   197f8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   197fd:	75 28                	jne    19827 <sys_setup+0x2e9>
			printk("Unable to read partition table of drive %d\n\r",
   197ff:	83 ec 08             	sub    $0x8,%esp
   19802:	ff 74 24 20          	pushl  0x20(%esp)
   19806:	8d 83 e4 56 ff ff    	lea    -0xa91c(%ebx),%eax
   1980c:	50                   	push   %eax
   1980d:	e8 20 fb fe ff       	call   9332 <printk>
   19812:	83 c4 10             	add    $0x10,%esp
				drive);
			panic("");
   19815:	83 ec 0c             	sub    $0xc,%esp
   19818:	8d 83 11 57 ff ff    	lea    -0xa8ef(%ebx),%eax
   1981e:	50                   	push   %eax
   1981f:	e8 ba fa fe ff       	call   92de <panic>
   19824:	83 c4 10             	add    $0x10,%esp
		}
		if (bh->b_data[510] != 0x55 || (unsigned char)
   19827:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1982b:	8b 00                	mov    (%eax),%eax
   1982d:	05 fe 01 00 00       	add    $0x1fe,%eax
   19832:	0f b6 00             	movzbl (%eax),%eax
   19835:	3c 55                	cmp    $0x55,%al
   19837:	75 12                	jne    1984b <sys_setup+0x30d>
		    bh->b_data[511] != 0xAA) {											// 判断硬盘标志0xAA55.
   19839:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1983d:	8b 00                	mov    (%eax),%eax
   1983f:	05 ff 01 00 00       	add    $0x1ff,%eax
   19844:	0f b6 00             	movzbl (%eax),%eax
		if (bh->b_data[510] != 0x55 || (unsigned char)
   19847:	3c aa                	cmp    $0xaa,%al
   19849:	74 28                	je     19873 <sys_setup+0x335>
			printk("Bad partition table on drive %d\n\r",drive);
   1984b:	83 ec 08             	sub    $0x8,%esp
   1984e:	ff 74 24 20          	pushl  0x20(%esp)
   19852:	8d 83 14 57 ff ff    	lea    -0xa8ec(%ebx),%eax
   19858:	50                   	push   %eax
   19859:	e8 d4 fa fe ff       	call   9332 <printk>
   1985e:	83 c4 10             	add    $0x10,%esp
			panic("");
   19861:	83 ec 0c             	sub    $0xc,%esp
   19864:	8d 83 11 57 ff ff    	lea    -0xa8ef(%ebx),%eax
   1986a:	50                   	push   %eax
   1986b:	e8 6e fa fe ff       	call   92de <panic>
   19870:	83 c4 10             	add    $0x10,%esp
		}
		p = 0x1BE + (void *)bh->b_data;	 										// 分区表位于第1扇区0x1BE处.
   19873:	8b 44 24 0c          	mov    0xc(%esp),%eax
   19877:	8b 00                	mov    (%eax),%eax
   19879:	05 be 01 00 00       	add    $0x1be,%eax
   1987e:	89 44 24 14          	mov    %eax,0x14(%esp)
		for (i = 1; i < 5; i++, p++) {
   19882:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
   19889:	00 
   1988a:	eb 4c                	jmp    198d8 <sys_setup+0x39a>
			hd[i + 5 * drive].start_sect = p->start_sect;
   1988c:	8b 44 24 14          	mov    0x14(%esp),%eax
   19890:	8b 48 08             	mov    0x8(%eax),%ecx
   19893:	8b 54 24 18          	mov    0x18(%esp),%edx
   19897:	89 d0                	mov    %edx,%eax
   19899:	c1 e0 02             	shl    $0x2,%eax
   1989c:	01 c2                	add    %eax,%edx
   1989e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   198a2:	01 d0                	add    %edx,%eax
   198a4:	89 ca                	mov    %ecx,%edx
   198a6:	89 94 c3 60 42 00 00 	mov    %edx,0x4260(%ebx,%eax,8)
			hd[i + 5 * drive].nr_sects = p->nr_sects;
   198ad:	8b 44 24 14          	mov    0x14(%esp),%eax
   198b1:	8b 48 0c             	mov    0xc(%eax),%ecx
   198b4:	8b 54 24 18          	mov    0x18(%esp),%edx
   198b8:	89 d0                	mov    %edx,%eax
   198ba:	c1 e0 02             	shl    $0x2,%eax
   198bd:	01 c2                	add    %eax,%edx
   198bf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   198c3:	01 d0                	add    %edx,%eax
   198c5:	89 ca                	mov    %ecx,%edx
   198c7:	89 94 c3 64 42 00 00 	mov    %edx,0x4264(%ebx,%eax,8)
		for (i = 1; i < 5; i++, p++) {
   198ce:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   198d3:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
   198d8:	83 7c 24 1c 04       	cmpl   $0x4,0x1c(%esp)
   198dd:	7e ad                	jle    1988c <sys_setup+0x34e>
		}
		brelse(bh);																// 释放为存放硬盘数据块而申请的缓冲区.
   198df:	83 ec 0c             	sub    $0xc,%esp
   198e2:	ff 74 24 18          	pushl  0x18(%esp)
   198e6:	e8 80 70 ff ff       	call   1096b <brelse>
   198eb:	83 c4 10             	add    $0x10,%esp
	for (drive = 0 ; drive < NR_HD ; drive++) {
   198ee:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   198f3:	8b 83 58 42 00 00    	mov    0x4258(%ebx),%eax
   198f9:	39 44 24 18          	cmp    %eax,0x18(%esp)
   198fd:	0f 8c d3 fe ff ff    	jl     197d6 <sys_setup+0x298>
    }
	// 现在再对每个分区中的数据块总数进行统计,并保存在硬盘分区总数据数组hd_sizes[]中.然后让设备数据块总数指针数组的本设备项指向该数组.
	for (i = 0 ; i < 5 * MAX_HD ; i++) {
   19903:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   1990a:	00 
   1990b:	eb 5e                	jmp    1996b <sys_setup+0x42d>
		if (hd[i].nr_sects != 0)
   1990d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   19911:	8b 84 c3 64 42 00 00 	mov    0x4264(%ebx,%eax,8),%eax
   19918:	85 c0                	test   %eax,%eax
   1991a:	74 30                	je     1994c <sys_setup+0x40e>
			Log(LOG_INFO_TYPE, "<<<<< HD Partition%d Info : start_sect = %d, nr_sects = %d >>>>>\n", i, hd[i].start_sect, hd[i].nr_sects);
   1991c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   19920:	8b 94 c3 64 42 00 00 	mov    0x4264(%ebx,%eax,8),%edx
   19927:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1992b:	8b 84 c3 60 42 00 00 	mov    0x4260(%ebx,%eax,8),%eax
   19932:	83 ec 0c             	sub    $0xc,%esp
   19935:	52                   	push   %edx
   19936:	50                   	push   %eax
   19937:	ff 74 24 30          	pushl  0x30(%esp)
   1993b:	8d 83 38 57 ff ff    	lea    -0xa8c8(%ebx),%eax
   19941:	50                   	push   %eax
   19942:	6a 00                	push   $0x0
   19944:	e8 56 c2 00 00       	call   25b9f <Log>
   19949:	83 c4 20             	add    $0x20,%esp
		hd_sizes[i] = hd[i].nr_sects >> 1 ;
   1994c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   19950:	8b 84 c3 64 42 00 00 	mov    0x4264(%ebx,%eax,8),%eax
   19957:	d1 f8                	sar    %eax
   19959:	89 c2                	mov    %eax,%edx
   1995b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1995f:	89 94 83 c0 42 00 00 	mov    %edx,0x42c0(%ebx,%eax,4)
	for (i = 0 ; i < 5 * MAX_HD ; i++) {
   19966:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   1996b:	83 7c 24 1c 09       	cmpl   $0x9,0x1c(%esp)
   19970:	7e 9b                	jle    1990d <sys_setup+0x3cf>
	}
	blk_size[MAJOR_NR] = hd_sizes;
   19972:	c7 c0 b8 61 03 00    	mov    $0x361b8,%eax
   19978:	8d 93 c0 42 00 00    	lea    0x42c0(%ebx),%edx
   1997e:	89 50 0c             	mov    %edx,0xc(%eax)
	// 现在总算完成设置硬盘分区结构数组hd[]的任务.如果确实有硬盘存在并且读入其分区表,则显示"分区表正常"信息.然后尝试在系统内存虚拟盘中加载启动盘中包含的
	// 根文件系统映像(blk_drv/ramdisk.c).即在系统设置有虚拟盘的情况下判断启动盘上是否还含有根文件系统的映像数据.如果有(此时该启动盘称为集成盘)则尝试
	// 把该映像加载并存放到虚拟盘中,然后把此时的根文件系统设备号ROOT_DEV修改成虚拟盘的设备号.接着再对交换设备进行初始化.最后安装根文件系统.
	if (NR_HD)
   19981:	8b 83 58 42 00 00    	mov    0x4258(%ebx),%eax
   19987:	85 c0                	test   %eax,%eax
   19989:	74 2e                	je     199b9 <sys_setup+0x47b>
		Log(LOG_INFO_TYPE, "<<<<< Partition table%s ok. >>>>>\n\r",(NR_HD > 1) ? "s":"");
   1998b:	8b 83 58 42 00 00    	mov    0x4258(%ebx),%eax
   19991:	83 f8 01             	cmp    $0x1,%eax
   19994:	7e 08                	jle    1999e <sys_setup+0x460>
   19996:	8d 83 7a 57 ff ff    	lea    -0xa886(%ebx),%eax
   1999c:	eb 06                	jmp    199a4 <sys_setup+0x466>
   1999e:	8d 83 11 57 ff ff    	lea    -0xa8ef(%ebx),%eax
   199a4:	83 ec 04             	sub    $0x4,%esp
   199a7:	50                   	push   %eax
   199a8:	8d 83 7c 57 ff ff    	lea    -0xa884(%ebx),%eax
   199ae:	50                   	push   %eax
   199af:	6a 00                	push   $0x0
   199b1:	e8 e9 c1 00 00       	call   25b9f <Log>
   199b6:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NR_HD; i++)
   199b9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   199c0:	00 
   199c1:	eb 7c                	jmp    19a3f <sys_setup+0x501>
		Log(LOG_INFO_TYPE, "<<<<< HD%d Info: cyl = %d, head = %d, sect = %d, ctl = %x >>>>>\n", hd_info[i].cyl, hd_info[i].head, hd_info[i].sect, hd_info[i].ctl);
   199c3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   199c7:	8d 8b 24 42 00 00    	lea    0x4224(%ebx),%ecx
   199cd:	89 d0                	mov    %edx,%eax
   199cf:	01 c0                	add    %eax,%eax
   199d1:	01 d0                	add    %edx,%eax
   199d3:	c1 e0 03             	shl    $0x3,%eax
   199d6:	01 c8                	add    %ecx,%eax
   199d8:	83 c0 10             	add    $0x10,%eax
   199db:	8b 38                	mov    (%eax),%edi
   199dd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   199e1:	8d 8b 24 42 00 00    	lea    0x4224(%ebx),%ecx
   199e7:	89 d0                	mov    %edx,%eax
   199e9:	01 c0                	add    %eax,%eax
   199eb:	01 d0                	add    %edx,%eax
   199ed:	c1 e0 03             	shl    $0x3,%eax
   199f0:	01 c8                	add    %ecx,%eax
   199f2:	8b 30                	mov    (%eax),%esi
   199f4:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   199f8:	8d 8b 20 42 00 00    	lea    0x4220(%ebx),%ecx
   199fe:	89 d0                	mov    %edx,%eax
   19a00:	01 c0                	add    %eax,%eax
   19a02:	01 d0                	add    %edx,%eax
   19a04:	c1 e0 03             	shl    $0x3,%eax
   19a07:	01 c8                	add    %ecx,%eax
   19a09:	8b 08                	mov    (%eax),%ecx
   19a0b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   19a0f:	8d ab 28 42 00 00    	lea    0x4228(%ebx),%ebp
   19a15:	89 d0                	mov    %edx,%eax
   19a17:	01 c0                	add    %eax,%eax
   19a19:	01 d0                	add    %edx,%eax
   19a1b:	c1 e0 03             	shl    $0x3,%eax
   19a1e:	01 e8                	add    %ebp,%eax
   19a20:	8b 00                	mov    (%eax),%eax
   19a22:	83 ec 08             	sub    $0x8,%esp
   19a25:	57                   	push   %edi
   19a26:	56                   	push   %esi
   19a27:	51                   	push   %ecx
   19a28:	50                   	push   %eax
   19a29:	8d 83 a0 57 ff ff    	lea    -0xa860(%ebx),%eax
   19a2f:	50                   	push   %eax
   19a30:	6a 00                	push   $0x0
   19a32:	e8 68 c1 00 00       	call   25b9f <Log>
   19a37:	83 c4 20             	add    $0x20,%esp
	for (i = 0; i < NR_HD; i++)
   19a3a:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   19a3f:	8b 83 58 42 00 00    	mov    0x4258(%ebx),%eax
   19a45:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
   19a49:	0f 8c 74 ff ff ff    	jl     199c3 <sys_setup+0x485>
	rd_load();																	// blk_drv/ramdisk.c
   19a4f:	e8 9d 0d 00 00       	call   1a7f1 <rd_load>
	init_swapping();															// mm/swap.c
   19a54:	e8 02 46 ff ff       	call   e05b <init_swapping>
	mount_root();																// fs/super.c
   19a59:	e8 9e 7c ff ff       	call   116fc <mount_root>
	return (0);
   19a5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   19a63:	83 c4 2c             	add    $0x2c,%esp
   19a66:	5b                   	pop    %ebx
   19a67:	5e                   	pop    %esi
   19a68:	5f                   	pop    %edi
   19a69:	5d                   	pop    %ebp
   19a6a:	c3                   	ret    

00019a6b <controller_ready>:
// 则表示等待控制器空闲的时间已经超时而发生错误,若返回值不为0则说明在等待(循环)时间期限内控制器回到空闲状态.OK!
// 实际上,我们仅需检测状态寄存器忙位(位7)是否为1来判断控制器是否处于忙状态,驱动器是否就绪(即位6是否为1)与控制器的状态无关.因此我们可能把第172行
// 语句改写成:"while(--retries && (inb_p(HD_STATUS)&0x80));"另外,由于现在的PC速度都很快,因此我们可以把等待的循环次数再加大一些,例如
// 再增加10倍.
static int controller_ready(void)
{
   19a6b:	83 ec 10             	sub    $0x10,%esp
   19a6e:	e8 7f d2 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   19a73:	05 8d 85 01 00       	add    $0x1858d,%eax
	int retries = 100000;
   19a78:	c7 44 24 0c a0 86 01 	movl   $0x186a0,0xc(%esp)
   19a7f:	00 

	//while (--retries && (inb_p(HD_STATUS)&0xc0)!=0x40);
	while(--retries && (inb_p(HD_STATUS) & 0X80)) ;
   19a80:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
   19a85:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   19a8a:	74 19                	je     19aa5 <controller_ready+0x3a>
   19a8c:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   19a91:	89 c2                	mov    %eax,%edx
   19a93:	ec                   	in     (%dx),%al
   19a94:	eb 00                	jmp    19a96 <controller_ready+0x2b>
   19a96:	eb 00                	jmp    19a98 <controller_ready+0x2d>
   19a98:	88 44 24 0b          	mov    %al,0xb(%esp)
   19a9c:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   19aa1:	84 c0                	test   %al,%al
   19aa3:	78 db                	js     19a80 <controller_ready+0x15>
	return (retries);									// 返回等待循环次数.
   19aa5:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   19aa9:	83 c4 10             	add    $0x10,%esp
   19aac:	c3                   	ret    

00019aad <win_result>:

// 检测硬盘执行命令后的状态.(win表示温切斯特硬盘的缩写)
// 读取状态寄存器中的命令执行结果状态.返回0表示正常;1表示出错.如果执行命令错,则需要再读错误寄存器HD_ERROR(0x1f1).
static int win_result(void)
{
   19aad:	83 ec 10             	sub    $0x10,%esp
   19ab0:	e8 3d d2 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   19ab5:	05 4b 85 01 00       	add    $0x1854b,%eax
	int i = inb_p(HD_STATUS);							// 取状态信息.
   19aba:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   19abf:	89 c2                	mov    %eax,%edx
   19ac1:	ec                   	in     (%dx),%al
   19ac2:	eb 00                	jmp    19ac4 <win_result+0x17>
   19ac4:	eb 00                	jmp    19ac6 <win_result+0x19>
   19ac6:	88 44 24 0f          	mov    %al,0xf(%esp)
   19aca:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   19acf:	0f b6 c0             	movzbl %al,%eax
   19ad2:	89 44 24 08          	mov    %eax,0x8(%esp)

	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
   19ad6:	8b 44 24 08          	mov    0x8(%esp),%eax
   19ada:	25 f1 00 00 00       	and    $0xf1,%eax
   19adf:	83 f8 50             	cmp    $0x50,%eax
   19ae2:	75 07                	jne    19aeb <win_result+0x3e>
		== (READY_STAT | SEEK_STAT))
		return(0); 										/* ok */
   19ae4:	b8 00 00 00 00       	mov    $0x0,%eax
   19ae9:	eb 28                	jmp    19b13 <win_result+0x66>
	if (i & 1) i = inb(HD_ERROR);						// 若ERR_STAT置位,则读取错误寄存器.
   19aeb:	8b 44 24 08          	mov    0x8(%esp),%eax
   19aef:	83 e0 01             	and    $0x1,%eax
   19af2:	85 c0                	test   %eax,%eax
   19af4:	74 18                	je     19b0e <win_result+0x61>
   19af6:	b8 f1 01 00 00       	mov    $0x1f1,%eax
   19afb:	89 c2                	mov    %eax,%edx
   19afd:	ec                   	in     (%dx),%al
   19afe:	88 44 24 07          	mov    %al,0x7(%esp)
   19b02:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
   19b07:	0f b6 c0             	movzbl %al,%eax
   19b0a:	89 44 24 08          	mov    %eax,0x8(%esp)
	return (1);
   19b0e:	b8 01 00 00 00       	mov    $0x1,%eax
}
   19b13:	83 c4 10             	add    $0x10,%esp
   19b16:	c3                   	ret    

00019b17 <hd_out>:
// 第191行定义1个寄存器变量__res.该变量将被保存在1个寄存器中,以便于快速访问.
// 如果想指定寄存器(如eax),则我们可以把该句写成"register char __res asm("ax");"
static void hd_out(unsigned int drive, unsigned int nsect, unsigned int sect,
		unsigned int head, unsigned int cyl, unsigned int cmd,
		void (*intr_addr)(void))
{
   19b17:	56                   	push   %esi
   19b18:	53                   	push   %ebx
   19b19:	83 ec 04             	sub    $0x4,%esp
   19b1c:	e8 e5 47 ff ff       	call   e306 <__x86.get_pc_thunk.si>
   19b21:	81 c6 df 84 01 00    	add    $0x184df,%esi
	register int port;

	// 首先对参数进行有效性检查.如果驱动器号大于1(只能是0,1)或者磁头号大于15,则程序不支持,停机.否则就判断并循环等待驱动器就绪.如果等待一段时间
	// 后仍未就绪则表示硬盘控制器出错,也停机.
	if (drive > 1 || head > 15)
   19b27:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
   19b2c:	77 07                	ja     19b35 <hd_out+0x1e>
   19b2e:	83 7c 24 1c 0f       	cmpl   $0xf,0x1c(%esp)
   19b33:	76 14                	jbe    19b49 <hd_out+0x32>
		panic("Trying to write bad sector");
   19b35:	83 ec 0c             	sub    $0xc,%esp
   19b38:	8d 86 e1 57 ff ff    	lea    -0xa81f(%esi),%eax
   19b3e:	50                   	push   %eax
   19b3f:	89 f3                	mov    %esi,%ebx
   19b41:	e8 98 f7 fe ff       	call   92de <panic>
   19b46:	83 c4 10             	add    $0x10,%esp
	if (!controller_ready())
   19b49:	e8 1d ff ff ff       	call   19a6b <controller_ready>
   19b4e:	85 c0                	test   %eax,%eax
   19b50:	75 14                	jne    19b66 <hd_out+0x4f>
		panic("HD controller not ready");
   19b52:	83 ec 0c             	sub    $0xc,%esp
   19b55:	8d 86 fc 57 ff ff    	lea    -0xa804(%esi),%eax
   19b5b:	50                   	push   %eax
   19b5c:	89 f3                	mov    %esi,%ebx
   19b5e:	e8 7b f7 fe ff       	call   92de <panic>
   19b63:	83 c4 10             	add    $0x10,%esp
	// 接着我们设置硬盘中断发生时将调用的C函数指针do_hd(该函数指针定义在blk.h文件).然后在向硬盘控制器发送参数和命令之前,规定要先向控制器命令端口
	// (0x3f6)发送一指定硬盘的控制字节,以建立相应的硬盘控制方式.该控制字节即是硬盘信息结构数组中的ctl字节.然后向控制器端口0x1f1-0x1f7发送7字节
	// 的参数命令块.
	SET_INTR(intr_addr);								// do_hd = intr_addr在中断中被调用.
   19b66:	8b 44 24 28          	mov    0x28(%esp),%eax
   19b6a:	89 86 00 42 00 00    	mov    %eax,0x4200(%esi)
   19b70:	c7 86 04 42 00 00 c8 	movl   $0xc8,0x4204(%esi)
   19b77:	00 00 00 
	outb_p(hd_info[drive].ctl, HD_CMD);					// 向控制寄存器输出控制字节
   19b7a:	8b 54 24 10          	mov    0x10(%esp),%edx
   19b7e:	8d 8e 24 42 00 00    	lea    0x4224(%esi),%ecx
   19b84:	89 d0                	mov    %edx,%eax
   19b86:	01 c0                	add    %eax,%eax
   19b88:	01 d0                	add    %edx,%eax
   19b8a:	c1 e0 03             	shl    $0x3,%eax
   19b8d:	01 c8                	add    %ecx,%eax
   19b8f:	83 c0 10             	add    $0x10,%eax
   19b92:	8b 00                	mov    (%eax),%eax
   19b94:	ba f6 03 00 00       	mov    $0x3f6,%edx
   19b99:	ee                   	out    %al,(%dx)
   19b9a:	eb 00                	jmp    19b9c <hd_out+0x85>
   19b9c:	eb 00                	jmp    19b9e <hd_out+0x87>
	port = HD_DATA;										// 置dx为数据寄存器端口(0x1f0)
   19b9e:	bb f0 01 00 00       	mov    $0x1f0,%ebx
	outb_p(hd_info[drive].wpcom >> 2, ++port);			// 参数:写预补偿柱面号(需除4)
   19ba3:	8b 54 24 10          	mov    0x10(%esp),%edx
   19ba7:	8d 8e 2c 42 00 00    	lea    0x422c(%esi),%ecx
   19bad:	89 d0                	mov    %edx,%eax
   19baf:	01 c0                	add    %eax,%eax
   19bb1:	01 d0                	add    %edx,%eax
   19bb3:	c1 e0 03             	shl    $0x3,%eax
   19bb6:	01 c8                	add    %ecx,%eax
   19bb8:	8b 00                	mov    (%eax),%eax
   19bba:	c1 f8 02             	sar    $0x2,%eax
   19bbd:	83 c3 01             	add    $0x1,%ebx
   19bc0:	89 da                	mov    %ebx,%edx
   19bc2:	ee                   	out    %al,(%dx)
   19bc3:	eb 00                	jmp    19bc5 <hd_out+0xae>
   19bc5:	eb 00                	jmp    19bc7 <hd_out+0xb0>
	outb_p(nsect, ++port);								// 参数:读/写扇区总数.
   19bc7:	83 c3 01             	add    $0x1,%ebx
   19bca:	8b 44 24 14          	mov    0x14(%esp),%eax
   19bce:	89 da                	mov    %ebx,%edx
   19bd0:	ee                   	out    %al,(%dx)
   19bd1:	eb 00                	jmp    19bd3 <hd_out+0xbc>
   19bd3:	eb 00                	jmp    19bd5 <hd_out+0xbe>
	outb_p(sect, ++port);								// 参数:起始扇区.
   19bd5:	83 c3 01             	add    $0x1,%ebx
   19bd8:	8b 44 24 18          	mov    0x18(%esp),%eax
   19bdc:	89 da                	mov    %ebx,%edx
   19bde:	ee                   	out    %al,(%dx)
   19bdf:	eb 00                	jmp    19be1 <hd_out+0xca>
   19be1:	eb 00                	jmp    19be3 <hd_out+0xcc>
	outb_p(cyl, ++port);								// 参数:柱面号低8位.
   19be3:	83 c3 01             	add    $0x1,%ebx
   19be6:	8b 44 24 20          	mov    0x20(%esp),%eax
   19bea:	89 da                	mov    %ebx,%edx
   19bec:	ee                   	out    %al,(%dx)
   19bed:	eb 00                	jmp    19bef <hd_out+0xd8>
   19bef:	eb 00                	jmp    19bf1 <hd_out+0xda>
	outb_p(cyl >> 8, ++port);							// 参数:柱面号高8位.
   19bf1:	8b 44 24 20          	mov    0x20(%esp),%eax
   19bf5:	c1 e8 08             	shr    $0x8,%eax
   19bf8:	83 c3 01             	add    $0x1,%ebx
   19bfb:	89 da                	mov    %ebx,%edx
   19bfd:	ee                   	out    %al,(%dx)
   19bfe:	eb 00                	jmp    19c00 <hd_out+0xe9>
   19c00:	eb 00                	jmp    19c02 <hd_out+0xeb>
	outb_p(0xA0 | (drive << 4) | head, ++port);			// 参数:驱动器号+磁头号.
   19c02:	8b 44 24 10          	mov    0x10(%esp),%eax
   19c06:	c1 e0 04             	shl    $0x4,%eax
   19c09:	0b 44 24 1c          	or     0x1c(%esp),%eax
   19c0d:	0c a0                	or     $0xa0,%al
   19c0f:	83 c3 01             	add    $0x1,%ebx
   19c12:	89 da                	mov    %ebx,%edx
   19c14:	ee                   	out    %al,(%dx)
   19c15:	eb 00                	jmp    19c17 <hd_out+0x100>
   19c17:	eb 00                	jmp    19c19 <hd_out+0x102>
	outb(cmd, ++port);									// 命令:硬盘控制命令.
   19c19:	83 c3 01             	add    $0x1,%ebx
   19c1c:	8b 44 24 24          	mov    0x24(%esp),%eax
   19c20:	89 da                	mov    %ebx,%edx
   19c22:	ee                   	out    %al,(%dx)
}
   19c23:	90                   	nop
   19c24:	83 c4 04             	add    $0x4,%esp
   19c27:	5b                   	pop    %ebx
   19c28:	5e                   	pop    %esi
   19c29:	c3                   	ret    

00019c2a <drive_busy>:

// 等待硬盘就绪.
// 该函数循环等待主状态控制器忙标志复位.若仅有就绪或寻道结束标志置位,则表示就绪,成功返回0.若经过一段时间仍为忙,则返回1.
static int drive_busy(void)
{
   19c2a:	53                   	push   %ebx
   19c2b:	83 ec 18             	sub    $0x18,%esp
   19c2e:	e8 04 2e ff ff       	call   ca37 <__x86.get_pc_thunk.cx>
   19c33:	81 c1 cd 83 01 00    	add    $0x183cd,%ecx
	unsigned int i;
	unsigned char c;

	// 循环读取控制器的主状态寄存器HD_STATUS,等待就绪标志位置位并且忙位复位.然后检测其中忙位,就绪位和寻道结束位.若仅有就绪或寻道结束标志置位,则表示硬盘
	// 就绪,返回0.否则表示等待超时.于是警告显示信息.并返回1.
	for (i = 0; i < 50000; i++) {
   19c39:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   19c40:	00 
   19c41:	eb 31                	jmp    19c74 <drive_busy+0x4a>
		c = inb_p(HD_STATUS);							// 取主控制器状态字节.
   19c43:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   19c48:	89 c2                	mov    %eax,%edx
   19c4a:	ec                   	in     (%dx),%al
   19c4b:	eb 00                	jmp    19c4d <drive_busy+0x23>
   19c4d:	eb 00                	jmp    19c4f <drive_busy+0x25>
   19c4f:	88 44 24 0b          	mov    %al,0xb(%esp)
   19c53:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   19c58:	88 44 24 0a          	mov    %al,0xa(%esp)
		c &= (BUSY_STAT | READY_STAT | SEEK_STAT);
   19c5c:	80 64 24 0a d0       	andb   $0xd0,0xa(%esp)
		if (c == (READY_STAT | SEEK_STAT))
   19c61:	80 7c 24 0a 50       	cmpb   $0x50,0xa(%esp)
   19c66:	75 07                	jne    19c6f <drive_busy+0x45>
			return 0;
   19c68:	b8 00 00 00 00       	mov    $0x0,%eax
   19c6d:	eb 28                	jmp    19c97 <drive_busy+0x6d>
	for (i = 0; i < 50000; i++) {
   19c6f:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   19c74:	81 7c 24 0c 4f c3 00 	cmpl   $0xc34f,0xc(%esp)
   19c7b:	00 
   19c7c:	76 c5                	jbe    19c43 <drive_busy+0x19>
	}
	printk("HD controller times out\n\r");				// 等待超时,显示信息.并返回1.
   19c7e:	83 ec 0c             	sub    $0xc,%esp
   19c81:	8d 81 14 58 ff ff    	lea    -0xa7ec(%ecx),%eax
   19c87:	50                   	push   %eax
   19c88:	89 cb                	mov    %ecx,%ebx
   19c8a:	e8 a3 f6 fe ff       	call   9332 <printk>
   19c8f:	83 c4 10             	add    $0x10,%esp
	return(1);
   19c92:	b8 01 00 00 00       	mov    $0x1,%eax
}
   19c97:	83 c4 18             	add    $0x18,%esp
   19c9a:	5b                   	pop    %ebx
   19c9b:	c3                   	ret    

00019c9c <reset_controller>:

// 诊断复位(重新校正)硬盘控制器.
// 首先向控制器寄存器端口(0x3f6)发送允许复位(4)控制字节.然后循环 操作等待一段时间让控制器执行复位操作.接着再向该端口发送正常的控制字节(不禁止重试,重读)
// 并等待硬盘就绪.若等待硬盘就绪超时,则显示警告信息.然后读取错误寄存器内容,若其不等于1(表示无错误)则显示硬盘控制器复位失败信息.
static void reset_controller(void)
{
   19c9c:	53                   	push   %ebx
   19c9d:	83 ec 18             	sub    $0x18,%esp
   19ca0:	e8 55 d0 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19ca5:	81 c3 5b 83 01 00    	add    $0x1835b,%ebx
	int	i;

	outb(4, HD_CMD);									// 向控制寄存器端口发送复位控制字节.
   19cab:	b8 04 00 00 00       	mov    $0x4,%eax
   19cb0:	ba f6 03 00 00       	mov    $0x3f6,%edx
   19cb5:	ee                   	out    %al,(%dx)
	for(i = 0; i < 1000; i++) nop();					// 等待一段时间.
   19cb6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   19cbd:	00 
   19cbe:	eb 06                	jmp    19cc6 <reset_controller+0x2a>
   19cc0:	90                   	nop
   19cc1:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   19cc6:	81 7c 24 0c e7 03 00 	cmpl   $0x3e7,0xc(%esp)
   19ccd:	00 
   19cce:	7e f0                	jle    19cc0 <reset_controller+0x24>
	outb(hd_info[0].ctl & 0x0f, HD_CMD);				// 发送正常控制字节(不禁止重试,重读).
   19cd0:	8b 83 34 42 00 00    	mov    0x4234(%ebx),%eax
   19cd6:	83 e0 0f             	and    $0xf,%eax
   19cd9:	ba f6 03 00 00       	mov    $0x3f6,%edx
   19cde:	ee                   	out    %al,(%dx)
	if (drive_busy())
   19cdf:	e8 46 ff ff ff       	call   19c2a <drive_busy>
   19ce4:	85 c0                	test   %eax,%eax
   19ce6:	74 12                	je     19cfa <reset_controller+0x5e>
		printk("HD-controller still busy\n\r");
   19ce8:	83 ec 0c             	sub    $0xc,%esp
   19ceb:	8d 83 2e 58 ff ff    	lea    -0xa7d2(%ebx),%eax
   19cf1:	50                   	push   %eax
   19cf2:	e8 3b f6 fe ff       	call   9332 <printk>
   19cf7:	83 c4 10             	add    $0x10,%esp
	if ((i = inb(HD_ERROR)) != 1)
   19cfa:	b8 f1 01 00 00       	mov    $0x1f1,%eax
   19cff:	89 c2                	mov    %eax,%edx
   19d01:	ec                   	in     (%dx),%al
   19d02:	88 44 24 0b          	mov    %al,0xb(%esp)
   19d06:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   19d0b:	0f b6 c0             	movzbl %al,%eax
   19d0e:	89 44 24 0c          	mov    %eax,0xc(%esp)
   19d12:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
   19d17:	74 16                	je     19d2f <reset_controller+0x93>
		printk("HD-controller reset failed: %02x\n\r",i);
   19d19:	83 ec 08             	sub    $0x8,%esp
   19d1c:	ff 74 24 14          	pushl  0x14(%esp)
   19d20:	8d 83 4c 58 ff ff    	lea    -0xa7b4(%ebx),%eax
   19d26:	50                   	push   %eax
   19d27:	e8 06 f6 fe ff       	call   9332 <printk>
   19d2c:	83 c4 10             	add    $0x10,%esp
}
   19d2f:	90                   	nop
   19d30:	83 c4 18             	add    $0x18,%esp
   19d33:	5b                   	pop    %ebx
   19d34:	c3                   	ret    

00019d35 <reset_hd>:

// 硬盘复位操作.
// 首先复位(重新校正)硬盘控制器.然后发送硬盘控制器命令"建立驱动器参数".在本命令引起的硬盘中断处理程序中又会调用本函数.此时该函数会根据执行该命令的结果判断是
// 否要进行出错处理或是继续执行请求项处理操作.
static void reset_hd(void)
{
   19d35:	55                   	push   %ebp
   19d36:	57                   	push   %edi
   19d37:	56                   	push   %esi
   19d38:	53                   	push   %ebx
   19d39:	83 ec 0c             	sub    $0xc,%esp
   19d3c:	e8 b9 cf fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19d41:	81 c3 bf 82 01 00    	add    $0x182bf,%ebx
	// 如果复位标志reset是置位的,则把复位标志清零后,执行复位硬盘控制在操作.然后针对第i个硬盘向控制器发送"建立驱动器参数"命令.当控制器执行了该命令后,又会发出硬盘
	// 中断信号.此时本函数会被中断过程调用而再次执行.由于reset已经标志复位,因此会首先去执行246行开始的语句,判断命令执行是否正常.若还是发生错误就会调用bad_rw_intr()
	// 函数以统计出错次数并根据次数确定是否在设置reset标志如果又设置了reset标志则跳转到repeat重新执行本函数.若复位操作正常,则针对下一个硬盘发送"建立驱动器参数"
	// 命令,并作上述处理.如果系统中NR_HD个硬盘都已经正常执行了发送的命令,则再次do_hd_request()函数开始对请求项进行处理.
repeat:
	if (reset) {
   19d47:	8b 83 54 42 00 00    	mov    0x4254(%ebx),%eax
   19d4d:	85 c0                	test   %eax,%eax
   19d4f:	74 1b                	je     19d6c <reset_hd+0x37>
		reset = 0;
   19d51:	c7 83 54 42 00 00 00 	movl   $0x0,0x4254(%ebx)
   19d58:	00 00 00 
		i = -1;											// 初始化当前硬盘号(静态变量).
   19d5b:	c7 83 e8 42 00 00 ff 	movl   $0xffffffff,0x42e8(%ebx)
   19d62:	ff ff ff 
		reset_controller();
   19d65:	e8 32 ff ff ff       	call   19c9c <reset_controller>
   19d6a:	eb 1a                	jmp    19d86 <reset_hd+0x51>
	} else if (win_result()) {
   19d6c:	e8 3c fd ff ff       	call   19aad <win_result>
   19d71:	85 c0                	test   %eax,%eax
   19d73:	74 11                	je     19d86 <reset_hd+0x51>
		bad_rw_intr();
   19d75:	e8 08 01 00 00       	call   19e82 <bad_rw_intr>
		if (reset)
   19d7a:	8b 83 54 42 00 00    	mov    0x4254(%ebx),%eax
   19d80:	85 c0                	test   %eax,%eax
   19d82:	74 02                	je     19d86 <reset_hd+0x51>
			goto repeat;
   19d84:	eb c1                	jmp    19d47 <reset_hd+0x12>
	}
	i++;												// 处理下一个硬盘(第1个是0).
   19d86:	8b 83 e8 42 00 00    	mov    0x42e8(%ebx),%eax
   19d8c:	83 c0 01             	add    $0x1,%eax
   19d8f:	89 83 e8 42 00 00    	mov    %eax,0x42e8(%ebx)
	if (i < NR_HD) {
   19d95:	8b 93 e8 42 00 00    	mov    0x42e8(%ebx),%edx
   19d9b:	8b 83 58 42 00 00    	mov    0x4258(%ebx),%eax
   19da1:	39 c2                	cmp    %eax,%edx
   19da3:	0f 8d 95 00 00 00    	jge    19e3e <reset_hd+0x109>
		hd_out(i, hd_info[i].sect, hd_info[i].sect,hd_info[i].head - 1,
			hd_info[i].cyl, WIN_SPECIFY, &reset_hd);
   19da9:	8b 93 e8 42 00 00    	mov    0x42e8(%ebx),%edx
   19daf:	8d 8b 28 42 00 00    	lea    0x4228(%ebx),%ecx
   19db5:	89 d0                	mov    %edx,%eax
   19db7:	01 c0                	add    %eax,%eax
   19db9:	01 d0                	add    %edx,%eax
   19dbb:	c1 e0 03             	shl    $0x3,%eax
   19dbe:	01 c8                	add    %ecx,%eax
   19dc0:	8b 00                	mov    (%eax),%eax
		hd_out(i, hd_info[i].sect, hd_info[i].sect,hd_info[i].head - 1,
   19dc2:	89 c5                	mov    %eax,%ebp
   19dc4:	8b 93 e8 42 00 00    	mov    0x42e8(%ebx),%edx
   19dca:	8d 8b 20 42 00 00    	lea    0x4220(%ebx),%ecx
   19dd0:	89 d0                	mov    %edx,%eax
   19dd2:	01 c0                	add    %eax,%eax
   19dd4:	01 d0                	add    %edx,%eax
   19dd6:	c1 e0 03             	shl    $0x3,%eax
   19dd9:	01 c8                	add    %ecx,%eax
   19ddb:	8b 00                	mov    (%eax),%eax
   19ddd:	83 e8 01             	sub    $0x1,%eax
   19de0:	89 c7                	mov    %eax,%edi
   19de2:	8b 93 e8 42 00 00    	mov    0x42e8(%ebx),%edx
   19de8:	8d 8b 24 42 00 00    	lea    0x4224(%ebx),%ecx
   19dee:	89 d0                	mov    %edx,%eax
   19df0:	01 c0                	add    %eax,%eax
   19df2:	01 d0                	add    %edx,%eax
   19df4:	c1 e0 03             	shl    $0x3,%eax
   19df7:	01 c8                	add    %ecx,%eax
   19df9:	8b 00                	mov    (%eax),%eax
   19dfb:	89 c6                	mov    %eax,%esi
   19dfd:	8b 93 e8 42 00 00    	mov    0x42e8(%ebx),%edx
   19e03:	8d 8b 24 42 00 00    	lea    0x4224(%ebx),%ecx
   19e09:	89 d0                	mov    %edx,%eax
   19e0b:	01 c0                	add    %eax,%eax
   19e0d:	01 d0                	add    %edx,%eax
   19e0f:	c1 e0 03             	shl    $0x3,%eax
   19e12:	01 c8                	add    %ecx,%eax
   19e14:	8b 00                	mov    (%eax),%eax
   19e16:	89 c1                	mov    %eax,%ecx
   19e18:	8b 83 e8 42 00 00    	mov    0x42e8(%ebx),%eax
   19e1e:	89 c2                	mov    %eax,%edx
   19e20:	83 ec 04             	sub    $0x4,%esp
   19e23:	8d 83 35 7d fe ff    	lea    -0x182cb(%ebx),%eax
   19e29:	50                   	push   %eax
   19e2a:	68 91 00 00 00       	push   $0x91
   19e2f:	55                   	push   %ebp
   19e30:	57                   	push   %edi
   19e31:	56                   	push   %esi
   19e32:	51                   	push   %ecx
   19e33:	52                   	push   %edx
   19e34:	e8 de fc ff ff       	call   19b17 <hd_out>
   19e39:	83 c4 20             	add    $0x20,%esp
	} else
		do_hd_request();								// 执行请求项处理.
}
   19e3c:	eb 05                	jmp    19e43 <reset_hd+0x10e>
		do_hd_request();								// 执行请求项处理.
   19e3e:	e8 c5 02 00 00       	call   1a108 <do_hd_request>
}
   19e43:	90                   	nop
   19e44:	83 c4 0c             	add    $0xc,%esp
   19e47:	5b                   	pop    %ebx
   19e48:	5e                   	pop    %esi
   19e49:	5f                   	pop    %edi
   19e4a:	5d                   	pop    %ebp
   19e4b:	c3                   	ret    

00019e4c <unexpected_hd_interrupt>:

// 意外硬盘中断调用函数
// 发生意外硬盘中断时,硬盘中断处理程序中调用的默认C处理函数.在被调用函数指针为NULL时调用该函数.该函数在显示警告信息后设置复位标志reset,然后继续调用请求项函数
// do_hd_request()并在其中执行复位处理操作.
void unexpected_hd_interrupt(void)
{
   19e4c:	53                   	push   %ebx
   19e4d:	83 ec 08             	sub    $0x8,%esp
   19e50:	e8 a5 ce fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19e55:	81 c3 ab 81 01 00    	add    $0x181ab,%ebx
	printk("Unexpected HD interrupt\n\r");
   19e5b:	83 ec 0c             	sub    $0xc,%esp
   19e5e:	8d 83 6f 58 ff ff    	lea    -0xa791(%ebx),%eax
   19e64:	50                   	push   %eax
   19e65:	e8 c8 f4 fe ff       	call   9332 <printk>
   19e6a:	83 c4 10             	add    $0x10,%esp
	reset = 1;
   19e6d:	c7 83 54 42 00 00 01 	movl   $0x1,0x4254(%ebx)
   19e74:	00 00 00 
	do_hd_request();
   19e77:	e8 8c 02 00 00       	call   1a108 <do_hd_request>
}
   19e7c:	90                   	nop
   19e7d:	83 c4 08             	add    $0x8,%esp
   19e80:	5b                   	pop    %ebx
   19e81:	c3                   	ret    

00019e82 <bad_rw_intr>:

// 读写硬盘失败处理调用函数
// 如果读扇区时的出错次数大于或等于7次时,则结束当前请求项并唤醒等待该请求的进程,而且对应缓冲区更新标志复位,表示数据没有更新.如果读写一扇区时的出错次数已经大于
// 3次,则要求执行复位硬盘控制器操作(设置复位标志).
static void bad_rw_intr(void)
{
   19e82:	53                   	push   %ebx
   19e83:	83 ec 08             	sub    $0x8,%esp
   19e86:	e8 6f ce fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19e8b:	81 c3 75 81 01 00    	add    $0x18175,%ebx
	if (++CURRENT->errors >= MAX_ERRORS)
   19e91:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19e97:	8b 40 1c             	mov    0x1c(%eax),%eax
   19e9a:	8b 50 08             	mov    0x8(%eax),%edx
   19e9d:	83 c2 01             	add    $0x1,%edx
   19ea0:	89 50 08             	mov    %edx,0x8(%eax)
   19ea3:	8b 40 08             	mov    0x8(%eax),%eax
   19ea6:	83 f8 06             	cmp    $0x6,%eax
   19ea9:	7e 0d                	jle    19eb8 <bad_rw_intr+0x36>
		end_request(0);
   19eab:	83 ec 0c             	sub    $0xc,%esp
   19eae:	6a 00                	push   $0x0
   19eb0:	e8 a4 f5 ff ff       	call   19459 <end_request>
   19eb5:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->errors > MAX_ERRORS / 2)
   19eb8:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19ebe:	8b 40 1c             	mov    0x1c(%eax),%eax
   19ec1:	8b 40 08             	mov    0x8(%eax),%eax
   19ec4:	83 f8 03             	cmp    $0x3,%eax
   19ec7:	7e 0a                	jle    19ed3 <bad_rw_intr+0x51>
		reset = 1;
   19ec9:	c7 83 54 42 00 00 01 	movl   $0x1,0x4254(%ebx)
   19ed0:	00 00 00 
}
   19ed3:	90                   	nop
   19ed4:	83 c4 08             	add    $0x8,%esp
   19ed7:	5b                   	pop    %ebx
   19ed8:	c3                   	ret    

00019ed9 <read_intr>:
// 读操作中断调用函数.
// 该函数将在硬盘读命令结束时引发的硬盘中断过程中调用.
// 在读命令执行后会产生硬盘中断信号,并执行硬盘中断处理程序,此时在硬盘中断处理程序调用的C函数指针do_hd已经指向read_intr(),因此会在一次读扇区操作完成(或出错)
// 后就会执行该函数.
static void read_intr(void)
{
   19ed9:	57                   	push   %edi
   19eda:	53                   	push   %ebx
   19edb:	83 ec 04             	sub    $0x4,%esp
   19ede:	e8 17 ce fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19ee3:	81 c3 1d 81 01 00    	add    $0x1811d,%ebx
	// 该函数首先判断此次读命令操作是否出错.若命令结束后控制器还处于忙状态,或者命令执行错误,则处理硬盘操作失败的问题,接着再次请求硬盘作复位处理并执行其他请求项.然后
	// 返回.每次读操作出错都会对当前请求项作出错次数累计,若出错次数不到最大允许出错次数一半,则会先执行硬盘复位操作,然后再执行本次请求项处理.若出错次数已经大于等于
	// 最大允许出错次数MAX_ERRORS(7次),则结束本次请求项的处理而去处理队列中下一个请求项.
	if (win_result()) {									// 若控制器忙,读写错或命令执行错,则进行读写硬盘失败处理.
   19ee9:	e8 bf fb ff ff       	call   19aad <win_result>
   19eee:	85 c0                	test   %eax,%eax
   19ef0:	74 0f                	je     19f01 <read_intr+0x28>
		bad_rw_intr();
   19ef2:	e8 8b ff ff ff       	call   19e82 <bad_rw_intr>
		do_hd_request();								// 再次请求硬盘作相应(复位)处理.
   19ef7:	e8 0c 02 00 00       	call   1a108 <do_hd_request>
		return;
   19efc:	e9 9f 00 00 00       	jmp    19fa0 <read_intr+0xc7>
	}
	// 如果读命令没有出错,则从数据寄存器端口把1扇区的数据读到请求项的缓冲区中,并且递减请求项所需读取的扇区数值.若递减后不等于0,表示本项请求还有数据没取完,于是再次置中断
	// 调用C函数指针do_hd为read_intr()并直接返回,等待硬盘在读出另1个扇区数据后发出中断并再次调用本函数.
	// 注意:281行语句中的256是指内存字,即512字节.
	// 注意:262行再次置do_hd指针指向read_intr()是因为硬盘中断处理程序每次调用do_hd时都会将该函数指针置空.
	port_read(HD_DATA, CURRENT->buffer, 256);			// 读数据到请求结构缓冲区.
   19f01:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19f07:	8b 40 1c             	mov    0x1c(%eax),%eax
   19f0a:	8b 40 14             	mov    0x14(%eax),%eax
   19f0d:	ba f0 01 00 00       	mov    $0x1f0,%edx
   19f12:	b9 00 01 00 00       	mov    $0x100,%ecx
   19f17:	89 c7                	mov    %eax,%edi
   19f19:	fc                   	cld    
   19f1a:	f3 66 6d             	rep insw (%dx),%es:(%edi)
	CURRENT->errors = 0;								// 清出错次数
   19f1d:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19f23:	8b 40 1c             	mov    0x1c(%eax),%eax
   19f26:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	CURRENT->buffer += 512;								// 高速缓冲区指针,指向新的空区.
   19f2d:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19f33:	8b 40 1c             	mov    0x1c(%eax),%eax
   19f36:	8b 50 14             	mov    0x14(%eax),%edx
   19f39:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19f3f:	8b 40 1c             	mov    0x1c(%eax),%eax
   19f42:	81 c2 00 02 00 00    	add    $0x200,%edx
   19f48:	89 50 14             	mov    %edx,0x14(%eax)
	CURRENT->sector++;									// 起始扇区号加1.
   19f4b:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19f51:	8b 40 1c             	mov    0x1c(%eax),%eax
   19f54:	8b 50 0c             	mov    0xc(%eax),%edx
   19f57:	83 c2 01             	add    $0x1,%edx
   19f5a:	89 50 0c             	mov    %edx,0xc(%eax)
	if (--CURRENT->nr_sectors) {						// 如果所需读出的扇区数还没读完,则再置硬盘调用C函数指针为read_intr().
   19f5d:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19f63:	8b 40 1c             	mov    0x1c(%eax),%eax
   19f66:	8b 50 10             	mov    0x10(%eax),%edx
   19f69:	83 ea 01             	sub    $0x1,%edx
   19f6c:	89 50 10             	mov    %edx,0x10(%eax)
   19f6f:	8b 40 10             	mov    0x10(%eax),%eax
   19f72:	85 c0                	test   %eax,%eax
   19f74:	74 18                	je     19f8e <read_intr+0xb5>
		SET_INTR(&read_intr);
   19f76:	8d 83 d9 7e fe ff    	lea    -0x18127(%ebx),%eax
   19f7c:	89 83 00 42 00 00    	mov    %eax,0x4200(%ebx)
   19f82:	c7 83 04 42 00 00 c8 	movl   $0xc8,0x4204(%ebx)
   19f89:	00 00 00 
		return;
   19f8c:	eb 12                	jmp    19fa0 <read_intr+0xc7>
	}
	// 执行到此,说明本次请求项的全部扇区数据已经读完,则调用end_request()函数去处理请求项结束事宜.最后再次调用do_hd_request(),去处理其他硬盘请求项.执行其他硬盘
	// 请求操作.
	end_request(1);										// 数据已更新标志置位(1).
   19f8e:	83 ec 0c             	sub    $0xc,%esp
   19f91:	6a 01                	push   $0x1
   19f93:	e8 c1 f4 ff ff       	call   19459 <end_request>
   19f98:	83 c4 10             	add    $0x10,%esp
	do_hd_request();
   19f9b:	e8 68 01 00 00       	call   1a108 <do_hd_request>
}
   19fa0:	83 c4 04             	add    $0x4,%esp
   19fa3:	5b                   	pop    %ebx
   19fa4:	5f                   	pop    %edi
   19fa5:	c3                   	ret    

00019fa6 <write_intr>:

// 写扇区中断调用函数
// 该函数将在硬盘写命令结束引发的硬盘中断过程中被调用.函数功能与read_intr()类似.在写命令执行后会产生硬盘中断信号,并执行硬盘中断处理程序,此时在硬盘中断处理程序中
// 调用的C函数指针do_hd已经指向write_intr(),因此会在一次写扇区操作完成(或出错)后就会执行该函数.
static void write_intr(void)
{
   19fa6:	56                   	push   %esi
   19fa7:	53                   	push   %ebx
   19fa8:	83 ec 04             	sub    $0x4,%esp
   19fab:	e8 4a cd fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   19fb0:	81 c3 50 80 01 00    	add    $0x18050,%ebx
	// 该函数首先判断此次写命令操作是否出错.若命令结束后控制器还处于忙状态,或者命令执行错误,则处理硬盘操作失败问题,接着再次请求硬盘作复位处理并执行其他请求项.然后返回.
	// 在bad_rw_intr()函数中,每次操作出错都会对当前请求项作出错次数累计,若出错次数不到最大允许出错次数的一半,则会先执行硬盘复位操作,然后再执行本次请求项处理.若出错
	// 次数已经大于等于最大允许出错次数MAX_ERRORS(7次),则结束本次请求项的处理而去处理队列中下一个请求项.do_hd_request()中会根据当时具体的标志状态来判别是否需要先执
	// 行复位,重新校正等操作,然后再继续或处理下一个请求项.
	if (win_result()) {									// 如果硬盘控制器返回错误信息,则首先进行硬盘读写失败处理,再次请求硬盘作相应(复位)处理.
   19fb6:	e8 f2 fa ff ff       	call   19aad <win_result>
   19fbb:	85 c0                	test   %eax,%eax
   19fbd:	74 0f                	je     19fce <write_intr+0x28>
		bad_rw_intr();
   19fbf:	e8 be fe ff ff       	call   19e82 <bad_rw_intr>
		do_hd_request();
   19fc4:	e8 3f 01 00 00       	call   1a108 <do_hd_request>
		return;
   19fc9:	e9 8f 00 00 00       	jmp    1a05d <write_intr+0xb7>
	}
	// 此时说明本次写一扇区操作成功,因为将欲写扇区数减1.若其不为0,则说明还有扇区要写,于是把当前请求起始扇区号+1,并调整请求项数据缓冲区指针指向下一块欲写的数据.然后再重置
	// 硬盘中断处理程序中调用的C函数指针do_hd(指向本函数).接着向控制器数据端口写入512字节数据,然后函数返回去等待控制器把些数据写入硬盘后产生的中断.
	if (--CURRENT->nr_sectors) {						// 若还有扇区要写,则
   19fce:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19fd4:	8b 40 1c             	mov    0x1c(%eax),%eax
   19fd7:	8b 50 10             	mov    0x10(%eax),%edx
   19fda:	83 ea 01             	sub    $0x1,%edx
   19fdd:	89 50 10             	mov    %edx,0x10(%eax)
   19fe0:	8b 40 10             	mov    0x10(%eax),%eax
   19fe3:	85 c0                	test   %eax,%eax
   19fe5:	74 64                	je     1a04b <write_intr+0xa5>
		CURRENT->sector++;								// 当前请求起始扇区号+1,
   19fe7:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19fed:	8b 40 1c             	mov    0x1c(%eax),%eax
   19ff0:	8b 50 0c             	mov    0xc(%eax),%edx
   19ff3:	83 c2 01             	add    $0x1,%edx
   19ff6:	89 50 0c             	mov    %edx,0xc(%eax)
		CURRENT->buffer += 512;							// 调整请求缓冲区指针,
   19ff9:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   19fff:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a002:	8b 50 14             	mov    0x14(%eax),%edx
   1a005:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a00b:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a00e:	81 c2 00 02 00 00    	add    $0x200,%edx
   1a014:	89 50 14             	mov    %edx,0x14(%eax)
		SET_INTR(&write_intr);							// do_hd置函数指针为write_intr().
   1a017:	8d 83 a6 7f fe ff    	lea    -0x1805a(%ebx),%eax
   1a01d:	89 83 00 42 00 00    	mov    %eax,0x4200(%ebx)
   1a023:	c7 83 04 42 00 00 c8 	movl   $0xc8,0x4204(%ebx)
   1a02a:	00 00 00 
		port_write(HD_DATA, CURRENT->buffer, 256);		// 向数据端口写256字.
   1a02d:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a033:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a036:	8b 40 14             	mov    0x14(%eax),%eax
   1a039:	ba f0 01 00 00       	mov    $0x1f0,%edx
   1a03e:	b9 00 01 00 00       	mov    $0x100,%ecx
   1a043:	89 c6                	mov    %eax,%esi
   1a045:	fc                   	cld    
   1a046:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
		return;
   1a049:	eb 12                	jmp    1a05d <write_intr+0xb7>
	}
	// 若本次请求项的全部扇区数据已经写完,则调用end_request()函数去处理请求项结束事宜.最后再次调用do_hd_requrest(),去处理其他硬盘请求项.执行其他硬盘请求操作.
	end_request(1);										// 处理请求结束事宜(已设置更新标志).
   1a04b:	83 ec 0c             	sub    $0xc,%esp
   1a04e:	6a 01                	push   $0x1
   1a050:	e8 04 f4 ff ff       	call   19459 <end_request>
   1a055:	83 c4 10             	add    $0x10,%esp
	do_hd_request();									// 执行其他硬盘请求操作.
   1a058:	e8 ab 00 00 00       	call   1a108 <do_hd_request>
}
   1a05d:	83 c4 04             	add    $0x4,%esp
   1a060:	5b                   	pop    %ebx
   1a061:	5e                   	pop    %esi
   1a062:	c3                   	ret    

0001a063 <recal_intr>:
// 该函数会在硬盘执行重新校正操作而引发的硬盘中断中被调用.
// 如果硬盘控制器返回错误信息,则函数首先进行硬盘读写失败处理,然后请求硬盘作相应(复位)处理.在bad_rw_intr()函数中,每次操作出错都会对当前请求项作出错次数累计,若出错次数
// 不到最大允许出错次数一半,则会先执行硬盘复位操作,然后再执行本次请求项处理.若出错次数已经大于等于最大允许出错次数MAX_ERRORS(7次),则结束本次请求项的处理而去处理队列中
// 下一个请求项.do_hd_request()中根据当时具体的标志状态来判别是否需要先执行复位,重新校正等操作,然后再继续或处理下一请求项.
static void recal_intr(void)
{
   1a063:	83 ec 0c             	sub    $0xc,%esp
   1a066:	e8 87 cc fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1a06b:	05 95 7f 01 00       	add    $0x17f95,%eax
	if (win_result())									// 若返回出错,则调用bad_rw_intr().
   1a070:	e8 38 fa ff ff       	call   19aad <win_result>
   1a075:	85 c0                	test   %eax,%eax
   1a077:	74 05                	je     1a07e <recal_intr+0x1b>
		bad_rw_intr();
   1a079:	e8 04 fe ff ff       	call   19e82 <bad_rw_intr>
	do_hd_request();
   1a07e:	e8 85 00 00 00       	call   1a108 <do_hd_request>
}
   1a083:	90                   	nop
   1a084:	83 c4 0c             	add    $0xc,%esp
   1a087:	c3                   	ret    

0001a088 <hd_times_out>:
// 硬盘操作超时处理
// 本函数会在do_timer()中(kernel/sched.c)被调用.在向硬盘控制器发送了一个命令后,若在经过了hd_timeout个系统滴答后控制器还没有发出一个硬盘中断信号,则说明控制器(或
// 硬盘)操作超时.此时do_timer()就会调用本函数设置复位标志reset并调用do_hd_request()执行复位处理.若在预定时间内(200滴答)硬盘控制器发出了硬盘中断并开始执行硬盘中断
// 处理程序,那么hd_timeout值就会在中断处理程序中被置0.此时do_timer()就会跳过本函数.
void hd_times_out(void)
{
   1a088:	53                   	push   %ebx
   1a089:	83 ec 08             	sub    $0x8,%esp
   1a08c:	e8 69 cc fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1a091:	81 c3 6f 7f 01 00    	add    $0x17f6f,%ebx
	// 如果当前并没有请求项要处理(设备请求项指针为NULL),则无超时可言,直接返回.否则先显示警告信息,然后判断当前请求项执行过程中发生的出错次数是否已经大于设定值MAX_ERRORS(7).
	// 如果是则以失败形式结束本次请求项的处理(不设置数据更新标志).然后把中断过程中调用的C函数指针do_hd置空,并设置复位标志reset,继而在请求项处理函数do_hd_request()中去
	// 执行复位操作.
	if (!CURRENT)
   1a097:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a09d:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a0a0:	85 c0                	test   %eax,%eax
   1a0a2:	74 5e                	je     1a102 <hd_times_out+0x7a>
		return;
	printk("HD timeout");
   1a0a4:	83 ec 0c             	sub    $0xc,%esp
   1a0a7:	8d 83 89 58 ff ff    	lea    -0xa777(%ebx),%eax
   1a0ad:	50                   	push   %eax
   1a0ae:	e8 7f f2 fe ff       	call   9332 <printk>
   1a0b3:	83 c4 10             	add    $0x10,%esp
	if (++CURRENT->errors >= MAX_ERRORS)
   1a0b6:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a0bc:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a0bf:	8b 50 08             	mov    0x8(%eax),%edx
   1a0c2:	83 c2 01             	add    $0x1,%edx
   1a0c5:	89 50 08             	mov    %edx,0x8(%eax)
   1a0c8:	8b 40 08             	mov    0x8(%eax),%eax
   1a0cb:	83 f8 06             	cmp    $0x6,%eax
   1a0ce:	7e 0d                	jle    1a0dd <hd_times_out+0x55>
		end_request(0);
   1a0d0:	83 ec 0c             	sub    $0xc,%esp
   1a0d3:	6a 00                	push   $0x0
   1a0d5:	e8 7f f3 ff ff       	call   19459 <end_request>
   1a0da:	83 c4 10             	add    $0x10,%esp
	SET_INTR(NULL);										// 令do_hd = NULL,time_out=200
   1a0dd:	c7 83 00 42 00 00 00 	movl   $0x0,0x4200(%ebx)
   1a0e4:	00 00 00 
   1a0e7:	c7 83 04 42 00 00 c8 	movl   $0xc8,0x4204(%ebx)
   1a0ee:	00 00 00 
	reset = 1;											// 设置复位标志.
   1a0f1:	c7 83 54 42 00 00 01 	movl   $0x1,0x4254(%ebx)
   1a0f8:	00 00 00 
	do_hd_request();
   1a0fb:	e8 08 00 00 00       	call   1a108 <do_hd_request>
   1a100:	eb 01                	jmp    1a103 <hd_times_out+0x7b>
		return;
   1a102:	90                   	nop
}
   1a103:	83 c4 08             	add    $0x8,%esp
   1a106:	5b                   	pop    %ebx
   1a107:	c3                   	ret    

0001a108 <do_hd_request>:
// 该函数根据设备当前请求项中的设备号和起始扇区号信息首先计算到对应硬盘上的柱面号,当前磁道中扇区号,磁头号数据,然后再根据请求项中的命令(READ/WRITE)对硬盘发送相应读/写命令
// 若控制器复位标志或硬盘重新校正已被置位,那么首先会执行复位或重新校正操作.
// 若请求项此时是块设备的第1个(原来设备空闲),则块设备当前请求项指针会直接指向该请求项(参见ll_rw_blk.c),并会立刻调用本函数执行读写操作.否则在一个读写操作完成而引发的硬盘
// 中断过程,若还有请求项需要处理,则也会在硬盘中断过程中调用本函数
void do_hd_request(void)
{
   1a108:	56                   	push   %esi
   1a109:	53                   	push   %ebx
   1a10a:	83 ec 34             	sub    $0x34,%esp
   1a10d:	e8 e8 cb fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1a112:	81 c3 ee 7e 01 00    	add    $0x17eee,%ebx

	// 函数首先检测请求项的合法性.若请求队列中已没有请求项则退出(参见blk.h)
	// 然后取设备号中的子设备号以及设备当前请求项中的起始扇区号.子设备号即对应硬盘上各分区.如果子设备号不存在或者起始扇区大于该分区扇区数-2,则结束该请求项,并跳转到标号repeat处(定义
	// 在INIT_REQUEST开始处).因为次要求读写一块数据(2个扇区,即1024字节),所以请求的扇区号不能大于分区中最后倒数第二个扇区号.然后通过加上子设备号对应分区的起始扇区号,就把需要读写的
	// 块对应到整个硬盘的绝对扇区号block上.而子设备号被5整除即可得到对应的硬盘号.
	INIT_REQUEST;
   1a118:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a11e:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a121:	85 c0                	test   %eax,%eax
   1a123:	75 19                	jne    1a13e <do_hd_request+0x36>
   1a125:	c7 83 00 42 00 00 00 	movl   $0x0,0x4200(%ebx)
   1a12c:	00 00 00 
   1a12f:	c7 83 04 42 00 00 00 	movl   $0x0,0x4204(%ebx)
   1a136:	00 00 00 
   1a139:	e9 c8 02 00 00       	jmp    1a406 <do_hd_request+0x2fe>
   1a13e:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a144:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a147:	8b 00                	mov    (%eax),%eax
   1a149:	c1 e8 08             	shr    $0x8,%eax
   1a14c:	83 f8 03             	cmp    $0x3,%eax
   1a14f:	74 12                	je     1a163 <do_hd_request+0x5b>
   1a151:	83 ec 0c             	sub    $0xc,%esp
   1a154:	8d 83 94 58 ff ff    	lea    -0xa76c(%ebx),%eax
   1a15a:	50                   	push   %eax
   1a15b:	e8 7e f1 fe ff       	call   92de <panic>
   1a160:	83 c4 10             	add    $0x10,%esp
   1a163:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a169:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a16c:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a16f:	85 c0                	test   %eax,%eax
   1a171:	74 26                	je     1a199 <do_hd_request+0x91>
   1a173:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a179:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a17c:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a17f:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1a183:	84 c0                	test   %al,%al
   1a185:	75 12                	jne    1a199 <do_hd_request+0x91>
   1a187:	83 ec 0c             	sub    $0xc,%esp
   1a18a:	8d 83 b5 58 ff ff    	lea    -0xa74b(%ebx),%eax
   1a190:	50                   	push   %eax
   1a191:	e8 48 f1 fe ff       	call   92de <panic>
   1a196:	83 c4 10             	add    $0x10,%esp
 	dev = MINOR(CURRENT->dev);
   1a199:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a19f:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a1a2:	8b 00                	mov    (%eax),%eax
   1a1a4:	25 ff 00 00 00       	and    $0xff,%eax
   1a1a9:	89 44 24 24          	mov    %eax,0x24(%esp)
	block = CURRENT->sector;						// 请求的起始扇区.
   1a1ad:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a1b3:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a1b6:	8b 40 0c             	mov    0xc(%eax),%eax
   1a1b9:	89 44 24 20          	mov    %eax,0x20(%esp)
	if (dev >= 5 * NR_HD || block + 2 > hd[dev].nr_sects) {
   1a1bd:	8b 93 58 42 00 00    	mov    0x4258(%ebx),%edx
   1a1c3:	89 d0                	mov    %edx,%eax
   1a1c5:	c1 e0 02             	shl    $0x2,%eax
   1a1c8:	01 d0                	add    %edx,%eax
   1a1ca:	39 44 24 24          	cmp    %eax,0x24(%esp)
   1a1ce:	73 16                	jae    1a1e6 <do_hd_request+0xde>
   1a1d0:	8b 44 24 20          	mov    0x20(%esp),%eax
   1a1d4:	8d 50 02             	lea    0x2(%eax),%edx
   1a1d7:	8b 44 24 24          	mov    0x24(%esp),%eax
   1a1db:	8b 84 c3 64 42 00 00 	mov    0x4264(%ebx,%eax,8),%eax
   1a1e2:	39 c2                	cmp    %eax,%edx
   1a1e4:	76 12                	jbe    1a1f8 <do_hd_request+0xf0>
		end_request(0);
   1a1e6:	83 ec 0c             	sub    $0xc,%esp
   1a1e9:	6a 00                	push   $0x0
   1a1eb:	e8 69 f2 ff ff       	call   19459 <end_request>
   1a1f0:	83 c4 10             	add    $0x10,%esp
		goto repeat;								// 该标号在blk.h最后面.
   1a1f3:	e9 20 ff ff ff       	jmp    1a118 <do_hd_request+0x10>
	}
	block += hd[dev].start_sect;
   1a1f8:	8b 44 24 24          	mov    0x24(%esp),%eax
   1a1fc:	8b 84 c3 60 42 00 00 	mov    0x4260(%ebx,%eax,8),%eax
   1a203:	01 44 24 20          	add    %eax,0x20(%esp)
	dev /= 5;										// 此时dev代表硬盘号(硬盘0还是硬盘1)
   1a207:	8b 44 24 24          	mov    0x24(%esp),%eax
   1a20b:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   1a210:	f7 e2                	mul    %edx
   1a212:	89 d0                	mov    %edx,%eax
   1a214:	c1 e8 02             	shr    $0x2,%eax
   1a217:	89 44 24 24          	mov    %eax,0x24(%esp)
	// 数和硬盘磁头数来计算这些数据.计算方法为:初始时eax是扇区号block,edx中置0.divl指令把edx:eax组成的扇区号除以每磁道扇区数(hd_info[dev].sect),所得整数商值在eax中,余数在edx
	// 中.其中eax中是到指定位置的对应总磁道数(所有磁头面),edx中是当前磁道上的扇区号.348-349行代码初始时eax是计算出的对应总磁道数,edx中置0.divl指令把edx:eax的对应总磁道数除以硬盘
	// 总磁头数(hd_info[dev].head),在eax中得到的整除值是柱面号(cyl),edx得到的余数就是对应得当前磁头号(head).
	// 对应总磁道数 * 每磁道扇区数 + 当前磁道上的扇区号 = 绝对扇区号
	__asm__("divl %4":"=a" (block), "=d" (sec):"0" (block), "1" (0),
		"r" (hd_info[dev].sect));
   1a21b:	8b 54 24 24          	mov    0x24(%esp),%edx
   1a21f:	8d 8b 24 42 00 00    	lea    0x4224(%ebx),%ecx
   1a225:	89 d0                	mov    %edx,%eax
   1a227:	01 c0                	add    %eax,%eax
   1a229:	01 d0                	add    %edx,%eax
   1a22b:	c1 e0 03             	shl    $0x3,%eax
   1a22e:	01 c8                	add    %ecx,%eax
   1a230:	8b 08                	mov    (%eax),%ecx
	__asm__("divl %4":"=a" (block), "=d" (sec):"0" (block), "1" (0),
   1a232:	8b 44 24 20          	mov    0x20(%esp),%eax
   1a236:	ba 00 00 00 00       	mov    $0x0,%edx
   1a23b:	f7 f1                	div    %ecx
   1a23d:	89 44 24 20          	mov    %eax,0x20(%esp)
   1a241:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	// 总磁头数 * 柱面号 + 磁头号 = 对应总磁道数
	__asm__("divl %4":"=a" (cyl), "=d" (head):"0" (block), "1" (0),
		"r" (hd_info[dev].head));
   1a245:	8b 54 24 24          	mov    0x24(%esp),%edx
   1a249:	8d 8b 20 42 00 00    	lea    0x4220(%ebx),%ecx
   1a24f:	89 d0                	mov    %edx,%eax
   1a251:	01 c0                	add    %eax,%eax
   1a253:	01 d0                	add    %edx,%eax
   1a255:	c1 e0 03             	shl    $0x3,%eax
   1a258:	01 c8                	add    %ecx,%eax
   1a25a:	8b 08                	mov    (%eax),%ecx
	__asm__("divl %4":"=a" (cyl), "=d" (head):"0" (block), "1" (0),
   1a25c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1a260:	ba 00 00 00 00       	mov    $0x0,%edx
   1a265:	f7 f1                	div    %ecx
   1a267:	89 44 24 18          	mov    %eax,0x18(%esp)
   1a26b:	89 54 24 14          	mov    %edx,0x14(%esp)
	sec++;											// 对计算所得当前磁道扇区号进行调整.
   1a26f:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
	nsect = CURRENT->nr_sectors;					// 预读/写的扇区数.
   1a274:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a27a:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a27d:	8b 40 10             	mov    0x10(%eax),%eax
   1a280:	89 44 24 10          	mov    %eax,0x10(%esp)
	// 此时我们得到了欲读写的硬盘起始扇区block所对应的硬盘上柱面号(cyl),在当前磁道上的扇区号(sec),磁头号(head)以及欲读写的总扇区数(nsect).接着我们可以根据这些信息向硬盘控制器发送I/O
	// 操作信息了.但在发送之前我们还需要先看看是否有复位控制器状态和重新校正硬盘的标志.通常在复位操作之后都需要重新校正硬盘磁头位置.若这些标志已被置位,则说明前面的硬盘操作可能出现了一些问题
	// 或者现在是系统第一次硬盘读写操作等情况.于是我们就需要重新复位硬盘或控制器并重新校正硬盘.
	// 如果此时复位标志reset是置位的,则需要执行复位操作.复位硬盘和控制器,并置硬盘需要重新校正标志,返回.reset_hd()将首先向硬盘控制器发送复位(重新校正)命令,然后发送硬盘控制命令"
	// 建立驱动器参数".
	if (reset) {
   1a284:	8b 83 54 42 00 00    	mov    0x4254(%ebx),%eax
   1a28a:	85 c0                	test   %eax,%eax
   1a28c:	74 14                	je     1a2a2 <do_hd_request+0x19a>
		recalibrate = 1;							// 置需重新校正标志.
   1a28e:	c7 83 50 42 00 00 01 	movl   $0x1,0x4250(%ebx)
   1a295:	00 00 00 
		reset_hd();
   1a298:	e8 98 fa ff ff       	call   19d35 <reset_hd>
		return;
   1a29d:	e9 64 01 00 00       	jmp    1a406 <do_hd_request+0x2fe>
	}
	// 如果此时重新校正标志(recalibrate)是置位的,则首先复位该标志,然后向硬盘控制器发送重新校正命令.该命令会执行寻道操作,让处于任何地方的磁头移动到0柱面.
	if (recalibrate) {
   1a2a2:	8b 83 50 42 00 00    	mov    0x4250(%ebx),%eax
   1a2a8:	85 c0                	test   %eax,%eax
   1a2aa:	74 63                	je     1a30f <do_hd_request+0x207>
		recalibrate = 0;
   1a2ac:	c7 83 50 42 00 00 00 	movl   $0x0,0x4250(%ebx)
   1a2b3:	00 00 00 
		hd_out(dev, hd_info[CURRENT_DEV].sect, 0, 0, 0,
   1a2b6:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a2bc:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a2bf:	8b 00                	mov    (%eax),%eax
   1a2c1:	0f b6 c8             	movzbl %al,%ecx
   1a2c4:	ba 67 66 66 66       	mov    $0x66666667,%edx
   1a2c9:	89 c8                	mov    %ecx,%eax
   1a2cb:	f7 ea                	imul   %edx
   1a2cd:	d1 fa                	sar    %edx
   1a2cf:	89 c8                	mov    %ecx,%eax
   1a2d1:	c1 f8 1f             	sar    $0x1f,%eax
   1a2d4:	29 c2                	sub    %eax,%edx
   1a2d6:	8d 8b 24 42 00 00    	lea    0x4224(%ebx),%ecx
   1a2dc:	89 d0                	mov    %edx,%eax
   1a2de:	01 c0                	add    %eax,%eax
   1a2e0:	01 d0                	add    %edx,%eax
   1a2e2:	c1 e0 03             	shl    $0x3,%eax
   1a2e5:	01 c8                	add    %ecx,%eax
   1a2e7:	8b 00                	mov    (%eax),%eax
   1a2e9:	89 c2                	mov    %eax,%edx
   1a2eb:	83 ec 04             	sub    $0x4,%esp
   1a2ee:	8d 83 63 80 fe ff    	lea    -0x17f9d(%ebx),%eax
   1a2f4:	50                   	push   %eax
   1a2f5:	6a 10                	push   $0x10
   1a2f7:	6a 00                	push   $0x0
   1a2f9:	6a 00                	push   $0x0
   1a2fb:	6a 00                	push   $0x0
   1a2fd:	52                   	push   %edx
   1a2fe:	ff 74 24 40          	pushl  0x40(%esp)
   1a302:	e8 10 f8 ff ff       	call   19b17 <hd_out>
   1a307:	83 c4 20             	add    $0x20,%esp
			WIN_RESTORE, &recal_intr);
		return;
   1a30a:	e9 f7 00 00 00       	jmp    1a406 <do_hd_request+0x2fe>
	}
	// 如果以上两个标志都没有置位,那么我们就可以开始向硬盘控制器发送真正的数据读/写操作命令了.如果当前请求是写扇区操作,则发送命令,循环读取状态寄存器信息并判断请求服务标志DRQ_STAT是否
	// 置位.DRQ_STAT是硬盘状态寄存器的请求服务位表示驱动器已经准备好在主机和数据端口之间传输一个字或一个字节的数据.如果请求服务DRQ置位则退出循环.若等到循环结束也没有置位,则表示发送的
	// 要求写硬盘命令失败,于是跳转去处理出现在问题或继续执行下一个硬盘请求.否则我们可以向硬盘控制器数据寄存器端口HD_DATA写入1个扇区的数据.
	if (CURRENT->cmd == WRITE) {
   1a30f:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a315:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a318:	8b 40 04             	mov    0x4(%eax),%eax
   1a31b:	83 f8 01             	cmp    $0x1,%eax
   1a31e:	0f 85 96 00 00 00    	jne    1a3ba <do_hd_request+0x2b2>
		hd_out(dev, nsect, sec, head, cyl, WIN_WRITE, &write_intr);
   1a324:	83 ec 04             	sub    $0x4,%esp
   1a327:	8d 83 a6 7f fe ff    	lea    -0x1805a(%ebx),%eax
   1a32d:	50                   	push   %eax
   1a32e:	6a 30                	push   $0x30
   1a330:	ff 74 24 24          	pushl  0x24(%esp)
   1a334:	ff 74 24 24          	pushl  0x24(%esp)
   1a338:	ff 74 24 30          	pushl  0x30(%esp)
   1a33c:	ff 74 24 28          	pushl  0x28(%esp)
   1a340:	ff 74 24 40          	pushl  0x40(%esp)
   1a344:	e8 ce f7 ff ff       	call   19b17 <hd_out>
   1a349:	83 c4 20             	add    $0x20,%esp
		for(i = 0 ; i < 10000 && !(r = inb_p(HD_STATUS) & DRQ_STAT) ; i++)
   1a34c:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   1a353:	00 
   1a354:	eb 05                	jmp    1a35b <do_hd_request+0x253>
   1a356:	83 44 24 2c 01       	addl   $0x1,0x2c(%esp)
   1a35b:	81 7c 24 2c 0f 27 00 	cmpl   $0x270f,0x2c(%esp)
   1a362:	00 
   1a363:	7f 26                	jg     1a38b <do_hd_request+0x283>
   1a365:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   1a36a:	89 c2                	mov    %eax,%edx
   1a36c:	ec                   	in     (%dx),%al
   1a36d:	eb 00                	jmp    1a36f <do_hd_request+0x267>
   1a36f:	eb 00                	jmp    1a371 <do_hd_request+0x269>
   1a371:	88 44 24 0f          	mov    %al,0xf(%esp)
   1a375:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1a37a:	0f b6 c0             	movzbl %al,%eax
   1a37d:	83 e0 08             	and    $0x8,%eax
   1a380:	89 44 24 28          	mov    %eax,0x28(%esp)
   1a384:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1a389:	74 cb                	je     1a356 <do_hd_request+0x24e>
			/* nothing */ ;
		if (!r) {
   1a38b:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1a390:	75 0a                	jne    1a39c <do_hd_request+0x294>
			bad_rw_intr();
   1a392:	e8 eb fa ff ff       	call   19e82 <bad_rw_intr>
			goto repeat;							// 该标号在blk.h文件最后面.
   1a397:	e9 7c fd ff ff       	jmp    1a118 <do_hd_request+0x10>
		}
		port_write(HD_DATA, CURRENT->buffer, 256);
   1a39c:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a3a2:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a3a5:	8b 40 14             	mov    0x14(%eax),%eax
   1a3a8:	ba f0 01 00 00       	mov    $0x1f0,%edx
   1a3ad:	b9 00 01 00 00       	mov    $0x100,%ecx
   1a3b2:	89 c6                	mov    %eax,%esi
   1a3b4:	fc                   	cld    
   1a3b5:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
   1a3b8:	eb 4c                	jmp    1a406 <do_hd_request+0x2fe>
	// 如果当前请求是读硬盘数据,则向硬盘控制器发送读扇区命令.若命令无效则停机.
	} else if (CURRENT->cmd == READ) {
   1a3ba:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a3c0:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a3c3:	8b 40 04             	mov    0x4(%eax),%eax
   1a3c6:	85 c0                	test   %eax,%eax
   1a3c8:	75 2a                	jne    1a3f4 <do_hd_request+0x2ec>
		hd_out(dev, nsect, sec, head, cyl, WIN_READ, &read_intr);
   1a3ca:	83 ec 04             	sub    $0x4,%esp
   1a3cd:	8d 83 d9 7e fe ff    	lea    -0x18127(%ebx),%eax
   1a3d3:	50                   	push   %eax
   1a3d4:	6a 20                	push   $0x20
   1a3d6:	ff 74 24 24          	pushl  0x24(%esp)
   1a3da:	ff 74 24 24          	pushl  0x24(%esp)
   1a3de:	ff 74 24 30          	pushl  0x30(%esp)
   1a3e2:	ff 74 24 28          	pushl  0x28(%esp)
   1a3e6:	ff 74 24 40          	pushl  0x40(%esp)
   1a3ea:	e8 28 f7 ff ff       	call   19b17 <hd_out>
   1a3ef:	83 c4 20             	add    $0x20,%esp
   1a3f2:	eb 12                	jmp    1a406 <do_hd_request+0x2fe>
	} else
		panic("unknown hd-command");
   1a3f4:	83 ec 0c             	sub    $0xc,%esp
   1a3f7:	8d 83 d0 58 ff ff    	lea    -0xa730(%ebx),%eax
   1a3fd:	50                   	push   %eax
   1a3fe:	e8 db ee fe ff       	call   92de <panic>
   1a403:	83 c4 10             	add    $0x10,%esp
}
   1a406:	83 c4 34             	add    $0x34,%esp
   1a409:	5b                   	pop    %ebx
   1a40a:	5e                   	pop    %esi
   1a40b:	c3                   	ret    

0001a40c <hd_init>:
// 设置硬盘中断描述符,并允许硬盘控制器发送中断请求信号.
// 该函数设置硬盘设备的请求项处理函数指针为do_hd_request(),然后设置硬盘中断门描述符.hd_interrup(kernel/sys_call.s)是其中断处理过程地址.硬盘中断号为int 0x2E(46),对应8259A
// 芯片的中断请求信号IRQ13.接着复位接联的主8259A int 2屏蔽位,允许从片发出中断请求信号.再复位硬盘的中断请求屏蔽位(在从片上),允许硬盘控制器发送中断请求信号.中断描述符表IDT内中断门
// 描述符设置宏set_intr_gate()在include/asm/system.h中实现.
void hd_init(void)
{
   1a40c:	53                   	push   %ebx
   1a40d:	83 ec 10             	sub    $0x10,%esp
   1a410:	e8 dd c8 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1a415:	05 eb 7b 01 00       	add    $0x17beb,%eax
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;				// do_hd_request().
   1a41a:	c7 c2 80 61 03 00    	mov    $0x36180,%edx
   1a420:	8d 88 08 81 fe ff    	lea    -0x17ef8(%eax),%ecx
   1a426:	89 4a 18             	mov    %ecx,0x18(%edx)
	set_intr_gate(0x2E, &hd_interrupt);							// 设置中断门中处理函数指针
   1a429:	c7 c2 b8 54 00 00    	mov    $0x54b8,%edx
   1a42f:	8d 8a 70 01 00 00    	lea    0x170(%edx),%ecx
   1a435:	c7 c2 b8 54 00 00    	mov    $0x54b8,%edx
   1a43b:	8d 9a 74 01 00 00    	lea    0x174(%edx),%ebx
   1a441:	c7 c0 c8 7d 00 00    	mov    $0x7dc8,%eax
   1a447:	89 c2                	mov    %eax,%edx
   1a449:	b8 00 00 08 00       	mov    $0x80000,%eax
   1a44e:	66 89 d0             	mov    %dx,%ax
   1a451:	66 ba 00 8e          	mov    $0x8e00,%dx
   1a455:	89 01                	mov    %eax,(%ecx)
   1a457:	89 13                	mov    %edx,(%ebx)
	outb_p(inb_p(0x21) & 0xfb, 0x21);							// 复位接联的主8259A int 2的屏蔽位
   1a459:	b8 21 00 00 00       	mov    $0x21,%eax
   1a45e:	89 c2                	mov    %eax,%edx
   1a460:	ec                   	in     (%dx),%al
   1a461:	eb 00                	jmp    1a463 <hd_init+0x57>
   1a463:	eb 00                	jmp    1a465 <hd_init+0x59>
   1a465:	88 44 24 0f          	mov    %al,0xf(%esp)
   1a469:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1a46e:	0f b6 c0             	movzbl %al,%eax
   1a471:	25 fb 00 00 00       	and    $0xfb,%eax
   1a476:	ba 21 00 00 00       	mov    $0x21,%edx
   1a47b:	ee                   	out    %al,(%dx)
   1a47c:	eb 00                	jmp    1a47e <hd_init+0x72>
   1a47e:	eb 00                	jmp    1a480 <hd_init+0x74>
	outb(inb_p(0xA1) & 0xbf, 0xA1);								// 复位硬盘中断请求屏蔽位(在从片上).
   1a480:	b8 a1 00 00 00       	mov    $0xa1,%eax
   1a485:	89 c2                	mov    %eax,%edx
   1a487:	ec                   	in     (%dx),%al
   1a488:	eb 00                	jmp    1a48a <hd_init+0x7e>
   1a48a:	eb 00                	jmp    1a48c <hd_init+0x80>
   1a48c:	88 44 24 0e          	mov    %al,0xe(%esp)
   1a490:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
   1a495:	0f b6 c0             	movzbl %al,%eax
   1a498:	25 bf 00 00 00       	and    $0xbf,%eax
   1a49d:	ba a1 00 00 00       	mov    $0xa1,%edx
   1a4a2:	ee                   	out    %al,(%dx)
}
   1a4a3:	90                   	nop
   1a4a4:	83 c4 10             	add    $0x10,%esp
   1a4a7:	5b                   	pop    %ebx
   1a4a8:	c3                   	ret    

0001a4a9 <memcpy>:
}

// 内存块复制.从源地址src处开始复制n个字节到目的地址dest处.
// 参数:dest - 复制的目的地址,src - 复制的源地址,n - 复制字节数.
static inline void * memcpy(void * dest, const void * src, int n)
{
   1a4a9:	57                   	push   %edi
   1a4aa:	56                   	push   %esi
   1a4ab:	53                   	push   %ebx
   1a4ac:	e8 41 c8 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1a4b1:	05 4f 7b 01 00       	add    $0x17b4f,%eax
__asm__(
   1a4b6:	8b 44 24 18          	mov    0x18(%esp),%eax
   1a4ba:	8b 54 24 14          	mov    0x14(%esp),%edx
   1a4be:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1a4c2:	89 c1                	mov    %eax,%ecx
   1a4c4:	89 d6                	mov    %edx,%esi
   1a4c6:	89 df                	mov    %ebx,%edi
   1a4c8:	fc                   	cld    
   1a4c9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	"cld\n\t"												// 清方向位
	"rep\n\t"												// 重复执行复制ecx个字节.
	"movsb"													// 从ds:[esi]到es:[edi],esi++,edi++.
	::"c" (n), "S" (src), "D" (dest)
	:);
return dest;												// 返回目的地址.
   1a4cb:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   1a4cf:	5b                   	pop    %ebx
   1a4d0:	5e                   	pop    %esi
   1a4d1:	5f                   	pop    %edi
   1a4d2:	c3                   	ret    

0001a4d3 <unlock_buffer>:
{
   1a4d3:	53                   	push   %ebx
   1a4d4:	83 ec 08             	sub    $0x8,%esp
   1a4d7:	e8 1e c8 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1a4dc:	81 c3 24 7b 01 00    	add    $0x17b24,%ebx
	if (!bh->b_lock)
   1a4e2:	8b 44 24 10          	mov    0x10(%esp),%eax
   1a4e6:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1a4ea:	84 c0                	test   %al,%al
   1a4ec:	75 12                	jne    1a500 <unlock_buffer+0x2d>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   1a4ee:	83 ec 0c             	sub    $0xc,%esp
   1a4f1:	8d 83 e4 58 ff ff    	lea    -0xa71c(%ebx),%eax
   1a4f7:	50                   	push   %eax
   1a4f8:	e8 35 ee fe ff       	call   9332 <printk>
   1a4fd:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   1a500:	8b 44 24 10          	mov    0x10(%esp),%eax
   1a504:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);
   1a508:	8b 44 24 10          	mov    0x10(%esp),%eax
   1a50c:	83 c0 10             	add    $0x10,%eax
   1a50f:	83 ec 0c             	sub    $0xc,%esp
   1a512:	50                   	push   %eax
   1a513:	e8 8f cd fe ff       	call   72a7 <wake_up>
   1a518:	83 c4 10             	add    $0x10,%esp
}
   1a51b:	90                   	nop
   1a51c:	83 c4 08             	add    $0x8,%esp
   1a51f:	5b                   	pop    %ebx
   1a520:	c3                   	ret    

0001a521 <end_request>:
{
   1a521:	53                   	push   %ebx
   1a522:	83 ec 08             	sub    $0x8,%esp
   1a525:	e8 d0 c7 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1a52a:	81 c3 d6 7a 01 00    	add    $0x17ad6,%ebx
	if (CURRENT->bh) {									// CURRENT为当前请求结构项指针
   1a530:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a536:	8b 40 0c             	mov    0xc(%eax),%eax
   1a539:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a53c:	85 c0                	test   %eax,%eax
   1a53e:	74 2b                	je     1a56b <end_request+0x4a>
		CURRENT->bh->b_uptodate = uptodate;				// 置更新标志.
   1a540:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a546:	8b 40 0c             	mov    0xc(%eax),%eax
   1a549:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a54c:	8b 54 24 10          	mov    0x10(%esp),%edx
   1a550:	88 50 0a             	mov    %dl,0xa(%eax)
		unlock_buffer(CURRENT->bh);						// 解锁缓冲区.
   1a553:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a559:	8b 40 0c             	mov    0xc(%eax),%eax
   1a55c:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a55f:	83 ec 0c             	sub    $0xc,%esp
   1a562:	50                   	push   %eax
   1a563:	e8 6b ff ff ff       	call   1a4d3 <unlock_buffer>
   1a568:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {									// 若更新标志为0则显示出错信息.
   1a56b:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1a570:	75 40                	jne    1a5b2 <end_request+0x91>
		printk(DEVICE_NAME " I/O error\n\r");
   1a572:	83 ec 0c             	sub    $0xc,%esp
   1a575:	8d 83 09 59 ff ff    	lea    -0xa6f7(%ebx),%eax
   1a57b:	50                   	push   %eax
   1a57c:	e8 b1 ed fe ff       	call   9332 <printk>
   1a581:	83 c4 10             	add    $0x10,%esp
			CURRENT->bh->b_blocknr);
   1a584:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a58a:	8b 40 0c             	mov    0xc(%eax),%eax
   1a58d:	8b 40 1c             	mov    0x1c(%eax),%eax
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   1a590:	8b 50 04             	mov    0x4(%eax),%edx
   1a593:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a599:	8b 40 0c             	mov    0xc(%eax),%eax
   1a59c:	8b 00                	mov    (%eax),%eax
   1a59e:	83 ec 04             	sub    $0x4,%esp
   1a5a1:	52                   	push   %edx
   1a5a2:	50                   	push   %eax
   1a5a3:	8d 83 1d 59 ff ff    	lea    -0xa6e3(%ebx),%eax
   1a5a9:	50                   	push   %eax
   1a5aa:	e8 83 ed fe ff       	call   9332 <printk>
   1a5af:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);							// 唤醒等待该请求项的进程.
   1a5b2:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a5b8:	8b 40 0c             	mov    0xc(%eax),%eax
   1a5bb:	83 c0 18             	add    $0x18,%eax
   1a5be:	83 ec 0c             	sub    $0xc,%esp
   1a5c1:	50                   	push   %eax
   1a5c2:	e8 e0 cc fe ff       	call   72a7 <wake_up>
   1a5c7:	83 c4 10             	add    $0x10,%esp
	wake_up(&wait_for_request);							// 唤醒等待空闲请求项的进程.
   1a5ca:	83 ec 0c             	sub    $0xc,%esp
   1a5cd:	c7 c0 60 61 03 00    	mov    $0x36160,%eax
   1a5d3:	50                   	push   %eax
   1a5d4:	e8 ce cc fe ff       	call   72a7 <wake_up>
   1a5d9:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;									// 释放该请求项.
   1a5dc:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a5e2:	8b 40 0c             	mov    0xc(%eax),%eax
   1a5e5:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;							// 指向下一请求项.
   1a5eb:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a5f1:	8b 40 0c             	mov    0xc(%eax),%eax
   1a5f4:	8b 50 20             	mov    0x20(%eax),%edx
   1a5f7:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a5fd:	89 50 0c             	mov    %edx,0xc(%eax)
}
   1a600:	90                   	nop
   1a601:	83 c4 08             	add    $0x8,%esp
   1a604:	5b                   	pop    %ebx
   1a605:	c3                   	ret    

0001a606 <do_rd_request>:
// 添加到rd的链表中之后,就会调用该函数对rd当前请求项进行处理.该函数首先计算当前请求项中指定起始扇区对应虚拟盘所处内存
// 的起始位置addr和要求的扇区数对应的字节长度值len,然后根据请求项中的命令进行操作.若是写命令WRITE,就把请求项所指缓
// 冲区中的数据直接复制到内存位置addr处。若是读操作作反之。数据复制完成后即可直接调用end_request()对本次请求项作结束
// 处理。然后跳转到函数开始处再去处理下一个请求项。若已没有请求项则退出。
void do_rd_request(void)
{
   1a606:	53                   	push   %ebx
   1a607:	83 ec 18             	sub    $0x18,%esp
   1a60a:	e8 eb c6 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1a60f:	81 c3 f1 79 01 00    	add    $0x179f1,%ebx
	char	*addr;

	// 首先检测请求项的合法性,若已没有请求项则退出(参见blk.h).然后计算请求项处理的虚拟盘中起始扇区在物理内存中对应的地址
	// addr和占用的内存字节长度值len.下句用于取得请求项中的起始扇区对应的内存起始位置和内存长度.其中sector<<9表示
	// sector * 512,换算成字节值.CURRENT被定义为(blk_dev[MAJOR_NR].current_request).
	INIT_REQUEST;
   1a615:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a61b:	8b 40 0c             	mov    0xc(%eax),%eax
   1a61e:	85 c0                	test   %eax,%eax
   1a620:	0f 84 58 01 00 00    	je     1a77e <do_rd_request+0x178>
   1a626:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a62c:	8b 40 0c             	mov    0xc(%eax),%eax
   1a62f:	8b 00                	mov    (%eax),%eax
   1a631:	c1 e8 08             	shr    $0x8,%eax
   1a634:	83 f8 01             	cmp    $0x1,%eax
   1a637:	74 12                	je     1a64b <do_rd_request+0x45>
   1a639:	83 ec 0c             	sub    $0xc,%esp
   1a63c:	8d 83 34 59 ff ff    	lea    -0xa6cc(%ebx),%eax
   1a642:	50                   	push   %eax
   1a643:	e8 96 ec fe ff       	call   92de <panic>
   1a648:	83 c4 10             	add    $0x10,%esp
   1a64b:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a651:	8b 40 0c             	mov    0xc(%eax),%eax
   1a654:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a657:	85 c0                	test   %eax,%eax
   1a659:	74 26                	je     1a681 <do_rd_request+0x7b>
   1a65b:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a661:	8b 40 0c             	mov    0xc(%eax),%eax
   1a664:	8b 40 1c             	mov    0x1c(%eax),%eax
   1a667:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1a66b:	84 c0                	test   %al,%al
   1a66d:	75 12                	jne    1a681 <do_rd_request+0x7b>
   1a66f:	83 ec 0c             	sub    $0xc,%esp
   1a672:	8d 83 54 59 ff ff    	lea    -0xa6ac(%ebx),%eax
   1a678:	50                   	push   %eax
   1a679:	e8 60 ec fe ff       	call   92de <panic>
   1a67e:	83 c4 10             	add    $0x10,%esp
	addr = rd_start + (CURRENT->sector << 9);
   1a681:	c7 c0 80 68 04 00    	mov    $0x46880,%eax
   1a687:	8b 10                	mov    (%eax),%edx
   1a689:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a68f:	8b 40 0c             	mov    0xc(%eax),%eax
   1a692:	8b 40 0c             	mov    0xc(%eax),%eax
   1a695:	c1 e0 09             	shl    $0x9,%eax
   1a698:	01 d0                	add    %edx,%eax
   1a69a:	89 44 24 0c          	mov    %eax,0xc(%esp)
	len = CURRENT->nr_sectors << 9;
   1a69e:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a6a4:	8b 40 0c             	mov    0xc(%eax),%eax
   1a6a7:	8b 40 10             	mov    0x10(%eax),%eax
   1a6aa:	c1 e0 09             	shl    $0x9,%eax
   1a6ad:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 如果当前请求项中子设备号不为1或者对应内存起始位置大于虚拟盘末尾，则结束该请求项，并跳转到repeat处去处理下一个虚拟
	// 盘请求项。标号repeat定义在宏INIT_REQUEST内，位于宏的开始处，参见blk.h文件。
	if ((MINOR(CURRENT->dev) != 1) || (addr + len > rd_start + rd_length)) {
   1a6b1:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a6b7:	8b 40 0c             	mov    0xc(%eax),%eax
   1a6ba:	8b 00                	mov    (%eax),%eax
   1a6bc:	0f b6 c0             	movzbl %al,%eax
   1a6bf:	83 f8 01             	cmp    $0x1,%eax
   1a6c2:	75 1f                	jne    1a6e3 <do_rd_request+0xdd>
   1a6c4:	8b 54 24 08          	mov    0x8(%esp),%edx
   1a6c8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1a6cc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1a6cf:	c7 c0 80 68 04 00    	mov    $0x46880,%eax
   1a6d5:	8b 00                	mov    (%eax),%eax
   1a6d7:	8b 93 ec 42 00 00    	mov    0x42ec(%ebx),%edx
   1a6dd:	01 d0                	add    %edx,%eax
   1a6df:	39 c1                	cmp    %eax,%ecx
   1a6e1:	76 12                	jbe    1a6f5 <do_rd_request+0xef>
		end_request(0);
   1a6e3:	83 ec 0c             	sub    $0xc,%esp
   1a6e6:	6a 00                	push   $0x0
   1a6e8:	e8 34 fe ff ff       	call   1a521 <end_request>
   1a6ed:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   1a6f0:	e9 20 ff ff ff       	jmp    1a615 <do_rd_request+0xf>
	}
	// 然后进行实际的读写操作。如果是写命令(WRITE)，则将请求项中缓冲区的内容复制到地址addr处，长度为len字节。如果是读命
	// 令(READ)，则将addr开始的内存内容复制到请求项缓冲区中，长度为len字节。否则显示命令不存在，死机。
	if (CURRENT-> cmd == WRITE) {
   1a6f5:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a6fb:	8b 40 0c             	mov    0xc(%eax),%eax
   1a6fe:	8b 40 04             	mov    0x4(%eax),%eax
   1a701:	83 f8 01             	cmp    $0x1,%eax
   1a704:	75 22                	jne    1a728 <do_rd_request+0x122>
		(void ) memcpy(addr,
			      CURRENT->buffer,
   1a706:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a70c:	8b 40 0c             	mov    0xc(%eax),%eax
   1a70f:	8b 40 14             	mov    0x14(%eax),%eax
		(void ) memcpy(addr,
   1a712:	83 ec 04             	sub    $0x4,%esp
   1a715:	ff 74 24 0c          	pushl  0xc(%esp)
   1a719:	50                   	push   %eax
   1a71a:	ff 74 24 18          	pushl  0x18(%esp)
   1a71e:	e8 86 fd ff ff       	call   1a4a9 <memcpy>
   1a723:	83 c4 10             	add    $0x10,%esp
   1a726:	eb 44                	jmp    1a76c <do_rd_request+0x166>
			      len);
	} else if (CURRENT->cmd == READ) {
   1a728:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a72e:	8b 40 0c             	mov    0xc(%eax),%eax
   1a731:	8b 40 04             	mov    0x4(%eax),%eax
   1a734:	85 c0                	test   %eax,%eax
   1a736:	75 22                	jne    1a75a <do_rd_request+0x154>
		(void) memcpy(CURRENT->buffer,
   1a738:	c7 c0 80 61 03 00    	mov    $0x36180,%eax
   1a73e:	8b 40 0c             	mov    0xc(%eax),%eax
   1a741:	8b 40 14             	mov    0x14(%eax),%eax
   1a744:	83 ec 04             	sub    $0x4,%esp
   1a747:	ff 74 24 0c          	pushl  0xc(%esp)
   1a74b:	ff 74 24 14          	pushl  0x14(%esp)
   1a74f:	50                   	push   %eax
   1a750:	e8 54 fd ff ff       	call   1a4a9 <memcpy>
   1a755:	83 c4 10             	add    $0x10,%esp
   1a758:	eb 12                	jmp    1a76c <do_rd_request+0x166>
			      addr,
			      len);
	} else
		panic("unknown ramdisk-command");
   1a75a:	83 ec 0c             	sub    $0xc,%esp
   1a75d:	8d 83 6e 59 ff ff    	lea    -0xa692(%ebx),%eax
   1a763:	50                   	push   %eax
   1a764:	e8 75 eb fe ff       	call   92de <panic>
   1a769:	83 c4 10             	add    $0x10,%esp
	// 然后在请求项成功后处理，置更新标志。并继续处理本设备的下一请求项。
	end_request(1);
   1a76c:	83 ec 0c             	sub    $0xc,%esp
   1a76f:	6a 01                	push   $0x1
   1a771:	e8 ab fd ff ff       	call   1a521 <end_request>
   1a776:	83 c4 10             	add    $0x10,%esp
	goto repeat;
   1a779:	e9 97 fe ff ff       	jmp    1a615 <do_rd_request+0xf>
	INIT_REQUEST;
   1a77e:	90                   	nop
}
   1a77f:	83 c4 18             	add    $0x18,%esp
   1a782:	5b                   	pop    %ebx
   1a783:	c3                   	ret    

0001a784 <rd_init>:
// 该函数首先设置虚拟盘设备的请求项处理函数指针指向do_rd_request(),然后确定虚拟盘在物理内存中的起始地址,占用字节长度
// 值.并对整个虚拟盘区清零.最后返回盘区长度.当linux/Makefile文件中设置过RAMDISK值不为零时,表示系统中会创建RAM虚拟盘
// 设备.在这种情况下的内核初始化过程中,本函数就会被调用(init/main.c).该函数在第2个参数length会被赋值成RAMDISK*1024
// 单位为字节.
long rd_init(long mem_start, int length)
{
   1a784:	83 ec 10             	sub    $0x10,%esp
   1a787:	e8 66 c5 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1a78c:	05 74 78 01 00       	add    $0x17874,%eax
	int	i;
	char	*cp;

	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   1a791:	c7 c2 80 61 03 00    	mov    $0x36180,%edx
   1a797:	8d 88 06 86 fe ff    	lea    -0x179fa(%eax),%ecx
   1a79d:	89 4a 08             	mov    %ecx,0x8(%edx)
	rd_start = (char *) mem_start;
   1a7a0:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   1a7a4:	c7 c2 80 68 04 00    	mov    $0x46880,%edx
   1a7aa:	89 0a                	mov    %ecx,(%edx)
	rd_length = length;
   1a7ac:	8b 54 24 18          	mov    0x18(%esp),%edx
   1a7b0:	89 90 ec 42 00 00    	mov    %edx,0x42ec(%eax)
	cp = rd_start;
   1a7b6:	c7 c0 80 68 04 00    	mov    $0x46880,%eax
   1a7bc:	8b 00                	mov    (%eax),%eax
   1a7be:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 将内存空间清零
	for (i = 0; i < length; i++)
   1a7c2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1a7c9:	00 
   1a7ca:	eb 13                	jmp    1a7df <rd_init+0x5b>
		*cp++ = '\0';
   1a7cc:	8b 44 24 08          	mov    0x8(%esp),%eax
   1a7d0:	8d 50 01             	lea    0x1(%eax),%edx
   1a7d3:	89 54 24 08          	mov    %edx,0x8(%esp)
   1a7d7:	c6 00 00             	movb   $0x0,(%eax)
	for (i = 0; i < length; i++)
   1a7da:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1a7df:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1a7e3:	3b 44 24 18          	cmp    0x18(%esp),%eax
   1a7e7:	7c e3                	jl     1a7cc <rd_init+0x48>
	return(length);
   1a7e9:	8b 44 24 18          	mov    0x18(%esp),%eax
}
   1a7ed:	83 c4 10             	add    $0x10,%esp
   1a7f0:	c3                   	ret    

0001a7f1 <rd_load>:
 */
// 尝试根文件系统加载到虚拟盘中.
// 该函数将在内核设置函数setup()(hd.c)中被调用.另外,1磁盘块 = 1024字节.变量block=256表示根文件系统映像被存储于boot盘第
// 256磁盘块开始处.
void rd_load(void)
{
   1a7f1:	53                   	push   %ebx
   1a7f2:	81 ec 88 00 00 00    	sub    $0x88,%esp
   1a7f8:	e8 fd c4 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1a7fd:	81 c3 03 78 01 00    	add    $0x17803,%ebx
	struct buffer_head *bh;								// 调整缓冲块头指针.
	struct super_block	s;								// 文件超级块结构.
	int		block = 256;								/* Start at block 256 */	/* 开始于256盘块 */
   1a803:	c7 44 24 78 00 01 00 	movl   $0x100,0x78(%esp)
   1a80a:	00 
	int		i = 1;
   1a80b:	c7 44 24 74 01 00 00 	movl   $0x1,0x74(%esp)
   1a812:	00 
	int		nblocks;									// 文件系统盘块总数.
	char		*cp;									/* Move pointer */

	// 首先检查虚拟盘的有效性和完整性.如果ramdisk的长度为零,则退出.否则显示ramdisk的大小以及内存起始位置.如果此时根文件设备不是软盘
	// 设备,则也退出.
	if (!rd_length)
   1a813:	8b 83 ec 42 00 00    	mov    0x42ec(%ebx),%eax
   1a819:	85 c0                	test   %eax,%eax
   1a81b:	0f 84 23 02 00 00    	je     1aa44 <rd_load+0x253>
		return;
	printk("Ram disk: %d bytes, starting at 0x%x, dev = 0x%x \n", rd_length, (int) rd_start, ROOT_DEV);
   1a821:	c7 c0 4c 61 03 00    	mov    $0x3614c,%eax
   1a827:	8b 10                	mov    (%eax),%edx
   1a829:	c7 c0 80 68 04 00    	mov    $0x46880,%eax
   1a82f:	8b 00                	mov    (%eax),%eax
   1a831:	89 c1                	mov    %eax,%ecx
   1a833:	8b 83 ec 42 00 00    	mov    0x42ec(%ebx),%eax
   1a839:	52                   	push   %edx
   1a83a:	51                   	push   %ecx
   1a83b:	50                   	push   %eax
   1a83c:	8d 83 88 59 ff ff    	lea    -0xa678(%ebx),%eax
   1a842:	50                   	push   %eax
   1a843:	e8 ea ea fe ff       	call   9332 <printk>
   1a848:	83 c4 10             	add    $0x10,%esp
	if (MAJOR(ROOT_DEV) != 2)
   1a84b:	c7 c0 4c 61 03 00    	mov    $0x3614c,%eax
   1a851:	8b 00                	mov    (%eax),%eax
   1a853:	c1 e8 08             	shr    $0x8,%eax
   1a856:	83 f8 02             	cmp    $0x2,%eax
   1a859:	0f 85 e8 01 00 00    	jne    1aa47 <rd_load+0x256>
		return;
	// 然后读根文件系统的基本参数.即读软盘块256+1,256和256+2.这里block+1是指磁盘上的超级块.breada()用于读取指定的数据块,并标出还需要读的块,
	// 然后返回含有数据块的缓冲区指针.如果返回NULL,则表示数据块不可读(fs/buffer.c).然后把缓冲区中的磁盘超级块(d_super_block是磁盘超级
	// 块结构)复制到s变量中,并释放缓冲区.接着我们开始对超级块的有效性进行判断.超级块中文件系统魔数不对,则说明加载的数据块不是MINIX文件
	// 系统,于是退出.
	bh = breada(ROOT_DEV, block + 1, block, block + 2, -1);
   1a85f:	8b 44 24 78          	mov    0x78(%esp),%eax
   1a863:	8d 48 02             	lea    0x2(%eax),%ecx
   1a866:	8b 44 24 78          	mov    0x78(%esp),%eax
   1a86a:	8d 50 01             	lea    0x1(%eax),%edx
   1a86d:	c7 c0 4c 61 03 00    	mov    $0x3614c,%eax
   1a873:	8b 00                	mov    (%eax),%eax
   1a875:	83 ec 0c             	sub    $0xc,%esp
   1a878:	6a ff                	push   $0xffffffff
   1a87a:	51                   	push   %ecx
   1a87b:	ff b4 24 8c 00 00 00 	pushl  0x8c(%esp)
   1a882:	52                   	push   %edx
   1a883:	50                   	push   %eax
   1a884:	e8 23 63 ff ff       	call   10bac <breada>
   1a889:	83 c4 20             	add    $0x20,%esp
   1a88c:	89 44 24 7c          	mov    %eax,0x7c(%esp)
	if (!bh) {
   1a890:	83 7c 24 7c 00       	cmpl   $0x0,0x7c(%esp)
   1a895:	75 17                	jne    1a8ae <rd_load+0xbd>
		printk("Disk error while looking for ramdisk!\n");
   1a897:	83 ec 0c             	sub    $0xc,%esp
   1a89a:	8d 83 bc 59 ff ff    	lea    -0xa644(%ebx),%eax
   1a8a0:	50                   	push   %eax
   1a8a1:	e8 8c ea fe ff       	call   9332 <printk>
   1a8a6:	83 c4 10             	add    $0x10,%esp
		return;
   1a8a9:	e9 9d 01 00 00       	jmp    1aa4b <rd_load+0x25a>
	}
	*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);
   1a8ae:	8b 44 24 7c          	mov    0x7c(%esp),%eax
   1a8b2:	8b 10                	mov    (%eax),%edx
   1a8b4:	89 e0                	mov    %esp,%eax
   1a8b6:	8b 0a                	mov    (%edx),%ecx
   1a8b8:	89 08                	mov    %ecx,(%eax)
   1a8ba:	8b 4a 04             	mov    0x4(%edx),%ecx
   1a8bd:	89 48 04             	mov    %ecx,0x4(%eax)
   1a8c0:	8b 4a 08             	mov    0x8(%edx),%ecx
   1a8c3:	89 48 08             	mov    %ecx,0x8(%eax)
   1a8c6:	8b 4a 0c             	mov    0xc(%edx),%ecx
   1a8c9:	89 48 0c             	mov    %ecx,0xc(%eax)
   1a8cc:	8b 52 10             	mov    0x10(%edx),%edx
   1a8cf:	89 50 10             	mov    %edx,0x10(%eax)
	brelse(bh);
   1a8d2:	83 ec 0c             	sub    $0xc,%esp
   1a8d5:	ff b4 24 88 00 00 00 	pushl  0x88(%esp)
   1a8dc:	e8 8a 60 ff ff       	call   1096b <brelse>
   1a8e1:	83 c4 10             	add    $0x10,%esp
	if (s.s_magic != SUPER_MAGIC)
   1a8e4:	0f b7 44 24 10       	movzwl 0x10(%esp),%eax
   1a8e9:	66 3d 7f 13          	cmp    $0x137f,%ax
   1a8ed:	0f 85 57 01 00 00    	jne    1aa4a <rd_load+0x259>
		return;
	// 然后我们试图把整个根文件系统读入在内存虚拟盘区中.对于一个文件系统来说,其超级块结构的s_nzones字段中保存着总逻辑块数(或称为区段数).一个
	// 逻辑块中含有的数据块数则由字段s_log_zone_size指定.因此文件系统中的数据块总数nblocks就等于(逻辑块数 *2^(每区段块数的次方)),即
	// nblocks=(s_nzones * 2^s_log_zone_size).如果遇到文件系统中数据块总数大于内存虚拟盘所能容纳的块数的情况,则不能执行加载操作,而只能显示
	// 出错信息并返回.
	nblocks = s.s_nzones << s.s_log_zone_size;
   1a8f3:	0f b7 44 24 02       	movzwl 0x2(%esp),%eax
   1a8f8:	0f b7 d0             	movzwl %ax,%edx
   1a8fb:	0f b7 44 24 0a       	movzwl 0xa(%esp),%eax
   1a900:	0f b7 c0             	movzwl %ax,%eax
   1a903:	89 c1                	mov    %eax,%ecx
   1a905:	d3 e2                	shl    %cl,%edx
   1a907:	89 d0                	mov    %edx,%eax
   1a909:	89 44 24 70          	mov    %eax,0x70(%esp)
	if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
   1a90d:	8b 83 ec 42 00 00    	mov    0x42ec(%ebx),%eax
   1a913:	c1 f8 0a             	sar    $0xa,%eax
   1a916:	39 44 24 70          	cmp    %eax,0x70(%esp)
   1a91a:	7e 25                	jle    1a941 <rd_load+0x150>
		printk("Ram disk image too big!  (%d blocks, %d avail)\n",
   1a91c:	8b 83 ec 42 00 00    	mov    0x42ec(%ebx),%eax
   1a922:	c1 f8 0a             	sar    $0xa,%eax
   1a925:	83 ec 04             	sub    $0x4,%esp
   1a928:	50                   	push   %eax
   1a929:	ff 74 24 78          	pushl  0x78(%esp)
   1a92d:	8d 83 e4 59 ff ff    	lea    -0xa61c(%ebx),%eax
   1a933:	50                   	push   %eax
   1a934:	e8 f9 e9 fe ff       	call   9332 <printk>
   1a939:	83 c4 10             	add    $0x10,%esp
			nblocks, rd_length >> BLOCK_SIZE_BITS);
		return;
   1a93c:	e9 0a 01 00 00       	jmp    1aa4b <rd_load+0x25a>
	}
	// 若虚拟盘能容纳得下文件系统总数据块数,则我们显示加载数据信息,并让cp指向内存虚拟盘起始处,然后开始执行循环操作将磁盘上根文件系统映像加载到
	// 虚拟盘上.在操作过程中,如果一次需要加载的盘块数大于2块,我们就是用超前预读函数breada(),否则就使用bread()函数进行单块读取.若在读盘过程
	// 中出现I/O操作错误,就只能放弃加载过程返回.所读取的磁盘块会使用memcpy()函数从高速缓冲区中复制到内存虚拟盘相应位置处,同时显示已加载的块数.
	// 显示字符串中的八进制数'\010'表示显示一个制表符.
	printk("Loading %d bytes into ram disk... (0k)",
   1a941:	8b 44 24 70          	mov    0x70(%esp),%eax
   1a945:	c1 e0 0a             	shl    $0xa,%eax
   1a948:	83 ec 08             	sub    $0x8,%esp
   1a94b:	50                   	push   %eax
   1a94c:	8d 83 14 5a ff ff    	lea    -0xa5ec(%ebx),%eax
   1a952:	50                   	push   %eax
   1a953:	e8 da e9 fe ff       	call   9332 <printk>
   1a958:	83 c4 10             	add    $0x10,%esp
		nblocks << BLOCK_SIZE_BITS);
	cp = rd_start;
   1a95b:	c7 c0 80 68 04 00    	mov    $0x46880,%eax
   1a961:	8b 00                	mov    (%eax),%eax
   1a963:	89 44 24 6c          	mov    %eax,0x6c(%esp)
	while (nblocks) {
   1a967:	e9 bf 00 00 00       	jmp    1aa2b <rd_load+0x23a>
		if (nblocks > 2)  								// 若读取块数多于2块则采用超前预读.
   1a96c:	83 7c 24 70 02       	cmpl   $0x2,0x70(%esp)
   1a971:	7e 33                	jle    1a9a6 <rd_load+0x1b5>
			bh = breada(ROOT_DEV, block, block + 1, block + 2, -1);
   1a973:	8b 44 24 78          	mov    0x78(%esp),%eax
   1a977:	8d 48 02             	lea    0x2(%eax),%ecx
   1a97a:	8b 44 24 78          	mov    0x78(%esp),%eax
   1a97e:	8d 50 01             	lea    0x1(%eax),%edx
   1a981:	c7 c0 4c 61 03 00    	mov    $0x3614c,%eax
   1a987:	8b 00                	mov    (%eax),%eax
   1a989:	83 ec 0c             	sub    $0xc,%esp
   1a98c:	6a ff                	push   $0xffffffff
   1a98e:	51                   	push   %ecx
   1a98f:	52                   	push   %edx
   1a990:	ff b4 24 90 00 00 00 	pushl  0x90(%esp)
   1a997:	50                   	push   %eax
   1a998:	e8 0f 62 ff ff       	call   10bac <breada>
   1a99d:	83 c4 20             	add    $0x20,%esp
   1a9a0:	89 44 24 7c          	mov    %eax,0x7c(%esp)
   1a9a4:	eb 1f                	jmp    1a9c5 <rd_load+0x1d4>
		else											// 否则就单块读取.
			bh = bread(ROOT_DEV, block);
   1a9a6:	c7 c0 4c 61 03 00    	mov    $0x3614c,%eax
   1a9ac:	8b 00                	mov    (%eax),%eax
   1a9ae:	83 ec 08             	sub    $0x8,%esp
   1a9b1:	ff b4 24 80 00 00 00 	pushl  0x80(%esp)
   1a9b8:	50                   	push   %eax
   1a9b9:	e8 14 60 ff ff       	call   109d2 <bread>
   1a9be:	83 c4 10             	add    $0x10,%esp
   1a9c1:	89 44 24 7c          	mov    %eax,0x7c(%esp)
		if (!bh) {
   1a9c5:	83 7c 24 7c 00       	cmpl   $0x0,0x7c(%esp)
   1a9ca:	75 1b                	jne    1a9e7 <rd_load+0x1f6>
			printk("I/O error on block %d, aborting load\n",
   1a9cc:	83 ec 08             	sub    $0x8,%esp
   1a9cf:	ff b4 24 80 00 00 00 	pushl  0x80(%esp)
   1a9d6:	8d 83 3c 5a ff ff    	lea    -0xa5c4(%ebx),%eax
   1a9dc:	50                   	push   %eax
   1a9dd:	e8 50 e9 fe ff       	call   9332 <printk>
   1a9e2:	83 c4 10             	add    $0x10,%esp
				block);
			return;
   1a9e5:	eb 64                	jmp    1aa4b <rd_load+0x25a>
		}
		(void) memcpy(cp, bh->b_data, BLOCK_SIZE);		// 复制到cp处.
   1a9e7:	8b 44 24 7c          	mov    0x7c(%esp),%eax
   1a9eb:	8b 00                	mov    (%eax),%eax
   1a9ed:	83 ec 04             	sub    $0x4,%esp
   1a9f0:	68 00 04 00 00       	push   $0x400
   1a9f5:	50                   	push   %eax
   1a9f6:	ff 74 24 78          	pushl  0x78(%esp)
   1a9fa:	e8 aa fa ff ff       	call   1a4a9 <memcpy>
   1a9ff:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   1aa02:	83 ec 0c             	sub    $0xc,%esp
   1aa05:	ff b4 24 88 00 00 00 	pushl  0x88(%esp)
   1aa0c:	e8 5a 5f ff ff       	call   1096b <brelse>
   1aa11:	83 c4 10             	add    $0x10,%esp
		cp += BLOCK_SIZE;								// 虚拟盘指针前移.
   1aa14:	81 44 24 6c 00 04 00 	addl   $0x400,0x6c(%esp)
   1aa1b:	00 
		block++;
   1aa1c:	83 44 24 78 01       	addl   $0x1,0x78(%esp)
		nblocks--;
   1aa21:	83 6c 24 70 01       	subl   $0x1,0x70(%esp)
		i++;
   1aa26:	83 44 24 74 01       	addl   $0x1,0x74(%esp)
	while (nblocks) {
   1aa2b:	83 7c 24 70 00       	cmpl   $0x0,0x70(%esp)
   1aa30:	0f 85 36 ff ff ff    	jne    1a96c <rd_load+0x17b>
	}
	// 当boot盘中从256盘块开始的整个文件系统加载完毕后,我们显示"done",并把目前根文件设备号修改成虚拟盘的设备号0x0101, 返回.
	ROOT_DEV = 0x0101;
   1aa36:	c7 c0 4c 61 03 00    	mov    $0x3614c,%eax
   1aa3c:	c7 00 01 01 00 00    	movl   $0x101,(%eax)
   1aa42:	eb 07                	jmp    1aa4b <rd_load+0x25a>
		return;
   1aa44:	90                   	nop
   1aa45:	eb 04                	jmp    1aa4b <rd_load+0x25a>
		return;
   1aa47:	90                   	nop
   1aa48:	eb 01                	jmp    1aa4b <rd_load+0x25a>
		return;
   1aa4a:	90                   	nop
}
   1aa4b:	81 c4 88 00 00 00    	add    $0x88,%esp
   1aa51:	5b                   	pop    %ebx
   1aa52:	c3                   	ret    

0001aa53 <get_fs_byte>:
//// 读取fs段中指定地址处的字节.
// 参数:addr - 指定的内存地址.
// %0 - (返回的字节_v);%1 - (内存地址addr)
// 返回:返回内存fs[addr]处的字节.
static inline unsigned char get_fs_byte(const char * addr)
{
   1aa53:	53                   	push   %ebx
   1aa54:	e8 99 c2 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1aa59:	05 a7 75 01 00       	add    $0x175a7,%eax
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   1aa5e:	8b 44 24 08          	mov    0x8(%esp),%eax
   1aa62:	64 8a 00             	mov    %fs:(%eax),%al
   1aa65:	89 c3                	mov    %eax,%ebx
	return _v;
   1aa67:	89 d8                	mov    %ebx,%eax
}
   1aa69:	5b                   	pop    %ebx
   1aa6a:	c3                   	ret    

0001aa6b <put_fs_byte>:

//// 将一字节存放在fs段中指定内存地址处.
// 参数:val - 字节值;addr - 内存地址.
// %0 - 寄存器(字节值val);%1 - (内存地址addr).
static inline void put_fs_byte(char val,char *addr)
{
   1aa6b:	83 ec 04             	sub    $0x4,%esp
   1aa6e:	e8 7f c2 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1aa73:	05 8d 75 01 00       	add    $0x1758d,%eax
   1aa78:	8b 44 24 08          	mov    0x8(%esp),%eax
   1aa7c:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   1aa7f:	0f b6 04 24          	movzbl (%esp),%eax
   1aa83:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1aa87:	64 88 02             	mov    %al,%fs:(%edx)
}
   1aa8a:	90                   	nop
   1aa8b:	83 c4 04             	add    $0x4,%esp
   1aa8e:	c3                   	ret    

0001aa8f <change_console>:

// 改变前台控制台.
// 将前台控制台设定为指定的虚拟控制台
// 参数:new_console - 指定的新控制台号
void change_console(unsigned int new_console)
{
   1aa8f:	53                   	push   %ebx
   1aa90:	83 ec 08             	sub    $0x8,%esp
   1aa93:	e8 5a c2 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1aa98:	05 68 75 01 00       	add    $0x17568,%eax
	// 如果参数指定的控制台已经在前台或者参数无效,则退出.否则设置当前前台控制台号,同时更新table_list[]中的前台控制台读/写队列结构地址.
	// 最后更新当前前台控制台屏幕.
	if (new_console == fg_console || new_console >= NR_CONSOLES)
   1aa9d:	8b 90 00 43 00 00    	mov    0x4300(%eax),%edx
   1aaa3:	39 54 24 10          	cmp    %edx,0x10(%esp)
   1aaa7:	74 5d                	je     1ab06 <change_console+0x77>
   1aaa9:	c7 c2 a0 3e 04 00    	mov    $0x43ea0,%edx
   1aaaf:	8b 12                	mov    (%edx),%edx
   1aab1:	39 54 24 10          	cmp    %edx,0x10(%esp)
   1aab5:	73 4f                	jae    1ab06 <change_console+0x77>
		return;
	fg_console = new_console;
   1aab7:	8b 54 24 10          	mov    0x10(%esp),%edx
   1aabb:	89 90 00 43 00 00    	mov    %edx,0x4300(%eax)
	table_list[0] = con_queues + 0 + fg_console * 3;
   1aac1:	8b 90 00 43 00 00    	mov    0x4300(%eax),%edx
   1aac7:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1aacd:	89 d1                	mov    %edx,%ecx
   1aacf:	8d 90 20 43 00 00    	lea    0x4320(%eax),%edx
   1aad5:	01 ca                	add    %ecx,%edx
   1aad7:	89 90 a8 15 00 00    	mov    %edx,0x15a8(%eax)
	table_list[1] = con_queues + 1 + fg_console * 3;
   1aadd:	8b 90 00 43 00 00    	mov    0x4300(%eax),%edx
   1aae3:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1aae9:	8d 8a 10 04 00 00    	lea    0x410(%edx),%ecx
   1aaef:	8d 90 20 43 00 00    	lea    0x4320(%eax),%edx
   1aaf5:	01 ca                	add    %ecx,%edx
   1aaf7:	89 90 ac 15 00 00    	mov    %edx,0x15ac(%eax)
	update_screen();
   1aafd:	89 c3                	mov    %eax,%ebx
   1aaff:	e8 48 54 00 00       	call   1ff4c <update_screen>
   1ab04:	eb 01                	jmp    1ab07 <change_console+0x78>
		return;
   1ab06:	90                   	nop
}
   1ab07:	83 c4 08             	add    $0x8,%esp
   1ab0a:	5b                   	pop    %ebx
   1ab0b:	c3                   	ret    

0001ab0c <sleep_if_empty>:
// 如果队列缓冲区空则让进程进入可中断睡眠状态.
// 参数:queue - 指定队列的指针.
// 进程在取队列缓冲区中字符之前需要调用此函数加以验证.如果当前进程没有信号要处理,并且指定的队列缓冲区空,则让进程进入可中断睡眠状态,并
// 让队列的进程等待指针指向该进程.
static void sleep_if_empty(struct tty_queue * queue)
{
   1ab0c:	53                   	push   %ebx
   1ab0d:	83 ec 08             	sub    $0x8,%esp
   1ab10:	e8 e5 c1 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1ab15:	81 c3 eb 74 01 00    	add    $0x174eb,%ebx
	cli();
   1ab1b:	fa                   	cli    
	while (!(current->signal & ~current->blocked) && EMPTY(queue))
   1ab1c:	eb 13                	jmp    1ab31 <sleep_if_empty+0x25>
		interruptible_sleep_on(&queue->proc_list);
   1ab1e:	8b 44 24 10          	mov    0x10(%esp),%eax
   1ab22:	83 c0 0c             	add    $0xc,%eax
   1ab25:	83 ec 0c             	sub    $0xc,%esp
   1ab28:	50                   	push   %eax
   1ab29:	e8 33 c7 fe ff       	call   7261 <interruptible_sleep_on>
   1ab2e:	83 c4 10             	add    $0x10,%esp
	while (!(current->signal & ~current->blocked) && EMPTY(queue))
   1ab31:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1ab37:	8b 00                	mov    (%eax),%eax
   1ab39:	8b 50 0c             	mov    0xc(%eax),%edx
   1ab3c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1ab42:	8b 00                	mov    (%eax),%eax
   1ab44:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   1ab4a:	f7 d0                	not    %eax
   1ab4c:	21 d0                	and    %edx,%eax
   1ab4e:	85 c0                	test   %eax,%eax
   1ab50:	75 12                	jne    1ab64 <sleep_if_empty+0x58>
   1ab52:	8b 44 24 10          	mov    0x10(%esp),%eax
   1ab56:	8b 50 04             	mov    0x4(%eax),%edx
   1ab59:	8b 44 24 10          	mov    0x10(%esp),%eax
   1ab5d:	8b 40 08             	mov    0x8(%eax),%eax
   1ab60:	39 c2                	cmp    %eax,%edx
   1ab62:	74 ba                	je     1ab1e <sleep_if_empty+0x12>
	sti();
   1ab64:	fb                   	sti    
}
   1ab65:	90                   	nop
   1ab66:	83 c4 08             	add    $0x8,%esp
   1ab69:	5b                   	pop    %ebx
   1ab6a:	c3                   	ret    

0001ab6b <sleep_if_full>:

// 若队列缓冲区满则让进程进入可中断的睡眠状态.
// 参数:queue - 指定队列的指针.
// 进程在往队列缓冲区中写入字符之前需要调用此函数判断队列的情况.
static void sleep_if_full(struct tty_queue * queue)
{
   1ab6b:	53                   	push   %ebx
   1ab6c:	83 ec 08             	sub    $0x8,%esp
   1ab6f:	e8 86 c1 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1ab74:	81 c3 8c 74 01 00    	add    $0x1748c,%ebx
	// 如果队列缓冲区不满则返回退出.否则若进程没有信号需要处理,并且队列缓冲区中空闲剩余区长度<128,则让进程进入可中断息状态,并让该队列的进程
	// 等待指针指向该进程.
	if (!FULL(queue))
   1ab7a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1ab7e:	8b 50 08             	mov    0x8(%eax),%edx
   1ab81:	8b 44 24 10          	mov    0x10(%esp),%eax
   1ab85:	8b 40 04             	mov    0x4(%eax),%eax
   1ab88:	29 c2                	sub    %eax,%edx
   1ab8a:	89 d0                	mov    %edx,%eax
   1ab8c:	83 e8 01             	sub    $0x1,%eax
   1ab8f:	25 ff 03 00 00       	and    $0x3ff,%eax
   1ab94:	85 c0                	test   %eax,%eax
   1ab96:	75 59                	jne    1abf1 <sleep_if_full+0x86>
		return;
	cli();
   1ab98:	fa                   	cli    
	while (!(current->signal & ~current->blocked) && LEFT(queue) < 128)
   1ab99:	eb 13                	jmp    1abae <sleep_if_full+0x43>
		interruptible_sleep_on(&queue->proc_list);
   1ab9b:	8b 44 24 10          	mov    0x10(%esp),%eax
   1ab9f:	83 c0 0c             	add    $0xc,%eax
   1aba2:	83 ec 0c             	sub    $0xc,%esp
   1aba5:	50                   	push   %eax
   1aba6:	e8 b6 c6 fe ff       	call   7261 <interruptible_sleep_on>
   1abab:	83 c4 10             	add    $0x10,%esp
	while (!(current->signal & ~current->blocked) && LEFT(queue) < 128)
   1abae:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1abb4:	8b 00                	mov    (%eax),%eax
   1abb6:	8b 50 0c             	mov    0xc(%eax),%edx
   1abb9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1abbf:	8b 00                	mov    (%eax),%eax
   1abc1:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   1abc7:	f7 d0                	not    %eax
   1abc9:	21 d0                	and    %edx,%eax
   1abcb:	85 c0                	test   %eax,%eax
   1abcd:	75 1f                	jne    1abee <sleep_if_full+0x83>
   1abcf:	8b 44 24 10          	mov    0x10(%esp),%eax
   1abd3:	8b 50 08             	mov    0x8(%eax),%edx
   1abd6:	8b 44 24 10          	mov    0x10(%esp),%eax
   1abda:	8b 40 04             	mov    0x4(%eax),%eax
   1abdd:	29 c2                	sub    %eax,%edx
   1abdf:	89 d0                	mov    %edx,%eax
   1abe1:	83 e8 01             	sub    $0x1,%eax
   1abe4:	25 ff 03 00 00       	and    $0x3ff,%eax
   1abe9:	83 f8 7f             	cmp    $0x7f,%eax
   1abec:	76 ad                	jbe    1ab9b <sleep_if_full+0x30>
	sti();
   1abee:	fb                   	sti    
   1abef:	eb 01                	jmp    1abf2 <sleep_if_full+0x87>
		return;
   1abf1:	90                   	nop
}
   1abf2:	83 c4 08             	add    $0x8,%esp
   1abf5:	5b                   	pop    %ebx
   1abf6:	c3                   	ret    

0001abf7 <wait_for_keypress>:

// 等待按键.
// 如果前台控制台读队列缓冲区空,则让进程进入可中断睡眠状态.
void wait_for_keypress(void)
{
   1abf7:	83 ec 0c             	sub    $0xc,%esp
   1abfa:	e8 f3 c0 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1abff:	05 01 74 01 00       	add    $0x17401,%eax
	sleep_if_empty(tty_table[fg_console].secondary);
   1ac04:	8b 90 00 43 00 00    	mov    0x4300(%eax),%edx
   1ac0a:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1ac10:	c1 e2 06             	shl    $0x6,%edx
   1ac13:	01 d0                	add    %edx,%eax
   1ac15:	83 c0 3c             	add    $0x3c,%eax
   1ac18:	8b 00                	mov    (%eax),%eax
   1ac1a:	83 ec 0c             	sub    $0xc,%esp
   1ac1d:	50                   	push   %eax
   1ac1e:	e8 e9 fe ff ff       	call   1ab0c <sleep_if_empty>
   1ac23:	83 c4 10             	add    $0x10,%esp
}
   1ac26:	90                   	nop
   1ac27:	83 c4 0c             	add    $0xc,%esp
   1ac2a:	c3                   	ret    

0001ac2b <copy_to_cooked>:

// 复制成规范模式字符序列
// 根据终端termios结构中设置的各种标志,将指定tty同读队列缓冲区中的字符复制转换成规范模式(熟模式)字符并存放在辅助队列(规范模式队列)中.
// 参数:tty - 指定终端的tty结构指针.
void copy_to_cooked(struct tty_struct * tty)
{
   1ac2b:	53                   	push   %ebx
   1ac2c:	83 ec 18             	sub    $0x18,%esp
   1ac2f:	e8 c6 c0 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1ac34:	81 c3 cc 73 01 00    	add    $0x173cc,%ebx
	signed char c;

	// 首先检查当前终端tty结构中缓冲队列指针是否有效.如果三个队列指针都是NULL,则说明内核tty初始化函数有问题.
	if (!(tty->read_q || tty->write_q || tty->secondary)) {
   1ac3a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac3e:	8b 40 34             	mov    0x34(%eax),%eax
   1ac41:	85 c0                	test   %eax,%eax
   1ac43:	75 2d                	jne    1ac72 <copy_to_cooked+0x47>
   1ac45:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac49:	8b 40 38             	mov    0x38(%eax),%eax
   1ac4c:	85 c0                	test   %eax,%eax
   1ac4e:	75 22                	jne    1ac72 <copy_to_cooked+0x47>
   1ac50:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac54:	8b 40 3c             	mov    0x3c(%eax),%eax
   1ac57:	85 c0                	test   %eax,%eax
   1ac59:	75 17                	jne    1ac72 <copy_to_cooked+0x47>
		printk("copy_to_cooked: missing queues\n\r");
   1ac5b:	83 ec 0c             	sub    $0xc,%esp
   1ac5e:	8d 83 80 5a ff ff    	lea    -0xa580(%ebx),%eax
   1ac64:	50                   	push   %eax
   1ac65:	e8 c8 e6 fe ff       	call   9332 <printk>
   1ac6a:	83 c4 10             	add    $0x10,%esp
		return;
   1ac6d:	e9 42 07 00 00       	jmp    1b3b4 <copy_to_cooked+0x789>
	// 循环体中,如果此时读队列缓冲区已经取空或都辅助队列缓冲区已经放满字符,就退出循环体.否则程序就从读队列缓冲区尾指针处取一字符,并把尾指针前移
	// 一个字符位置.然后根据该字符代码值进行处理.
	// 另外,如果定义了_POSIX_VDISABLE(\0),那么在对字符处理过程中,若字符代码值等于_POSIX_VDISABLE的值时,表示禁止使用相应特殊控制字符的功能.
	while (1) {
		// 如果tty对应的读队列为空则直接立刻中断循环
		if (EMPTY(tty->read_q))
   1ac72:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac76:	8b 40 34             	mov    0x34(%eax),%eax
   1ac79:	8b 50 04             	mov    0x4(%eax),%edx
   1ac7c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac80:	8b 40 34             	mov    0x34(%eax),%eax
   1ac83:	8b 40 08             	mov    0x8(%eax),%eax
   1ac86:	39 c2                	cmp    %eax,%edx
   1ac88:	0f 84 0c 07 00 00    	je     1b39a <copy_to_cooked+0x76f>
			break;
		// 如果tty对应的第三个队列为空则直接立刻中断循环
		if (FULL(tty->secondary))
   1ac8e:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac92:	8b 40 3c             	mov    0x3c(%eax),%eax
   1ac95:	8b 50 08             	mov    0x8(%eax),%edx
   1ac98:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac9c:	8b 40 3c             	mov    0x3c(%eax),%eax
   1ac9f:	8b 40 04             	mov    0x4(%eax),%eax
   1aca2:	29 c2                	sub    %eax,%edx
   1aca4:	89 d0                	mov    %edx,%eax
   1aca6:	83 e8 01             	sub    $0x1,%eax
   1aca9:	25 ff 03 00 00       	and    $0x3ff,%eax
   1acae:	85 c0                	test   %eax,%eax
   1acb0:	0f 84 e7 06 00 00    	je     1b39d <copy_to_cooked+0x772>
			break;
		GETCH(tty->read_q, c);								// 取一字符到c,并前移尾指针
   1acb6:	8b 44 24 20          	mov    0x20(%esp),%eax
   1acba:	8b 50 34             	mov    0x34(%eax),%edx
   1acbd:	8b 44 24 20          	mov    0x20(%esp),%eax
   1acc1:	8b 40 34             	mov    0x34(%eax),%eax
   1acc4:	8b 40 08             	mov    0x8(%eax),%eax
   1acc7:	0f b6 44 02 10       	movzbl 0x10(%edx,%eax,1),%eax
   1accc:	88 44 24 0f          	mov    %al,0xf(%esp)
   1acd0:	8b 44 24 20          	mov    0x20(%esp),%eax
   1acd4:	8b 40 34             	mov    0x34(%eax),%eax
   1acd7:	8b 40 08             	mov    0x8(%eax),%eax
   1acda:	8d 50 01             	lea    0x1(%eax),%edx
   1acdd:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ace1:	8b 40 34             	mov    0x34(%eax),%eax
   1ace4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1acea:	89 50 08             	mov    %edx,0x8(%eax)
		// 如果该字符是回车符CR(13),那么若回车换行转换行CRNL置位,则将字符转换为换行符NL(10).否则如果忽略回车标志NOCR置位,则忽略该字符,继续处理其他字符
		if (c == 13) {
   1aced:	80 7c 24 0f 0d       	cmpb   $0xd,0xf(%esp)
   1acf2:	75 2a                	jne    1ad1e <copy_to_cooked+0xf3>
			if (I_CRNL(tty))
   1acf4:	8b 44 24 20          	mov    0x20(%esp),%eax
   1acf8:	8b 00                	mov    (%eax),%eax
   1acfa:	25 00 01 00 00       	and    $0x100,%eax
   1acff:	85 c0                	test   %eax,%eax
   1ad01:	74 07                	je     1ad0a <copy_to_cooked+0xdf>
				c = 10;
   1ad03:	c6 44 24 0f 0a       	movb   $0xa,0xf(%esp)
   1ad08:	eb 2d                	jmp    1ad37 <copy_to_cooked+0x10c>
			else if (I_NOCR(tty))
   1ad0a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ad0e:	8b 00                	mov    (%eax),%eax
   1ad10:	25 80 00 00 00       	and    $0x80,%eax
   1ad15:	85 c0                	test   %eax,%eax
   1ad17:	74 1e                	je     1ad37 <copy_to_cooked+0x10c>
				continue;
   1ad19:	e9 77 06 00 00       	jmp    1b395 <copy_to_cooked+0x76a>
		// 如果字符是换行符NL(10),换行转回车标志NLCR置位,则将其转换为回车符CR(13).
		} else if (c == 10 && I_NLCR(tty))
   1ad1e:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1ad23:	75 12                	jne    1ad37 <copy_to_cooked+0x10c>
   1ad25:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ad29:	8b 00                	mov    (%eax),%eax
   1ad2b:	83 e0 40             	and    $0x40,%eax
   1ad2e:	85 c0                	test   %eax,%eax
   1ad30:	74 05                	je     1ad37 <copy_to_cooked+0x10c>
			c = 13;
   1ad32:	c6 44 24 0f 0d       	movb   $0xd,0xf(%esp)
		// 如果大写转小写输入标志UCLC置位,则将该字符转换为小写字符.
		if (I_UCLC(tty))
   1ad37:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ad3b:	8b 00                	mov    (%eax),%eax
   1ad3d:	25 00 02 00 00       	and    $0x200,%eax
   1ad42:	85 c0                	test   %eax,%eax
   1ad44:	74 4c                	je     1ad92 <copy_to_cooked+0x167>
			c = tolower(c);
   1ad46:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1ad4c:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
   1ad51:	88 10                	mov    %dl,(%eax)
   1ad53:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1ad59:	0f b6 00             	movzbl (%eax),%eax
   1ad5c:	0f be c0             	movsbl %al,%eax
   1ad5f:	8d 50 01             	lea    0x1(%eax),%edx
   1ad62:	c7 c0 20 36 03 00    	mov    $0x33620,%eax
   1ad68:	01 d0                	add    %edx,%eax
   1ad6a:	0f b6 00             	movzbl (%eax),%eax
   1ad6d:	0f b6 c0             	movzbl %al,%eax
   1ad70:	83 e0 01             	and    $0x1,%eax
   1ad73:	85 c0                	test   %eax,%eax
   1ad75:	74 0e                	je     1ad85 <copy_to_cooked+0x15a>
   1ad77:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1ad7d:	0f b6 00             	movzbl (%eax),%eax
   1ad80:	83 c0 20             	add    $0x20,%eax
   1ad83:	eb 09                	jmp    1ad8e <copy_to_cooked+0x163>
   1ad85:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1ad8b:	0f b6 00             	movzbl (%eax),%eax
   1ad8e:	88 44 24 0f          	mov    %al,0xf(%esp)
		// 字符(^D),则循环执行下列代码:
		// 如果本了回显标志ECHO置位,那么:若字符是控制字符(值 < 32),则往tty写队列放入擦除控制字符ERASE(^H).然后再放入一个擦除字符ERASE,并且调用
		// 该tty写函数,把写队列中的所有字符输出到终端屏幕上.另外,因为控制字符在放入写队列时需要用2个字节表示(例如^V),因此要求特别对控制字符多放入
		// 一个ERASE.最后将tty辅助队列头指针后退1字节.另外,如果了_POSIZ_VDISABLE(\0),那么在对字符修理过程中,若字符代码值等于_POSIX_VDISABLE
		// 的值时,表示禁止使用相应特殊控制字符的功能.
		if (L_CANON(tty)) {
   1ad92:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ad96:	8b 40 0c             	mov    0xc(%eax),%eax
   1ad99:	83 e0 02             	and    $0x2,%eax
   1ad9c:	85 c0                	test   %eax,%eax
   1ad9e:	0f 84 9d 02 00 00    	je     1b041 <copy_to_cooked+0x416>
			if ((KILL_CHAR(tty) != _POSIX_VDISABLE) &&
   1ada4:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ada8:	0f b6 40 14          	movzbl 0x14(%eax),%eax
   1adac:	84 c0                	test   %al,%al
   1adae:	0f 84 43 01 00 00    	je     1aef7 <copy_to_cooked+0x2cc>
			    (c == KILL_CHAR(tty))) {
   1adb4:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1adb9:	8b 44 24 20          	mov    0x20(%esp),%eax
   1adbd:	0f b6 40 14          	movzbl 0x14(%eax),%eax
   1adc1:	0f b6 c0             	movzbl %al,%eax
			if ((KILL_CHAR(tty) != _POSIX_VDISABLE) &&
   1adc4:	39 c2                	cmp    %eax,%edx
   1adc6:	0f 85 2b 01 00 00    	jne    1aef7 <copy_to_cooked+0x2cc>
				/* deal with killing the input line */
				while(!(EMPTY(tty->secondary) ||
   1adcc:	e9 af 00 00 00       	jmp    1ae80 <copy_to_cooked+0x255>
				        (c = LAST(tty->secondary)) == 10 ||
				        ((EOF_CHAR(tty) != _POSIX_VDISABLE) && (c == EOF_CHAR(tty))))) {
					if (L_ECHO(tty)) {						// 若本地回显标志置位
   1add1:	8b 44 24 20          	mov    0x20(%esp),%eax
   1add5:	8b 40 0c             	mov    0xc(%eax),%eax
   1add8:	83 e0 08             	and    $0x8,%eax
   1addb:	85 c0                	test   %eax,%eax
   1addd:	0f 84 80 00 00 00    	je     1ae63 <copy_to_cooked+0x238>
						if (c < 32)							// 控制字符要删2字节
   1ade3:	80 7c 24 0f 1f       	cmpb   $0x1f,0xf(%esp)
   1ade8:	7f 33                	jg     1ae1d <copy_to_cooked+0x1f2>
							PUTCH(127, tty->write_q);
   1adea:	8b 44 24 20          	mov    0x20(%esp),%eax
   1adee:	8b 50 38             	mov    0x38(%eax),%edx
   1adf1:	8b 44 24 20          	mov    0x20(%esp),%eax
   1adf5:	8b 40 38             	mov    0x38(%eax),%eax
   1adf8:	8b 40 04             	mov    0x4(%eax),%eax
   1adfb:	c6 44 02 10 7f       	movb   $0x7f,0x10(%edx,%eax,1)
   1ae00:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae04:	8b 40 38             	mov    0x38(%eax),%eax
   1ae07:	8b 40 04             	mov    0x4(%eax),%eax
   1ae0a:	8d 50 01             	lea    0x1(%eax),%edx
   1ae0d:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae11:	8b 40 38             	mov    0x38(%eax),%eax
   1ae14:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1ae1a:	89 50 04             	mov    %edx,0x4(%eax)
						PUTCH(127, tty->write_q);
   1ae1d:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae21:	8b 50 38             	mov    0x38(%eax),%edx
   1ae24:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae28:	8b 40 38             	mov    0x38(%eax),%eax
   1ae2b:	8b 40 04             	mov    0x4(%eax),%eax
   1ae2e:	c6 44 02 10 7f       	movb   $0x7f,0x10(%edx,%eax,1)
   1ae33:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae37:	8b 40 38             	mov    0x38(%eax),%eax
   1ae3a:	8b 40 04             	mov    0x4(%eax),%eax
   1ae3d:	8d 50 01             	lea    0x1(%eax),%edx
   1ae40:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae44:	8b 40 38             	mov    0x38(%eax),%eax
   1ae47:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1ae4d:	89 50 04             	mov    %edx,0x4(%eax)
						tty->write(tty);
   1ae50:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae54:	8b 40 30             	mov    0x30(%eax),%eax
   1ae57:	83 ec 0c             	sub    $0xc,%esp
   1ae5a:	ff 74 24 2c          	pushl  0x2c(%esp)
   1ae5e:	ff d0                	call   *%eax
   1ae60:	83 c4 10             	add    $0x10,%esp
					}
					DEC(tty->secondary->head);
   1ae63:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae67:	8b 40 3c             	mov    0x3c(%eax),%eax
   1ae6a:	8b 40 04             	mov    0x4(%eax),%eax
   1ae6d:	8d 50 ff             	lea    -0x1(%eax),%edx
   1ae70:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae74:	8b 40 3c             	mov    0x3c(%eax),%eax
   1ae77:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1ae7d:	89 50 04             	mov    %edx,0x4(%eax)
				while(!(EMPTY(tty->secondary) ||
   1ae80:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae84:	8b 40 3c             	mov    0x3c(%eax),%eax
   1ae87:	8b 50 04             	mov    0x4(%eax),%edx
   1ae8a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ae8e:	8b 40 3c             	mov    0x3c(%eax),%eax
   1ae91:	8b 40 08             	mov    0x8(%eax),%eax
   1ae94:	39 c2                	cmp    %eax,%edx
   1ae96:	0f 84 ec 04 00 00    	je     1b388 <copy_to_cooked+0x75d>
				        (c = LAST(tty->secondary)) == 10 ||
   1ae9c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1aea0:	8b 40 3c             	mov    0x3c(%eax),%eax
   1aea3:	8b 54 24 20          	mov    0x20(%esp),%edx
   1aea7:	8b 52 3c             	mov    0x3c(%edx),%edx
   1aeaa:	8b 52 04             	mov    0x4(%edx),%edx
   1aead:	83 ea 01             	sub    $0x1,%edx
   1aeb0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1aeb6:	0f b6 44 10 10       	movzbl 0x10(%eax,%edx,1),%eax
   1aebb:	88 44 24 0f          	mov    %al,0xf(%esp)
				while(!(EMPTY(tty->secondary) ||
   1aebf:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1aec4:	0f 84 be 04 00 00    	je     1b388 <copy_to_cooked+0x75d>
				        ((EOF_CHAR(tty) != _POSIX_VDISABLE) && (c == EOF_CHAR(tty))))) {
   1aeca:	8b 44 24 20          	mov    0x20(%esp),%eax
   1aece:	0f b6 40 15          	movzbl 0x15(%eax),%eax
				while(!(EMPTY(tty->secondary) ||
   1aed2:	84 c0                	test   %al,%al
   1aed4:	0f 84 f7 fe ff ff    	je     1add1 <copy_to_cooked+0x1a6>
				        ((EOF_CHAR(tty) != _POSIX_VDISABLE) && (c == EOF_CHAR(tty))))) {
   1aeda:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1aedf:	8b 44 24 20          	mov    0x20(%esp),%eax
   1aee3:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1aee7:	0f b6 c0             	movzbl %al,%eax
   1aeea:	39 c2                	cmp    %eax,%edx
   1aeec:	0f 85 df fe ff ff    	jne    1add1 <copy_to_cooked+0x1a6>
				}
				continue;									// 继续读取读队列中字符进行处理.
   1aef2:	e9 91 04 00 00       	jmp    1b388 <copy_to_cooked+0x75d>
			}
			// 如果该字符是删除控制字符ERASE(^H),那么:如果tty的辅助队列为空,或者其最后一个字符是换行符NL(10),或者是文件结束符,则继续处理其他字符.如果本地回显
			// 标志ECHO置位,那么:若字符是控制字符(值 < 32),则往tty的写队列中放入擦除字符ERASE.再放入一个擦除字符ERASE,并且调用该tty的写函数.最后将tty辅助
			// 队列头指针后退1字节,继续处理其他字符.同样地,如果定义了_POSIX_VDISABLE(\0),那么在对字符处理过程中,若字符代码值等于_POSIX_VDISABLE的值时,
			// 表示禁止使用相应特殊控制字符的功能.
			if ((ERASE_CHAR(tty) != _POSIX_VDISABLE) && (c == ERASE_CHAR(tty))) {
   1aef7:	8b 44 24 20          	mov    0x20(%esp),%eax
   1aefb:	0f b6 40 13          	movzbl 0x13(%eax),%eax
   1aeff:	84 c0                	test   %al,%al
   1af01:	0f 84 3a 01 00 00    	je     1b041 <copy_to_cooked+0x416>
   1af07:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1af0c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1af10:	0f b6 40 13          	movzbl 0x13(%eax),%eax
   1af14:	0f b6 c0             	movzbl %al,%eax
   1af17:	39 c2                	cmp    %eax,%edx
   1af19:	0f 85 22 01 00 00    	jne    1b041 <copy_to_cooked+0x416>
				if (EMPTY(tty->secondary) ||
   1af1f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1af23:	8b 40 3c             	mov    0x3c(%eax),%eax
   1af26:	8b 50 04             	mov    0x4(%eax),%edx
   1af29:	8b 44 24 20          	mov    0x20(%esp),%eax
   1af2d:	8b 40 3c             	mov    0x3c(%eax),%eax
   1af30:	8b 40 08             	mov    0x8(%eax),%eax
   1af33:	39 c2                	cmp    %eax,%edx
   1af35:	0f 84 53 04 00 00    	je     1b38e <copy_to_cooked+0x763>
				   (c = LAST(tty->secondary)) == 10 ||
   1af3b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1af3f:	8b 40 3c             	mov    0x3c(%eax),%eax
   1af42:	8b 54 24 20          	mov    0x20(%esp),%edx
   1af46:	8b 52 3c             	mov    0x3c(%edx),%edx
   1af49:	8b 52 04             	mov    0x4(%edx),%edx
   1af4c:	83 ea 01             	sub    $0x1,%edx
   1af4f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1af55:	0f b6 44 10 10       	movzbl 0x10(%eax,%edx,1),%eax
   1af5a:	88 44 24 0f          	mov    %al,0xf(%esp)
				if (EMPTY(tty->secondary) ||
   1af5e:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1af63:	0f 84 25 04 00 00    	je     1b38e <copy_to_cooked+0x763>
				   ((EOF_CHAR(tty) != _POSIX_VDISABLE) &&
   1af69:	8b 44 24 20          	mov    0x20(%esp),%eax
   1af6d:	0f b6 40 15          	movzbl 0x15(%eax),%eax
				   (c = LAST(tty->secondary)) == 10 ||
   1af71:	84 c0                	test   %al,%al
   1af73:	74 18                	je     1af8d <copy_to_cooked+0x362>
				    (c == EOF_CHAR(tty))))
   1af75:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1af7a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1af7e:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1af82:	0f b6 c0             	movzbl %al,%eax
				   ((EOF_CHAR(tty) != _POSIX_VDISABLE) &&
   1af85:	39 c2                	cmp    %eax,%edx
   1af87:	0f 84 01 04 00 00    	je     1b38e <copy_to_cooked+0x763>
					continue;
				if (L_ECHO(tty)) {							// 若本地回显标志置位.
   1af8d:	8b 44 24 20          	mov    0x20(%esp),%eax
   1af91:	8b 40 0c             	mov    0xc(%eax),%eax
   1af94:	83 e0 08             	and    $0x8,%eax
   1af97:	85 c0                	test   %eax,%eax
   1af99:	0f 84 80 00 00 00    	je     1b01f <copy_to_cooked+0x3f4>
					if (c < 32)
   1af9f:	80 7c 24 0f 1f       	cmpb   $0x1f,0xf(%esp)
   1afa4:	7f 33                	jg     1afd9 <copy_to_cooked+0x3ae>
						PUTCH(127, tty->write_q);
   1afa6:	8b 44 24 20          	mov    0x20(%esp),%eax
   1afaa:	8b 50 38             	mov    0x38(%eax),%edx
   1afad:	8b 44 24 20          	mov    0x20(%esp),%eax
   1afb1:	8b 40 38             	mov    0x38(%eax),%eax
   1afb4:	8b 40 04             	mov    0x4(%eax),%eax
   1afb7:	c6 44 02 10 7f       	movb   $0x7f,0x10(%edx,%eax,1)
   1afbc:	8b 44 24 20          	mov    0x20(%esp),%eax
   1afc0:	8b 40 38             	mov    0x38(%eax),%eax
   1afc3:	8b 40 04             	mov    0x4(%eax),%eax
   1afc6:	8d 50 01             	lea    0x1(%eax),%edx
   1afc9:	8b 44 24 20          	mov    0x20(%esp),%eax
   1afcd:	8b 40 38             	mov    0x38(%eax),%eax
   1afd0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1afd6:	89 50 04             	mov    %edx,0x4(%eax)
					PUTCH(127, tty->write_q);
   1afd9:	8b 44 24 20          	mov    0x20(%esp),%eax
   1afdd:	8b 50 38             	mov    0x38(%eax),%edx
   1afe0:	8b 44 24 20          	mov    0x20(%esp),%eax
   1afe4:	8b 40 38             	mov    0x38(%eax),%eax
   1afe7:	8b 40 04             	mov    0x4(%eax),%eax
   1afea:	c6 44 02 10 7f       	movb   $0x7f,0x10(%edx,%eax,1)
   1afef:	8b 44 24 20          	mov    0x20(%esp),%eax
   1aff3:	8b 40 38             	mov    0x38(%eax),%eax
   1aff6:	8b 40 04             	mov    0x4(%eax),%eax
   1aff9:	8d 50 01             	lea    0x1(%eax),%edx
   1affc:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b000:	8b 40 38             	mov    0x38(%eax),%eax
   1b003:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b009:	89 50 04             	mov    %edx,0x4(%eax)
					tty->write(tty);
   1b00c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b010:	8b 40 30             	mov    0x30(%eax),%eax
   1b013:	83 ec 0c             	sub    $0xc,%esp
   1b016:	ff 74 24 2c          	pushl  0x2c(%esp)
   1b01a:	ff d0                	call   *%eax
   1b01c:	83 c4 10             	add    $0x10,%esp
				}
				DEC(tty->secondary->head);
   1b01f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b023:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b026:	8b 40 04             	mov    0x4(%eax),%eax
   1b029:	8d 50 ff             	lea    -0x1(%eax),%edx
   1b02c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b030:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b033:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b039:	89 50 04             	mov    %edx,0x4(%eax)
				continue;
   1b03c:	e9 54 03 00 00       	jmp    1b395 <copy_to_cooked+0x76a>
		// 如果设置了IXON标志,则使终端停止/开始输出控制字符起作用.如果没有设置此标志,那么停止和开始字符将被作为一般字符供进程读取.在这段代码中,如果读取的字符是停止
		// 字符STOP(^S),则置tty停止标志,让tty暂停输出.同时丢弃该特殊控制字符(不放入辅助队列中),并继续处理其他字符.如果字符是开始字符START(^Q),则复位tty停止
		// 标志,恢复tty输出.同时丢弃该控制字符,并继续处理其他字符.对于控制台来说,这里的tty->write()是console.c中的con_write()函数.因此对于伪终端也是由于设置
		// 了终端stopped标志而会暂停写操作(chr_drv/console.c).对于伪终端也是由于设置了终端stopped标志而会暂停写操作(chr_drv/pty.c).
		// 对于串行终端,也应该在发送终端过程中根据终端stopped标志暂停发送,但本版未实现.
		if (I_IXON(tty)) {
   1b041:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b045:	8b 00                	mov    (%eax),%eax
   1b047:	25 00 04 00 00       	and    $0x400,%eax
   1b04c:	85 c0                	test   %eax,%eax
   1b04e:	0f 84 86 00 00 00    	je     1b0da <copy_to_cooked+0x4af>
			if ((STOP_CHAR(tty) != _POSIX_VDISABLE) && (c==STOP_CHAR(tty))) {
   1b054:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b058:	0f b6 40 1a          	movzbl 0x1a(%eax),%eax
   1b05c:	84 c0                	test   %al,%al
   1b05e:	74 37                	je     1b097 <copy_to_cooked+0x46c>
   1b060:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1b065:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b069:	0f b6 40 1a          	movzbl 0x1a(%eax),%eax
   1b06d:	0f b6 c0             	movzbl %al,%eax
   1b070:	39 c2                	cmp    %eax,%edx
   1b072:	75 23                	jne    1b097 <copy_to_cooked+0x46c>
				tty->stopped = 1;
   1b074:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b078:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
				tty->write(tty);
   1b07f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b083:	8b 40 30             	mov    0x30(%eax),%eax
   1b086:	83 ec 0c             	sub    $0xc,%esp
   1b089:	ff 74 24 2c          	pushl  0x2c(%esp)
   1b08d:	ff d0                	call   *%eax
   1b08f:	83 c4 10             	add    $0x10,%esp
				continue;
   1b092:	e9 fe 02 00 00       	jmp    1b395 <copy_to_cooked+0x76a>
			}
			if ((START_CHAR(tty) != _POSIX_VDISABLE) && (c==START_CHAR(tty))) {
   1b097:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b09b:	0f b6 40 19          	movzbl 0x19(%eax),%eax
   1b09f:	84 c0                	test   %al,%al
   1b0a1:	74 37                	je     1b0da <copy_to_cooked+0x4af>
   1b0a3:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1b0a8:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b0ac:	0f b6 40 19          	movzbl 0x19(%eax),%eax
   1b0b0:	0f b6 c0             	movzbl %al,%eax
   1b0b3:	39 c2                	cmp    %eax,%edx
   1b0b5:	75 23                	jne    1b0da <copy_to_cooked+0x4af>
				tty->stopped = 0;
   1b0b7:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b0bb:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
				tty->write(tty);
   1b0c2:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b0c6:	8b 40 30             	mov    0x30(%eax),%eax
   1b0c9:	83 ec 0c             	sub    $0xc,%esp
   1b0cc:	ff 74 24 2c          	pushl  0x2c(%esp)
   1b0d0:	ff d0                	call   *%eax
   1b0d2:	83 c4 10             	add    $0x10,%esp
				continue;
   1b0d5:	e9 bb 02 00 00       	jmp    1b395 <copy_to_cooked+0x76a>
        }
		// 若输入模式标志集中ISIG标志置位,表示终端键盘可以产生信号,则在收到控制字符INTR,QUIT,SUSP或DSUSP时,需要为进程产生相应的信号.如果该字符是键盘中断符(^C),则向
		// 当前进程之进程组中所有进程发送键盘中断信号SIGINT,并继续处理下一字符.如果该字符是退出符(^\),则向当前进程之进程组中所有进程发送键盘退出信号SIGQUIT,并继续处理
		// 下一字符.如果字符是暂停符(^Z),则向当前进程发送暂停信息SIGTSTP.同样,若定义了_POSIX_VDISABLE(\0),那么在对字符处理过程中,若字符代码值等于_POSIX_VDISABLE
		// 的值时,表示禁止使用相应特殊控制字符的功能.
		if (L_ISIG(tty)) {
   1b0da:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b0de:	8b 40 0c             	mov    0xc(%eax),%eax
   1b0e1:	83 e0 01             	and    $0x1,%eax
   1b0e4:	85 c0                	test   %eax,%eax
   1b0e6:	0f 84 cf 00 00 00    	je     1b1bb <copy_to_cooked+0x590>
			if ((INTR_CHAR(tty) != _POSIX_VDISABLE) && (c==INTR_CHAR(tty))) {
   1b0ec:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b0f0:	0f b6 40 11          	movzbl 0x11(%eax),%eax
   1b0f4:	84 c0                	test   %al,%al
   1b0f6:	74 30                	je     1b128 <copy_to_cooked+0x4fd>
   1b0f8:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1b0fd:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b101:	0f b6 40 11          	movzbl 0x11(%eax),%eax
   1b105:	0f b6 c0             	movzbl %al,%eax
   1b108:	39 c2                	cmp    %eax,%edx
   1b10a:	75 1c                	jne    1b128 <copy_to_cooked+0x4fd>
				kill_pg(tty->pgrp, SIGINT, 1);
   1b10c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b110:	8b 40 24             	mov    0x24(%eax),%eax
   1b113:	83 ec 04             	sub    $0x4,%esp
   1b116:	6a 01                	push   $0x1
   1b118:	6a 02                	push   $0x2
   1b11a:	50                   	push   %eax
   1b11b:	e8 15 05 ff ff       	call   b635 <kill_pg>
   1b120:	83 c4 10             	add    $0x10,%esp
				continue;
   1b123:	e9 6d 02 00 00       	jmp    1b395 <copy_to_cooked+0x76a>
			}
			if ((QUIT_CHAR(tty) != _POSIX_VDISABLE) && (c==QUIT_CHAR(tty))) {
   1b128:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b12c:	0f b6 40 12          	movzbl 0x12(%eax),%eax
   1b130:	84 c0                	test   %al,%al
   1b132:	74 30                	je     1b164 <copy_to_cooked+0x539>
   1b134:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1b139:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b13d:	0f b6 40 12          	movzbl 0x12(%eax),%eax
   1b141:	0f b6 c0             	movzbl %al,%eax
   1b144:	39 c2                	cmp    %eax,%edx
   1b146:	75 1c                	jne    1b164 <copy_to_cooked+0x539>
				kill_pg(tty->pgrp, SIGQUIT, 1);
   1b148:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b14c:	8b 40 24             	mov    0x24(%eax),%eax
   1b14f:	83 ec 04             	sub    $0x4,%esp
   1b152:	6a 01                	push   $0x1
   1b154:	6a 03                	push   $0x3
   1b156:	50                   	push   %eax
   1b157:	e8 d9 04 ff ff       	call   b635 <kill_pg>
   1b15c:	83 c4 10             	add    $0x10,%esp
				continue;
   1b15f:	e9 31 02 00 00       	jmp    1b395 <copy_to_cooked+0x76a>
			}
			if ((SUSPEND_CHAR(tty) != _POSIX_VDISABLE) && (c == SUSPEND_CHAR(tty))) {
   1b164:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b168:	0f b6 40 1b          	movzbl 0x1b(%eax),%eax
   1b16c:	84 c0                	test   %al,%al
   1b16e:	74 4b                	je     1b1bb <copy_to_cooked+0x590>
   1b170:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1b175:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b179:	0f b6 40 1b          	movzbl 0x1b(%eax),%eax
   1b17d:	0f b6 c0             	movzbl %al,%eax
   1b180:	39 c2                	cmp    %eax,%edx
   1b182:	75 37                	jne    1b1bb <copy_to_cooked+0x590>
				if (!is_orphaned_pgrp(tty->pgrp))				// 判断一个进程组是否孤儿进程
   1b184:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b188:	8b 40 24             	mov    0x24(%eax),%eax
   1b18b:	83 ec 0c             	sub    $0xc,%esp
   1b18e:	50                   	push   %eax
   1b18f:	e8 ae 06 ff ff       	call   b842 <is_orphaned_pgrp>
   1b194:	83 c4 10             	add    $0x10,%esp
   1b197:	85 c0                	test   %eax,%eax
   1b199:	0f 85 f5 01 00 00    	jne    1b394 <copy_to_cooked+0x769>
					kill_pg(tty->pgrp, SIGTSTP, 1);
   1b19f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b1a3:	8b 40 24             	mov    0x24(%eax),%eax
   1b1a6:	83 ec 04             	sub    $0x4,%esp
   1b1a9:	6a 01                	push   $0x1
   1b1ab:	6a 14                	push   $0x14
   1b1ad:	50                   	push   %eax
   1b1ae:	e8 82 04 ff ff       	call   b635 <kill_pg>
   1b1b3:	83 c4 10             	add    $0x10,%esp
				continue;
   1b1b6:	e9 d9 01 00 00       	jmp    1b394 <copy_to_cooked+0x769>
			}
		}
		// 如果该字符是换行符NL(10),或者是文件结束符EOF(4,^D),表示一行字符已处理完,则把辅助缓冲队列中当前含有字符行数值secondar.data增1.如果在函数tty_read()中取走一行
		// 字符,该值即会减1.
		if (c == 10 || (EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)))
   1b1bb:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1b1c0:	74 20                	je     1b1e2 <copy_to_cooked+0x5b7>
   1b1c2:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b1c6:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1b1ca:	84 c0                	test   %al,%al
   1b1cc:	74 22                	je     1b1f0 <copy_to_cooked+0x5c5>
   1b1ce:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1b1d3:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b1d7:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1b1db:	0f b6 c0             	movzbl %al,%eax
   1b1de:	39 c2                	cmp    %eax,%edx
   1b1e0:	75 0e                	jne    1b1f0 <copy_to_cooked+0x5c5>
			tty->secondary->data++;
   1b1e2:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b1e6:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b1e9:	8b 10                	mov    (%eax),%edx
   1b1eb:	83 c2 01             	add    $0x1,%edx
   1b1ee:	89 10                	mov    %edx,(%eax)
		// 如果本地模式标志中回显标志ECHO在置位状态,那么,如果字符是换行符NL(10),则将换行符NL(10)和回车符(13)放入tty写队列缓冲区中;如果字符是控制字符(值<32)并且回显控制
		// 字符标志ECHOCTL置位,则将字符'^'和字符c+64放入tty写队列中(也即会显示^C,^H等);否则将该字符直接放入tty写缓冲队列中.最后调用该tty写操作函数.
		if (L_ECHO(tty)) {
   1b1f0:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b1f4:	8b 40 0c             	mov    0xc(%eax),%eax
   1b1f7:	83 e0 08             	and    $0x8,%eax
   1b1fa:	85 c0                	test   %eax,%eax
   1b1fc:	0f 84 4a 01 00 00    	je     1b34c <copy_to_cooked+0x721>
			if (c == 10) {
   1b202:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1b207:	75 6b                	jne    1b274 <copy_to_cooked+0x649>
				PUTCH(10, tty->write_q);
   1b209:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b20d:	8b 50 38             	mov    0x38(%eax),%edx
   1b210:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b214:	8b 40 38             	mov    0x38(%eax),%eax
   1b217:	8b 40 04             	mov    0x4(%eax),%eax
   1b21a:	c6 44 02 10 0a       	movb   $0xa,0x10(%edx,%eax,1)
   1b21f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b223:	8b 40 38             	mov    0x38(%eax),%eax
   1b226:	8b 40 04             	mov    0x4(%eax),%eax
   1b229:	8d 50 01             	lea    0x1(%eax),%edx
   1b22c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b230:	8b 40 38             	mov    0x38(%eax),%eax
   1b233:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b239:	89 50 04             	mov    %edx,0x4(%eax)
				PUTCH(13, tty->write_q);
   1b23c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b240:	8b 50 38             	mov    0x38(%eax),%edx
   1b243:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b247:	8b 40 38             	mov    0x38(%eax),%eax
   1b24a:	8b 40 04             	mov    0x4(%eax),%eax
   1b24d:	c6 44 02 10 0d       	movb   $0xd,0x10(%edx,%eax,1)
   1b252:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b256:	8b 40 38             	mov    0x38(%eax),%eax
   1b259:	8b 40 04             	mov    0x4(%eax),%eax
   1b25c:	8d 50 01             	lea    0x1(%eax),%edx
   1b25f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b263:	8b 40 38             	mov    0x38(%eax),%eax
   1b266:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b26c:	89 50 04             	mov    %edx,0x4(%eax)
   1b26f:	e9 c5 00 00 00       	jmp    1b339 <copy_to_cooked+0x70e>
			} else if (c < 32) {
   1b274:	80 7c 24 0f 1f       	cmpb   $0x1f,0xf(%esp)
   1b279:	0f 8f 83 00 00 00    	jg     1b302 <copy_to_cooked+0x6d7>
				if (L_ECHOCTL(tty)) {
   1b27f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b283:	8b 40 0c             	mov    0xc(%eax),%eax
   1b286:	25 00 02 00 00       	and    $0x200,%eax
   1b28b:	85 c0                	test   %eax,%eax
   1b28d:	0f 84 a6 00 00 00    	je     1b339 <copy_to_cooked+0x70e>
					PUTCH('^', tty->write_q);
   1b293:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b297:	8b 50 38             	mov    0x38(%eax),%edx
   1b29a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b29e:	8b 40 38             	mov    0x38(%eax),%eax
   1b2a1:	8b 40 04             	mov    0x4(%eax),%eax
   1b2a4:	c6 44 02 10 5e       	movb   $0x5e,0x10(%edx,%eax,1)
   1b2a9:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b2ad:	8b 40 38             	mov    0x38(%eax),%eax
   1b2b0:	8b 40 04             	mov    0x4(%eax),%eax
   1b2b3:	8d 50 01             	lea    0x1(%eax),%edx
   1b2b6:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b2ba:	8b 40 38             	mov    0x38(%eax),%eax
   1b2bd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b2c3:	89 50 04             	mov    %edx,0x4(%eax)
					PUTCH(c + 64, tty->write_q);
   1b2c6:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1b2cb:	8d 48 40             	lea    0x40(%eax),%ecx
   1b2ce:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b2d2:	8b 50 38             	mov    0x38(%eax),%edx
   1b2d5:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b2d9:	8b 40 38             	mov    0x38(%eax),%eax
   1b2dc:	8b 40 04             	mov    0x4(%eax),%eax
   1b2df:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   1b2e3:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b2e7:	8b 40 38             	mov    0x38(%eax),%eax
   1b2ea:	8b 40 04             	mov    0x4(%eax),%eax
   1b2ed:	8d 50 01             	lea    0x1(%eax),%edx
   1b2f0:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b2f4:	8b 40 38             	mov    0x38(%eax),%eax
   1b2f7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b2fd:	89 50 04             	mov    %edx,0x4(%eax)
   1b300:	eb 37                	jmp    1b339 <copy_to_cooked+0x70e>
				}
			} else
				PUTCH(c, tty->write_q);
   1b302:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b306:	8b 50 38             	mov    0x38(%eax),%edx
   1b309:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b30d:	8b 40 38             	mov    0x38(%eax),%eax
   1b310:	8b 40 04             	mov    0x4(%eax),%eax
   1b313:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
   1b318:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   1b31c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b320:	8b 40 38             	mov    0x38(%eax),%eax
   1b323:	8b 40 04             	mov    0x4(%eax),%eax
   1b326:	8d 50 01             	lea    0x1(%eax),%edx
   1b329:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b32d:	8b 40 38             	mov    0x38(%eax),%eax
   1b330:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b336:	89 50 04             	mov    %edx,0x4(%eax)
			tty->write(tty);
   1b339:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b33d:	8b 40 30             	mov    0x30(%eax),%eax
   1b340:	83 ec 0c             	sub    $0xc,%esp
   1b343:	ff 74 24 2c          	pushl  0x2c(%esp)
   1b347:	ff d0                	call   *%eax
   1b349:	83 c4 10             	add    $0x10,%esp
		}
		// 每一次循环末将处理过的字符放入辅助队列中
		PUTCH(c, tty->secondary);
   1b34c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b350:	8b 50 3c             	mov    0x3c(%eax),%edx
   1b353:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b357:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b35a:	8b 40 04             	mov    0x4(%eax),%eax
   1b35d:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
   1b362:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   1b366:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b36a:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b36d:	8b 40 04             	mov    0x4(%eax),%eax
   1b370:	8d 50 01             	lea    0x1(%eax),%edx
   1b373:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b377:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b37a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b380:	89 50 04             	mov    %edx,0x4(%eax)
   1b383:	e9 ea f8 ff ff       	jmp    1ac72 <copy_to_cooked+0x47>
				continue;									// 继续读取读队列中字符进行处理.
   1b388:	90                   	nop
   1b389:	e9 e4 f8 ff ff       	jmp    1ac72 <copy_to_cooked+0x47>
					continue;
   1b38e:	90                   	nop
   1b38f:	e9 de f8 ff ff       	jmp    1ac72 <copy_to_cooked+0x47>
				continue;
   1b394:	90                   	nop
		if (EMPTY(tty->read_q))
   1b395:	e9 d8 f8 ff ff       	jmp    1ac72 <copy_to_cooked+0x47>
			break;
   1b39a:	90                   	nop
   1b39b:	eb 01                	jmp    1b39e <copy_to_cooked+0x773>
			break;
   1b39d:	90                   	nop
    }
	// 在退出循环体后唤醒等待该辅助缓冲队列的进程(如果有的话).
	wake_up(&tty->secondary->proc_list);
   1b39e:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b3a2:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b3a5:	83 c0 0c             	add    $0xc,%eax
   1b3a8:	83 ec 0c             	sub    $0xc,%esp
   1b3ab:	50                   	push   %eax
   1b3ac:	e8 f6 be fe ff       	call   72a7 <wake_up>
   1b3b1:	83 c4 10             	add    $0x10,%esp
}
   1b3b4:	83 c4 18             	add    $0x18,%esp
   1b3b7:	5b                   	pop    %ebx
   1b3b8:	c3                   	ret    

0001b3b9 <tty_signal>:
 */
// 向使用终端的进程组中所有进程发送信号。
// 在后台进程组中的一个进程访问控制终端时，该函数用于向后台进程组中的所有进程发送SIGTTIN或SIGTTOU信号。无论后台进程组
// 中的进程是否已经阻塞或忽略掉了这两个信号，当前进程都将立刻退出读写操作而返回。
int tty_signal(int sig, struct tty_struct *tty)
{
   1b3b9:	56                   	push   %esi
   1b3ba:	53                   	push   %ebx
   1b3bb:	83 ec 04             	sub    $0x4,%esp
   1b3be:	e8 37 b9 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1b3c3:	81 c3 3d 6c 01 00    	add    $0x16c3d,%ebx
	// 我们不希望停止一个孤儿进程组的进程（参见文件kernel/exit.c的说明）。
	// 因此如果当前进程组是孤儿进程组，就出错返回。否则就向当前进程组所有进程发送指定信号。
	if (is_orphaned_pgrp(current->pgrp))
   1b3c9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b3cf:	8b 00                	mov    (%eax),%eax
   1b3d1:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
   1b3d7:	83 ec 0c             	sub    $0xc,%esp
   1b3da:	50                   	push   %eax
   1b3db:	e8 62 04 ff ff       	call   b842 <is_orphaned_pgrp>
   1b3e0:	83 c4 10             	add    $0x10,%esp
   1b3e3:	85 c0                	test   %eax,%eax
   1b3e5:	74 0a                	je     1b3f1 <tty_signal+0x38>
		return -EIO;									/* don't stop an orphaned pgrp */
   1b3e7:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   1b3ec:	e9 94 00 00 00       	jmp    1b485 <tty_signal+0xcc>
	(void) kill_pg(current->pgrp, sig, 1);            	// 发送信号sig。
   1b3f1:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b3f7:	8b 00                	mov    (%eax),%eax
   1b3f9:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
   1b3ff:	83 ec 04             	sub    $0x4,%esp
   1b402:	6a 01                	push   $0x1
   1b404:	ff 74 24 18          	pushl  0x18(%esp)
   1b408:	50                   	push   %eax
   1b409:	e8 27 02 ff ff       	call   b635 <kill_pg>
   1b40e:	83 c4 10             	add    $0x10,%esp
	// 如果这个信号被当前进程阻塞（屏蔽），或者被当前进程忽略掉，则出错返回。否则，如果当前进程的对信号sig设置了新的处理句柄
	// 那么就返回我们可被中断的信息。否则就返回在系统调用重新启动后可以继续执行的信息。
	if ((current->blocked & (1 << (sig - 1))) ||
   1b411:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b417:	8b 00                	mov    (%eax),%eax
   1b419:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   1b41f:	8b 54 24 10          	mov    0x10(%esp),%edx
   1b423:	83 ea 01             	sub    $0x1,%edx
   1b426:	be 01 00 00 00       	mov    $0x1,%esi
   1b42b:	89 d1                	mov    %edx,%ecx
   1b42d:	d3 e6                	shl    %cl,%esi
   1b42f:	89 f2                	mov    %esi,%edx
   1b431:	21 d0                	and    %edx,%eax
   1b433:	85 c0                	test   %eax,%eax
   1b435:	75 1e                	jne    1b455 <tty_signal+0x9c>
	    ((int) current->sigaction[sig - 1].sa_handler == 1))
   1b437:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b43d:	8b 00                	mov    (%eax),%eax
   1b43f:	8b 54 24 10          	mov    0x10(%esp),%edx
   1b443:	83 ea 01             	sub    $0x1,%edx
   1b446:	83 c2 01             	add    $0x1,%edx
   1b449:	c1 e2 04             	shl    $0x4,%edx
   1b44c:	01 d0                	add    %edx,%eax
   1b44e:	8b 00                	mov    (%eax),%eax
	if ((current->blocked & (1 << (sig - 1))) ||
   1b450:	83 f8 01             	cmp    $0x1,%eax
   1b453:	75 07                	jne    1b45c <tty_signal+0xa3>
		return -EIO;		/* Our signal will be ignored */
   1b455:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   1b45a:	eb 29                	jmp    1b485 <tty_signal+0xcc>
	else if (current->sigaction[sig-1].sa_handler)
   1b45c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b462:	8b 00                	mov    (%eax),%eax
   1b464:	8b 54 24 10          	mov    0x10(%esp),%edx
   1b468:	83 ea 01             	sub    $0x1,%edx
   1b46b:	83 c2 01             	add    $0x1,%edx
   1b46e:	c1 e2 04             	shl    $0x4,%edx
   1b471:	01 d0                	add    %edx,%eax
   1b473:	8b 00                	mov    (%eax),%eax
   1b475:	85 c0                	test   %eax,%eax
   1b477:	74 07                	je     1b480 <tty_signal+0xc7>
		return -EINTR;		/* We _will_ be interrupted :-) */
   1b479:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   1b47e:	eb 05                	jmp    1b485 <tty_signal+0xcc>
	else
		return -ERESTARTSYS;	/* We _will_ be interrupted :-) */
   1b480:	b8 00 fe ff ff       	mov    $0xfffffe00,%eax
					/* (but restart after we continue) */
}
   1b485:	83 c4 04             	add    $0x4,%esp
   1b488:	5b                   	pop    %ebx
   1b489:	5e                   	pop    %esi
   1b48a:	c3                   	ret    

0001b48b <tty_read>:

// tty读函数。
// 从终端辅助缓冲队列读取指定数量的字符，放到用户指定的缓冲区中。
// 参数：channel - 子设备号；buf - 用户缓冲区指针；nr - 欲读字节数。
int tty_read(unsigned channel, char * buf, int nr)
{
   1b48b:	53                   	push   %ebx
   1b48c:	83 ec 28             	sub    $0x28,%esp
   1b48f:	e8 66 b8 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1b494:	81 c3 6c 6b 01 00    	add    $0x16b6c,%ebx
	struct tty_struct * tty;
	struct tty_struct * other_tty = NULL;
   1b49a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   1b4a1:	00 
	char c, *b = buf;
   1b4a2:	8b 44 24 34          	mov    0x34(%esp),%eax
   1b4a6:	89 44 24 18          	mov    %eax,0x18(%esp)
	int minimum, time;

	// 首先判断参数有效性并取终端的tty结构指针。如果tty终端的三个缓冲队列指针都是NULL，则返回EIO出错信息。如果tty
	// 终端是一个伪终端，则再取得另一个对应伪终端的tty结构other_tty。
	if (channel > 255)
   1b4aa:	81 7c 24 30 ff 00 00 	cmpl   $0xff,0x30(%esp)
   1b4b1:	00 
   1b4b2:	76 0a                	jbe    1b4be <tty_read+0x33>
		return -EIO;
   1b4b4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   1b4b9:	e9 51 04 00 00       	jmp    1b90f <tty_read+0x484>
	tty = TTY_TABLE(channel);
   1b4be:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
   1b4c3:	74 32                	je     1b4f7 <tty_read+0x6c>
   1b4c5:	83 7c 24 30 3f       	cmpl   $0x3f,0x30(%esp)
   1b4ca:	77 18                	ja     1b4e4 <tty_read+0x59>
   1b4cc:	8b 44 24 30          	mov    0x30(%esp),%eax
   1b4d0:	05 ff ff ff 03       	add    $0x3ffffff,%eax
   1b4d5:	c1 e0 06             	shl    $0x6,%eax
   1b4d8:	89 c2                	mov    %eax,%edx
   1b4da:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1b4e0:	01 d0                	add    %edx,%eax
   1b4e2:	eb 26                	jmp    1b50a <tty_read+0x7f>
   1b4e4:	8b 44 24 30          	mov    0x30(%esp),%eax
   1b4e8:	c1 e0 06             	shl    $0x6,%eax
   1b4eb:	89 c2                	mov    %eax,%edx
   1b4ed:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1b4f3:	01 d0                	add    %edx,%eax
   1b4f5:	eb 13                	jmp    1b50a <tty_read+0x7f>
   1b4f7:	8b 83 00 43 00 00    	mov    0x4300(%ebx),%eax
   1b4fd:	c1 e0 06             	shl    $0x6,%eax
   1b500:	89 c2                	mov    %eax,%edx
   1b502:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1b508:	01 d0                	add    %edx,%eax
   1b50a:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!(tty->write_q || tty->read_q || tty->secondary))
   1b50e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b512:	8b 40 38             	mov    0x38(%eax),%eax
   1b515:	85 c0                	test   %eax,%eax
   1b517:	75 20                	jne    1b539 <tty_read+0xae>
   1b519:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b51d:	8b 40 34             	mov    0x34(%eax),%eax
   1b520:	85 c0                	test   %eax,%eax
   1b522:	75 15                	jne    1b539 <tty_read+0xae>
   1b524:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b528:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b52b:	85 c0                	test   %eax,%eax
   1b52d:	75 0a                	jne    1b539 <tty_read+0xae>
		return -EIO;
   1b52f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   1b534:	e9 d6 03 00 00       	jmp    1b90f <tty_read+0x484>
	// 如果当前进程使用的是这里正在处理的tty终端，但该终端的进程组号却与当前进程组号不同，表示当前进程是后台进程组中
	// 的一个进程，即进程不在前台。于是我们要停止当前进程组的所有进程。因此这里就需要向当前进程组发送SIGTTIN信号，
	// 并返回等待成为前台进程组后再执行读操作。
	if ((current->tty == channel) && (tty->pgrp != current->pgrp))
   1b539:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b53f:	8b 00                	mov    (%eax),%eax
   1b541:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
   1b547:	39 44 24 30          	cmp    %eax,0x30(%esp)
   1b54b:	75 2f                	jne    1b57c <tty_read+0xf1>
   1b54d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b551:	8b 50 24             	mov    0x24(%eax),%edx
   1b554:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b55a:	8b 00                	mov    (%eax),%eax
   1b55c:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
   1b562:	39 c2                	cmp    %eax,%edx
   1b564:	74 16                	je     1b57c <tty_read+0xf1>
		return(tty_signal(SIGTTIN, tty));
   1b566:	83 ec 08             	sub    $0x8,%esp
   1b569:	ff 74 24 14          	pushl  0x14(%esp)
   1b56d:	6a 15                	push   $0x15
   1b56f:	e8 45 fe ff ff       	call   1b3b9 <tty_signal>
   1b574:	83 c4 10             	add    $0x10,%esp
   1b577:	e9 93 03 00 00       	jmp    1b90f <tty_read+0x484>
	// 如果当前终端是伪终端，那么对应的另一个伪终端就是other_tty。若这里tty是主伪终端，那么other_tty就是对应的从伪
	// 终端，反之亦然。
	if (channel & 0x80)
   1b57c:	8b 44 24 30          	mov    0x30(%esp),%eax
   1b580:	25 80 00 00 00       	and    $0x80,%eax
   1b585:	85 c0                	test   %eax,%eax
   1b587:	74 18                	je     1b5a1 <tty_read+0x116>
		other_tty = tty_table + (channel ^ 0x40);
   1b589:	8b 44 24 30          	mov    0x30(%esp),%eax
   1b58d:	83 f0 40             	xor    $0x40,%eax
   1b590:	c1 e0 06             	shl    $0x6,%eax
   1b593:	89 c2                	mov    %eax,%edx
   1b595:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1b59b:	01 d0                	add    %edx,%eax
   1b59d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	// 然后根据VTIME和VMIN对应的控制字符数组值设置读字符操作超时定时值time和最少需要读取的字符个数minimum。在非规范
	// 模式下，这两个是超时定时值。VMIN表示为了满足读操作而需要读取的最少字符个数。VTIME是一个1/10秒计数计时值。
	time = 10L * tty->termios.c_cc[VTIME];            				// 设置读操作超时定时值。
   1b5a1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b5a5:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   1b5a9:	0f b6 d0             	movzbl %al,%edx
   1b5ac:	89 d0                	mov    %edx,%eax
   1b5ae:	c1 e0 02             	shl    $0x2,%eax
   1b5b1:	01 d0                	add    %edx,%eax
   1b5b3:	01 c0                	add    %eax,%eax
   1b5b5:	89 44 24 10          	mov    %eax,0x10(%esp)
	minimum = tty->termios.c_cc[VMIN];              				// 最少需要读取的字符个数。
   1b5b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b5bd:	0f b6 40 17          	movzbl 0x17(%eax),%eax
   1b5c1:	0f b6 c0             	movzbl %al,%eax
   1b5c4:	89 44 24 14          	mov    %eax,0x14(%esp)
	// 定时值为无限大，以让进程先读取辅助队列中已有字符。如果读到的字符数不足minimum的话，后面代码会根据指定的超时值time
	// 来设置进程的读超时值timeout，并会等待读取其余字符。若此时没有设置最少读取字符数minimum（为0），则将其设置为进程
	// 欲读字符数nr，并且如果设置了超时定时值time的话，就把进程读字符超时定时值timeout设置为系统当前时间值+指定的超时
	// 值time，同时复位time。另外，如果以上设置的最少读取字符数minimum大于进程欲读取的字符数nr，则让minimum=nr。即对
	// 于规范模式下的读取操作，它不受VTIME和VMIN对应控制字符值的约束和控制，它们仅在非规范模式（生模式）操作中起作用。
	if (L_CANON(tty)) {
   1b5c8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b5cc:	8b 40 0c             	mov    0xc(%eax),%eax
   1b5cf:	83 e0 02             	and    $0x2,%eax
   1b5d2:	85 c0                	test   %eax,%eax
   1b5d4:	74 24                	je     1b5fa <tty_read+0x16f>
		minimum = nr;
   1b5d6:	8b 44 24 38          	mov    0x38(%esp),%eax
   1b5da:	89 44 24 14          	mov    %eax,0x14(%esp)
		current->timeout = 0xffffffff;
   1b5de:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b5e4:	8b 00                	mov    (%eax),%eax
   1b5e6:	c7 80 d8 02 00 00 ff 	movl   $0xffffffff,0x2d8(%eax)
   1b5ed:	ff ff ff 
		time = 0;
   1b5f0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   1b5f7:	00 
   1b5f8:	eb 4e                	jmp    1b648 <tty_read+0x1bd>
	} else if (minimum)
   1b5fa:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1b5ff:	74 14                	je     1b615 <tty_read+0x18a>
		current->timeout = 0xffffffff;
   1b601:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b607:	8b 00                	mov    (%eax),%eax
   1b609:	c7 80 d8 02 00 00 ff 	movl   $0xffffffff,0x2d8(%eax)
   1b610:	ff ff ff 
   1b613:	eb 33                	jmp    1b648 <tty_read+0x1bd>
	else {
		minimum = nr;
   1b615:	8b 44 24 38          	mov    0x38(%esp),%eax
   1b619:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (time)
   1b61d:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1b622:	74 1c                	je     1b640 <tty_read+0x1b5>
			current->timeout = time + jiffies;
   1b624:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1b628:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   1b62e:	8b 10                	mov    (%eax),%edx
   1b630:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b636:	8b 00                	mov    (%eax),%eax
   1b638:	01 ca                	add    %ecx,%edx
   1b63a:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%eax)
		time = 0;
   1b640:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   1b647:	00 
	}
	if (minimum > nr)
   1b648:	8b 44 24 14          	mov    0x14(%esp),%eax
   1b64c:	3b 44 24 38          	cmp    0x38(%esp),%eax
   1b650:	0f 8e 59 02 00 00    	jle    1b8af <tty_read+0x424>
		minimum = nr;           									// 最多读取要求的字符数。
   1b656:	8b 44 24 38          	mov    0x38(%esp),%eax
   1b65a:	89 44 24 14          	mov    %eax,0x14(%esp)
	// 现在我们开始从辅助队列中循环取出字符并放到用户缓冲区buf中。当欲读的字节数大于0,则执行以下循环操作。在循环过程中
	// 如果当前终端是伪终端，那么我们就执行其对应的另一个伪终端的写操作函数，让另一个伪终端把字符写入当前伪终端辅助队列
	// 缓冲区中。即让另一终端把写队列缓冲区中字符复制到当前伪终端读队列缓冲区中，并经行规则函数转换后放入当前伪终端辅助
	// 队列中。
	while (nr > 0) {
   1b65e:	e9 4c 02 00 00       	jmp    1b8af <tty_read+0x424>
		if (other_tty)
   1b663:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   1b668:	74 13                	je     1b67d <tty_read+0x1f2>
			other_tty->write(other_tty);
   1b66a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1b66e:	8b 40 30             	mov    0x30(%eax),%eax
   1b671:	83 ec 0c             	sub    $0xc,%esp
   1b674:	ff 74 24 28          	pushl  0x28(%esp)
   1b678:	ff d0                	call   *%eax
   1b67a:	83 c4 10             	add    $0x10,%esp
		// 如果tty辅助缓冲队列为空，或者设置了规范模式标志并且tty读队列缓冲区未满，并且辅助队列中字符行数为0,那么，如果没
		// 有设置过进程读字符超时值（为0），或者当前进程目前收到信号，就先退出循环体。否则如果本终端是一个从伪终端，并且其
		// 对应的主伪终端已经挂断，那么我们也退出循环体。如果不是以上这两种情况，我们就让当前进程进入可中断睡眠状态，返回后
		// 继续处理。由于规范模式时内核以行为单位为用户提供数据，因此在该模式下辅助队列中必须至少有一行字符可供取胜，即
		// secondary.data起码是1才行。
		cli();
   1b67d:	fa                   	cli    
		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
   1b67e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b682:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b685:	8b 50 04             	mov    0x4(%eax),%edx
   1b688:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b68c:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b68f:	8b 40 08             	mov    0x8(%eax),%eax
   1b692:	39 c2                	cmp    %eax,%edx
   1b694:	74 47                	je     1b6dd <tty_read+0x252>
   1b696:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b69a:	8b 40 0c             	mov    0xc(%eax),%eax
   1b69d:	83 e0 02             	and    $0x2,%eax
   1b6a0:	85 c0                	test   %eax,%eax
   1b6a2:	0f 84 ac 00 00 00    	je     1b754 <tty_read+0x2c9>
		    !FULL(tty->read_q) && !tty->secondary->data)) {
   1b6a8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b6ac:	8b 40 34             	mov    0x34(%eax),%eax
   1b6af:	8b 50 08             	mov    0x8(%eax),%edx
   1b6b2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b6b6:	8b 40 34             	mov    0x34(%eax),%eax
   1b6b9:	8b 40 04             	mov    0x4(%eax),%eax
   1b6bc:	29 c2                	sub    %eax,%edx
   1b6be:	89 d0                	mov    %edx,%eax
   1b6c0:	83 e8 01             	sub    $0x1,%eax
   1b6c3:	25 ff 03 00 00       	and    $0x3ff,%eax
		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
   1b6c8:	85 c0                	test   %eax,%eax
   1b6ca:	0f 84 84 00 00 00    	je     1b754 <tty_read+0x2c9>
		    !FULL(tty->read_q) && !tty->secondary->data)) {
   1b6d0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b6d4:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b6d7:	8b 00                	mov    (%eax),%eax
   1b6d9:	85 c0                	test   %eax,%eax
   1b6db:	75 77                	jne    1b754 <tty_read+0x2c9>
			if (!current->timeout ||
   1b6dd:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b6e3:	8b 00                	mov    (%eax),%eax
   1b6e5:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
   1b6eb:	85 c0                	test   %eax,%eax
   1b6ed:	74 21                	je     1b710 <tty_read+0x285>
			  (current->signal & ~current->blocked)) {
   1b6ef:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b6f5:	8b 00                	mov    (%eax),%eax
   1b6f7:	8b 50 0c             	mov    0xc(%eax),%edx
   1b6fa:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b700:	8b 00                	mov    (%eax),%eax
   1b702:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   1b708:	f7 d0                	not    %eax
   1b70a:	21 d0                	and    %edx,%eax
			if (!current->timeout ||
   1b70c:	85 c0                	test   %eax,%eax
   1b70e:	74 06                	je     1b716 <tty_read+0x28b>
			  	sti();
   1b710:	fb                   	sti    
				break;
   1b711:	e9 a7 01 00 00       	jmp    1b8bd <tty_read+0x432>
			}
			if (IS_A_PTY_SLAVE(channel) && C_HUP(other_tty))
   1b716:	8b 44 24 30          	mov    0x30(%esp),%eax
   1b71a:	25 c0 00 00 00       	and    $0xc0,%eax
   1b71f:	3d c0 00 00 00       	cmp    $0xc0,%eax
   1b724:	75 12                	jne    1b738 <tty_read+0x2ad>
   1b726:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1b72a:	8b 40 08             	mov    0x8(%eax),%eax
   1b72d:	83 e0 0f             	and    $0xf,%eax
   1b730:	85 c0                	test   %eax,%eax
   1b732:	0f 84 84 01 00 00    	je     1b8bc <tty_read+0x431>
				break;
			interruptible_sleep_on(&tty->secondary->proc_list);
   1b738:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b73c:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b73f:	83 c0 0c             	add    $0xc,%eax
   1b742:	83 ec 0c             	sub    $0xc,%esp
   1b745:	50                   	push   %eax
   1b746:	e8 16 bb fe ff       	call   7261 <interruptible_sleep_on>
   1b74b:	83 c4 10             	add    $0x10,%esp
			sti();
   1b74e:	fb                   	sti    
			continue;
   1b74f:	e9 5b 01 00 00       	jmp    1b8af <tty_read+0x424>
		}
		sti();
   1b754:	fb                   	sti    
		// 现在还没有遇到文件结束符或者正处于原始（非规范）模式。在这种模式中用户以字符流作为读取对象，也不识别其中的控制字符
		// （如文件结束符）。于是将字符直接放入用户数据缓冲区buf中，并把欲读字符数减1.此时如果欲读字符数已为0则中断循环。另外
		// 如果终端处于规范模式并且读取的字符是换行符NL（10），则也退出循环。除此之外，只要还没有取完欲读字符数nr并且辅助队列
		// 不空，就继续取队列中的字符。
		do {
			GETCH(tty->secondary, c);
   1b755:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b759:	8b 50 3c             	mov    0x3c(%eax),%edx
   1b75c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b760:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b763:	8b 40 08             	mov    0x8(%eax),%eax
   1b766:	0f b6 44 02 10       	movzbl 0x10(%edx,%eax,1),%eax
   1b76b:	88 44 24 0b          	mov    %al,0xb(%esp)
   1b76f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b773:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b776:	8b 40 08             	mov    0x8(%eax),%eax
   1b779:	8d 50 01             	lea    0x1(%eax),%edx
   1b77c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b780:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b783:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1b789:	89 50 08             	mov    %edx,0x8(%eax)
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) || c == 10)
   1b78c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b790:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1b794:	84 c0                	test   %al,%al
   1b796:	74 14                	je     1b7ac <tty_read+0x321>
   1b798:	0f be 54 24 0b       	movsbl 0xb(%esp),%edx
   1b79d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b7a1:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1b7a5:	0f b6 c0             	movzbl %al,%eax
   1b7a8:	39 c2                	cmp    %eax,%edx
   1b7aa:	74 07                	je     1b7b3 <tty_read+0x328>
   1b7ac:	80 7c 24 0b 0a       	cmpb   $0xa,0xb(%esp)
   1b7b1:	75 0e                	jne    1b7c1 <tty_read+0x336>
				tty->secondary->data--;
   1b7b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b7b7:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b7ba:	8b 10                	mov    (%eax),%edx
   1b7bc:	83 ea 01             	sub    $0x1,%edx
   1b7bf:	89 10                	mov    %edx,(%eax)
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) && L_CANON(tty))
   1b7c1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b7c5:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1b7c9:	84 c0                	test   %al,%al
   1b7cb:	74 22                	je     1b7ef <tty_read+0x364>
   1b7cd:	0f be 54 24 0b       	movsbl 0xb(%esp),%edx
   1b7d2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b7d6:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1b7da:	0f b6 c0             	movzbl %al,%eax
   1b7dd:	39 c2                	cmp    %eax,%edx
   1b7df:	75 0e                	jne    1b7ef <tty_read+0x364>
   1b7e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b7e5:	8b 40 0c             	mov    0xc(%eax),%eax
   1b7e8:	83 e0 02             	and    $0x2,%eax
   1b7eb:	85 c0                	test   %eax,%eax
   1b7ed:	75 67                	jne    1b856 <tty_read+0x3cb>
				break;
			else {
				put_fs_byte(c, b++);
   1b7ef:	8b 44 24 18          	mov    0x18(%esp),%eax
   1b7f3:	8d 50 01             	lea    0x1(%eax),%edx
   1b7f6:	89 54 24 18          	mov    %edx,0x18(%esp)
   1b7fa:	0f be 54 24 0b       	movsbl 0xb(%esp),%edx
   1b7ff:	83 ec 08             	sub    $0x8,%esp
   1b802:	50                   	push   %eax
   1b803:	52                   	push   %edx
   1b804:	e8 62 f2 ff ff       	call   1aa6b <put_fs_byte>
   1b809:	83 c4 10             	add    $0x10,%esp
				if (!--nr)
   1b80c:	83 6c 24 38 01       	subl   $0x1,0x38(%esp)
   1b811:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   1b816:	74 3a                	je     1b852 <tty_read+0x3c7>
					break;
			}
			if (c == 10 && L_CANON(tty))
   1b818:	80 7c 24 0b 0a       	cmpb   $0xa,0xb(%esp)
   1b81d:	75 0e                	jne    1b82d <tty_read+0x3a2>
   1b81f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b823:	8b 40 0c             	mov    0xc(%eax),%eax
   1b826:	83 e0 02             	and    $0x2,%eax
   1b829:	85 c0                	test   %eax,%eax
   1b82b:	75 28                	jne    1b855 <tty_read+0x3ca>
				break;
		} while (nr > 0 && !EMPTY(tty->secondary));
   1b82d:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   1b832:	7e 22                	jle    1b856 <tty_read+0x3cb>
   1b834:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b838:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b83b:	8b 50 04             	mov    0x4(%eax),%edx
   1b83e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b842:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b845:	8b 40 08             	mov    0x8(%eax),%eax
   1b848:	39 c2                	cmp    %eax,%edx
   1b84a:	0f 85 05 ff ff ff    	jne    1b755 <tty_read+0x2ca>
   1b850:	eb 04                	jmp    1b856 <tty_read+0x3cb>
					break;
   1b852:	90                   	nop
   1b853:	eb 01                	jmp    1b856 <tty_read+0x3cb>
				break;
   1b855:	90                   	nop
		// 执行到此，那么如果tty终端处于规范模式下，说明我们可能读到了换行符或者遇到了文件结束符。如果是处于非规范模式下，那么
		// 说明我们已经读取了nr个字符，或者辅助队列已经被取空了。于是我们首先唤醒等待队列的进程，然后看看是否设置过超时定时值
		// time。如果超时定时值time不为0,我们就要求等待一定的时间让其他进程可以把字符写入读队列中。于是设置进程读超时定时值
		// 为系统当前时间jiffies + 读超时值time。当然，如果终端处于规范模式，或者已经读取nr个字符，我们就可以直接退出这个大
		// 循环了。
		wake_up(&tty->read_q->proc_list);
   1b856:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b85a:	8b 40 34             	mov    0x34(%eax),%eax
   1b85d:	83 c0 0c             	add    $0xc,%eax
   1b860:	83 ec 0c             	sub    $0xc,%esp
   1b863:	50                   	push   %eax
   1b864:	e8 3e ba fe ff       	call   72a7 <wake_up>
   1b869:	83 c4 10             	add    $0x10,%esp
		if (time)
   1b86c:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1b871:	74 1c                	je     1b88f <tty_read+0x404>
			current->timeout = time + jiffies;
   1b873:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1b877:	c7 c0 80 3b 03 00    	mov    $0x33b80,%eax
   1b87d:	8b 10                	mov    (%eax),%edx
   1b87f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b885:	8b 00                	mov    (%eax),%eax
   1b887:	01 ca                	add    %ecx,%edx
   1b889:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%eax)
		if (L_CANON(tty) || b - buf >= minimum)
   1b88f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1b893:	8b 40 0c             	mov    0xc(%eax),%eax
   1b896:	83 e0 02             	and    $0x2,%eax
   1b899:	85 c0                	test   %eax,%eax
   1b89b:	75 20                	jne    1b8bd <tty_read+0x432>
   1b89d:	8b 54 24 18          	mov    0x18(%esp),%edx
   1b8a1:	8b 44 24 34          	mov    0x34(%esp),%eax
   1b8a5:	29 c2                	sub    %eax,%edx
   1b8a7:	89 d0                	mov    %edx,%eax
   1b8a9:	39 44 24 14          	cmp    %eax,0x14(%esp)
   1b8ad:	7e 0e                	jle    1b8bd <tty_read+0x432>
	while (nr > 0) {
   1b8af:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   1b8b4:	0f 8f a9 fd ff ff    	jg     1b663 <tty_read+0x1d8>
   1b8ba:	eb 01                	jmp    1b8bd <tty_read+0x432>
				break;
   1b8bc:	90                   	nop
			break;
    }
	// 此时读取tty字符循环操作结束，因此复位进程的读取超时定时值timeout。如果此时当前进程已收到信号并且还没有读取到任何字符
	// 则以重新启动系统调用号“-ERESTARTSYS”返回。否则就返回已读取的字符数（b-buf）。
	current->timeout = 0;
   1b8bd:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b8c3:	8b 00                	mov    (%eax),%eax
   1b8c5:	c7 80 d8 02 00 00 00 	movl   $0x0,0x2d8(%eax)
   1b8cc:	00 00 00 
	if ((current->signal & ~current->blocked) && !(b - buf))
   1b8cf:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b8d5:	8b 00                	mov    (%eax),%eax
   1b8d7:	8b 50 0c             	mov    0xc(%eax),%edx
   1b8da:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b8e0:	8b 00                	mov    (%eax),%eax
   1b8e2:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   1b8e8:	f7 d0                	not    %eax
   1b8ea:	21 d0                	and    %edx,%eax
   1b8ec:	85 c0                	test   %eax,%eax
   1b8ee:	74 13                	je     1b903 <tty_read+0x478>
   1b8f0:	8b 54 24 18          	mov    0x18(%esp),%edx
   1b8f4:	8b 44 24 34          	mov    0x34(%esp),%eax
   1b8f8:	39 c2                	cmp    %eax,%edx
   1b8fa:	75 07                	jne    1b903 <tty_read+0x478>
		return -ERESTARTSYS;
   1b8fc:	b8 00 fe ff ff       	mov    $0xfffffe00,%eax
   1b901:	eb 0c                	jmp    1b90f <tty_read+0x484>
	return (b - buf);
   1b903:	8b 54 24 18          	mov    0x18(%esp),%edx
   1b907:	8b 44 24 34          	mov    0x34(%esp),%eax
   1b90b:	29 c2                	sub    %eax,%edx
   1b90d:	89 d0                	mov    %edx,%eax
}
   1b90f:	83 c4 28             	add    $0x28,%esp
   1b912:	5b                   	pop    %ebx
   1b913:	c3                   	ret    

0001b914 <tty_write>:
// tty写函数.
// 把用户缓冲区中的字符放入tty写队列缓冲区中.
// 参数:channel - 子设备号;buf - 缓冲区指针;nr - 写字节数.
// 返回已写字节数.
int tty_write(unsigned channel, char * buf, int nr)
{
   1b914:	53                   	push   %ebx
   1b915:	83 ec 18             	sub    $0x18,%esp
   1b918:	e8 dd b3 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1b91d:	81 c3 e3 66 01 00    	add    $0x166e3,%ebx
	static int cr_flag=0;
	struct tty_struct * tty;
	char c, *b = buf;
   1b923:	8b 44 24 24          	mov    0x24(%esp),%eax
   1b927:	89 44 24 08          	mov    %eax,0x8(%esp)

	// 首先判断参数有效性并取终端的tty结构指针.如果tty终端的三个缓冲队列指针都是NULL,则返回EIO出错信息.
	if (channel > 255)
   1b92b:	81 7c 24 20 ff 00 00 	cmpl   $0xff,0x20(%esp)
   1b932:	00 
   1b933:	76 0a                	jbe    1b93f <tty_write+0x2b>
		return -EIO;
   1b935:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   1b93a:	e9 e0 02 00 00       	jmp    1bc1f <tty_write+0x30b>
	tty = TTY_TABLE(channel);
   1b93f:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   1b944:	74 32                	je     1b978 <tty_write+0x64>
   1b946:	83 7c 24 20 3f       	cmpl   $0x3f,0x20(%esp)
   1b94b:	77 18                	ja     1b965 <tty_write+0x51>
   1b94d:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b951:	05 ff ff ff 03       	add    $0x3ffffff,%eax
   1b956:	c1 e0 06             	shl    $0x6,%eax
   1b959:	89 c2                	mov    %eax,%edx
   1b95b:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1b961:	01 d0                	add    %edx,%eax
   1b963:	eb 26                	jmp    1b98b <tty_write+0x77>
   1b965:	8b 44 24 20          	mov    0x20(%esp),%eax
   1b969:	c1 e0 06             	shl    $0x6,%eax
   1b96c:	89 c2                	mov    %eax,%edx
   1b96e:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1b974:	01 d0                	add    %edx,%eax
   1b976:	eb 13                	jmp    1b98b <tty_write+0x77>
   1b978:	8b 83 00 43 00 00    	mov    0x4300(%ebx),%eax
   1b97e:	c1 e0 06             	shl    $0x6,%eax
   1b981:	89 c2                	mov    %eax,%edx
   1b983:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1b989:	01 d0                	add    %edx,%eax
   1b98b:	89 44 24 04          	mov    %eax,0x4(%esp)
	if (!(tty->write_q || tty->read_q || tty->secondary))
   1b98f:	8b 44 24 04          	mov    0x4(%esp),%eax
   1b993:	8b 40 38             	mov    0x38(%eax),%eax
   1b996:	85 c0                	test   %eax,%eax
   1b998:	75 20                	jne    1b9ba <tty_write+0xa6>
   1b99a:	8b 44 24 04          	mov    0x4(%esp),%eax
   1b99e:	8b 40 34             	mov    0x34(%eax),%eax
   1b9a1:	85 c0                	test   %eax,%eax
   1b9a3:	75 15                	jne    1b9ba <tty_write+0xa6>
   1b9a5:	8b 44 24 04          	mov    0x4(%esp),%eax
   1b9a9:	8b 40 3c             	mov    0x3c(%eax),%eax
   1b9ac:	85 c0                	test   %eax,%eax
   1b9ae:	75 0a                	jne    1b9ba <tty_write+0xa6>
		return -EIO;
   1b9b0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   1b9b5:	e9 65 02 00 00       	jmp    1bc1f <tty_write+0x30b>
	// 如果若终端本地模式标志集中设置了TOSTOP,表示后台进程输出时需要发送信号SIGTTOU.如果当前进程使用的是这里正在处理的tty终端,但该终端的进程组号却与当前
	// 进程组号不同,即表示当前进程是后台进程组中的一个进程,即进程不在前台.于是我们要停止当前进程组的所有进程.因此这里就需要向当前进程组发送SIGTTOU信号,并返回
	// 等待成为前台进程组后再执行写操作.
	if (L_TOSTOP(tty) &&
   1b9ba:	8b 44 24 04          	mov    0x4(%esp),%eax
   1b9be:	8b 40 0c             	mov    0xc(%eax),%eax
   1b9c1:	25 00 01 00 00       	and    $0x100,%eax
   1b9c6:	85 c0                	test   %eax,%eax
   1b9c8:	0f 84 37 02 00 00    	je     1bc05 <tty_write+0x2f1>
	    (current->tty == channel) && (tty->pgrp != current->pgrp))
   1b9ce:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b9d4:	8b 00                	mov    (%eax),%eax
   1b9d6:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
	if (L_TOSTOP(tty) &&
   1b9dc:	39 44 24 20          	cmp    %eax,0x20(%esp)
   1b9e0:	0f 85 1f 02 00 00    	jne    1bc05 <tty_write+0x2f1>
	    (current->tty == channel) && (tty->pgrp != current->pgrp))
   1b9e6:	8b 44 24 04          	mov    0x4(%esp),%eax
   1b9ea:	8b 50 24             	mov    0x24(%eax),%edx
   1b9ed:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1b9f3:	8b 00                	mov    (%eax),%eax
   1b9f5:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
   1b9fb:	39 c2                	cmp    %eax,%edx
   1b9fd:	0f 84 02 02 00 00    	je     1bc05 <tty_write+0x2f1>
		return(tty_signal(SIGTTOU, tty));
   1ba03:	83 ec 08             	sub    $0x8,%esp
   1ba06:	ff 74 24 0c          	pushl  0xc(%esp)
   1ba0a:	6a 16                	push   $0x16
   1ba0c:	e8 a8 f9 ff ff       	call   1b3b9 <tty_signal>
   1ba11:	83 c4 10             	add    $0x10,%esp
   1ba14:	e9 06 02 00 00       	jmp    1bc1f <tty_write+0x30b>
	// 现在我们开始从用户缓冲区buf中循环取出字符并放到写队列缓冲区中.当欲写字节数大于0,则执行以下循环操作.在循环过程中,如果此时tty写队列已满,则当前进程进入可中断
	// 睡眠状态.如果当前进程有信号要处理,则退出循环体.
	while (nr > 0) {
		sleep_if_full(tty->write_q);
   1ba19:	8b 44 24 04          	mov    0x4(%esp),%eax
   1ba1d:	8b 40 38             	mov    0x38(%eax),%eax
   1ba20:	83 ec 0c             	sub    $0xc,%esp
   1ba23:	50                   	push   %eax
   1ba24:	e8 42 f1 ff ff       	call   1ab6b <sleep_if_full>
   1ba29:	83 c4 10             	add    $0x10,%esp
		if (current->signal & ~current->blocked)
   1ba2c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1ba32:	8b 00                	mov    (%eax),%eax
   1ba34:	8b 50 0c             	mov    0xc(%eax),%edx
   1ba37:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   1ba3d:	8b 00                	mov    (%eax),%eax
   1ba3f:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   1ba45:	f7 d0                	not    %eax
   1ba47:	21 d0                	and    %edx,%eax
   1ba49:	85 c0                	test   %eax,%eax
   1ba4b:	0f 85 c1 01 00 00    	jne    1bc12 <tty_write+0x2fe>
			break;
		// 当要写的字符数nr还大于0并且tty写队列缓冲区不满,则循环执行以下操作.首先从用户缓冲区中取1字节.
		while (nr > 0 && !FULL(tty->write_q)) {
   1ba51:	e9 61 01 00 00       	jmp    1bbb7 <tty_write+0x2a3>
			c = get_fs_byte(b);
   1ba56:	83 ec 0c             	sub    $0xc,%esp
   1ba59:	ff 74 24 14          	pushl  0x14(%esp)
   1ba5d:	e8 f1 ef ff ff       	call   1aa53 <get_fs_byte>
   1ba62:	83 c4 10             	add    $0x10,%esp
   1ba65:	88 44 24 0f          	mov    %al,0xf(%esp)
			// 如果终端输出模式标志集中的执行输出处理标志OPOST置位,则执行对字符的后处理操作.
			if (O_POST(tty)) {
   1ba69:	8b 44 24 04          	mov    0x4(%esp),%eax
   1ba6d:	8b 40 04             	mov    0x4(%eax),%eax
   1ba70:	83 e0 01             	and    $0x1,%eax
   1ba73:	85 c0                	test   %eax,%eax
   1ba75:	0f 84 f1 00 00 00    	je     1bb6c <tty_write+0x258>
				// 如果该字符是回车符'\r'(CR,13)并且回车符转换行标志OCRNL置位,则将该字符换成行符'\n'(NL,10);
				if (c == '\r' && O_CRNL(tty))
   1ba7b:	80 7c 24 0f 0d       	cmpb   $0xd,0xf(%esp)
   1ba80:	75 15                	jne    1ba97 <tty_write+0x183>
   1ba82:	8b 44 24 04          	mov    0x4(%esp),%eax
   1ba86:	8b 40 04             	mov    0x4(%eax),%eax
   1ba89:	83 e0 08             	and    $0x8,%eax
   1ba8c:	85 c0                	test   %eax,%eax
   1ba8e:	74 07                	je     1ba97 <tty_write+0x183>
					c = '\n';
   1ba90:	c6 44 24 0f 0a       	movb   $0xa,0xf(%esp)
   1ba95:	eb 1a                	jmp    1bab1 <tty_write+0x19d>
				// 如果该字符是换行符'\n'(NL,10)并且换行转回车功能标志ONLRET置位的话,则将该字符换成回车符'\r'(CR,13).
				else if (c == '\n' && O_NLRET(tty))
   1ba97:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1ba9c:	75 13                	jne    1bab1 <tty_write+0x19d>
   1ba9e:	8b 44 24 04          	mov    0x4(%esp),%eax
   1baa2:	8b 40 04             	mov    0x4(%eax),%eax
   1baa5:	83 e0 20             	and    $0x20,%eax
   1baa8:	85 c0                	test   %eax,%eax
   1baaa:	74 05                	je     1bab1 <tty_write+0x19d>
					c = '\r';
   1baac:	c6 44 24 0f 0d       	movb   $0xd,0xf(%esp)
				// 如果该字符是换行符'\n'并且回车标志cr_flag没有置位,但换行转回车-换行标志ONLCR置位的话,则将cr_flag标志置位,并将一回车符放入写队列中.然后继续处理下一个字符.
				if (c == '\n' && !cr_flag && O_NLCR(tty)) {
   1bab1:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1bab6:	75 5a                	jne    1bb12 <tty_write+0x1fe>
   1bab8:	8b 83 80 1e 01 00    	mov    0x11e80(%ebx),%eax
   1babe:	85 c0                	test   %eax,%eax
   1bac0:	75 50                	jne    1bb12 <tty_write+0x1fe>
   1bac2:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bac6:	8b 40 04             	mov    0x4(%eax),%eax
   1bac9:	83 e0 04             	and    $0x4,%eax
   1bacc:	85 c0                	test   %eax,%eax
   1bace:	74 42                	je     1bb12 <tty_write+0x1fe>
					cr_flag = 1;
   1bad0:	c7 83 80 1e 01 00 01 	movl   $0x1,0x11e80(%ebx)
   1bad7:	00 00 00 
					PUTCH(13, tty->write_q);
   1bada:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bade:	8b 50 38             	mov    0x38(%eax),%edx
   1bae1:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bae5:	8b 40 38             	mov    0x38(%eax),%eax
   1bae8:	8b 40 04             	mov    0x4(%eax),%eax
   1baeb:	c6 44 02 10 0d       	movb   $0xd,0x10(%edx,%eax,1)
   1baf0:	8b 44 24 04          	mov    0x4(%esp),%eax
   1baf4:	8b 40 38             	mov    0x38(%eax),%eax
   1baf7:	8b 40 04             	mov    0x4(%eax),%eax
   1bafa:	8d 50 01             	lea    0x1(%eax),%edx
   1bafd:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bb01:	8b 40 38             	mov    0x38(%eax),%eax
   1bb04:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1bb0a:	89 50 04             	mov    %edx,0x4(%eax)
					continue;
   1bb0d:	e9 a5 00 00 00       	jmp    1bbb7 <tty_write+0x2a3>
				}
				// 如果小写转大写标志OLCUC置位的话,就将该字符转成大写字符.
				if (O_LCUC(tty))
   1bb12:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bb16:	8b 40 04             	mov    0x4(%eax),%eax
   1bb19:	83 e0 02             	and    $0x2,%eax
   1bb1c:	85 c0                	test   %eax,%eax
   1bb1e:	74 4c                	je     1bb6c <tty_write+0x258>
					c = toupper(c);									// 小写转成大写字符.
   1bb20:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1bb26:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
   1bb2b:	88 10                	mov    %dl,(%eax)
   1bb2d:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1bb33:	0f b6 00             	movzbl (%eax),%eax
   1bb36:	0f be c0             	movsbl %al,%eax
   1bb39:	8d 50 01             	lea    0x1(%eax),%edx
   1bb3c:	c7 c0 20 36 03 00    	mov    $0x33620,%eax
   1bb42:	01 d0                	add    %edx,%eax
   1bb44:	0f b6 00             	movzbl (%eax),%eax
   1bb47:	0f b6 c0             	movzbl %al,%eax
   1bb4a:	83 e0 02             	and    $0x2,%eax
   1bb4d:	85 c0                	test   %eax,%eax
   1bb4f:	74 0e                	je     1bb5f <tty_write+0x24b>
   1bb51:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1bb57:	0f b6 00             	movzbl (%eax),%eax
   1bb5a:	83 e8 20             	sub    $0x20,%eax
   1bb5d:	eb 09                	jmp    1bb68 <tty_write+0x254>
   1bb5f:	c7 c0 a0 a8 04 00    	mov    $0x4a8a0,%eax
   1bb65:	0f b6 00             	movzbl (%eax),%eax
   1bb68:	88 44 24 0f          	mov    %al,0xf(%esp)
			}
			// 接着把用户数据缓冲指针b前移1字节;欲写字节数减1字节;复位cr_flag标志,并将该字节放入tty写队列中.
			b++; nr--;
   1bb6c:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   1bb71:	83 6c 24 28 01       	subl   $0x1,0x28(%esp)
			cr_flag = 0;
   1bb76:	c7 83 80 1e 01 00 00 	movl   $0x0,0x11e80(%ebx)
   1bb7d:	00 00 00 
			PUTCH(c, tty->write_q);
   1bb80:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bb84:	8b 50 38             	mov    0x38(%eax),%edx
   1bb87:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bb8b:	8b 40 38             	mov    0x38(%eax),%eax
   1bb8e:	8b 40 04             	mov    0x4(%eax),%eax
   1bb91:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
   1bb96:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   1bb9a:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bb9e:	8b 40 38             	mov    0x38(%eax),%eax
   1bba1:	8b 40 04             	mov    0x4(%eax),%eax
   1bba4:	8d 50 01             	lea    0x1(%eax),%edx
   1bba7:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bbab:	8b 40 38             	mov    0x38(%eax),%eax
   1bbae:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1bbb4:	89 50 04             	mov    %edx,0x4(%eax)
		while (nr > 0 && !FULL(tty->write_q)) {
   1bbb7:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1bbbc:	7e 28                	jle    1bbe6 <tty_write+0x2d2>
   1bbbe:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bbc2:	8b 40 38             	mov    0x38(%eax),%eax
   1bbc5:	8b 50 08             	mov    0x8(%eax),%edx
   1bbc8:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bbcc:	8b 40 38             	mov    0x38(%eax),%eax
   1bbcf:	8b 40 04             	mov    0x4(%eax),%eax
   1bbd2:	29 c2                	sub    %eax,%edx
   1bbd4:	89 d0                	mov    %edx,%eax
   1bbd6:	83 e8 01             	sub    $0x1,%eax
   1bbd9:	25 ff 03 00 00       	and    $0x3ff,%eax
   1bbde:	85 c0                	test   %eax,%eax
   1bbe0:	0f 85 70 fe ff ff    	jne    1ba56 <tty_write+0x142>
		}
		// 若要求的字符全部写完,或者写队列已满,则程序退出循环.此时会调用对应tty写函数,把写队列缓冲区中的字符显示在控制台屏幕上,或者通过串行端口发送出去.如果当前处理的tty
		// 是控制台终端,那么tty->write()调用的是con_write();如果tty是串行终端,则tty->write()调用的是rs_write()函数.若还有字节要写,则等待写队列中字符取走.
		// 所以这里调用调度程序,先去执行其他任务.
		tty->write(tty);
   1bbe6:	8b 44 24 04          	mov    0x4(%esp),%eax
   1bbea:	8b 40 30             	mov    0x30(%eax),%eax
   1bbed:	83 ec 0c             	sub    $0xc,%esp
   1bbf0:	ff 74 24 10          	pushl  0x10(%esp)
   1bbf4:	ff d0                	call   *%eax
   1bbf6:	83 c4 10             	add    $0x10,%esp
		if (nr > 0)
   1bbf9:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1bbfe:	7e 05                	jle    1bc05 <tty_write+0x2f1>
			schedule();
   1bc00:	e8 46 b3 fe ff       	call   6f4b <schedule>
	while (nr > 0) {
   1bc05:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1bc0a:	0f 8f 09 fe ff ff    	jg     1ba19 <tty_write+0x105>
   1bc10:	eb 01                	jmp    1bc13 <tty_write+0x2ff>
			break;
   1bc12:	90                   	nop
        }
	return (b - buf);												// 最后返回写入的字节数.
   1bc13:	8b 54 24 08          	mov    0x8(%esp),%edx
   1bc17:	8b 44 24 24          	mov    0x24(%esp),%eax
   1bc1b:	29 c2                	sub    %eax,%edx
   1bc1d:	89 d0                	mov    %edx,%eax
}
   1bc1f:	83 c4 18             	add    $0x18,%esp
   1bc22:	5b                   	pop    %ebx
   1bc23:	c3                   	ret    

0001bc24 <do_tty_interrupt>:
// tty中断处理调用函数 - 字符规范模式处理.
// 参数:tty - 指定的tty终端号.
// 将指定tty终端队列缓冲区中的字符复制或转换成规范(熟)模式字符并存放在辅助队列中.该函数会在串口读字符中断(rs_io.s)和键盘中断(
// kerboard.S)中被调用.
void do_tty_interrupt(int tty)
{
   1bc24:	83 ec 0c             	sub    $0xc,%esp
   1bc27:	e8 c6 b0 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1bc2c:	05 d4 63 01 00       	add    $0x163d4,%eax
	copy_to_cooked(TTY_TABLE(tty));
   1bc31:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1bc36:	74 2c                	je     1bc64 <do_tty_interrupt+0x40>
   1bc38:	83 7c 24 10 3f       	cmpl   $0x3f,0x10(%esp)
   1bc3d:	7f 14                	jg     1bc53 <do_tty_interrupt+0x2f>
   1bc3f:	8b 54 24 10          	mov    0x10(%esp),%edx
   1bc43:	83 ea 01             	sub    $0x1,%edx
   1bc46:	c1 e2 06             	shl    $0x6,%edx
   1bc49:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bc4f:	01 d0                	add    %edx,%eax
   1bc51:	eb 22                	jmp    1bc75 <do_tty_interrupt+0x51>
   1bc53:	8b 54 24 10          	mov    0x10(%esp),%edx
   1bc57:	c1 e2 06             	shl    $0x6,%edx
   1bc5a:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bc60:	01 d0                	add    %edx,%eax
   1bc62:	eb 11                	jmp    1bc75 <do_tty_interrupt+0x51>
   1bc64:	8b 90 00 43 00 00    	mov    0x4300(%eax),%edx
   1bc6a:	c1 e2 06             	shl    $0x6,%edx
   1bc6d:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bc73:	01 d0                	add    %edx,%eax
   1bc75:	83 ec 0c             	sub    $0xc,%esp
   1bc78:	50                   	push   %eax
   1bc79:	e8 ad ef ff ff       	call   1ac2b <copy_to_cooked>
   1bc7e:	83 c4 10             	add    $0x10,%esp
}
   1bc81:	90                   	nop
   1bc82:	83 c4 0c             	add    $0xc,%esp
   1bc85:	c3                   	ret    

0001bc86 <chr_dev_init>:

//字符设备初始化函数.空,为以后扩展做准备.
void chr_dev_init(void)
{
   1bc86:	e8 67 b0 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1bc8b:	05 75 63 01 00       	add    $0x16375,%eax
}
   1bc90:	90                   	nop
   1bc91:	c3                   	ret    

0001bc92 <tty_init>:

// tty终端初始化函数
// 初始化所有终端缓冲队列,初始化串口终端和控制台终端.
void tty_init(void)
{
   1bc92:	57                   	push   %edi
   1bc93:	56                   	push   %esi
   1bc94:	53                   	push   %ebx
   1bc95:	83 ec 10             	sub    $0x10,%esp
   1bc98:	e8 5d b0 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1bc9d:	81 c3 63 63 01 00    	add    $0x16363,%ebx
	int i;

	// 首先初始化所有终端的缓冲队列结构,设置初值.对于串行终端的读/写缓冲队列,将它们的data字段设置为串行端口基地址值.串中1是0x3f8,
	// 串口2是0x2f8.然后先初步设置所有终端的tty结构.
	// 其中特殊字符数组c_cc[]设置的初值定义在include/linux/tty.h文件中.
	for (i = 0 ; i < QUEUES ; i++)
   1bca3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1bcaa:	00 
   1bcab:	e9 91 00 00 00       	jmp    1bd41 <tty_init+0xaf>
		tty_queues[i] = (struct tty_queue) {0, 0, 0, 0, ""};
   1bcb0:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bcb4:	8d 83 20 43 00 00    	lea    0x4320(%ebx),%eax
   1bcba:	69 d2 10 04 00 00    	imul   $0x410,%edx,%edx
   1bcc0:	01 d0                	add    %edx,%eax
   1bcc2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bcc8:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bccc:	8d 83 24 43 00 00    	lea    0x4324(%ebx),%eax
   1bcd2:	69 d2 10 04 00 00    	imul   $0x410,%edx,%edx
   1bcd8:	01 d0                	add    %edx,%eax
   1bcda:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bce0:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bce4:	8d 83 28 43 00 00    	lea    0x4328(%ebx),%eax
   1bcea:	69 d2 10 04 00 00    	imul   $0x410,%edx,%edx
   1bcf0:	01 d0                	add    %edx,%eax
   1bcf2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bcf8:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bcfc:	8d 83 2c 43 00 00    	lea    0x432c(%ebx),%eax
   1bd02:	69 d2 10 04 00 00    	imul   $0x410,%edx,%edx
   1bd08:	01 d0                	add    %edx,%eax
   1bd0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bd10:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bd14:	8d 83 20 43 00 00    	lea    0x4320(%ebx),%eax
   1bd1a:	69 d2 10 04 00 00    	imul   $0x410,%edx,%edx
   1bd20:	01 d0                	add    %edx,%eax
   1bd22:	83 c0 10             	add    $0x10,%eax
   1bd25:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bd2b:	8d 50 04             	lea    0x4(%eax),%edx
   1bd2e:	b8 00 00 00 00       	mov    $0x0,%eax
   1bd33:	b9 ff 00 00 00       	mov    $0xff,%ecx
   1bd38:	89 d7                	mov    %edx,%edi
   1bd3a:	f3 ab                	rep stos %eax,%es:(%edi)
	for (i = 0 ; i < QUEUES ; i++)
   1bd3c:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1bd41:	83 7c 24 0c 35       	cmpl   $0x35,0xc(%esp)
   1bd46:	0f 8e 64 ff ff ff    	jle    1bcb0 <tty_init+0x1e>
	rs_queues[0] = (struct tty_queue) {0x3f8, 0, 0, 0, ""};
   1bd4c:	8d 83 a0 a4 00 00    	lea    0xa4a0(%ebx),%eax
   1bd52:	8d 93 e0 5a ff ff    	lea    -0xa520(%ebx),%edx
   1bd58:	b9 04 01 00 00       	mov    $0x104,%ecx
   1bd5d:	89 c7                	mov    %eax,%edi
   1bd5f:	89 d6                	mov    %edx,%esi
   1bd61:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	rs_queues[1] = (struct tty_queue) {0x3f8, 0, 0, 0, ""};
   1bd63:	8d 83 b0 a8 00 00    	lea    0xa8b0(%ebx),%eax
   1bd69:	8d 93 e0 5a ff ff    	lea    -0xa520(%ebx),%edx
   1bd6f:	b9 04 01 00 00       	mov    $0x104,%ecx
   1bd74:	89 c7                	mov    %eax,%edi
   1bd76:	89 d6                	mov    %edx,%esi
   1bd78:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	rs_queues[3] = (struct tty_queue) {0x2f8, 0, 0, 0, ""};
   1bd7a:	8d 83 d0 b0 00 00    	lea    0xb0d0(%ebx),%eax
   1bd80:	8d 93 00 5f ff ff    	lea    -0xa100(%ebx),%edx
   1bd86:	b9 04 01 00 00       	mov    $0x104,%ecx
   1bd8b:	89 c7                	mov    %eax,%edi
   1bd8d:	89 d6                	mov    %edx,%esi
   1bd8f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	rs_queues[4] = (struct tty_queue) {0x2f8, 0, 0, 0, ""};
   1bd91:	8d 83 e0 b4 00 00    	lea    0xb4e0(%ebx),%eax
   1bd97:	8d 93 00 5f ff ff    	lea    -0xa100(%ebx),%edx
   1bd9d:	b9 04 01 00 00       	mov    $0x104,%ecx
   1bda2:	89 c7                	mov    %eax,%edi
   1bda4:	89 d6                	mov    %edx,%esi
   1bda6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	for (i = 0 ; i < 256 ; i++) {
   1bda8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1bdaf:	00 
   1bdb0:	e9 5f 01 00 00       	jmp    1bf14 <tty_init+0x282>
		tty_table[i] =  (struct tty_struct) {
   1bdb5:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bdbb:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bdbf:	c1 e2 06             	shl    $0x6,%edx
   1bdc2:	01 d0                	add    %edx,%eax
   1bdc4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bdca:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bdd0:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bdd4:	c1 e2 06             	shl    $0x6,%edx
   1bdd7:	01 d0                	add    %edx,%eax
   1bdd9:	83 c0 04             	add    $0x4,%eax
   1bddc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bde2:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bde8:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bdec:	c1 e2 06             	shl    $0x6,%edx
   1bdef:	01 d0                	add    %edx,%eax
   1bdf1:	83 c0 08             	add    $0x8,%eax
   1bdf4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bdfa:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1be00:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1be04:	c1 e2 06             	shl    $0x6,%edx
   1be07:	01 d0                	add    %edx,%eax
   1be09:	83 c0 0c             	add    $0xc,%eax
   1be0c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1be12:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1be18:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1be1c:	c1 e2 06             	shl    $0x6,%edx
   1be1f:	01 d0                	add    %edx,%eax
   1be21:	83 c0 10             	add    $0x10,%eax
   1be24:	c6 00 00             	movb   $0x0,(%eax)
   1be27:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1be2d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1be31:	c1 e2 06             	shl    $0x6,%edx
   1be34:	01 d0                	add    %edx,%eax
   1be36:	83 c0 10             	add    $0x10,%eax
   1be39:	8b 93 10 63 ff ff    	mov    -0x9cf0(%ebx),%edx
   1be3f:	89 50 01             	mov    %edx,0x1(%eax)
   1be42:	8b 93 14 63 ff ff    	mov    -0x9cec(%ebx),%edx
   1be48:	89 50 05             	mov    %edx,0x5(%eax)
   1be4b:	8b 93 18 63 ff ff    	mov    -0x9ce8(%ebx),%edx
   1be51:	89 50 09             	mov    %edx,0x9(%eax)
   1be54:	8b 93 1c 63 ff ff    	mov    -0x9ce4(%ebx),%edx
   1be5a:	89 50 0d             	mov    %edx,0xd(%eax)
   1be5d:	0f b6 93 20 63 ff ff 	movzbl -0x9ce0(%ebx),%edx
   1be64:	88 50 11             	mov    %dl,0x11(%eax)
   1be67:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1be6d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1be71:	c1 e2 06             	shl    $0x6,%edx
   1be74:	01 d0                	add    %edx,%eax
   1be76:	83 c0 24             	add    $0x24,%eax
   1be79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1be7f:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1be85:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1be89:	c1 e2 06             	shl    $0x6,%edx
   1be8c:	01 d0                	add    %edx,%eax
   1be8e:	83 c0 28             	add    $0x28,%eax
   1be91:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1be97:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1be9d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bea1:	c1 e2 06             	shl    $0x6,%edx
   1bea4:	01 d0                	add    %edx,%eax
   1bea6:	83 c0 2c             	add    $0x2c,%eax
   1bea9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1beaf:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1beb5:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1beb9:	c1 e2 06             	shl    $0x6,%edx
   1bebc:	01 d0                	add    %edx,%eax
   1bebe:	83 c0 30             	add    $0x30,%eax
   1bec1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bec7:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1becd:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bed1:	c1 e2 06             	shl    $0x6,%edx
   1bed4:	01 d0                	add    %edx,%eax
   1bed6:	83 c0 34             	add    $0x34,%eax
   1bed9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bedf:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bee5:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bee9:	c1 e2 06             	shl    $0x6,%edx
   1beec:	01 d0                	add    %edx,%eax
   1beee:	83 c0 38             	add    $0x38,%eax
   1bef1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bef7:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1befd:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bf01:	c1 e2 06             	shl    $0x6,%edx
   1bf04:	01 d0                	add    %edx,%eax
   1bf06:	83 c0 3c             	add    $0x3c,%eax
   1bf09:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	for (i = 0 ; i < 256 ; i++) {
   1bf0f:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1bf14:	81 7c 24 0c ff 00 00 	cmpl   $0xff,0xc(%esp)
   1bf1b:	00 
   1bf1c:	0f 8e 93 fe ff ff    	jle    1bdb5 <tty_init+0x123>
	// 接着初始化控制台终端(console.c).把con_init()放在这里,是因为我们需要根据显示卡类型和显示内存容量来确定系统虚拟控制台的数量
	// NR_CONSOLES.该值被用于随后的控制tty结构初始化循环中.对于控制台的tty结构,425--430行是tty结构中包含的termios结构字段.其中
	// 输入模式标志集被初始化为ICRNL标志;输出模式标志被初始化含有后处理标志OPOST和把NL转换成CRNL的标志ONLCR;本地模式标志集被初始化
	// 含有IXON,ICAON,ECHO,ECHOCTL和ECHOKE标志;控制字符数组c_cc[]被设置含有初始值INIT_C_CC.
	// 435行上初始化控制台终端tty结构中的读缓冲,写缓冲和辅助缓冲队列结构,它们分别指向tty缓冲队列结构数组tty_table[]中的相应结构项.
	con_init();
   1bf22:	e8 c6 39 00 00       	call   1f8ed <con_init>
	for (i = 0 ; i < NR_CONSOLES ; i++) {
   1bf27:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1bf2e:	00 
   1bf2f:	e9 9c 01 00 00       	jmp    1c0d0 <tty_init+0x43e>
			INIT_C_CC},												// 控制字符数组c_cc[]
			0,														/* initial pgrp */	// 所属初始进程组pgrp
			0,														/* initial session */	// 初始会话级session
			0,														/* initial stopped */	// 初始停止标志stopped
			con_write,
			con_queues + 0 + i * 3, con_queues + 1 + i * 3, con_queues + 2 + i * 3
   1bf34:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1bf38:	69 c0 30 0c 00 00    	imul   $0xc30,%eax,%eax
   1bf3e:	89 c2                	mov    %eax,%edx
   1bf40:	8d 83 20 43 00 00    	lea    0x4320(%ebx),%eax
   1bf46:	8d 3c 02             	lea    (%edx,%eax,1),%edi
   1bf49:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1bf4d:	69 c0 30 0c 00 00    	imul   $0xc30,%eax,%eax
   1bf53:	8d 90 10 04 00 00    	lea    0x410(%eax),%edx
   1bf59:	8d 83 20 43 00 00    	lea    0x4320(%ebx),%eax
   1bf5f:	8d 34 02             	lea    (%edx,%eax,1),%esi
   1bf62:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1bf66:	69 c0 30 0c 00 00    	imul   $0xc30,%eax,%eax
   1bf6c:	8d 90 20 08 00 00    	lea    0x820(%eax),%edx
   1bf72:	8d 83 20 43 00 00    	lea    0x4320(%ebx),%eax
   1bf78:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
		con_table[i] = (struct tty_struct) {
   1bf7b:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bf81:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bf85:	c1 e2 06             	shl    $0x6,%edx
   1bf88:	01 d0                	add    %edx,%eax
   1bf8a:	c7 00 00 01 00 00    	movl   $0x100,(%eax)
   1bf90:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bf96:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bf9a:	c1 e2 06             	shl    $0x6,%edx
   1bf9d:	01 d0                	add    %edx,%eax
   1bf9f:	83 c0 04             	add    $0x4,%eax
   1bfa2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1bfa8:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bfae:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bfb2:	c1 e2 06             	shl    $0x6,%edx
   1bfb5:	01 d0                	add    %edx,%eax
   1bfb7:	83 c0 08             	add    $0x8,%eax
   1bfba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1bfc0:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bfc6:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bfca:	c1 e2 06             	shl    $0x6,%edx
   1bfcd:	01 d0                	add    %edx,%eax
   1bfcf:	83 c0 0c             	add    $0xc,%eax
   1bfd2:	c7 00 0b 0e 00 00    	movl   $0xe0b,(%eax)
   1bfd8:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bfde:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bfe2:	c1 e2 06             	shl    $0x6,%edx
   1bfe5:	01 d0                	add    %edx,%eax
   1bfe7:	83 c0 10             	add    $0x10,%eax
   1bfea:	c6 00 00             	movb   $0x0,(%eax)
   1bfed:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1bff3:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1bff7:	c1 e2 06             	shl    $0x6,%edx
   1bffa:	01 d0                	add    %edx,%eax
   1bffc:	83 c0 10             	add    $0x10,%eax
   1bfff:	8b 93 10 63 ff ff    	mov    -0x9cf0(%ebx),%edx
   1c005:	89 50 01             	mov    %edx,0x1(%eax)
   1c008:	8b 93 14 63 ff ff    	mov    -0x9cec(%ebx),%edx
   1c00e:	89 50 05             	mov    %edx,0x5(%eax)
   1c011:	8b 93 18 63 ff ff    	mov    -0x9ce8(%ebx),%edx
   1c017:	89 50 09             	mov    %edx,0x9(%eax)
   1c01a:	8b 93 1c 63 ff ff    	mov    -0x9ce4(%ebx),%edx
   1c020:	89 50 0d             	mov    %edx,0xd(%eax)
   1c023:	0f b6 93 20 63 ff ff 	movzbl -0x9ce0(%ebx),%edx
   1c02a:	88 50 11             	mov    %dl,0x11(%eax)
   1c02d:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c033:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c037:	c1 e2 06             	shl    $0x6,%edx
   1c03a:	01 d0                	add    %edx,%eax
   1c03c:	83 c0 24             	add    $0x24,%eax
   1c03f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c045:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c04b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c04f:	c1 e2 06             	shl    $0x6,%edx
   1c052:	01 d0                	add    %edx,%eax
   1c054:	83 c0 28             	add    $0x28,%eax
   1c057:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c05d:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c063:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c067:	c1 e2 06             	shl    $0x6,%edx
   1c06a:	01 d0                	add    %edx,%eax
   1c06c:	83 c0 2c             	add    $0x2c,%eax
   1c06f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c075:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c07b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c07f:	c1 e2 06             	shl    $0x6,%edx
   1c082:	01 d0                	add    %edx,%eax
   1c084:	83 c0 30             	add    $0x30,%eax
   1c087:	c7 c2 74 e1 01 00    	mov    $0x1e174,%edx
   1c08d:	89 10                	mov    %edx,(%eax)
   1c08f:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c095:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c099:	c1 e2 06             	shl    $0x6,%edx
   1c09c:	01 d0                	add    %edx,%eax
   1c09e:	83 c0 34             	add    $0x34,%eax
   1c0a1:	89 38                	mov    %edi,(%eax)
   1c0a3:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c0a9:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c0ad:	c1 e2 06             	shl    $0x6,%edx
   1c0b0:	01 d0                	add    %edx,%eax
   1c0b2:	83 c0 38             	add    $0x38,%eax
   1c0b5:	89 30                	mov    %esi,(%eax)
   1c0b7:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c0bd:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c0c1:	c1 e2 06             	shl    $0x6,%edx
   1c0c4:	01 d0                	add    %edx,%eax
   1c0c6:	83 c0 3c             	add    $0x3c,%eax
   1c0c9:	89 08                	mov    %ecx,(%eax)
	for (i = 0 ; i < NR_CONSOLES ; i++) {
   1c0cb:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1c0d0:	c7 c0 a0 3e 04 00    	mov    $0x43ea0,%eax
   1c0d6:	8b 00                	mov    (%eax),%eax
   1c0d8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
   1c0dc:	0f 8c 52 fe ff ff    	jl     1bf34 <tty_init+0x2a2>
		};
	}
	// 然后初始化串行终端的tty结构各字段。450行初始化串行终端tty结构中的读/写和辅助缓冲队列结构，它们分别指向tty缓冲队列
	// 结构数组tty_table[]中相应结构项。
	for (i = 0 ; i < NR_SERIALS ; i++) {
   1c0e2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1c0e9:	00 
   1c0ea:	e9 d7 00 00 00       	jmp    1c1c6 <tty_init+0x534>
		rs_table[i] = (struct tty_struct) {
   1c0ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c0f3:	83 c0 40             	add    $0x40,%eax
   1c0f6:	c1 e0 06             	shl    $0x6,%eax
   1c0f9:	89 c2                	mov    %eax,%edx
   1c0fb:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c101:	01 d0                	add    %edx,%eax
			INIT_C_CC},                     						// 控制字符数组。
			0,                              						// 所属初始进程组。
			0,                              						// 初始会话组。
			0,                              						// 初始停止标志。
			rs_write,                       						// 串口终端写函数。
			rs_queues + 0 + i * 3, rs_queues + 1 + i * 3, rs_queues + 2 + i * 3
   1c103:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c107:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c10d:	8d 8a 80 61 00 00    	lea    0x6180(%edx),%ecx
   1c113:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c119:	8d 3c 11             	lea    (%ecx,%edx,1),%edi
   1c11c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c120:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c126:	8d 8a 90 65 00 00    	lea    0x6590(%edx),%ecx
   1c12c:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c132:	8d 34 11             	lea    (%ecx,%edx,1),%esi
   1c135:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c139:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c13f:	8d 8a a0 69 00 00    	lea    0x69a0(%edx),%ecx
   1c145:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c14b:	01 d1                	add    %edx,%ecx
		rs_table[i] = (struct tty_struct) {
   1c14d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c153:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1c15a:	c7 40 08 3b 00 00 00 	movl   $0x3b,0x8(%eax)
   1c161:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1c168:	c6 40 10 00          	movb   $0x0,0x10(%eax)
   1c16c:	8b 93 10 63 ff ff    	mov    -0x9cf0(%ebx),%edx
   1c172:	89 50 11             	mov    %edx,0x11(%eax)
   1c175:	8b 93 14 63 ff ff    	mov    -0x9cec(%ebx),%edx
   1c17b:	89 50 15             	mov    %edx,0x15(%eax)
   1c17e:	8b 93 18 63 ff ff    	mov    -0x9ce8(%ebx),%edx
   1c184:	89 50 19             	mov    %edx,0x19(%eax)
   1c187:	8b 93 1c 63 ff ff    	mov    -0x9ce4(%ebx),%edx
   1c18d:	89 50 1d             	mov    %edx,0x1d(%eax)
   1c190:	0f b6 93 20 63 ff ff 	movzbl -0x9ce0(%ebx),%edx
   1c197:	88 50 21             	mov    %dl,0x21(%eax)
   1c19a:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
   1c1a1:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   1c1a8:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   1c1af:	c7 c2 f4 0c 02 00    	mov    $0x20cf4,%edx
   1c1b5:	89 50 30             	mov    %edx,0x30(%eax)
   1c1b8:	89 78 34             	mov    %edi,0x34(%eax)
   1c1bb:	89 70 38             	mov    %esi,0x38(%eax)
   1c1be:	89 48 3c             	mov    %ecx,0x3c(%eax)
	for (i = 0 ; i < NR_SERIALS ; i++) {
   1c1c1:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1c1c6:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
   1c1cb:	0f 8e 1e ff ff ff    	jle    1c0ef <tty_init+0x45d>
		};
	}
	// 然后再初始化伪终端使用的tty结构。伪终端是配对使用的，即一个主（master）伪终端配有一个从（slave）伪终端。因此对它们
	// 都要进行初始化设置。在循环中，我们首先初始化每个主伪终端的tty结构，然后再初始化其对应的从伪终端的tty结构。
	for (i = 0 ; i < NR_PTYS ; i++) {
   1c1d1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1c1d8:	00 
   1c1d9:	e9 ab 01 00 00       	jmp    1c389 <tty_init+0x6f7>
		mpty_table[i] = (struct tty_struct) {
   1c1de:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c1e2:	83 e8 80             	sub    $0xffffff80,%eax
   1c1e5:	c1 e0 06             	shl    $0x6,%eax
   1c1e8:	89 c2                	mov    %eax,%edx
   1c1ea:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c1f0:	01 d0                	add    %edx,%eax
			INIT_C_CC},                    							// 控制字符数组。
			0,                              						// 所属初始进程组。
			0,                              						// 初始会话组。
			0,                              						// 初始停止标志。
			mpty_write,                     						// 主伪终端写函数。
			mpty_queues + 0 + i * 3, mpty_queues + 1 + i * 3, mpty_queues + 2 + i * 3
   1c1f2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c1f6:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c1fc:	8d 8a e0 79 00 00    	lea    0x79e0(%edx),%ecx
   1c202:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c208:	8d 3c 11             	lea    (%ecx,%edx,1),%edi
   1c20b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c20f:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c215:	8d 8a f0 7d 00 00    	lea    0x7df0(%edx),%ecx
   1c21b:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c221:	8d 34 11             	lea    (%ecx,%edx,1),%esi
   1c224:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c228:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c22e:	8d 8a 00 82 00 00    	lea    0x8200(%edx),%ecx
   1c234:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c23a:	01 d1                	add    %edx,%ecx
		mpty_table[i] = (struct tty_struct) {
   1c23c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c242:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1c249:	c7 40 08 3d 00 00 00 	movl   $0x3d,0x8(%eax)
   1c250:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1c257:	c6 40 10 00          	movb   $0x0,0x10(%eax)
   1c25b:	8b 93 10 63 ff ff    	mov    -0x9cf0(%ebx),%edx
   1c261:	89 50 11             	mov    %edx,0x11(%eax)
   1c264:	8b 93 14 63 ff ff    	mov    -0x9cec(%ebx),%edx
   1c26a:	89 50 15             	mov    %edx,0x15(%eax)
   1c26d:	8b 93 18 63 ff ff    	mov    -0x9ce8(%ebx),%edx
   1c273:	89 50 19             	mov    %edx,0x19(%eax)
   1c276:	8b 93 1c 63 ff ff    	mov    -0x9ce4(%ebx),%edx
   1c27c:	89 50 1d             	mov    %edx,0x1d(%eax)
   1c27f:	0f b6 93 20 63 ff ff 	movzbl -0x9ce0(%ebx),%edx
   1c286:	88 50 21             	mov    %dl,0x21(%eax)
   1c289:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
   1c290:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   1c297:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   1c29e:	c7 c2 32 19 02 00    	mov    $0x21932,%edx
   1c2a4:	89 50 30             	mov    %edx,0x30(%eax)
   1c2a7:	89 78 34             	mov    %edi,0x34(%eax)
   1c2aa:	89 70 38             	mov    %esi,0x38(%eax)
   1c2ad:	89 48 3c             	mov    %ecx,0x3c(%eax)
		};
		spty_table[i] = (struct tty_struct) {
   1c2b0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c2b4:	05 c0 00 00 00       	add    $0xc0,%eax
   1c2b9:	c1 e0 06             	shl    $0x6,%eax
   1c2bc:	89 c2                	mov    %eax,%edx
   1c2be:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   1c2c4:	01 d0                	add    %edx,%eax
			INIT_C_CC},                    							// 控制字符数组。
			0,                              						// 所属初始进程组。
			0,                              						// 初始会话组。
			0,                              						// 初始停止标志。
			spty_write,                     						// 从伪终端写函数。
			spty_queues + 0 + i * 3, spty_queues + 1 + i * 3, spty_queues + 2 + i * 3
   1c2c6:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c2ca:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c2d0:	8d 8a a0 aa 00 00    	lea    0xaaa0(%edx),%ecx
   1c2d6:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c2dc:	8d 3c 11             	lea    (%ecx,%edx,1),%edi
   1c2df:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c2e3:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c2e9:	8d 8a b0 ae 00 00    	lea    0xaeb0(%edx),%ecx
   1c2ef:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c2f5:	8d 34 11             	lea    (%ecx,%edx,1),%esi
   1c2f8:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c2fc:	69 d2 30 0c 00 00    	imul   $0xc30,%edx,%edx
   1c302:	8d 8a c0 b2 00 00    	lea    0xb2c0(%edx),%ecx
   1c308:	8d 93 20 43 00 00    	lea    0x4320(%ebx),%edx
   1c30e:	01 d1                	add    %edx,%ecx
		spty_table[i] = (struct tty_struct) {
   1c310:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c316:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1c31d:	c7 40 08 3d 00 00 00 	movl   $0x3d,0x8(%eax)
   1c324:	c7 40 0c 03 04 00 00 	movl   $0x403,0xc(%eax)
   1c32b:	c6 40 10 00          	movb   $0x0,0x10(%eax)
   1c32f:	8b 93 10 63 ff ff    	mov    -0x9cf0(%ebx),%edx
   1c335:	89 50 11             	mov    %edx,0x11(%eax)
   1c338:	8b 93 14 63 ff ff    	mov    -0x9cec(%ebx),%edx
   1c33e:	89 50 15             	mov    %edx,0x15(%eax)
   1c341:	8b 93 18 63 ff ff    	mov    -0x9ce8(%ebx),%edx
   1c347:	89 50 19             	mov    %edx,0x19(%eax)
   1c34a:	8b 93 1c 63 ff ff    	mov    -0x9ce4(%ebx),%edx
   1c350:	89 50 1d             	mov    %edx,0x1d(%eax)
   1c353:	0f b6 93 20 63 ff ff 	movzbl -0x9ce0(%ebx),%edx
   1c35a:	88 50 21             	mov    %dl,0x21(%eax)
   1c35d:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
   1c364:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   1c36b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   1c372:	c7 c2 94 19 02 00    	mov    $0x21994,%edx
   1c378:	89 50 30             	mov    %edx,0x30(%eax)
   1c37b:	89 78 34             	mov    %edi,0x34(%eax)
   1c37e:	89 70 38             	mov    %esi,0x38(%eax)
   1c381:	89 48 3c             	mov    %ecx,0x3c(%eax)
	for (i = 0 ; i < NR_PTYS ; i++) {
   1c384:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1c389:	83 7c 24 0c 03       	cmpl   $0x3,0xc(%esp)
   1c38e:	0f 8e 4a fe ff ff    	jle    1c1de <tty_init+0x54c>
		};
	}
	// 最后初始化串行中断处理程序和串行接口1和2（serial.c），并显示系统含有的虚拟控制台数NR_CONSOLES和伪终端数NR_PTYS。
	rs_init();
   1c394:	e8 93 48 00 00       	call   20c2c <rs_init>
	printk("%d virtual consoles\n\r", NR_CONSOLES);
   1c399:	c7 c0 a0 3e 04 00    	mov    $0x43ea0,%eax
   1c39f:	8b 00                	mov    (%eax),%eax
   1c3a1:	83 ec 08             	sub    $0x8,%esp
   1c3a4:	50                   	push   %eax
   1c3a5:	8d 83 a1 5a ff ff    	lea    -0xa55f(%ebx),%eax
   1c3ab:	50                   	push   %eax
   1c3ac:	e8 81 cf fe ff       	call   9332 <printk>
   1c3b1:	83 c4 10             	add    $0x10,%esp
	printk("%d pty's\n\r", NR_PTYS);
   1c3b4:	83 ec 08             	sub    $0x8,%esp
   1c3b7:	6a 04                	push   $0x4
   1c3b9:	8d 83 b7 5a ff ff    	lea    -0xa549(%ebx),%eax
   1c3bf:	50                   	push   %eax
   1c3c0:	e8 6d cf fe ff       	call   9332 <printk>
   1c3c5:	83 c4 10             	add    $0x10,%esp
}
   1c3c8:	90                   	nop
   1c3c9:	83 c4 10             	add    $0x10,%esp
   1c3cc:	5b                   	pop    %ebx
   1c3cd:	5e                   	pop    %esi
   1c3ce:	5f                   	pop    %edi
   1c3cf:	c3                   	ret    

0001c3d0 <get_fs_byte>:
{
   1c3d0:	53                   	push   %ebx
   1c3d1:	e8 1c a9 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1c3d6:	05 2a 5c 01 00       	add    $0x15c2a,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   1c3db:	8b 44 24 08          	mov    0x8(%esp),%eax
   1c3df:	64 8a 00             	mov    %fs:(%eax),%al
   1c3e2:	89 c3                	mov    %eax,%ebx
	return _v;
   1c3e4:	89 d8                	mov    %ebx,%eax
}
   1c3e6:	5b                   	pop    %ebx
   1c3e7:	c3                   	ret    

0001c3e8 <put_fs_byte>:
{
   1c3e8:	83 ec 04             	sub    $0x4,%esp
   1c3eb:	e8 02 a9 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1c3f0:	05 10 5c 01 00       	add    $0x15c10,%eax
   1c3f5:	8b 44 24 08          	mov    0x8(%esp),%eax
   1c3f9:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   1c3fc:	0f b6 04 24          	movzbl (%esp),%eax
   1c400:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c404:	64 88 02             	mov    %al,%fs:(%edx)
}
   1c407:	90                   	nop
   1c408:	83 c4 04             	add    $0x4,%esp
   1c40b:	c3                   	ret    

0001c40c <gotoxy>:
// 光标行号不低于显示的最大行数,则退出.否则就更新当前光标变量和新光标位置对应在显示内存中位置pos.
// 注意,函数中的所有变量实际上是vc_cons[currcons]结构中的相应字段.以下函数相同.
/* NOTE! gotoxy thinks x==video_num_columns is ok */
/* 注意!gotoxy函数认为x==video_num_columns时是正确的 */
static inline void gotoxy(int currcons, int new_x, unsigned int new_y)
{
   1c40c:	56                   	push   %esi
   1c40d:	53                   	push   %ebx
   1c40e:	e8 df a8 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1c413:	05 ed 5b 01 00       	add    $0x15bed,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   1c418:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1c41c:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1c422:	39 d1                	cmp    %edx,%ecx
   1c424:	0f 87 cd 00 00 00    	ja     1c4f7 <gotoxy+0xeb>
   1c42a:	8b 90 c4 1e 01 00    	mov    0x11ec4(%eax),%edx
   1c430:	39 54 24 14          	cmp    %edx,0x14(%esp)
   1c434:	0f 83 bd 00 00 00    	jae    1c4f7 <gotoxy+0xeb>
		return;
	x = new_x;
   1c43a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1c43e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1c442:	8d b0 e4 1e 01 00    	lea    0x11ee4(%eax),%esi
   1c448:	89 ca                	mov    %ecx,%edx
   1c44a:	c1 e2 03             	shl    $0x3,%edx
   1c44d:	01 ca                	add    %ecx,%edx
   1c44f:	c1 e2 04             	shl    $0x4,%edx
   1c452:	01 f2                	add    %esi,%edx
   1c454:	83 c2 20             	add    $0x20,%edx
   1c457:	89 1a                	mov    %ebx,(%edx)
	y = new_y;
   1c459:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1c45d:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1c463:	89 ca                	mov    %ecx,%edx
   1c465:	c1 e2 03             	shl    $0x3,%edx
   1c468:	01 ca                	add    %ecx,%edx
   1c46a:	c1 e2 04             	shl    $0x4,%edx
   1c46d:	01 da                	add    %ebx,%edx
   1c46f:	8d 4a 20             	lea    0x20(%edx),%ecx
   1c472:	8b 54 24 14          	mov    0x14(%esp),%edx
   1c476:	89 11                	mov    %edx,(%ecx)
	pos = origin + y * video_size_row + (x << 1);	// 1列用2个字节表示,所以x<<1.
   1c478:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1c47c:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1c482:	89 ca                	mov    %ecx,%edx
   1c484:	c1 e2 03             	shl    $0x3,%edx
   1c487:	01 ca                	add    %ecx,%edx
   1c489:	c1 e2 04             	shl    $0x4,%edx
   1c48c:	01 da                	add    %ebx,%edx
   1c48e:	83 c2 10             	add    $0x10,%edx
   1c491:	8b 1a                	mov    (%edx),%ebx
   1c493:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1c497:	8d b0 e8 1e 01 00    	lea    0x11ee8(%eax),%esi
   1c49d:	89 ca                	mov    %ecx,%edx
   1c49f:	c1 e2 03             	shl    $0x3,%edx
   1c4a2:	01 ca                	add    %ecx,%edx
   1c4a4:	c1 e2 04             	shl    $0x4,%edx
   1c4a7:	01 f2                	add    %esi,%edx
   1c4a9:	83 c2 20             	add    $0x20,%edx
   1c4ac:	8b 0a                	mov    (%edx),%ecx
   1c4ae:	8b 90 c0 1e 01 00    	mov    0x11ec0(%eax),%edx
   1c4b4:	0f af d1             	imul   %ecx,%edx
   1c4b7:	8d 34 13             	lea    (%ebx,%edx,1),%esi
   1c4ba:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1c4be:	8d 98 e4 1e 01 00    	lea    0x11ee4(%eax),%ebx
   1c4c4:	89 ca                	mov    %ecx,%edx
   1c4c6:	c1 e2 03             	shl    $0x3,%edx
   1c4c9:	01 ca                	add    %ecx,%edx
   1c4cb:	c1 e2 04             	shl    $0x4,%edx
   1c4ce:	01 da                	add    %ebx,%edx
   1c4d0:	83 c2 20             	add    $0x20,%edx
   1c4d3:	8b 12                	mov    (%edx),%edx
   1c4d5:	01 d2                	add    %edx,%edx
   1c4d7:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
   1c4da:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1c4de:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1c4e4:	89 d0                	mov    %edx,%eax
   1c4e6:	c1 e0 03             	shl    $0x3,%eax
   1c4e9:	01 d0                	add    %edx,%eax
   1c4eb:	c1 e0 04             	shl    $0x4,%eax
   1c4ee:	01 d8                	add    %ebx,%eax
   1c4f0:	83 c0 20             	add    $0x20,%eax
   1c4f3:	89 08                	mov    %ecx,(%eax)
   1c4f5:	eb 01                	jmp    1c4f8 <gotoxy+0xec>
		return;
   1c4f7:	90                   	nop
}
   1c4f8:	5b                   	pop    %ebx
   1c4f9:	5e                   	pop    %esi
   1c4fa:	c3                   	ret    

0001c4fb <set_origin>:

// 设置滚屏起始显示内存地址.
static inline void set_origin(int currcons)
{
   1c4fb:	53                   	push   %ebx
   1c4fc:	e8 36 05 ff ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1c501:	81 c1 ff 5a 01 00    	add    $0x15aff,%ecx
	// 首先判断显示卡类型.对于EGA/VGA,我们可以指定屏内范围(区域)进行滚屏操作,而MDA单色显示卡只能进行整屏滚屏操作.因此只有EGA/VGA卡才需要设置
	// 滚屏起始行显示内存地址(起始行是origin对应的行).即显示类型如果不是EGA/VGA彩色模式,也不是EGA/VGA单色模式,那么就直接返回.另外,我们只对前
	// 台控制台进行操作,因此当前控制台currocons必须是前台控制台时,我们才需要设置其滚屏起始行对应的内存起点位置.
	if (video_type != VIDEO_TYPE_EGAC && video_type != VIDEO_TYPE_EGAM)
   1c507:	0f b6 81 b0 1e 01 00 	movzbl 0x11eb0(%ecx),%eax
   1c50e:	3c 21                	cmp    $0x21,%al
   1c510:	74 0f                	je     1c521 <set_origin+0x26>
   1c512:	0f b6 81 b0 1e 01 00 	movzbl 0x11eb0(%ecx),%eax
   1c519:	3c 20                	cmp    $0x20,%al
   1c51b:	0f 85 a5 00 00 00    	jne    1c5c6 <set_origin+0xcb>
		return;
	if (currcons != fg_console)
   1c521:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
   1c527:	8b 00                	mov    (%eax),%eax
   1c529:	39 44 24 08          	cmp    %eax,0x8(%esp)
   1c52d:	0f 85 96 00 00 00    	jne    1c5c9 <set_origin+0xce>
		return;
	// 然后向显示寄存器选择端口video_port_reg输出12,即选择显示控制数据寄存器r12,接着写入滚屏起始地址高字节.其中向右移动9位,实际上表示向右移动
	// 8位再除以2(上1个字符用2字节表示).再选择显示控制数据寄存器r13,然后写入滚屏起始地址低字节.向右移动1位表示除以2,同样代表屏幕上1个字符用2字节
	// 表示.输出值相对于默认显示内存起始位置video_mem_base进行操作.
	// 例如对于EGA/VGA彩色模式,viedo_mem_base = 物理内存地址0xb8000.
	cli();
   1c533:	fa                   	cli    
	outb_p(12, video_port_reg);											// 选择数据寄存器r12,输出滚屏起始位置高字节.
   1c534:	0f b7 91 ca 1e 01 00 	movzwl 0x11eca(%ecx),%edx
   1c53b:	b8 0c 00 00 00       	mov    $0xc,%eax
   1c540:	ee                   	out    %al,(%dx)
   1c541:	eb 00                	jmp    1c543 <set_origin+0x48>
   1c543:	eb 00                	jmp    1c545 <set_origin+0x4a>
	outb_p(0xff & ((origin - video_mem_base) >> 9), video_port_val);
   1c545:	8b 54 24 08          	mov    0x8(%esp),%edx
   1c549:	8d 99 e8 1e 01 00    	lea    0x11ee8(%ecx),%ebx
   1c54f:	89 d0                	mov    %edx,%eax
   1c551:	c1 e0 03             	shl    $0x3,%eax
   1c554:	01 d0                	add    %edx,%eax
   1c556:	c1 e0 04             	shl    $0x4,%eax
   1c559:	01 d8                	add    %ebx,%eax
   1c55b:	83 c0 10             	add    $0x10,%eax
   1c55e:	8b 10                	mov    (%eax),%edx
   1c560:	8b 81 b8 1e 01 00    	mov    0x11eb8(%ecx),%eax
   1c566:	29 c2                	sub    %eax,%edx
   1c568:	89 d0                	mov    %edx,%eax
   1c56a:	c1 e8 09             	shr    $0x9,%eax
   1c56d:	0f b6 c0             	movzbl %al,%eax
   1c570:	0f b7 91 cc 1e 01 00 	movzwl 0x11ecc(%ecx),%edx
   1c577:	ee                   	out    %al,(%dx)
   1c578:	eb 00                	jmp    1c57a <set_origin+0x7f>
   1c57a:	eb 00                	jmp    1c57c <set_origin+0x81>
	outb_p(13, video_port_reg);											// 选择数据寄存器r13,输出滚屏起始位置低字节.
   1c57c:	0f b7 91 ca 1e 01 00 	movzwl 0x11eca(%ecx),%edx
   1c583:	b8 0d 00 00 00       	mov    $0xd,%eax
   1c588:	ee                   	out    %al,(%dx)
   1c589:	eb 00                	jmp    1c58b <set_origin+0x90>
   1c58b:	eb 00                	jmp    1c58d <set_origin+0x92>
	outb_p(0xff & ((origin - video_mem_base) >> 1), video_port_val);
   1c58d:	8b 54 24 08          	mov    0x8(%esp),%edx
   1c591:	8d 99 e8 1e 01 00    	lea    0x11ee8(%ecx),%ebx
   1c597:	89 d0                	mov    %edx,%eax
   1c599:	c1 e0 03             	shl    $0x3,%eax
   1c59c:	01 d0                	add    %edx,%eax
   1c59e:	c1 e0 04             	shl    $0x4,%eax
   1c5a1:	01 d8                	add    %ebx,%eax
   1c5a3:	83 c0 10             	add    $0x10,%eax
   1c5a6:	8b 10                	mov    (%eax),%edx
   1c5a8:	8b 81 b8 1e 01 00    	mov    0x11eb8(%ecx),%eax
   1c5ae:	29 c2                	sub    %eax,%edx
   1c5b0:	89 d0                	mov    %edx,%eax
   1c5b2:	d1 e8                	shr    %eax
   1c5b4:	0f b6 c0             	movzbl %al,%eax
   1c5b7:	0f b7 91 cc 1e 01 00 	movzwl 0x11ecc(%ecx),%edx
   1c5be:	ee                   	out    %al,(%dx)
   1c5bf:	eb 00                	jmp    1c5c1 <set_origin+0xc6>
   1c5c1:	eb 00                	jmp    1c5c3 <set_origin+0xc8>
	sti();
   1c5c3:	fb                   	sti    
   1c5c4:	eb 04                	jmp    1c5ca <set_origin+0xcf>
		return;
   1c5c6:	90                   	nop
   1c5c7:	eb 01                	jmp    1c5ca <set_origin+0xcf>
		return;
   1c5c9:	90                   	nop
}
   1c5ca:	5b                   	pop    %ebx
   1c5cb:	c3                   	ret    

0001c5cc <scrup>:

// 向上卷动上行
// 将屏幕滚动窗口向上移动一行,并在屏幕滚动区域底出现的新行上添加空格字符.滚屏区域必须大于1行.
static void scrup(int currcons)
{
   1c5cc:	55                   	push   %ebp
   1c5cd:	57                   	push   %edi
   1c5ce:	56                   	push   %esi
   1c5cf:	53                   	push   %ebx
   1c5d0:	83 ec 04             	sub    $0x4,%esp
   1c5d3:	e8 1e a7 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   1c5d8:	81 c2 28 5a 01 00    	add    $0x15a28,%edx
	// 滚屏区域必须至少有2行.如果滚屏区域顶行号大于等于区域底行号,则不满足进行滚行操作的条件.另外,对于EGA/VGA卡,我们可以指定屏内行范围(区域)
	// 进行滚屏操作,而MDA单色显示卡只能进行整屏操作.该函数对EGA和MDA显示类型进行分别处理.如果显示类型是EGA,则还分为整屏窗口移动和区域内窗口移动
	// 这里首先处理显示卡是EGA/VGA显示类型的情况.
	if (bottom <= top)
   1c5de:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c5e2:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c5e8:	89 c8                	mov    %ecx,%eax
   1c5ea:	c1 e0 03             	shl    $0x3,%eax
   1c5ed:	01 c8                	add    %ecx,%eax
   1c5ef:	c1 e0 04             	shl    $0x4,%eax
   1c5f2:	01 d8                	add    %ebx,%eax
   1c5f4:	83 c0 30             	add    $0x30,%eax
   1c5f7:	8b 18                	mov    (%eax),%ebx
   1c5f9:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c5fd:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1c603:	89 c8                	mov    %ecx,%eax
   1c605:	c1 e0 03             	shl    $0x3,%eax
   1c608:	01 c8                	add    %ecx,%eax
   1c60a:	c1 e0 04             	shl    $0x4,%eax
   1c60d:	01 f0                	add    %esi,%eax
   1c60f:	83 c0 20             	add    $0x20,%eax
   1c612:	8b 00                	mov    (%eax),%eax
   1c614:	39 c3                	cmp    %eax,%ebx
   1c616:	0f 86 54 05 00 00    	jbe    1cb70 <scrup+0x5a4>
		return;
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   1c61c:	0f b6 82 b0 1e 01 00 	movzbl 0x11eb0(%edx),%eax
   1c623:	3c 21                	cmp    $0x21,%al
   1c625:	74 0f                	je     1c636 <scrup+0x6a>
   1c627:	0f b6 82 b0 1e 01 00 	movzbl 0x11eb0(%edx),%eax
   1c62e:	3c 20                	cmp    $0x20,%al
   1c630:	0f 85 3a 04 00 00    	jne    1ca70 <scrup+0x4a4>
	{
		// 如果移动起始行top=0,移动最底行bottom = video_num_lines = 25,则表示整屏窗口向下移动,于是把整个屏幕窗口左上角对应的起始内存位置origin
		// 调整为向下移动一行对应的内存位置,同时也跟踪调整当前光标对应的内存位置以及屏幕末行末端字符指针scr_end的位置.最后把新屏幕窗口内存起始位置值
		// origin写入显示控制器中
		if (!top && bottom == video_num_lines) {
   1c636:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c63a:	8d 9a ec 1e 01 00    	lea    0x11eec(%edx),%ebx
   1c640:	89 c8                	mov    %ecx,%eax
   1c642:	c1 e0 03             	shl    $0x3,%eax
   1c645:	01 c8                	add    %ecx,%eax
   1c647:	c1 e0 04             	shl    $0x4,%eax
   1c64a:	01 d8                	add    %ebx,%eax
   1c64c:	83 c0 20             	add    $0x20,%eax
   1c64f:	8b 00                	mov    (%eax),%eax
   1c651:	85 c0                	test   %eax,%eax
   1c653:	0f 85 14 03 00 00    	jne    1c96d <scrup+0x3a1>
   1c659:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c65d:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c663:	89 c8                	mov    %ecx,%eax
   1c665:	c1 e0 03             	shl    $0x3,%eax
   1c668:	01 c8                	add    %ecx,%eax
   1c66a:	c1 e0 04             	shl    $0x4,%eax
   1c66d:	01 d8                	add    %ebx,%eax
   1c66f:	83 c0 30             	add    $0x30,%eax
   1c672:	8b 08                	mov    (%eax),%ecx
   1c674:	8b 82 c4 1e 01 00    	mov    0x11ec4(%edx),%eax
   1c67a:	39 c1                	cmp    %eax,%ecx
   1c67c:	0f 85 eb 02 00 00    	jne    1c96d <scrup+0x3a1>
			origin += video_size_row;
   1c682:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c686:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1c68c:	89 c8                	mov    %ecx,%eax
   1c68e:	c1 e0 03             	shl    $0x3,%eax
   1c691:	01 c8                	add    %ecx,%eax
   1c693:	c1 e0 04             	shl    $0x4,%eax
   1c696:	01 d8                	add    %ebx,%eax
   1c698:	83 c0 10             	add    $0x10,%eax
   1c69b:	8b 08                	mov    (%eax),%ecx
   1c69d:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1c6a3:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
   1c6a6:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c6aa:	8d b2 e8 1e 01 00    	lea    0x11ee8(%edx),%esi
   1c6b0:	89 c8                	mov    %ecx,%eax
   1c6b2:	c1 e0 03             	shl    $0x3,%eax
   1c6b5:	01 c8                	add    %ecx,%eax
   1c6b7:	c1 e0 04             	shl    $0x4,%eax
   1c6ba:	01 f0                	add    %esi,%eax
   1c6bc:	83 c0 10             	add    $0x10,%eax
   1c6bf:	89 18                	mov    %ebx,(%eax)
			pos += video_size_row;
   1c6c1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c6c5:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c6cb:	89 c8                	mov    %ecx,%eax
   1c6cd:	c1 e0 03             	shl    $0x3,%eax
   1c6d0:	01 c8                	add    %ecx,%eax
   1c6d2:	c1 e0 04             	shl    $0x4,%eax
   1c6d5:	01 d8                	add    %ebx,%eax
   1c6d7:	83 c0 20             	add    $0x20,%eax
   1c6da:	8b 08                	mov    (%eax),%ecx
   1c6dc:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1c6e2:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
   1c6e5:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c6e9:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1c6ef:	89 c8                	mov    %ecx,%eax
   1c6f1:	c1 e0 03             	shl    $0x3,%eax
   1c6f4:	01 c8                	add    %ecx,%eax
   1c6f6:	c1 e0 04             	shl    $0x4,%eax
   1c6f9:	01 f0                	add    %esi,%eax
   1c6fb:	83 c0 20             	add    $0x20,%eax
   1c6fe:	89 18                	mov    %ebx,(%eax)
			scr_end += video_size_row;
   1c700:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c704:	8d 9a ec 1e 01 00    	lea    0x11eec(%edx),%ebx
   1c70a:	89 c8                	mov    %ecx,%eax
   1c70c:	c1 e0 03             	shl    $0x3,%eax
   1c70f:	01 c8                	add    %ecx,%eax
   1c711:	c1 e0 04             	shl    $0x4,%eax
   1c714:	01 d8                	add    %ebx,%eax
   1c716:	83 c0 10             	add    $0x10,%eax
   1c719:	8b 08                	mov    (%eax),%ecx
   1c71b:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1c721:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
   1c724:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c728:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1c72e:	89 c8                	mov    %ecx,%eax
   1c730:	c1 e0 03             	shl    $0x3,%eax
   1c733:	01 c8                	add    %ecx,%eax
   1c735:	c1 e0 04             	shl    $0x4,%eax
   1c738:	01 f0                	add    %esi,%eax
   1c73a:	83 c0 10             	add    $0x10,%eax
   1c73d:	89 18                	mov    %ebx,(%eax)
			// 如果屏幕窗口末端所对应的显示内存指针scr_end超出了实际显示内存末端,则将屏幕内容除第一行以外所有行对应的内存数据移动到显示内存的起始位置video_mem_start
			// 处,并在整屏窗口向下移动出现的新行上填入空格字符.然后根据屏幕内存数据移动后的情况,重新调整当前屏幕对应内存的起始指针,光标位置指针和屏幕末端
			// 对应内存指针scr_end.
			if (scr_end > video_mem_end) {
   1c73f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c743:	8d 9a ec 1e 01 00    	lea    0x11eec(%edx),%ebx
   1c749:	89 c8                	mov    %ecx,%eax
   1c74b:	c1 e0 03             	shl    $0x3,%eax
   1c74e:	01 c8                	add    %ecx,%eax
   1c750:	c1 e0 04             	shl    $0x4,%eax
   1c753:	01 d8                	add    %ebx,%eax
   1c755:	83 c0 10             	add    $0x10,%eax
   1c758:	8b 18                	mov    (%eax),%ebx
   1c75a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c75e:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1c764:	89 c8                	mov    %ecx,%eax
   1c766:	c1 e0 03             	shl    $0x3,%eax
   1c769:	01 c8                	add    %ecx,%eax
   1c76b:	c1 e0 04             	shl    $0x4,%eax
   1c76e:	01 f0                	add    %esi,%eax
   1c770:	83 c0 70             	add    $0x70,%eax
   1c773:	8b 00                	mov    (%eax),%eax
   1c775:	39 c3                	cmp    %eax,%ebx
   1c777:	0f 86 91 01 00 00    	jbe    1c90e <scrup+0x342>
					"rep\n\t"												// 重复操作,将当前屏幕内存数据移动到显示内存起始处
					"movsl\n\t"
					"movl video_num_columns, %1\n\t"
					"rep\n\t"												// 在新行上填入空格字符
					"stosw"
					::"a" (video_erase_char),
   1c77d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c781:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c787:	89 c8                	mov    %ecx,%eax
   1c789:	c1 e0 03             	shl    $0x3,%eax
   1c78c:	01 c8                	add    %ecx,%eax
   1c78e:	c1 e0 04             	shl    $0x4,%eax
   1c791:	01 d8                	add    %ebx,%eax
   1c793:	0f b7 18             	movzwl (%eax),%ebx
					"c" ((video_num_lines - 1) * video_num_columns >> 1),
   1c796:	8b 82 c4 1e 01 00    	mov    0x11ec4(%edx),%eax
   1c79c:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1c79f:	8b 82 b4 1e 01 00    	mov    0x11eb4(%edx),%eax
   1c7a5:	0f af c1             	imul   %ecx,%eax
   1c7a8:	d1 e8                	shr    %eax
   1c7aa:	89 c5                	mov    %eax,%ebp
					"D" (video_mem_start),
   1c7ac:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c7b0:	8d b2 e8 1e 01 00    	lea    0x11ee8(%edx),%esi
   1c7b6:	89 c8                	mov    %ecx,%eax
   1c7b8:	c1 e0 03             	shl    $0x3,%eax
   1c7bb:	01 c8                	add    %ecx,%eax
   1c7bd:	c1 e0 04             	shl    $0x4,%eax
   1c7c0:	01 f0                	add    %esi,%eax
   1c7c2:	83 c0 70             	add    $0x70,%eax
   1c7c5:	8b 38                	mov    (%eax),%edi
					"S" (origin)
   1c7c7:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c7cb:	8d b2 e8 1e 01 00    	lea    0x11ee8(%edx),%esi
   1c7d1:	89 c8                	mov    %ecx,%eax
   1c7d3:	c1 e0 03             	shl    $0x3,%eax
   1c7d6:	01 c8                	add    %ecx,%eax
   1c7d8:	c1 e0 04             	shl    $0x4,%eax
   1c7db:	01 f0                	add    %esi,%eax
   1c7dd:	83 c0 10             	add    $0x10,%eax
   1c7e0:	8b 30                	mov    (%eax),%esi
				__asm__("cld\n\t"											// 清方向位
   1c7e2:	89 d8                	mov    %ebx,%eax
   1c7e4:	89 e9                	mov    %ebp,%ecx
   1c7e6:	fc                   	cld    
   1c7e7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1c7e9:	8b 0d b4 3e 04 00    	mov    0x43eb4,%ecx
   1c7ef:	f3 66 ab             	rep stos %ax,%es:(%edi)
					:);
				// 重新设置快速滚屏的末端位置
				scr_end -= origin - video_mem_start;
   1c7f2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c7f6:	8d 9a ec 1e 01 00    	lea    0x11eec(%edx),%ebx
   1c7fc:	89 c8                	mov    %ecx,%eax
   1c7fe:	c1 e0 03             	shl    $0x3,%eax
   1c801:	01 c8                	add    %ecx,%eax
   1c803:	c1 e0 04             	shl    $0x4,%eax
   1c806:	01 d8                	add    %ebx,%eax
   1c808:	83 c0 10             	add    $0x10,%eax
   1c80b:	8b 18                	mov    (%eax),%ebx
   1c80d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c811:	8d b2 e8 1e 01 00    	lea    0x11ee8(%edx),%esi
   1c817:	89 c8                	mov    %ecx,%eax
   1c819:	c1 e0 03             	shl    $0x3,%eax
   1c81c:	01 c8                	add    %ecx,%eax
   1c81e:	c1 e0 04             	shl    $0x4,%eax
   1c821:	01 f0                	add    %esi,%eax
   1c823:	83 c0 70             	add    $0x70,%eax
   1c826:	8b 30                	mov    (%eax),%esi
   1c828:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c82c:	8d ba e8 1e 01 00    	lea    0x11ee8(%edx),%edi
   1c832:	89 c8                	mov    %ecx,%eax
   1c834:	c1 e0 03             	shl    $0x3,%eax
   1c837:	01 c8                	add    %ecx,%eax
   1c839:	c1 e0 04             	shl    $0x4,%eax
   1c83c:	01 f8                	add    %edi,%eax
   1c83e:	83 c0 10             	add    $0x10,%eax
   1c841:	8b 00                	mov    (%eax),%eax
   1c843:	29 c6                	sub    %eax,%esi
   1c845:	89 f0                	mov    %esi,%eax
   1c847:	01 c3                	add    %eax,%ebx
   1c849:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c84d:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1c853:	89 c8                	mov    %ecx,%eax
   1c855:	c1 e0 03             	shl    $0x3,%eax
   1c858:	01 c8                	add    %ecx,%eax
   1c85a:	c1 e0 04             	shl    $0x4,%eax
   1c85d:	01 f0                	add    %esi,%eax
   1c85f:	83 c0 10             	add    $0x10,%eax
   1c862:	89 18                	mov    %ebx,(%eax)
				// 设置当前显示位置
				pos -= origin - video_mem_start;
   1c864:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c868:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c86e:	89 c8                	mov    %ecx,%eax
   1c870:	c1 e0 03             	shl    $0x3,%eax
   1c873:	01 c8                	add    %ecx,%eax
   1c875:	c1 e0 04             	shl    $0x4,%eax
   1c878:	01 d8                	add    %ebx,%eax
   1c87a:	83 c0 20             	add    $0x20,%eax
   1c87d:	8b 18                	mov    (%eax),%ebx
   1c87f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c883:	8d b2 e8 1e 01 00    	lea    0x11ee8(%edx),%esi
   1c889:	89 c8                	mov    %ecx,%eax
   1c88b:	c1 e0 03             	shl    $0x3,%eax
   1c88e:	01 c8                	add    %ecx,%eax
   1c890:	c1 e0 04             	shl    $0x4,%eax
   1c893:	01 f0                	add    %esi,%eax
   1c895:	83 c0 70             	add    $0x70,%eax
   1c898:	8b 30                	mov    (%eax),%esi
   1c89a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c89e:	8d ba e8 1e 01 00    	lea    0x11ee8(%edx),%edi
   1c8a4:	89 c8                	mov    %ecx,%eax
   1c8a6:	c1 e0 03             	shl    $0x3,%eax
   1c8a9:	01 c8                	add    %ecx,%eax
   1c8ab:	c1 e0 04             	shl    $0x4,%eax
   1c8ae:	01 f8                	add    %edi,%eax
   1c8b0:	83 c0 10             	add    $0x10,%eax
   1c8b3:	8b 00                	mov    (%eax),%eax
   1c8b5:	29 c6                	sub    %eax,%esi
   1c8b7:	89 f0                	mov    %esi,%eax
   1c8b9:	01 c3                	add    %eax,%ebx
   1c8bb:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c8bf:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1c8c5:	89 c8                	mov    %ecx,%eax
   1c8c7:	c1 e0 03             	shl    $0x3,%eax
   1c8ca:	01 c8                	add    %ecx,%eax
   1c8cc:	c1 e0 04             	shl    $0x4,%eax
   1c8cf:	01 f0                	add    %esi,%eax
   1c8d1:	83 c0 20             	add    $0x20,%eax
   1c8d4:	89 18                	mov    %ebx,(%eax)
				// 重新设置快速滚屏的起始位置
				origin = video_mem_start;
   1c8d6:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c8da:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1c8e0:	89 c8                	mov    %ecx,%eax
   1c8e2:	c1 e0 03             	shl    $0x3,%eax
   1c8e5:	01 c8                	add    %ecx,%eax
   1c8e7:	c1 e0 04             	shl    $0x4,%eax
   1c8ea:	01 d8                	add    %ebx,%eax
   1c8ec:	83 c0 70             	add    $0x70,%eax
   1c8ef:	8b 18                	mov    (%eax),%ebx
   1c8f1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c8f5:	8d 92 e8 1e 01 00    	lea    0x11ee8(%edx),%edx
   1c8fb:	89 c8                	mov    %ecx,%eax
   1c8fd:	c1 e0 03             	shl    $0x3,%eax
   1c900:	01 c8                	add    %ecx,%eax
   1c902:	c1 e0 04             	shl    $0x4,%eax
   1c905:	01 d0                	add    %edx,%eax
   1c907:	83 c0 10             	add    $0x10,%eax
   1c90a:	89 18                	mov    %ebx,(%eax)
   1c90c:	eb 4e                	jmp    1c95c <scrup+0x390>
			// %0 - eax(擦除字符+属性);%1 - ecx(屏幕行数);%2 - edi(最后1行开始处对应内存位置);
			} else {
				__asm__("cld\n\t"
					"rep\n\t"												// 重复操作,在新出现现上填入擦除字符(空格字符).
					"stosw"
					::"a" (video_erase_char),
   1c90e:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c912:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c918:	89 c8                	mov    %ecx,%eax
   1c91a:	c1 e0 03             	shl    $0x3,%eax
   1c91d:	01 c8                	add    %ecx,%eax
   1c91f:	c1 e0 04             	shl    $0x4,%eax
   1c922:	01 d8                	add    %ebx,%eax
   1c924:	0f b7 18             	movzwl (%eax),%ebx
				__asm__("cld\n\t"
   1c927:	8b b2 b4 1e 01 00    	mov    0x11eb4(%edx),%esi
					"c" (video_num_columns),
					"D" (scr_end - video_size_row)
   1c92d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c931:	8d ba ec 1e 01 00    	lea    0x11eec(%edx),%edi
   1c937:	89 c8                	mov    %ecx,%eax
   1c939:	c1 e0 03             	shl    $0x3,%eax
   1c93c:	01 c8                	add    %ecx,%eax
   1c93e:	c1 e0 04             	shl    $0x4,%eax
   1c941:	01 f8                	add    %edi,%eax
   1c943:	83 c0 10             	add    $0x10,%eax
   1c946:	8b 08                	mov    (%eax),%ecx
   1c948:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1c94e:	89 ca                	mov    %ecx,%edx
   1c950:	29 c2                	sub    %eax,%edx
				__asm__("cld\n\t"
   1c952:	89 d8                	mov    %ebx,%eax
   1c954:	89 f1                	mov    %esi,%ecx
   1c956:	89 d7                	mov    %edx,%edi
   1c958:	fc                   	cld    
   1c959:	f3 66 ab             	rep stos %ax,%es:(%edi)
					:);
			}
			// 然后把新屏幕滚动窗口内存起始位置值origin写入显示控制器中.
			set_origin(currcons);
   1c95c:	ff 74 24 18          	pushl  0x18(%esp)
   1c960:	e8 96 fb ff ff       	call   1c4fb <set_origin>
   1c965:	83 c4 04             	add    $0x4,%esp
		if (!top && bottom == video_num_lines) {
   1c968:	e9 04 02 00 00       	jmp    1cb71 <scrup+0x5a5>
				"rep\n\t"													// 循环操作,将top+1到bottom行所对应的内存块移到top行开始处.
				"movsl\n\t"
				"movl video_num_columns, %%ecx\n\t"
				"rep\n\t"													// 在新行上填入擦除字符.
				"stosw"
				::"a" (video_erase_char),
   1c96d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c971:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c977:	89 c8                	mov    %ecx,%eax
   1c979:	c1 e0 03             	shl    $0x3,%eax
   1c97c:	01 c8                	add    %ecx,%eax
   1c97e:	c1 e0 04             	shl    $0x4,%eax
   1c981:	01 d8                	add    %ebx,%eax
   1c983:	0f b7 28             	movzwl (%eax),%ebp
				"c" ((bottom - top - 1) * video_num_columns >> 1),
   1c986:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c98a:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1c990:	89 c8                	mov    %ecx,%eax
   1c992:	c1 e0 03             	shl    $0x3,%eax
   1c995:	01 c8                	add    %ecx,%eax
   1c997:	c1 e0 04             	shl    $0x4,%eax
   1c99a:	01 d8                	add    %ebx,%eax
   1c99c:	83 c0 30             	add    $0x30,%eax
   1c99f:	8b 18                	mov    (%eax),%ebx
   1c9a1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c9a5:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1c9ab:	89 c8                	mov    %ecx,%eax
   1c9ad:	c1 e0 03             	shl    $0x3,%eax
   1c9b0:	01 c8                	add    %ecx,%eax
   1c9b2:	c1 e0 04             	shl    $0x4,%eax
   1c9b5:	01 f0                	add    %esi,%eax
   1c9b7:	83 c0 20             	add    $0x20,%eax
   1c9ba:	8b 00                	mov    (%eax),%eax
   1c9bc:	29 c3                	sub    %eax,%ebx
   1c9be:	89 d8                	mov    %ebx,%eax
   1c9c0:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1c9c3:	8b 82 b4 1e 01 00    	mov    0x11eb4(%edx),%eax
   1c9c9:	0f af c1             	imul   %ecx,%eax
   1c9cc:	d1 e8                	shr    %eax
   1c9ce:	89 04 24             	mov    %eax,(%esp)
				"D" (origin + video_size_row * top),
   1c9d1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c9d5:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1c9db:	89 c8                	mov    %ecx,%eax
   1c9dd:	c1 e0 03             	shl    $0x3,%eax
   1c9e0:	01 c8                	add    %ecx,%eax
   1c9e2:	c1 e0 04             	shl    $0x4,%eax
   1c9e5:	01 d8                	add    %ebx,%eax
   1c9e7:	83 c0 10             	add    $0x10,%eax
   1c9ea:	8b 18                	mov    (%eax),%ebx
   1c9ec:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1c9f0:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1c9f6:	89 c8                	mov    %ecx,%eax
   1c9f8:	c1 e0 03             	shl    $0x3,%eax
   1c9fb:	01 c8                	add    %ecx,%eax
   1c9fd:	c1 e0 04             	shl    $0x4,%eax
   1ca00:	01 f0                	add    %esi,%eax
   1ca02:	83 c0 20             	add    $0x20,%eax
   1ca05:	8b 08                	mov    (%eax),%ecx
   1ca07:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1ca0d:	0f af c1             	imul   %ecx,%eax
   1ca10:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
				"S" (origin + video_size_row * (top + 1))
   1ca13:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1ca17:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1ca1d:	89 c8                	mov    %ecx,%eax
   1ca1f:	c1 e0 03             	shl    $0x3,%eax
   1ca22:	01 c8                	add    %ecx,%eax
   1ca24:	c1 e0 04             	shl    $0x4,%eax
   1ca27:	01 d8                	add    %ebx,%eax
   1ca29:	83 c0 10             	add    $0x10,%eax
   1ca2c:	8b 18                	mov    (%eax),%ebx
   1ca2e:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1ca32:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1ca38:	89 c8                	mov    %ecx,%eax
   1ca3a:	c1 e0 03             	shl    $0x3,%eax
   1ca3d:	01 c8                	add    %ecx,%eax
   1ca3f:	c1 e0 04             	shl    $0x4,%eax
   1ca42:	01 f0                	add    %esi,%eax
   1ca44:	83 c0 20             	add    $0x20,%eax
   1ca47:	8b 00                	mov    (%eax),%eax
   1ca49:	8d 48 01             	lea    0x1(%eax),%ecx
   1ca4c:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1ca52:	0f af c1             	imul   %ecx,%eax
   1ca55:	8d 14 03             	lea    (%ebx,%eax,1),%edx
			__asm__("cld\n\t"
   1ca58:	89 e8                	mov    %ebp,%eax
   1ca5a:	8b 0c 24             	mov    (%esp),%ecx
   1ca5d:	89 d6                	mov    %edx,%esi
   1ca5f:	fc                   	cld    
   1ca60:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1ca62:	8b 0d b4 3e 04 00    	mov    0x43eb4,%ecx
   1ca68:	f3 66 ab             	rep stos %ax,%es:(%edi)
		if (!top && bottom == video_num_lines) {
   1ca6b:	e9 01 01 00 00       	jmp    1cb71 <scrup+0x5a5>
			"rep\n\t"
			"movsl\n\t"
			"movl video_num_columns, %%ecx\n\t"
			"rep\n\t"
			"stosw"
			::"a" (video_erase_char),
   1ca70:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1ca74:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1ca7a:	89 c8                	mov    %ecx,%eax
   1ca7c:	c1 e0 03             	shl    $0x3,%eax
   1ca7f:	01 c8                	add    %ecx,%eax
   1ca81:	c1 e0 04             	shl    $0x4,%eax
   1ca84:	01 d8                	add    %ebx,%eax
   1ca86:	0f b7 28             	movzwl (%eax),%ebp
			"c" ((bottom - top - 1) * video_num_columns >> 1),
   1ca89:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1ca8d:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1ca93:	89 c8                	mov    %ecx,%eax
   1ca95:	c1 e0 03             	shl    $0x3,%eax
   1ca98:	01 c8                	add    %ecx,%eax
   1ca9a:	c1 e0 04             	shl    $0x4,%eax
   1ca9d:	01 d8                	add    %ebx,%eax
   1ca9f:	83 c0 30             	add    $0x30,%eax
   1caa2:	8b 18                	mov    (%eax),%ebx
   1caa4:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1caa8:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1caae:	89 c8                	mov    %ecx,%eax
   1cab0:	c1 e0 03             	shl    $0x3,%eax
   1cab3:	01 c8                	add    %ecx,%eax
   1cab5:	c1 e0 04             	shl    $0x4,%eax
   1cab8:	01 f0                	add    %esi,%eax
   1caba:	83 c0 20             	add    $0x20,%eax
   1cabd:	8b 00                	mov    (%eax),%eax
   1cabf:	29 c3                	sub    %eax,%ebx
   1cac1:	89 d8                	mov    %ebx,%eax
   1cac3:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1cac6:	8b 82 b4 1e 01 00    	mov    0x11eb4(%edx),%eax
   1cacc:	0f af c1             	imul   %ecx,%eax
   1cacf:	d1 e8                	shr    %eax
   1cad1:	89 04 24             	mov    %eax,(%esp)
			"D" (origin + video_size_row * top),
   1cad4:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cad8:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1cade:	89 c8                	mov    %ecx,%eax
   1cae0:	c1 e0 03             	shl    $0x3,%eax
   1cae3:	01 c8                	add    %ecx,%eax
   1cae5:	c1 e0 04             	shl    $0x4,%eax
   1cae8:	01 d8                	add    %ebx,%eax
   1caea:	83 c0 10             	add    $0x10,%eax
   1caed:	8b 18                	mov    (%eax),%ebx
   1caef:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1caf3:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1caf9:	89 c8                	mov    %ecx,%eax
   1cafb:	c1 e0 03             	shl    $0x3,%eax
   1cafe:	01 c8                	add    %ecx,%eax
   1cb00:	c1 e0 04             	shl    $0x4,%eax
   1cb03:	01 f0                	add    %esi,%eax
   1cb05:	83 c0 20             	add    $0x20,%eax
   1cb08:	8b 08                	mov    (%eax),%ecx
   1cb0a:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1cb10:	0f af c1             	imul   %ecx,%eax
   1cb13:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
			"S" (origin + video_size_row * (top + 1))
   1cb16:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cb1a:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1cb20:	89 c8                	mov    %ecx,%eax
   1cb22:	c1 e0 03             	shl    $0x3,%eax
   1cb25:	01 c8                	add    %ecx,%eax
   1cb27:	c1 e0 04             	shl    $0x4,%eax
   1cb2a:	01 d8                	add    %ebx,%eax
   1cb2c:	83 c0 10             	add    $0x10,%eax
   1cb2f:	8b 18                	mov    (%eax),%ebx
   1cb31:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cb35:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1cb3b:	89 c8                	mov    %ecx,%eax
   1cb3d:	c1 e0 03             	shl    $0x3,%eax
   1cb40:	01 c8                	add    %ecx,%eax
   1cb42:	c1 e0 04             	shl    $0x4,%eax
   1cb45:	01 f0                	add    %esi,%eax
   1cb47:	83 c0 20             	add    $0x20,%eax
   1cb4a:	8b 00                	mov    (%eax),%eax
   1cb4c:	8d 48 01             	lea    0x1(%eax),%ecx
   1cb4f:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1cb55:	0f af c1             	imul   %ecx,%eax
   1cb58:	8d 14 03             	lea    (%ebx,%eax,1),%edx
		__asm__("cld\n\t"
   1cb5b:	89 e8                	mov    %ebp,%eax
   1cb5d:	8b 0c 24             	mov    (%esp),%ecx
   1cb60:	89 d6                	mov    %edx,%esi
   1cb62:	fc                   	cld    
   1cb63:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1cb65:	8b 0d b4 3e 04 00    	mov    0x43eb4,%ecx
   1cb6b:	f3 66 ab             	rep stos %ax,%es:(%edi)
   1cb6e:	eb 01                	jmp    1cb71 <scrup+0x5a5>
		return;
   1cb70:	90                   	nop
			:);
	}
}
   1cb71:	83 c4 04             	add    $0x4,%esp
   1cb74:	5b                   	pop    %ebx
   1cb75:	5e                   	pop    %esi
   1cb76:	5f                   	pop    %edi
   1cb77:	5d                   	pop    %ebp
   1cb78:	c3                   	ret    

0001cb79 <scrdown>:
// 将屏幕滚动窗口向上移动一行,相应屏幕滚动区域内容向下移动1行.并在移动开始行的上方出现一新行.处理方法与scrup()相似,只是为了在
// 移动显示内存数据时不会出现数据覆盖的问题,复制操作是以逆向进行的,即先从屏幕倒数第2行的最后一个字符开始复制到最后一行,再将倒数第3行
// 复制到倒数第2行,等等.因为此时对EGA/VGA显示类型和MDA类型的处理过程完全一样,所以该函数实际上没有必要写两段相同的代码.即这里if和
// else语句块中的操作完全一样.
static void scrdown(int currcons)
{
   1cb79:	55                   	push   %ebp
   1cb7a:	57                   	push   %edi
   1cb7b:	56                   	push   %esi
   1cb7c:	53                   	push   %ebx
   1cb7d:	83 ec 04             	sub    $0x4,%esp
   1cb80:	e8 71 a1 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   1cb85:	81 c2 7b 54 01 00    	add    $0x1547b,%edx
	// 同样,滚屏区域必须至少有2行.如果滚屏区域顶行号大于等于区域底行号,则不满足进行滚行操作的条件.另外,对于EGA/VGA卡,我们可以指定屏内行范围(区域)
	// 进行滚屏操作,而MDA单色显示卡只能进行整屏操作.由于窗口向上移动最多移动以当前控制台实际显示内存末端的情况,所以这里只需要处理普通的内存数据
	// 移动情况.
	if (bottom <= top)
   1cb8b:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cb8f:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1cb95:	89 c8                	mov    %ecx,%eax
   1cb97:	c1 e0 03             	shl    $0x3,%eax
   1cb9a:	01 c8                	add    %ecx,%eax
   1cb9c:	c1 e0 04             	shl    $0x4,%eax
   1cb9f:	01 d8                	add    %ebx,%eax
   1cba1:	83 c0 30             	add    $0x30,%eax
   1cba4:	8b 18                	mov    (%eax),%ebx
   1cba6:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cbaa:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1cbb0:	89 c8                	mov    %ecx,%eax
   1cbb2:	c1 e0 03             	shl    $0x3,%eax
   1cbb5:	01 c8                	add    %ecx,%eax
   1cbb7:	c1 e0 04             	shl    $0x4,%eax
   1cbba:	01 f0                	add    %esi,%eax
   1cbbc:	83 c0 20             	add    $0x20,%eax
   1cbbf:	8b 00                	mov    (%eax),%eax
   1cbc1:	39 c3                	cmp    %eax,%ebx
   1cbc3:	0f 86 2b 02 00 00    	jbe    1cdf4 <scrdown+0x27b>
		return;
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   1cbc9:	0f b6 82 b0 1e 01 00 	movzbl 0x11eb0(%edx),%eax
   1cbd0:	3c 21                	cmp    $0x21,%al
   1cbd2:	74 0f                	je     1cbe3 <scrdown+0x6a>
   1cbd4:	0f b6 82 b0 1e 01 00 	movzbl 0x11eb0(%edx),%eax
   1cbdb:	3c 20                	cmp    $0x20,%al
   1cbdd:	0f 85 0a 01 00 00    	jne    1cced <scrdown+0x174>
			"movsl\n\t"
			"addl $2, %%edi\n\t"								/* %edi has been decremented by 4 */ /* %edi已减4,因也是反向填擦除字符 */
			"movl video_num_columns, %%ecx\n\t"
			"rep\n\t"											// 将擦除字符填入上方新行中.
			"stosw"
			::"a" (video_erase_char),
   1cbe3:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cbe7:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1cbed:	89 c8                	mov    %ecx,%eax
   1cbef:	c1 e0 03             	shl    $0x3,%eax
   1cbf2:	01 c8                	add    %ecx,%eax
   1cbf4:	c1 e0 04             	shl    $0x4,%eax
   1cbf7:	01 d8                	add    %ebx,%eax
   1cbf9:	0f b7 28             	movzwl (%eax),%ebp
			"c" ((bottom - top - 1) * video_num_columns >> 1),
   1cbfc:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cc00:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1cc06:	89 c8                	mov    %ecx,%eax
   1cc08:	c1 e0 03             	shl    $0x3,%eax
   1cc0b:	01 c8                	add    %ecx,%eax
   1cc0d:	c1 e0 04             	shl    $0x4,%eax
   1cc10:	01 d8                	add    %ebx,%eax
   1cc12:	83 c0 30             	add    $0x30,%eax
   1cc15:	8b 18                	mov    (%eax),%ebx
   1cc17:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cc1b:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1cc21:	89 c8                	mov    %ecx,%eax
   1cc23:	c1 e0 03             	shl    $0x3,%eax
   1cc26:	01 c8                	add    %ecx,%eax
   1cc28:	c1 e0 04             	shl    $0x4,%eax
   1cc2b:	01 f0                	add    %esi,%eax
   1cc2d:	83 c0 20             	add    $0x20,%eax
   1cc30:	8b 00                	mov    (%eax),%eax
   1cc32:	29 c3                	sub    %eax,%ebx
   1cc34:	89 d8                	mov    %ebx,%eax
   1cc36:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1cc39:	8b 82 b4 1e 01 00    	mov    0x11eb4(%edx),%eax
   1cc3f:	0f af c1             	imul   %ecx,%eax
   1cc42:	d1 e8                	shr    %eax
   1cc44:	89 04 24             	mov    %eax,(%esp)
			"D" (origin + video_size_row * bottom - 4),
   1cc47:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cc4b:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1cc51:	89 c8                	mov    %ecx,%eax
   1cc53:	c1 e0 03             	shl    $0x3,%eax
   1cc56:	01 c8                	add    %ecx,%eax
   1cc58:	c1 e0 04             	shl    $0x4,%eax
   1cc5b:	01 d8                	add    %ebx,%eax
   1cc5d:	83 c0 10             	add    $0x10,%eax
   1cc60:	8b 18                	mov    (%eax),%ebx
   1cc62:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cc66:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1cc6c:	89 c8                	mov    %ecx,%eax
   1cc6e:	c1 e0 03             	shl    $0x3,%eax
   1cc71:	01 c8                	add    %ecx,%eax
   1cc73:	c1 e0 04             	shl    $0x4,%eax
   1cc76:	01 f0                	add    %esi,%eax
   1cc78:	83 c0 30             	add    $0x30,%eax
   1cc7b:	8b 08                	mov    (%eax),%ecx
   1cc7d:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1cc83:	0f af c1             	imul   %ecx,%eax
   1cc86:	01 d8                	add    %ebx,%eax
   1cc88:	8d 78 fc             	lea    -0x4(%eax),%edi
			"S" (origin + video_size_row * (bottom - 1) - 4)
   1cc8b:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cc8f:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1cc95:	89 c8                	mov    %ecx,%eax
   1cc97:	c1 e0 03             	shl    $0x3,%eax
   1cc9a:	01 c8                	add    %ecx,%eax
   1cc9c:	c1 e0 04             	shl    $0x4,%eax
   1cc9f:	01 d8                	add    %ebx,%eax
   1cca1:	83 c0 10             	add    $0x10,%eax
   1cca4:	8b 18                	mov    (%eax),%ebx
   1cca6:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1ccaa:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1ccb0:	89 c8                	mov    %ecx,%eax
   1ccb2:	c1 e0 03             	shl    $0x3,%eax
   1ccb5:	01 c8                	add    %ecx,%eax
   1ccb7:	c1 e0 04             	shl    $0x4,%eax
   1ccba:	01 f0                	add    %esi,%eax
   1ccbc:	83 c0 30             	add    $0x30,%eax
   1ccbf:	8b 00                	mov    (%eax),%eax
   1ccc1:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1ccc4:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1ccca:	0f af c1             	imul   %ecx,%eax
   1cccd:	01 d8                	add    %ebx,%eax
   1cccf:	8d 50 fc             	lea    -0x4(%eax),%edx
		__asm__("std\n\t"										// 置方向位!!
   1ccd2:	89 e8                	mov    %ebp,%eax
   1ccd4:	8b 0c 24             	mov    (%esp),%ecx
   1ccd7:	89 d6                	mov    %edx,%esi
   1ccd9:	fd                   	std    
   1ccda:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1ccdc:	83 c7 02             	add    $0x2,%edi
   1ccdf:	8b 0d b4 3e 04 00    	mov    0x43eb4,%ecx
   1cce5:	f3 66 ab             	rep stos %ax,%es:(%edi)
   1cce8:	e9 08 01 00 00       	jmp    1cdf5 <scrdown+0x27c>
			"movsl\n\t"
			"addl $2, %%edi\n\t"									/* %edi has been decremented by 4 */
			"movl video_num_columns, %%ecx\n\t"
			"rep\n\t"
			"stosw"
			::"a" (video_erase_char),
   1cced:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1ccf1:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1ccf7:	89 c8                	mov    %ecx,%eax
   1ccf9:	c1 e0 03             	shl    $0x3,%eax
   1ccfc:	01 c8                	add    %ecx,%eax
   1ccfe:	c1 e0 04             	shl    $0x4,%eax
   1cd01:	01 d8                	add    %ebx,%eax
   1cd03:	0f b7 28             	movzwl (%eax),%ebp
			"c" ((bottom - top - 1) * video_num_columns >> 1),
   1cd06:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cd0a:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1cd10:	89 c8                	mov    %ecx,%eax
   1cd12:	c1 e0 03             	shl    $0x3,%eax
   1cd15:	01 c8                	add    %ecx,%eax
   1cd17:	c1 e0 04             	shl    $0x4,%eax
   1cd1a:	01 d8                	add    %ebx,%eax
   1cd1c:	83 c0 30             	add    $0x30,%eax
   1cd1f:	8b 18                	mov    (%eax),%ebx
   1cd21:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cd25:	8d b2 ec 1e 01 00    	lea    0x11eec(%edx),%esi
   1cd2b:	89 c8                	mov    %ecx,%eax
   1cd2d:	c1 e0 03             	shl    $0x3,%eax
   1cd30:	01 c8                	add    %ecx,%eax
   1cd32:	c1 e0 04             	shl    $0x4,%eax
   1cd35:	01 f0                	add    %esi,%eax
   1cd37:	83 c0 20             	add    $0x20,%eax
   1cd3a:	8b 00                	mov    (%eax),%eax
   1cd3c:	29 c3                	sub    %eax,%ebx
   1cd3e:	89 d8                	mov    %ebx,%eax
   1cd40:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1cd43:	8b 82 b4 1e 01 00    	mov    0x11eb4(%edx),%eax
   1cd49:	0f af c1             	imul   %ecx,%eax
   1cd4c:	d1 e8                	shr    %eax
   1cd4e:	89 04 24             	mov    %eax,(%esp)
			"D" (origin + video_size_row * bottom - 4),
   1cd51:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cd55:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1cd5b:	89 c8                	mov    %ecx,%eax
   1cd5d:	c1 e0 03             	shl    $0x3,%eax
   1cd60:	01 c8                	add    %ecx,%eax
   1cd62:	c1 e0 04             	shl    $0x4,%eax
   1cd65:	01 d8                	add    %ebx,%eax
   1cd67:	83 c0 10             	add    $0x10,%eax
   1cd6a:	8b 18                	mov    (%eax),%ebx
   1cd6c:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cd70:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1cd76:	89 c8                	mov    %ecx,%eax
   1cd78:	c1 e0 03             	shl    $0x3,%eax
   1cd7b:	01 c8                	add    %ecx,%eax
   1cd7d:	c1 e0 04             	shl    $0x4,%eax
   1cd80:	01 f0                	add    %esi,%eax
   1cd82:	83 c0 30             	add    $0x30,%eax
   1cd85:	8b 08                	mov    (%eax),%ecx
   1cd87:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1cd8d:	0f af c1             	imul   %ecx,%eax
   1cd90:	01 d8                	add    %ebx,%eax
   1cd92:	8d 78 fc             	lea    -0x4(%eax),%edi
			"S" (origin + video_size_row * (bottom - 1) - 4)
   1cd95:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cd99:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1cd9f:	89 c8                	mov    %ecx,%eax
   1cda1:	c1 e0 03             	shl    $0x3,%eax
   1cda4:	01 c8                	add    %ecx,%eax
   1cda6:	c1 e0 04             	shl    $0x4,%eax
   1cda9:	01 d8                	add    %ebx,%eax
   1cdab:	83 c0 10             	add    $0x10,%eax
   1cdae:	8b 18                	mov    (%eax),%ebx
   1cdb0:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1cdb4:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1cdba:	89 c8                	mov    %ecx,%eax
   1cdbc:	c1 e0 03             	shl    $0x3,%eax
   1cdbf:	01 c8                	add    %ecx,%eax
   1cdc1:	c1 e0 04             	shl    $0x4,%eax
   1cdc4:	01 f0                	add    %esi,%eax
   1cdc6:	83 c0 30             	add    $0x30,%eax
   1cdc9:	8b 00                	mov    (%eax),%eax
   1cdcb:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1cdce:	8b 82 c0 1e 01 00    	mov    0x11ec0(%edx),%eax
   1cdd4:	0f af c1             	imul   %ecx,%eax
   1cdd7:	01 d8                	add    %ebx,%eax
   1cdd9:	8d 50 fc             	lea    -0x4(%eax),%edx
		__asm__("std\n\t"
   1cddc:	89 e8                	mov    %ebp,%eax
   1cdde:	8b 0c 24             	mov    (%esp),%ecx
   1cde1:	89 d6                	mov    %edx,%esi
   1cde3:	fd                   	std    
   1cde4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1cde6:	83 c7 02             	add    $0x2,%edi
   1cde9:	8b 0d b4 3e 04 00    	mov    0x43eb4,%ecx
   1cdef:	f3 66 ab             	rep stos %ax,%es:(%edi)
   1cdf2:	eb 01                	jmp    1cdf5 <scrdown+0x27c>
		return;
   1cdf4:	90                   	nop
			:);
	}
}
   1cdf5:	83 c4 04             	add    $0x4,%esp
   1cdf8:	5b                   	pop    %ebx
   1cdf9:	5e                   	pop    %esi
   1cdfa:	5f                   	pop    %edi
   1cdfb:	5d                   	pop    %ebp
   1cdfc:	c3                   	ret    

0001cdfd <lf>:
// 光标在同列位置下移一行.
// 如果光标没有处在最后一行,则直接修改光标当前行变量y++,并调整光标对应显示内存位置pos(加上一行字符所对应的内存长度).否则
// 需要将屏幕窗口内容上移一行.
// 函数名称lf(line feed 换行)是指处理控制字符LF.
static void lf(int currcons)
{
   1cdfd:	56                   	push   %esi
   1cdfe:	53                   	push   %ebx
   1cdff:	e8 ee 9e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1ce04:	05 fc 51 01 00       	add    $0x151fc,%eax
	if (y + 1 < bottom) {
   1ce09:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1ce0d:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1ce13:	89 ca                	mov    %ecx,%edx
   1ce15:	c1 e2 03             	shl    $0x3,%edx
   1ce18:	01 ca                	add    %ecx,%edx
   1ce1a:	c1 e2 04             	shl    $0x4,%edx
   1ce1d:	01 da                	add    %ebx,%edx
   1ce1f:	83 c2 20             	add    $0x20,%edx
   1ce22:	8b 12                	mov    (%edx),%edx
   1ce24:	8d 72 01             	lea    0x1(%edx),%esi
   1ce27:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1ce2b:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1ce31:	89 ca                	mov    %ecx,%edx
   1ce33:	c1 e2 03             	shl    $0x3,%edx
   1ce36:	01 ca                	add    %ecx,%edx
   1ce38:	c1 e2 04             	shl    $0x4,%edx
   1ce3b:	01 da                	add    %ebx,%edx
   1ce3d:	83 c2 30             	add    $0x30,%edx
   1ce40:	8b 12                	mov    (%edx),%edx
   1ce42:	39 d6                	cmp    %edx,%esi
   1ce44:	73 79                	jae    1cebf <lf+0xc2>
		y++;
   1ce46:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1ce4a:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1ce50:	89 ca                	mov    %ecx,%edx
   1ce52:	c1 e2 03             	shl    $0x3,%edx
   1ce55:	01 ca                	add    %ecx,%edx
   1ce57:	c1 e2 04             	shl    $0x4,%edx
   1ce5a:	01 da                	add    %ebx,%edx
   1ce5c:	83 c2 20             	add    $0x20,%edx
   1ce5f:	8b 12                	mov    (%edx),%edx
   1ce61:	8d 5a 01             	lea    0x1(%edx),%ebx
   1ce64:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1ce68:	8d b0 e8 1e 01 00    	lea    0x11ee8(%eax),%esi
   1ce6e:	89 ca                	mov    %ecx,%edx
   1ce70:	c1 e2 03             	shl    $0x3,%edx
   1ce73:	01 ca                	add    %ecx,%edx
   1ce75:	c1 e2 04             	shl    $0x4,%edx
   1ce78:	01 f2                	add    %esi,%edx
   1ce7a:	83 c2 20             	add    $0x20,%edx
   1ce7d:	89 1a                	mov    %ebx,(%edx)
		pos += video_size_row;							// 加上屏幕一行占用内存的字节数.
   1ce7f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1ce83:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1ce89:	89 ca                	mov    %ecx,%edx
   1ce8b:	c1 e2 03             	shl    $0x3,%edx
   1ce8e:	01 ca                	add    %ecx,%edx
   1ce90:	c1 e2 04             	shl    $0x4,%edx
   1ce93:	01 da                	add    %ebx,%edx
   1ce95:	83 c2 20             	add    $0x20,%edx
   1ce98:	8b 0a                	mov    (%edx),%ecx
   1ce9a:	8b 90 c0 1e 01 00    	mov    0x11ec0(%eax),%edx
   1cea0:	01 d1                	add    %edx,%ecx
   1cea2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1cea6:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1ceac:	89 d0                	mov    %edx,%eax
   1ceae:	c1 e0 03             	shl    $0x3,%eax
   1ceb1:	01 d0                	add    %edx,%eax
   1ceb3:	c1 e0 04             	shl    $0x4,%eax
   1ceb6:	01 d8                	add    %ebx,%eax
   1ceb8:	83 c0 20             	add    $0x20,%eax
   1cebb:	89 08                	mov    %ecx,(%eax)
		return;
   1cebd:	eb 0c                	jmp    1cecb <lf+0xce>
	}
	scrup(currcons);									// 将屏幕窗口内容上移一行.
   1cebf:	ff 74 24 0c          	pushl  0xc(%esp)
   1cec3:	e8 04 f7 ff ff       	call   1c5cc <scrup>
   1cec8:	83 c4 04             	add    $0x4,%esp
}
   1cecb:	5b                   	pop    %ebx
   1cecc:	5e                   	pop    %esi
   1cecd:	c3                   	ret    

0001cece <ri>:
// 光标在同列上移一行
// 如果光标不在屏幕第一行上,则直接修改光标当前标量y--,并调整光标对应显示内存位置pos,减去屏幕上一行字符所对应的内存长度字节数.
// 否则需要将屏幕窗口内容下移一行.
// 函数名称ri(reverse index 反向索引)是指控制字符RI或转义序列"ESC M".
static void ri(int currcons)
{
   1cece:	56                   	push   %esi
   1cecf:	53                   	push   %ebx
   1ced0:	e8 1d 9e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1ced5:	05 2b 51 01 00       	add    $0x1512b,%eax
	if (y > top) {
   1ceda:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cede:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1cee4:	89 ca                	mov    %ecx,%edx
   1cee6:	c1 e2 03             	shl    $0x3,%edx
   1cee9:	01 ca                	add    %ecx,%edx
   1ceeb:	c1 e2 04             	shl    $0x4,%edx
   1ceee:	01 da                	add    %ebx,%edx
   1cef0:	83 c2 20             	add    $0x20,%edx
   1cef3:	8b 1a                	mov    (%edx),%ebx
   1cef5:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cef9:	8d b0 ec 1e 01 00    	lea    0x11eec(%eax),%esi
   1ceff:	89 ca                	mov    %ecx,%edx
   1cf01:	c1 e2 03             	shl    $0x3,%edx
   1cf04:	01 ca                	add    %ecx,%edx
   1cf06:	c1 e2 04             	shl    $0x4,%edx
   1cf09:	01 f2                	add    %esi,%edx
   1cf0b:	83 c2 20             	add    $0x20,%edx
   1cf0e:	8b 12                	mov    (%edx),%edx
   1cf10:	39 d3                	cmp    %edx,%ebx
   1cf12:	76 79                	jbe    1cf8d <ri+0xbf>
		y--;											// 减去屏幕一行占用内存的字节数
   1cf14:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cf18:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1cf1e:	89 ca                	mov    %ecx,%edx
   1cf20:	c1 e2 03             	shl    $0x3,%edx
   1cf23:	01 ca                	add    %ecx,%edx
   1cf25:	c1 e2 04             	shl    $0x4,%edx
   1cf28:	01 da                	add    %ebx,%edx
   1cf2a:	83 c2 20             	add    $0x20,%edx
   1cf2d:	8b 12                	mov    (%edx),%edx
   1cf2f:	8d 5a ff             	lea    -0x1(%edx),%ebx
   1cf32:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cf36:	8d b0 e8 1e 01 00    	lea    0x11ee8(%eax),%esi
   1cf3c:	89 ca                	mov    %ecx,%edx
   1cf3e:	c1 e2 03             	shl    $0x3,%edx
   1cf41:	01 ca                	add    %ecx,%edx
   1cf43:	c1 e2 04             	shl    $0x4,%edx
   1cf46:	01 f2                	add    %esi,%edx
   1cf48:	83 c2 20             	add    $0x20,%edx
   1cf4b:	89 1a                	mov    %ebx,(%edx)
		pos -= video_size_row;
   1cf4d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cf51:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1cf57:	89 ca                	mov    %ecx,%edx
   1cf59:	c1 e2 03             	shl    $0x3,%edx
   1cf5c:	01 ca                	add    %ecx,%edx
   1cf5e:	c1 e2 04             	shl    $0x4,%edx
   1cf61:	01 da                	add    %ebx,%edx
   1cf63:	83 c2 20             	add    $0x20,%edx
   1cf66:	8b 0a                	mov    (%edx),%ecx
   1cf68:	8b 90 c0 1e 01 00    	mov    0x11ec0(%eax),%edx
   1cf6e:	29 d1                	sub    %edx,%ecx
   1cf70:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1cf74:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1cf7a:	89 d0                	mov    %edx,%eax
   1cf7c:	c1 e0 03             	shl    $0x3,%eax
   1cf7f:	01 d0                	add    %edx,%eax
   1cf81:	c1 e0 04             	shl    $0x4,%eax
   1cf84:	01 d8                	add    %ebx,%eax
   1cf86:	83 c0 20             	add    $0x20,%eax
   1cf89:	89 08                	mov    %ecx,(%eax)
		return;
   1cf8b:	eb 0c                	jmp    1cf99 <ri+0xcb>
	}
	scrdown(currcons);									// 将屏幕窗口内容下移一行
   1cf8d:	ff 74 24 0c          	pushl  0xc(%esp)
   1cf91:	e8 e3 fb ff ff       	call   1cb79 <scrdown>
   1cf96:	83 c4 04             	add    $0x4,%esp
}
   1cf99:	5b                   	pop    %ebx
   1cf9a:	5e                   	pop    %esi
   1cf9b:	c3                   	ret    

0001cf9c <cr>:

// 光标回到第1列(0列).
// 调整光标对应内存位置pos.光标所在列号*2即是0列到光标所在列对应的内存字节长度.
// 函数名称cr(carriage return回车)指明处理的控制字符的回车.
static void cr(int currcons)
{
   1cf9c:	56                   	push   %esi
   1cf9d:	53                   	push   %ebx
   1cf9e:	e8 53 9d fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   1cfa3:	81 c2 5d 50 01 00    	add    $0x1505d,%edx
	pos -= x << 1;										// 减去0列到光标处占用的内存字节数.
   1cfa9:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cfad:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1cfb3:	89 c8                	mov    %ecx,%eax
   1cfb5:	c1 e0 03             	shl    $0x3,%eax
   1cfb8:	01 c8                	add    %ecx,%eax
   1cfba:	c1 e0 04             	shl    $0x4,%eax
   1cfbd:	01 d8                	add    %ebx,%eax
   1cfbf:	83 c0 20             	add    $0x20,%eax
   1cfc2:	8b 18                	mov    (%eax),%ebx
   1cfc4:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cfc8:	8d b2 e4 1e 01 00    	lea    0x11ee4(%edx),%esi
   1cfce:	89 c8                	mov    %ecx,%eax
   1cfd0:	c1 e0 03             	shl    $0x3,%eax
   1cfd3:	01 c8                	add    %ecx,%eax
   1cfd5:	c1 e0 04             	shl    $0x4,%eax
   1cfd8:	01 f0                	add    %esi,%eax
   1cfda:	83 c0 20             	add    $0x20,%eax
   1cfdd:	8b 00                	mov    (%eax),%eax
   1cfdf:	01 c0                	add    %eax,%eax
   1cfe1:	29 c3                	sub    %eax,%ebx
   1cfe3:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cfe7:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1cfed:	89 c8                	mov    %ecx,%eax
   1cfef:	c1 e0 03             	shl    $0x3,%eax
   1cff2:	01 c8                	add    %ecx,%eax
   1cff4:	c1 e0 04             	shl    $0x4,%eax
   1cff7:	01 f0                	add    %esi,%eax
   1cff9:	83 c0 20             	add    $0x20,%eax
   1cffc:	89 18                	mov    %ebx,(%eax)
	x = 0;
   1cffe:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1d002:	8d 92 e4 1e 01 00    	lea    0x11ee4(%edx),%edx
   1d008:	89 c8                	mov    %ecx,%eax
   1d00a:	c1 e0 03             	shl    $0x3,%eax
   1d00d:	01 c8                	add    %ecx,%eax
   1d00f:	c1 e0 04             	shl    $0x4,%eax
   1d012:	01 d0                	add    %edx,%eax
   1d014:	83 c0 20             	add    $0x20,%eax
   1d017:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   1d01d:	90                   	nop
   1d01e:	5b                   	pop    %ebx
   1d01f:	5e                   	pop    %esi
   1d020:	c3                   	ret    

0001d021 <del>:

// 擦除光标前一字符(用空格替代)(del -delete 删除)
// 如果光标没有处在0列,则将光标对应内存位置pos后退2字节(对应屏幕上一个字符),然后将当前光标变量列值减1,并将光标所在位置处字符符擦除
static void del(int currcons)
{
   1d021:	56                   	push   %esi
   1d022:	53                   	push   %ebx
   1d023:	e8 ca 9c fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1d028:	05 d8 4f 01 00       	add    $0x14fd8,%eax
	if (x) {
   1d02d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1d031:	8d 98 e4 1e 01 00    	lea    0x11ee4(%eax),%ebx
   1d037:	89 ca                	mov    %ecx,%edx
   1d039:	c1 e2 03             	shl    $0x3,%edx
   1d03c:	01 ca                	add    %ecx,%edx
   1d03e:	c1 e2 04             	shl    $0x4,%edx
   1d041:	01 da                	add    %ebx,%edx
   1d043:	83 c2 20             	add    $0x20,%edx
   1d046:	8b 12                	mov    (%edx),%edx
   1d048:	85 d2                	test   %edx,%edx
   1d04a:	0f 84 ab 00 00 00    	je     1d0fb <del+0xda>
		pos -= 2;
   1d050:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1d054:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1d05a:	89 ca                	mov    %ecx,%edx
   1d05c:	c1 e2 03             	shl    $0x3,%edx
   1d05f:	01 ca                	add    %ecx,%edx
   1d061:	c1 e2 04             	shl    $0x4,%edx
   1d064:	01 da                	add    %ebx,%edx
   1d066:	83 c2 20             	add    $0x20,%edx
   1d069:	8b 12                	mov    (%edx),%edx
   1d06b:	8d 5a fe             	lea    -0x2(%edx),%ebx
   1d06e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1d072:	8d b0 e0 1e 01 00    	lea    0x11ee0(%eax),%esi
   1d078:	89 ca                	mov    %ecx,%edx
   1d07a:	c1 e2 03             	shl    $0x3,%edx
   1d07d:	01 ca                	add    %ecx,%edx
   1d07f:	c1 e2 04             	shl    $0x4,%edx
   1d082:	01 f2                	add    %esi,%edx
   1d084:	83 c2 20             	add    $0x20,%edx
   1d087:	89 1a                	mov    %ebx,(%edx)
		x--;
   1d089:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1d08d:	8d 98 e4 1e 01 00    	lea    0x11ee4(%eax),%ebx
   1d093:	89 ca                	mov    %ecx,%edx
   1d095:	c1 e2 03             	shl    $0x3,%edx
   1d098:	01 ca                	add    %ecx,%edx
   1d09a:	c1 e2 04             	shl    $0x4,%edx
   1d09d:	01 da                	add    %ebx,%edx
   1d09f:	83 c2 20             	add    $0x20,%edx
   1d0a2:	8b 12                	mov    (%edx),%edx
   1d0a4:	8d 5a ff             	lea    -0x1(%edx),%ebx
   1d0a7:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1d0ab:	8d b0 e4 1e 01 00    	lea    0x11ee4(%eax),%esi
   1d0b1:	89 ca                	mov    %ecx,%edx
   1d0b3:	c1 e2 03             	shl    $0x3,%edx
   1d0b6:	01 ca                	add    %ecx,%edx
   1d0b8:	c1 e2 04             	shl    $0x4,%edx
   1d0bb:	01 f2                	add    %esi,%edx
   1d0bd:	83 c2 20             	add    $0x20,%edx
   1d0c0:	89 1a                	mov    %ebx,(%edx)
		*(unsigned short *)pos = video_erase_char;
   1d0c2:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1d0c6:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1d0cc:	89 ca                	mov    %ecx,%edx
   1d0ce:	c1 e2 03             	shl    $0x3,%edx
   1d0d1:	01 ca                	add    %ecx,%edx
   1d0d3:	c1 e2 04             	shl    $0x4,%edx
   1d0d6:	01 da                	add    %ebx,%edx
   1d0d8:	83 c2 20             	add    $0x20,%edx
   1d0db:	8b 12                	mov    (%edx),%edx
   1d0dd:	89 d3                	mov    %edx,%ebx
   1d0df:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1d0e3:	8d 88 e0 1e 01 00    	lea    0x11ee0(%eax),%ecx
   1d0e9:	89 d0                	mov    %edx,%eax
   1d0eb:	c1 e0 03             	shl    $0x3,%eax
   1d0ee:	01 d0                	add    %edx,%eax
   1d0f0:	c1 e0 04             	shl    $0x4,%eax
   1d0f3:	01 c8                	add    %ecx,%eax
   1d0f5:	0f b7 00             	movzwl (%eax),%eax
   1d0f8:	66 89 03             	mov    %ax,(%ebx)
	}
}
   1d0fb:	90                   	nop
   1d0fc:	5b                   	pop    %ebx
   1d0fd:	5e                   	pop    %esi
   1d0fe:	c3                   	ret    

0001d0ff <csi_J>:
// ANSI控制序列: 'ESC [ Ps J'(Ps = 0 - 删除光标处到屏幕底端;1 - 删除屏幕开始到光标处;2 - 整屏删除).本函数根据指定的控制序列
// 具体参数值,执行与光标位置的删除操作,并且在擦除字符或行时光标位置不变.
// 函数名称csi_J(CSI - Control Sequence Introducer,即控制序列引导码)指明对控制序列"CSI Ps J"进行处理.
// 参数:vpar - 对应上面控制序列中Ps的值.
static void csi_J(int currcons, int vpar)
{
   1d0ff:	57                   	push   %edi
   1d100:	56                   	push   %esi
   1d101:	53                   	push   %ebx
   1d102:	83 ec 10             	sub    $0x10,%esp
   1d105:	e8 e8 9b fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1d10a:	05 f6 4e 01 00       	add    $0x14ef6,%eax
	long count;
	long start;

	// 首先根据三种情况分别设置需要删除的字符数和删除开始的显示内存位置.
	switch (vpar) {
   1d10f:	8b 54 24 24          	mov    0x24(%esp),%edx
   1d113:	83 fa 01             	cmp    $0x1,%edx
   1d116:	74 76                	je     1d18e <csi_J+0x8f>
   1d118:	83 fa 02             	cmp    $0x2,%edx
   1d11b:	0f 84 ce 00 00 00    	je     1d1ef <csi_J+0xf0>
   1d121:	85 d2                	test   %edx,%edx
   1d123:	74 05                	je     1d12a <csi_J+0x2b>
		case 2: 											/* erase whole display */
			count = video_num_columns * video_num_lines;	/* 删除整个屏幕上的所有字符 */
			start = origin;
			break;
		default:
			return;
   1d125:	e9 21 01 00 00       	jmp    1d24b <csi_J+0x14c>
			count = (scr_end - pos) >> 1;					/* 擦除光标到屏幕底端所有字符 */
   1d12a:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d12e:	8d 98 ec 1e 01 00    	lea    0x11eec(%eax),%ebx
   1d134:	89 ca                	mov    %ecx,%edx
   1d136:	c1 e2 03             	shl    $0x3,%edx
   1d139:	01 ca                	add    %ecx,%edx
   1d13b:	c1 e2 04             	shl    $0x4,%edx
   1d13e:	01 da                	add    %ebx,%edx
   1d140:	83 c2 10             	add    $0x10,%edx
   1d143:	8b 1a                	mov    (%edx),%ebx
   1d145:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d149:	8d b0 e0 1e 01 00    	lea    0x11ee0(%eax),%esi
   1d14f:	89 ca                	mov    %ecx,%edx
   1d151:	c1 e2 03             	shl    $0x3,%edx
   1d154:	01 ca                	add    %ecx,%edx
   1d156:	c1 e2 04             	shl    $0x4,%edx
   1d159:	01 f2                	add    %esi,%edx
   1d15b:	83 c2 20             	add    $0x20,%edx
   1d15e:	8b 12                	mov    (%edx),%edx
   1d160:	29 d3                	sub    %edx,%ebx
   1d162:	89 da                	mov    %ebx,%edx
   1d164:	d1 ea                	shr    %edx
   1d166:	89 54 24 0c          	mov    %edx,0xc(%esp)
			start = pos;
   1d16a:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d16e:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1d174:	89 ca                	mov    %ecx,%edx
   1d176:	c1 e2 03             	shl    $0x3,%edx
   1d179:	01 ca                	add    %ecx,%edx
   1d17b:	c1 e2 04             	shl    $0x4,%edx
   1d17e:	01 da                	add    %ebx,%edx
   1d180:	83 c2 20             	add    $0x20,%edx
   1d183:	8b 12                	mov    (%edx),%edx
   1d185:	89 54 24 08          	mov    %edx,0x8(%esp)
			break;
   1d189:	e9 94 00 00 00       	jmp    1d222 <csi_J+0x123>
			count = (pos - origin) >> 1;					/* 删除从屏幕开始到光标处的字符 */
   1d18e:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d192:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1d198:	89 ca                	mov    %ecx,%edx
   1d19a:	c1 e2 03             	shl    $0x3,%edx
   1d19d:	01 ca                	add    %ecx,%edx
   1d19f:	c1 e2 04             	shl    $0x4,%edx
   1d1a2:	01 da                	add    %ebx,%edx
   1d1a4:	83 c2 20             	add    $0x20,%edx
   1d1a7:	8b 1a                	mov    (%edx),%ebx
   1d1a9:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d1ad:	8d b0 e8 1e 01 00    	lea    0x11ee8(%eax),%esi
   1d1b3:	89 ca                	mov    %ecx,%edx
   1d1b5:	c1 e2 03             	shl    $0x3,%edx
   1d1b8:	01 ca                	add    %ecx,%edx
   1d1ba:	c1 e2 04             	shl    $0x4,%edx
   1d1bd:	01 f2                	add    %esi,%edx
   1d1bf:	83 c2 10             	add    $0x10,%edx
   1d1c2:	8b 12                	mov    (%edx),%edx
   1d1c4:	29 d3                	sub    %edx,%ebx
   1d1c6:	89 da                	mov    %ebx,%edx
   1d1c8:	d1 ea                	shr    %edx
   1d1ca:	89 54 24 0c          	mov    %edx,0xc(%esp)
			start = origin;
   1d1ce:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d1d2:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1d1d8:	89 ca                	mov    %ecx,%edx
   1d1da:	c1 e2 03             	shl    $0x3,%edx
   1d1dd:	01 ca                	add    %ecx,%edx
   1d1df:	c1 e2 04             	shl    $0x4,%edx
   1d1e2:	01 da                	add    %ebx,%edx
   1d1e4:	83 c2 10             	add    $0x10,%edx
   1d1e7:	8b 12                	mov    (%edx),%edx
   1d1e9:	89 54 24 08          	mov    %edx,0x8(%esp)
			break;
   1d1ed:	eb 33                	jmp    1d222 <csi_J+0x123>
			count = video_num_columns * video_num_lines;	/* 删除整个屏幕上的所有字符 */
   1d1ef:	8b 88 b4 1e 01 00    	mov    0x11eb4(%eax),%ecx
   1d1f5:	8b 90 c4 1e 01 00    	mov    0x11ec4(%eax),%edx
   1d1fb:	0f af d1             	imul   %ecx,%edx
   1d1fe:	89 54 24 0c          	mov    %edx,0xc(%esp)
			start = origin;
   1d202:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d206:	8d 98 e8 1e 01 00    	lea    0x11ee8(%eax),%ebx
   1d20c:	89 ca                	mov    %ecx,%edx
   1d20e:	c1 e2 03             	shl    $0x3,%edx
   1d211:	01 ca                	add    %ecx,%edx
   1d213:	c1 e2 04             	shl    $0x4,%edx
   1d216:	01 da                	add    %ebx,%edx
   1d218:	83 c2 10             	add    $0x10,%edx
   1d21b:	8b 12                	mov    (%edx),%edx
   1d21d:	89 54 24 08          	mov    %edx,0x8(%esp)
			break;
   1d221:	90                   	nop
	// %0 - ecx(删除的字符数count);%1 - edi(删除操作开始的地址);%2 - eax(填入的擦除字符).
	__asm__("cld\n\t"
		"rep\n\t"
		"stosw\n\t"
		::"c" (count),
		"D" (start),"a" (video_erase_char)
   1d222:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d226:	8d 88 e0 1e 01 00    	lea    0x11ee0(%eax),%ecx
   1d22c:	89 d0                	mov    %edx,%eax
   1d22e:	c1 e0 03             	shl    $0x3,%eax
   1d231:	01 d0                	add    %edx,%eax
   1d233:	c1 e0 04             	shl    $0x4,%eax
   1d236:	01 c8                	add    %ecx,%eax
   1d238:	0f b7 00             	movzwl (%eax),%eax
	__asm__("cld\n\t"
   1d23b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1d23f:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1d243:	89 d1                	mov    %edx,%ecx
   1d245:	89 df                	mov    %ebx,%edi
   1d247:	fc                   	cld    
   1d248:	f3 66 ab             	rep stos %ax,%es:(%edi)
		:);
}
   1d24b:	83 c4 10             	add    $0x10,%esp
   1d24e:	5b                   	pop    %ebx
   1d24f:	5e                   	pop    %esi
   1d250:	5f                   	pop    %edi
   1d251:	c3                   	ret    

0001d252 <csi_K>:
// 删除上一行上与光标位置相关的部分.
// ANSI转义字符序列:'ESC [ Ps K'(Ps = 0删除到行尾;1 从开始删除;2 整行都删除).本函数根据参数擦除光标所在行的部分或所有字符.擦除操作从屏幕上
// 移走字符但不影响其他字符.擦除的字符被丢弃.在擦除字符或行时光标位置不变.
// 参数:par - 对应上面控制序列中Ps的值.
static void csi_K(int currcons, int vpar)
{
   1d252:	57                   	push   %edi
   1d253:	56                   	push   %esi
   1d254:	53                   	push   %ebx
   1d255:	83 ec 10             	sub    $0x10,%esp
   1d258:	e8 95 9a fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1d25d:	05 a3 4d 01 00       	add    $0x14da3,%eax
	long count;
	long start;

	// 首先根据三种情况分别设置需要删除的字符数和删除开始的显示内存位置.
	switch (vpar) {
   1d262:	8b 54 24 24          	mov    0x24(%esp),%edx
   1d266:	83 fa 01             	cmp    $0x1,%edx
   1d269:	0f 84 88 00 00 00    	je     1d2f7 <csi_K+0xa5>
   1d26f:	83 fa 02             	cmp    $0x2,%edx
   1d272:	0f 84 eb 00 00 00    	je     1d363 <csi_K+0x111>
   1d278:	85 d2                	test   %edx,%edx
   1d27a:	74 05                	je     1d281 <csi_K+0x2f>
		case 2: 												/* erase whole line */
			start = pos - (x << 1);								/* 将整行字符全删除 */
			count = video_num_columns;
			break;
		default:
			return;
   1d27c:	e9 59 01 00 00       	jmp    1d3da <csi_K+0x188>
			if (x >= video_num_columns)							/* 删除光标到行尾所有字符 */
   1d281:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d285:	8d 98 e4 1e 01 00    	lea    0x11ee4(%eax),%ebx
   1d28b:	89 ca                	mov    %ecx,%edx
   1d28d:	c1 e2 03             	shl    $0x3,%edx
   1d290:	01 ca                	add    %ecx,%edx
   1d292:	c1 e2 04             	shl    $0x4,%edx
   1d295:	01 da                	add    %ebx,%edx
   1d297:	83 c2 20             	add    $0x20,%edx
   1d29a:	8b 0a                	mov    (%edx),%ecx
   1d29c:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1d2a2:	39 d1                	cmp    %edx,%ecx
   1d2a4:	0f 83 2f 01 00 00    	jae    1d3d9 <csi_K+0x187>
			count = video_num_columns - x;
   1d2aa:	8b 98 b4 1e 01 00    	mov    0x11eb4(%eax),%ebx
   1d2b0:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d2b4:	8d b0 e4 1e 01 00    	lea    0x11ee4(%eax),%esi
   1d2ba:	89 ca                	mov    %ecx,%edx
   1d2bc:	c1 e2 03             	shl    $0x3,%edx
   1d2bf:	01 ca                	add    %ecx,%edx
   1d2c1:	c1 e2 04             	shl    $0x4,%edx
   1d2c4:	01 f2                	add    %esi,%edx
   1d2c6:	83 c2 20             	add    $0x20,%edx
   1d2c9:	8b 12                	mov    (%edx),%edx
   1d2cb:	29 d3                	sub    %edx,%ebx
   1d2cd:	89 da                	mov    %ebx,%edx
   1d2cf:	89 54 24 0c          	mov    %edx,0xc(%esp)
			start = pos;
   1d2d3:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d2d7:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1d2dd:	89 ca                	mov    %ecx,%edx
   1d2df:	c1 e2 03             	shl    $0x3,%edx
   1d2e2:	01 ca                	add    %ecx,%edx
   1d2e4:	c1 e2 04             	shl    $0x4,%edx
   1d2e7:	01 da                	add    %ebx,%edx
   1d2e9:	83 c2 20             	add    $0x20,%edx
   1d2ec:	8b 12                	mov    (%edx),%edx
   1d2ee:	89 54 24 08          	mov    %edx,0x8(%esp)
			break;
   1d2f2:	e9 b7 00 00 00       	jmp    1d3ae <csi_K+0x15c>
			start = pos - (x << 1);								/* 删除从行开始到光标处 */
   1d2f7:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d2fb:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1d301:	89 ca                	mov    %ecx,%edx
   1d303:	c1 e2 03             	shl    $0x3,%edx
   1d306:	01 ca                	add    %ecx,%edx
   1d308:	c1 e2 04             	shl    $0x4,%edx
   1d30b:	01 da                	add    %ebx,%edx
   1d30d:	83 c2 20             	add    $0x20,%edx
   1d310:	8b 1a                	mov    (%edx),%ebx
   1d312:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d316:	8d b0 e4 1e 01 00    	lea    0x11ee4(%eax),%esi
   1d31c:	89 ca                	mov    %ecx,%edx
   1d31e:	c1 e2 03             	shl    $0x3,%edx
   1d321:	01 ca                	add    %ecx,%edx
   1d323:	c1 e2 04             	shl    $0x4,%edx
   1d326:	01 f2                	add    %esi,%edx
   1d328:	83 c2 20             	add    $0x20,%edx
   1d32b:	8b 12                	mov    (%edx),%edx
   1d32d:	01 d2                	add    %edx,%edx
   1d32f:	29 d3                	sub    %edx,%ebx
   1d331:	89 da                	mov    %ebx,%edx
   1d333:	89 54 24 08          	mov    %edx,0x8(%esp)
			count = (x < video_num_columns) ? x : video_num_columns;
   1d337:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d33b:	8d 98 e4 1e 01 00    	lea    0x11ee4(%eax),%ebx
   1d341:	89 ca                	mov    %ecx,%edx
   1d343:	c1 e2 03             	shl    $0x3,%edx
   1d346:	01 ca                	add    %ecx,%edx
   1d348:	c1 e2 04             	shl    $0x4,%edx
   1d34b:	01 da                	add    %ebx,%edx
   1d34d:	83 c2 20             	add    $0x20,%edx
   1d350:	8b 0a                	mov    (%edx),%ecx
   1d352:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1d358:	39 d1                	cmp    %edx,%ecx
   1d35a:	0f 46 d1             	cmovbe %ecx,%edx
   1d35d:	89 54 24 0c          	mov    %edx,0xc(%esp)
			break;
   1d361:	eb 4b                	jmp    1d3ae <csi_K+0x15c>
			start = pos - (x << 1);								/* 将整行字符全删除 */
   1d363:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d367:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1d36d:	89 ca                	mov    %ecx,%edx
   1d36f:	c1 e2 03             	shl    $0x3,%edx
   1d372:	01 ca                	add    %ecx,%edx
   1d374:	c1 e2 04             	shl    $0x4,%edx
   1d377:	01 da                	add    %ebx,%edx
   1d379:	83 c2 20             	add    $0x20,%edx
   1d37c:	8b 1a                	mov    (%edx),%ebx
   1d37e:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   1d382:	8d b0 e4 1e 01 00    	lea    0x11ee4(%eax),%esi
   1d388:	89 ca                	mov    %ecx,%edx
   1d38a:	c1 e2 03             	shl    $0x3,%edx
   1d38d:	01 ca                	add    %ecx,%edx
   1d38f:	c1 e2 04             	shl    $0x4,%edx
   1d392:	01 f2                	add    %esi,%edx
   1d394:	83 c2 20             	add    $0x20,%edx
   1d397:	8b 12                	mov    (%edx),%edx
   1d399:	01 d2                	add    %edx,%edx
   1d39b:	29 d3                	sub    %edx,%ebx
   1d39d:	89 da                	mov    %ebx,%edx
   1d39f:	89 54 24 08          	mov    %edx,0x8(%esp)
			count = video_num_columns;
   1d3a3:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1d3a9:	89 54 24 0c          	mov    %edx,0xc(%esp)
			break;
   1d3ad:	90                   	nop
	// %0 - ecx(删除字符数count);%1 - edi(删除操作开始地址);%2 - eax(填入的擦除字符).
	__asm__("cld\n\t"
		"rep\n\t"
		"stosw\n\t"
		::"c" (count),
		"D" (start),"a" (video_erase_char)
   1d3ae:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d3b2:	8d 88 e0 1e 01 00    	lea    0x11ee0(%eax),%ecx
   1d3b8:	89 d0                	mov    %edx,%eax
   1d3ba:	c1 e0 03             	shl    $0x3,%eax
   1d3bd:	01 d0                	add    %edx,%eax
   1d3bf:	c1 e0 04             	shl    $0x4,%eax
   1d3c2:	01 c8                	add    %ecx,%eax
   1d3c4:	0f b7 00             	movzwl (%eax),%eax
	__asm__("cld\n\t"
   1d3c7:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1d3cb:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1d3cf:	89 d1                	mov    %edx,%ecx
   1d3d1:	89 df                	mov    %ebx,%edi
   1d3d3:	fc                   	cld    
   1d3d4:	f3 66 ab             	rep stos %ax,%es:(%edi)
   1d3d7:	eb 01                	jmp    1d3da <csi_K+0x188>
				return;
   1d3d9:	90                   	nop
		:);
}
   1d3da:	83 c4 10             	add    $0x10,%esp
   1d3dd:	5b                   	pop    %ebx
   1d3de:	5e                   	pop    %esi
   1d3df:	5f                   	pop    %edi
   1d3e0:	c3                   	ret    

0001d3e1 <csi_m>:
// 设置显示字符属性
// ANSI转义序列:'ESC [ Ps;PS m'.Ps = 0 - 默认属性;1 - 粗体并增亮;4 - 下划线;5 - 闪烁;7 - 反显;22 - 非粗体;24 - 无下划线;
// 25 - 无闪烁;27 - 正显;30~38 - 设置前景色彩;39 - 默认前景色(White);40~48 - 设置背景色彩;49 - 默认背景色(Black).
// 该控制序列根据参数设置字符显示属性.以后所有发送到终端的字符都将使用这里指定的属性,直到再次执行本控制序列重新设置字符显示的属性.
void csi_m(int currcons)
{
   1d3e1:	56                   	push   %esi
   1d3e2:	53                   	push   %ebx
   1d3e3:	83 ec 14             	sub    $0x14,%esp
   1d3e6:	e8 4c f6 fe ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1d3eb:	81 c1 15 4c 01 00    	add    $0x14c15,%ecx
	// 如果Ps = 0,则把当前虚拟控制台随后显示的字符属性设置为默认属性def_attr.初始化时def_attr已被设置成0x07(黑底白字).
	// 如果Ps = 1,则把当前虚拟控制台随后显示的字符属性设置为粗体或增亮显示.如果是彩色显示,则把字符属性或上0x08让字符高亮度显示;如果是单色显示,
	// 则让人带下划线显示.
	// 如果ps = 4,则对彩色和单色显示进行不同的处理.若此时不是彩色显示方式,则让字符带下划线显示.如果是彩色显示,那么若原来vc_bold_attr不等于-1
	// 时就复位其背景色;否则的话就把背景色取反.若取反后前景色与背景色相同,就把前景色增1而取另一种颜色.
	for (i = 0; i <= npar; i++)
   1d3f1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   1d3f8:	00 
   1d3f9:	e9 9d 06 00 00       	jmp    1da9b <.L59+0x195>
		switch (par[i]) {
   1d3fe:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d402:	89 d0                	mov    %edx,%eax
   1d404:	c1 e0 03             	shl    $0x3,%eax
   1d407:	01 d0                	add    %edx,%eax
   1d409:	c1 e0 02             	shl    $0x2,%eax
   1d40c:	8b 54 24 10          	mov    0x10(%esp),%edx
   1d410:	01 d0                	add    %edx,%eax
   1d412:	83 c0 0c             	add    $0xc,%eax
   1d415:	8b 84 81 e8 1e 01 00 	mov    0x11ee8(%ecx,%eax,4),%eax
   1d41c:	83 f8 31             	cmp    $0x31,%eax
   1d41f:	0f 87 e1 04 00 00    	ja     1d906 <.L59>
   1d425:	c1 e0 02             	shl    $0x2,%eax
   1d428:	8b 84 08 ec 63 ff ff 	mov    -0x9c14(%eax,%ecx,1),%eax
   1d42f:	01 c8                	add    %ecx,%eax
   1d431:	ff e0                	jmp    *%eax

0001d433 <.L60>:
			case 0:
				attr = def_attr; break;  									/* default */
   1d433:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d437:	8d 99 e3 1e 01 00    	lea    0x11ee3(%ecx),%ebx
   1d43d:	89 d0                	mov    %edx,%eax
   1d43f:	c1 e0 03             	shl    $0x3,%eax
   1d442:	01 d0                	add    %edx,%eax
   1d444:	c1 e0 04             	shl    $0x4,%eax
   1d447:	01 d8                	add    %ebx,%eax
   1d449:	0f b6 18             	movzbl (%eax),%ebx
   1d44c:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d450:	8d b1 e2 1e 01 00    	lea    0x11ee2(%ecx),%esi
   1d456:	89 d0                	mov    %edx,%eax
   1d458:	c1 e0 03             	shl    $0x3,%eax
   1d45b:	01 d0                	add    %edx,%eax
   1d45d:	c1 e0 04             	shl    $0x4,%eax
   1d460:	01 f0                	add    %esi,%eax
   1d462:	88 18                	mov    %bl,(%eax)
   1d464:	e9 2d 06 00 00       	jmp    1da96 <.L59+0x190>

0001d469 <.L62>:
			case 1:
				attr = (iscolor ? attr | 0x08 : attr | 0x0f); break;  		/* bold */
   1d469:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d46d:	8d 99 e8 1e 01 00    	lea    0x11ee8(%ecx),%ebx
   1d473:	89 d0                	mov    %edx,%eax
   1d475:	c1 e0 03             	shl    $0x3,%eax
   1d478:	01 d0                	add    %edx,%eax
   1d47a:	c1 e0 04             	shl    $0x4,%eax
   1d47d:	01 d8                	add    %ebx,%eax
   1d47f:	83 e8 80             	sub    $0xffffff80,%eax
   1d482:	8b 00                	mov    (%eax),%eax
   1d484:	85 c0                	test   %eax,%eax
   1d486:	74 22                	je     1d4aa <.L62+0x41>
   1d488:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d48c:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d492:	89 d0                	mov    %edx,%eax
   1d494:	c1 e0 03             	shl    $0x3,%eax
   1d497:	01 d0                	add    %edx,%eax
   1d499:	c1 e0 04             	shl    $0x4,%eax
   1d49c:	01 d8                	add    %ebx,%eax
   1d49e:	0f b6 00             	movzbl (%eax),%eax
   1d4a1:	83 c8 08             	or     $0x8,%eax
   1d4a4:	88 44 24 03          	mov    %al,0x3(%esp)
   1d4a8:	eb 20                	jmp    1d4ca <.L62+0x61>
   1d4aa:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d4ae:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d4b4:	89 d0                	mov    %edx,%eax
   1d4b6:	c1 e0 03             	shl    $0x3,%eax
   1d4b9:	01 d0                	add    %edx,%eax
   1d4bb:	c1 e0 04             	shl    $0x4,%eax
   1d4be:	01 d8                	add    %ebx,%eax
   1d4c0:	0f b6 00             	movzbl (%eax),%eax
   1d4c3:	83 c8 0f             	or     $0xf,%eax
   1d4c6:	88 44 24 03          	mov    %al,0x3(%esp)
   1d4ca:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d4ce:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d4d4:	89 d0                	mov    %edx,%eax
   1d4d6:	c1 e0 03             	shl    $0x3,%eax
   1d4d9:	01 d0                	add    %edx,%eax
   1d4db:	c1 e0 04             	shl    $0x4,%eax
   1d4de:	01 d8                	add    %ebx,%eax
   1d4e0:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d4e5:	88 18                	mov    %bl,(%eax)
   1d4e7:	e9 aa 05 00 00       	jmp    1da96 <.L59+0x190>

0001d4ec <.L63>:
			/*case 4: attr=attr|0x01;break;*/  /* underline */
			case 4: 														/* bold */
			  if (!iscolor)
   1d4ec:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d4f0:	8d 99 e8 1e 01 00    	lea    0x11ee8(%ecx),%ebx
   1d4f6:	89 d0                	mov    %edx,%eax
   1d4f8:	c1 e0 03             	shl    $0x3,%eax
   1d4fb:	01 d0                	add    %edx,%eax
   1d4fd:	c1 e0 04             	shl    $0x4,%eax
   1d500:	01 d8                	add    %ebx,%eax
   1d502:	83 e8 80             	sub    $0xffffff80,%eax
   1d505:	8b 00                	mov    (%eax),%eax
   1d507:	85 c0                	test   %eax,%eax
   1d509:	75 42                	jne    1d54d <.L63+0x61>
			    attr |= 0x01;												// 单色则带下划线显示.
   1d50b:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d50f:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d515:	89 d0                	mov    %edx,%eax
   1d517:	c1 e0 03             	shl    $0x3,%eax
   1d51a:	01 d0                	add    %edx,%eax
   1d51c:	c1 e0 04             	shl    $0x4,%eax
   1d51f:	01 d8                	add    %ebx,%eax
   1d521:	0f b6 00             	movzbl (%eax),%eax
   1d524:	83 c8 01             	or     $0x1,%eax
   1d527:	88 44 24 03          	mov    %al,0x3(%esp)
   1d52b:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d52f:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d535:	89 d0                	mov    %edx,%eax
   1d537:	c1 e0 03             	shl    $0x3,%eax
   1d53a:	01 d0                	add    %edx,%eax
   1d53c:	c1 e0 04             	shl    $0x4,%eax
   1d53f:	01 d8                	add    %ebx,%eax
   1d541:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d546:	88 18                	mov    %bl,(%eax)
			      	attr = ((newattr&0xf)==((attr>>4)&0xf)?
			        (attr&0xf0)|(((attr&0xf)+1)%0xf):
			        newattr);
			    }
			  }
			  break;
   1d548:	e9 49 05 00 00       	jmp    1da96 <.L59+0x190>
			    if (vc_cons[currcons].vc_bold_attr != -1)
   1d54d:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d551:	8d 99 e4 1e 01 00    	lea    0x11ee4(%ecx),%ebx
   1d557:	89 d0                	mov    %edx,%eax
   1d559:	c1 e0 03             	shl    $0x3,%eax
   1d55c:	01 d0                	add    %edx,%eax
   1d55e:	c1 e0 04             	shl    $0x4,%eax
   1d561:	01 d8                	add    %ebx,%eax
   1d563:	8b 00                	mov    (%eax),%eax
   1d565:	83 f8 ff             	cmp    $0xffffffff,%eax
   1d568:	74 61                	je     1d5cb <.L63+0xdf>
			      attr = (vc_cons[currcons].vc_bold_attr & 0x0f) | (0xf0 & (attr));
   1d56a:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d56e:	8d 99 e4 1e 01 00    	lea    0x11ee4(%ecx),%ebx
   1d574:	89 d0                	mov    %edx,%eax
   1d576:	c1 e0 03             	shl    $0x3,%eax
   1d579:	01 d0                	add    %edx,%eax
   1d57b:	c1 e0 04             	shl    $0x4,%eax
   1d57e:	01 d8                	add    %ebx,%eax
   1d580:	8b 00                	mov    (%eax),%eax
   1d582:	83 e0 0f             	and    $0xf,%eax
   1d585:	89 c6                	mov    %eax,%esi
   1d587:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d58b:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d591:	89 d0                	mov    %edx,%eax
   1d593:	c1 e0 03             	shl    $0x3,%eax
   1d596:	01 d0                	add    %edx,%eax
   1d598:	c1 e0 04             	shl    $0x4,%eax
   1d59b:	01 d8                	add    %ebx,%eax
   1d59d:	0f b6 00             	movzbl (%eax),%eax
   1d5a0:	83 e0 f0             	and    $0xfffffff0,%eax
   1d5a3:	09 f0                	or     %esi,%eax
   1d5a5:	88 44 24 03          	mov    %al,0x3(%esp)
   1d5a9:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d5ad:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d5b3:	89 d0                	mov    %edx,%eax
   1d5b5:	c1 e0 03             	shl    $0x3,%eax
   1d5b8:	01 d0                	add    %edx,%eax
   1d5ba:	c1 e0 04             	shl    $0x4,%eax
   1d5bd:	01 d8                	add    %ebx,%eax
   1d5bf:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d5c4:	88 18                	mov    %bl,(%eax)
			  break;
   1d5c6:	e9 cb 04 00 00       	jmp    1da96 <.L59+0x190>
			    	short newattr = (attr&0xf0)|(0xf&(~attr));
   1d5cb:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d5cf:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d5d5:	89 d0                	mov    %edx,%eax
   1d5d7:	c1 e0 03             	shl    $0x3,%eax
   1d5da:	01 d0                	add    %edx,%eax
   1d5dc:	c1 e0 04             	shl    $0x4,%eax
   1d5df:	01 d8                	add    %ebx,%eax
   1d5e1:	0f b6 00             	movzbl (%eax),%eax
   1d5e4:	83 f0 0f             	xor    $0xf,%eax
   1d5e7:	0f b6 c0             	movzbl %al,%eax
   1d5ea:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
			      	attr = ((newattr&0xf)==((attr>>4)&0xf)?
   1d5ef:	0f bf 5c 24 0e       	movswl 0xe(%esp),%ebx
   1d5f4:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d5f8:	8d b1 e2 1e 01 00    	lea    0x11ee2(%ecx),%esi
   1d5fe:	89 d0                	mov    %edx,%eax
   1d600:	c1 e0 03             	shl    $0x3,%eax
   1d603:	01 d0                	add    %edx,%eax
   1d605:	c1 e0 04             	shl    $0x4,%eax
   1d608:	01 f0                	add    %esi,%eax
   1d60a:	0f b6 00             	movzbl (%eax),%eax
   1d60d:	c0 e8 04             	shr    $0x4,%al
   1d610:	0f b6 c0             	movzbl %al,%eax
   1d613:	31 d8                	xor    %ebx,%eax
   1d615:	83 e0 0f             	and    $0xf,%eax
   1d618:	85 c0                	test   %eax,%eax
   1d61a:	75 6d                	jne    1d689 <.L63+0x19d>
			        (attr&0xf0)|(((attr&0xf)+1)%0xf):
   1d61c:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d620:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d626:	89 d0                	mov    %edx,%eax
   1d628:	c1 e0 03             	shl    $0x3,%eax
   1d62b:	01 d0                	add    %edx,%eax
   1d62d:	c1 e0 04             	shl    $0x4,%eax
   1d630:	01 d8                	add    %ebx,%eax
   1d632:	0f b6 00             	movzbl (%eax),%eax
   1d635:	83 e0 f0             	and    $0xfffffff0,%eax
   1d638:	89 c6                	mov    %eax,%esi
   1d63a:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d63e:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d644:	89 d0                	mov    %edx,%eax
   1d646:	c1 e0 03             	shl    $0x3,%eax
   1d649:	01 d0                	add    %edx,%eax
   1d64b:	c1 e0 04             	shl    $0x4,%eax
   1d64e:	01 d8                	add    %ebx,%eax
   1d650:	0f b6 00             	movzbl (%eax),%eax
   1d653:	0f b6 c0             	movzbl %al,%eax
   1d656:	83 e0 0f             	and    $0xf,%eax
   1d659:	8d 58 01             	lea    0x1(%eax),%ebx
   1d65c:	ba 89 88 88 88       	mov    $0x88888889,%edx
   1d661:	89 d8                	mov    %ebx,%eax
   1d663:	f7 ea                	imul   %edx
   1d665:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
   1d668:	c1 f8 03             	sar    $0x3,%eax
   1d66b:	89 c2                	mov    %eax,%edx
   1d66d:	89 d8                	mov    %ebx,%eax
   1d66f:	c1 f8 1f             	sar    $0x1f,%eax
   1d672:	29 c2                	sub    %eax,%edx
   1d674:	89 d0                	mov    %edx,%eax
   1d676:	89 c2                	mov    %eax,%edx
   1d678:	c1 e2 04             	shl    $0x4,%edx
   1d67b:	29 c2                	sub    %eax,%edx
   1d67d:	89 d8                	mov    %ebx,%eax
   1d67f:	29 d0                	sub    %edx,%eax
   1d681:	09 f0                	or     %esi,%eax
			      	attr = ((newattr&0xf)==((attr>>4)&0xf)?
   1d683:	88 44 24 03          	mov    %al,0x3(%esp)
   1d687:	eb 09                	jmp    1d692 <.L63+0x1a6>
   1d689:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
   1d68e:	88 44 24 03          	mov    %al,0x3(%esp)
   1d692:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d696:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d69c:	89 d0                	mov    %edx,%eax
   1d69e:	c1 e0 03             	shl    $0x3,%eax
   1d6a1:	01 d0                	add    %edx,%eax
   1d6a3:	c1 e0 04             	shl    $0x4,%eax
   1d6a6:	01 d8                	add    %ebx,%eax
   1d6a8:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d6ad:	88 18                	mov    %bl,(%eax)
			  break;
   1d6af:	e9 e2 03 00 00       	jmp    1da96 <.L59+0x190>

0001d6b4 <.L64>:
			// 如果Ps = 5,则把当前虚拟控制台随后显示的字符设置为闪烁,即把属性字节位7置1.
			case 5: attr = attr | 0x80; break;  							/* blinking */
   1d6b4:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d6b8:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d6be:	89 d0                	mov    %edx,%eax
   1d6c0:	c1 e0 03             	shl    $0x3,%eax
   1d6c3:	01 d0                	add    %edx,%eax
   1d6c5:	c1 e0 04             	shl    $0x4,%eax
   1d6c8:	01 d8                	add    %ebx,%eax
   1d6ca:	0f b6 00             	movzbl (%eax),%eax
   1d6cd:	83 c8 80             	or     $0xffffff80,%eax
   1d6d0:	88 44 24 03          	mov    %al,0x3(%esp)
   1d6d4:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d6d8:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d6de:	89 d0                	mov    %edx,%eax
   1d6e0:	c1 e0 03             	shl    $0x3,%eax
   1d6e3:	01 d0                	add    %edx,%eax
   1d6e5:	c1 e0 04             	shl    $0x4,%eax
   1d6e8:	01 d8                	add    %ebx,%eax
   1d6ea:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d6ef:	88 18                	mov    %bl,(%eax)
   1d6f1:	e9 a0 03 00 00       	jmp    1da96 <.L59+0x190>

0001d6f6 <.L65>:
			// 如果Ps = 7,则把当前虚拟控制台随后显示的字符设置为反显,即把前景色和背景色交换.
			case 7: attr = (attr << 4) | (attr >> 4); break;  				/* negative */
   1d6f6:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d6fa:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d700:	89 d0                	mov    %edx,%eax
   1d702:	c1 e0 03             	shl    $0x3,%eax
   1d705:	01 d0                	add    %edx,%eax
   1d707:	c1 e0 04             	shl    $0x4,%eax
   1d70a:	01 d8                	add    %ebx,%eax
   1d70c:	0f b6 00             	movzbl (%eax),%eax
   1d70f:	0f b6 c0             	movzbl %al,%eax
   1d712:	c1 e0 04             	shl    $0x4,%eax
   1d715:	89 c6                	mov    %eax,%esi
   1d717:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d71b:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d721:	89 d0                	mov    %edx,%eax
   1d723:	c1 e0 03             	shl    $0x3,%eax
   1d726:	01 d0                	add    %edx,%eax
   1d728:	c1 e0 04             	shl    $0x4,%eax
   1d72b:	01 d8                	add    %ebx,%eax
   1d72d:	0f b6 00             	movzbl (%eax),%eax
   1d730:	c0 e8 04             	shr    $0x4,%al
   1d733:	09 f0                	or     %esi,%eax
   1d735:	88 44 24 03          	mov    %al,0x3(%esp)
   1d739:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d73d:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d743:	89 d0                	mov    %edx,%eax
   1d745:	c1 e0 03             	shl    $0x3,%eax
   1d748:	01 d0                	add    %edx,%eax
   1d74a:	c1 e0 04             	shl    $0x4,%eax
   1d74d:	01 d8                	add    %ebx,%eax
   1d74f:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d754:	88 18                	mov    %bl,(%eax)
   1d756:	e9 3b 03 00 00       	jmp    1da96 <.L59+0x190>

0001d75b <.L66>:
			// 如果Ps = 22,则取消随后字符的高亮度显示(取消粗体显示).
			case 22: attr = attr & 0xf7; break; 							/* not bold */
   1d75b:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d75f:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d765:	89 d0                	mov    %edx,%eax
   1d767:	c1 e0 03             	shl    $0x3,%eax
   1d76a:	01 d0                	add    %edx,%eax
   1d76c:	c1 e0 04             	shl    $0x4,%eax
   1d76f:	01 d8                	add    %ebx,%eax
   1d771:	0f b6 00             	movzbl (%eax),%eax
   1d774:	83 e0 f7             	and    $0xfffffff7,%eax
   1d777:	89 c3                	mov    %eax,%ebx
   1d779:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d77d:	8d b1 e2 1e 01 00    	lea    0x11ee2(%ecx),%esi
   1d783:	89 d0                	mov    %edx,%eax
   1d785:	c1 e0 03             	shl    $0x3,%eax
   1d788:	01 d0                	add    %edx,%eax
   1d78a:	c1 e0 04             	shl    $0x4,%eax
   1d78d:	01 f0                	add    %esi,%eax
   1d78f:	88 18                	mov    %bl,(%eax)
   1d791:	e9 00 03 00 00       	jmp    1da96 <.L59+0x190>

0001d796 <.L67>:
			// 如果Ps = 24,则对于单色显示是取消随后字符的下划线显示,对于彩色显示取是取消绿色.
			case 24: attr = attr & 0xfe; break;  							/* not underline */
   1d796:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d79a:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d7a0:	89 d0                	mov    %edx,%eax
   1d7a2:	c1 e0 03             	shl    $0x3,%eax
   1d7a5:	01 d0                	add    %edx,%eax
   1d7a7:	c1 e0 04             	shl    $0x4,%eax
   1d7aa:	01 d8                	add    %ebx,%eax
   1d7ac:	0f b6 00             	movzbl (%eax),%eax
   1d7af:	83 e0 fe             	and    $0xfffffffe,%eax
   1d7b2:	89 c3                	mov    %eax,%ebx
   1d7b4:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d7b8:	8d b1 e2 1e 01 00    	lea    0x11ee2(%ecx),%esi
   1d7be:	89 d0                	mov    %edx,%eax
   1d7c0:	c1 e0 03             	shl    $0x3,%eax
   1d7c3:	01 d0                	add    %edx,%eax
   1d7c5:	c1 e0 04             	shl    $0x4,%eax
   1d7c8:	01 f0                	add    %esi,%eax
   1d7ca:	88 18                	mov    %bl,(%eax)
   1d7cc:	e9 c5 02 00 00       	jmp    1da96 <.L59+0x190>

0001d7d1 <.L68>:
			// 如果Ps = 25,则取消随后字符的闪烁显示.
			case 25: attr = attr & 0x7f; break;  							/* not blinking */
   1d7d1:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d7d5:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d7db:	89 d0                	mov    %edx,%eax
   1d7dd:	c1 e0 03             	shl    $0x3,%eax
   1d7e0:	01 d0                	add    %edx,%eax
   1d7e2:	c1 e0 04             	shl    $0x4,%eax
   1d7e5:	01 d8                	add    %ebx,%eax
   1d7e7:	0f b6 00             	movzbl (%eax),%eax
   1d7ea:	83 e0 7f             	and    $0x7f,%eax
   1d7ed:	89 c3                	mov    %eax,%ebx
   1d7ef:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d7f3:	8d b1 e2 1e 01 00    	lea    0x11ee2(%ecx),%esi
   1d7f9:	89 d0                	mov    %edx,%eax
   1d7fb:	c1 e0 03             	shl    $0x3,%eax
   1d7fe:	01 d0                	add    %edx,%eax
   1d800:	c1 e0 04             	shl    $0x4,%eax
   1d803:	01 f0                	add    %esi,%eax
   1d805:	88 18                	mov    %bl,(%eax)
   1d807:	e9 8a 02 00 00       	jmp    1da96 <.L59+0x190>

0001d80c <.L69>:
			// 如果Ps = 27,则取消随后字符的反显.
			case 27: attr = def_attr; break; 								/* positive image */
   1d80c:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d810:	8d 99 e3 1e 01 00    	lea    0x11ee3(%ecx),%ebx
   1d816:	89 d0                	mov    %edx,%eax
   1d818:	c1 e0 03             	shl    $0x3,%eax
   1d81b:	01 d0                	add    %edx,%eax
   1d81d:	c1 e0 04             	shl    $0x4,%eax
   1d820:	01 d8                	add    %ebx,%eax
   1d822:	0f b6 18             	movzbl (%eax),%ebx
   1d825:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d829:	8d b1 e2 1e 01 00    	lea    0x11ee2(%ecx),%esi
   1d82f:	89 d0                	mov    %edx,%eax
   1d831:	c1 e0 03             	shl    $0x3,%eax
   1d834:	01 d0                	add    %edx,%eax
   1d836:	c1 e0 04             	shl    $0x4,%eax
   1d839:	01 f0                	add    %esi,%eax
   1d83b:	88 18                	mov    %bl,(%eax)
   1d83d:	e9 54 02 00 00       	jmp    1da96 <.L59+0x190>

0001d842 <.L70>:
			// 如果Ps = 39,则复位随后字符的前景色为默认前景色(白色).
			case 39: attr = (attr & 0xf0) | (def_attr & 0x0f); break;
   1d842:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d846:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d84c:	89 d0                	mov    %edx,%eax
   1d84e:	c1 e0 03             	shl    $0x3,%eax
   1d851:	01 d0                	add    %edx,%eax
   1d853:	c1 e0 04             	shl    $0x4,%eax
   1d856:	01 d8                	add    %ebx,%eax
   1d858:	0f b6 00             	movzbl (%eax),%eax
   1d85b:	83 e0 f0             	and    $0xfffffff0,%eax
   1d85e:	89 c6                	mov    %eax,%esi
   1d860:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d864:	8d 99 e3 1e 01 00    	lea    0x11ee3(%ecx),%ebx
   1d86a:	89 d0                	mov    %edx,%eax
   1d86c:	c1 e0 03             	shl    $0x3,%eax
   1d86f:	01 d0                	add    %edx,%eax
   1d871:	c1 e0 04             	shl    $0x4,%eax
   1d874:	01 d8                	add    %ebx,%eax
   1d876:	0f b6 00             	movzbl (%eax),%eax
   1d879:	83 e0 0f             	and    $0xf,%eax
   1d87c:	09 f0                	or     %esi,%eax
   1d87e:	88 44 24 03          	mov    %al,0x3(%esp)
   1d882:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d886:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d88c:	89 d0                	mov    %edx,%eax
   1d88e:	c1 e0 03             	shl    $0x3,%eax
   1d891:	01 d0                	add    %edx,%eax
   1d893:	c1 e0 04             	shl    $0x4,%eax
   1d896:	01 d8                	add    %ebx,%eax
   1d898:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d89d:	88 18                	mov    %bl,(%eax)
   1d89f:	e9 f2 01 00 00       	jmp    1da96 <.L59+0x190>

0001d8a4 <.L71>:
			// 如果Ps = 49,则复位随后字符的背景色为默认背景色(黑色).
			case 49: attr = (attr & 0x0f) | (def_attr & 0xf0); break;
   1d8a4:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d8a8:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d8ae:	89 d0                	mov    %edx,%eax
   1d8b0:	c1 e0 03             	shl    $0x3,%eax
   1d8b3:	01 d0                	add    %edx,%eax
   1d8b5:	c1 e0 04             	shl    $0x4,%eax
   1d8b8:	01 d8                	add    %ebx,%eax
   1d8ba:	0f b6 00             	movzbl (%eax),%eax
   1d8bd:	83 e0 0f             	and    $0xf,%eax
   1d8c0:	89 c6                	mov    %eax,%esi
   1d8c2:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d8c6:	8d 99 e3 1e 01 00    	lea    0x11ee3(%ecx),%ebx
   1d8cc:	89 d0                	mov    %edx,%eax
   1d8ce:	c1 e0 03             	shl    $0x3,%eax
   1d8d1:	01 d0                	add    %edx,%eax
   1d8d3:	c1 e0 04             	shl    $0x4,%eax
   1d8d6:	01 d8                	add    %ebx,%eax
   1d8d8:	0f b6 00             	movzbl (%eax),%eax
   1d8db:	83 e0 f0             	and    $0xfffffff0,%eax
   1d8de:	09 f0                	or     %esi,%eax
   1d8e0:	88 44 24 03          	mov    %al,0x3(%esp)
   1d8e4:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d8e8:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d8ee:	89 d0                	mov    %edx,%eax
   1d8f0:	c1 e0 03             	shl    $0x3,%eax
   1d8f3:	01 d0                	add    %edx,%eax
   1d8f5:	c1 e0 04             	shl    $0x4,%eax
   1d8f8:	01 d8                	add    %ebx,%eax
   1d8fa:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d8ff:	88 18                	mov    %bl,(%eax)
   1d901:	e9 90 01 00 00       	jmp    1da96 <.L59+0x190>

0001d906 <.L59>:
			// 当Ps(par[i])为其他值时,则是设置指定的前景色或背景色.如果Ps = 30..37,则是设置前景色;如果Ps=40..47,则是设置背景色.
			default:
			  if (!can_do_colour)
   1d906:	8b 81 d0 1e 01 00    	mov    0x11ed0(%ecx),%eax
   1d90c:	85 c0                	test   %eax,%eax
   1d90e:	0f 84 81 01 00 00    	je     1da95 <.L59+0x18f>
			    break;
			  iscolor = 1;
   1d914:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d918:	8d 99 e8 1e 01 00    	lea    0x11ee8(%ecx),%ebx
   1d91e:	89 d0                	mov    %edx,%eax
   1d920:	c1 e0 03             	shl    $0x3,%eax
   1d923:	01 d0                	add    %edx,%eax
   1d925:	c1 e0 04             	shl    $0x4,%eax
   1d928:	01 d8                	add    %ebx,%eax
   1d92a:	83 e8 80             	sub    $0xffffff80,%eax
   1d92d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
			  if ((par[i] >= 30) && (par[i] <= 38))		 					// 设置前景色.
   1d933:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d937:	89 d0                	mov    %edx,%eax
   1d939:	c1 e0 03             	shl    $0x3,%eax
   1d93c:	01 d0                	add    %edx,%eax
   1d93e:	c1 e0 02             	shl    $0x2,%eax
   1d941:	8b 54 24 10          	mov    0x10(%esp),%edx
   1d945:	01 d0                	add    %edx,%eax
   1d947:	83 c0 0c             	add    $0xc,%eax
   1d94a:	8b 84 81 e8 1e 01 00 	mov    0x11ee8(%ecx,%eax,4),%eax
   1d951:	83 f8 1d             	cmp    $0x1d,%eax
   1d954:	0f 86 8a 00 00 00    	jbe    1d9e4 <.L59+0xde>
   1d95a:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d95e:	89 d0                	mov    %edx,%eax
   1d960:	c1 e0 03             	shl    $0x3,%eax
   1d963:	01 d0                	add    %edx,%eax
   1d965:	c1 e0 02             	shl    $0x2,%eax
   1d968:	8b 54 24 10          	mov    0x10(%esp),%edx
   1d96c:	01 d0                	add    %edx,%eax
   1d96e:	83 c0 0c             	add    $0xc,%eax
   1d971:	8b 84 81 e8 1e 01 00 	mov    0x11ee8(%ecx,%eax,4),%eax
   1d978:	83 f8 26             	cmp    $0x26,%eax
   1d97b:	77 67                	ja     1d9e4 <.L59+0xde>
			    attr = (attr & 0xf0) | (par[i] - 30);
   1d97d:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d981:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d987:	89 d0                	mov    %edx,%eax
   1d989:	c1 e0 03             	shl    $0x3,%eax
   1d98c:	01 d0                	add    %edx,%eax
   1d98e:	c1 e0 04             	shl    $0x4,%eax
   1d991:	01 d8                	add    %ebx,%eax
   1d993:	0f b6 00             	movzbl (%eax),%eax
   1d996:	83 e0 f0             	and    $0xfffffff0,%eax
   1d999:	89 c3                	mov    %eax,%ebx
   1d99b:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d99f:	89 d0                	mov    %edx,%eax
   1d9a1:	c1 e0 03             	shl    $0x3,%eax
   1d9a4:	01 d0                	add    %edx,%eax
   1d9a6:	c1 e0 02             	shl    $0x2,%eax
   1d9a9:	8b 54 24 10          	mov    0x10(%esp),%edx
   1d9ad:	01 d0                	add    %edx,%eax
   1d9af:	83 c0 0c             	add    $0xc,%eax
   1d9b2:	8b 84 81 e8 1e 01 00 	mov    0x11ee8(%ecx,%eax,4),%eax
   1d9b9:	83 e8 1e             	sub    $0x1e,%eax
   1d9bc:	09 c3                	or     %eax,%ebx
   1d9be:	88 5c 24 03          	mov    %bl,0x3(%esp)
   1d9c2:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d9c6:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1d9cc:	89 d0                	mov    %edx,%eax
   1d9ce:	c1 e0 03             	shl    $0x3,%eax
   1d9d1:	01 d0                	add    %edx,%eax
   1d9d3:	c1 e0 04             	shl    $0x4,%eax
   1d9d6:	01 d8                	add    %ebx,%eax
   1d9d8:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1d9dd:	88 18                	mov    %bl,(%eax)
   1d9df:	e9 b2 00 00 00       	jmp    1da96 <.L59+0x190>
			  else  														/* Background color */			 // 设置背景色.
			    if ((par[i] >= 40) && (par[i] <= 48))
   1d9e4:	8b 54 24 20          	mov    0x20(%esp),%edx
   1d9e8:	89 d0                	mov    %edx,%eax
   1d9ea:	c1 e0 03             	shl    $0x3,%eax
   1d9ed:	01 d0                	add    %edx,%eax
   1d9ef:	c1 e0 02             	shl    $0x2,%eax
   1d9f2:	8b 54 24 10          	mov    0x10(%esp),%edx
   1d9f6:	01 d0                	add    %edx,%eax
   1d9f8:	83 c0 0c             	add    $0xc,%eax
   1d9fb:	8b 84 81 e8 1e 01 00 	mov    0x11ee8(%ecx,%eax,4),%eax
   1da02:	83 f8 27             	cmp    $0x27,%eax
   1da05:	0f 86 8b 00 00 00    	jbe    1da96 <.L59+0x190>
   1da0b:	8b 54 24 20          	mov    0x20(%esp),%edx
   1da0f:	89 d0                	mov    %edx,%eax
   1da11:	c1 e0 03             	shl    $0x3,%eax
   1da14:	01 d0                	add    %edx,%eax
   1da16:	c1 e0 02             	shl    $0x2,%eax
   1da19:	8b 54 24 10          	mov    0x10(%esp),%edx
   1da1d:	01 d0                	add    %edx,%eax
   1da1f:	83 c0 0c             	add    $0xc,%eax
   1da22:	8b 84 81 e8 1e 01 00 	mov    0x11ee8(%ecx,%eax,4),%eax
   1da29:	83 f8 30             	cmp    $0x30,%eax
   1da2c:	77 68                	ja     1da96 <.L59+0x190>
			      attr = (attr & 0x0f) | ((par[i] - 40) << 4);
   1da2e:	8b 54 24 20          	mov    0x20(%esp),%edx
   1da32:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1da38:	89 d0                	mov    %edx,%eax
   1da3a:	c1 e0 03             	shl    $0x3,%eax
   1da3d:	01 d0                	add    %edx,%eax
   1da3f:	c1 e0 04             	shl    $0x4,%eax
   1da42:	01 d8                	add    %ebx,%eax
   1da44:	0f b6 00             	movzbl (%eax),%eax
   1da47:	83 e0 0f             	and    $0xf,%eax
   1da4a:	89 c3                	mov    %eax,%ebx
   1da4c:	8b 54 24 20          	mov    0x20(%esp),%edx
   1da50:	89 d0                	mov    %edx,%eax
   1da52:	c1 e0 03             	shl    $0x3,%eax
   1da55:	01 d0                	add    %edx,%eax
   1da57:	c1 e0 02             	shl    $0x2,%eax
   1da5a:	8b 54 24 10          	mov    0x10(%esp),%edx
   1da5e:	01 d0                	add    %edx,%eax
   1da60:	83 c0 0c             	add    $0xc,%eax
   1da63:	8b 84 81 e8 1e 01 00 	mov    0x11ee8(%ecx,%eax,4),%eax
   1da6a:	83 e8 28             	sub    $0x28,%eax
   1da6d:	c1 e0 04             	shl    $0x4,%eax
   1da70:	09 c3                	or     %eax,%ebx
   1da72:	88 5c 24 03          	mov    %bl,0x3(%esp)
   1da76:	8b 54 24 20          	mov    0x20(%esp),%edx
   1da7a:	8d 99 e2 1e 01 00    	lea    0x11ee2(%ecx),%ebx
   1da80:	89 d0                	mov    %edx,%eax
   1da82:	c1 e0 03             	shl    $0x3,%eax
   1da85:	01 d0                	add    %edx,%eax
   1da87:	c1 e0 04             	shl    $0x4,%eax
   1da8a:	01 d8                	add    %ebx,%eax
   1da8c:	0f b6 5c 24 03       	movzbl 0x3(%esp),%ebx
   1da91:	88 18                	mov    %bl,(%eax)
   1da93:	eb 01                	jmp    1da96 <.L59+0x190>
			    break;
   1da95:	90                   	nop
	for (i = 0; i <= npar; i++)
   1da96:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
   1da9b:	8b 54 24 20          	mov    0x20(%esp),%edx
   1da9f:	8d 99 e4 1e 01 00    	lea    0x11ee4(%ecx),%ebx
   1daa5:	89 d0                	mov    %edx,%eax
   1daa7:	c1 e0 03             	shl    $0x3,%eax
   1daaa:	01 d0                	add    %edx,%eax
   1daac:	c1 e0 04             	shl    $0x4,%eax
   1daaf:	01 d8                	add    %ebx,%eax
   1dab1:	83 c0 30             	add    $0x30,%eax
   1dab4:	8b 10                	mov    (%eax),%edx
   1dab6:	8b 44 24 10          	mov    0x10(%esp),%eax
   1daba:	39 c2                	cmp    %eax,%edx
   1dabc:	0f 83 3c f9 ff ff    	jae    1d3fe <csi_m+0x1d>
			    else
					break;
		}
}
   1dac2:	90                   	nop
   1dac3:	83 c4 14             	add    $0x14,%esp
   1dac6:	5b                   	pop    %ebx
   1dac7:	5e                   	pop    %esi
   1dac8:	c3                   	ret    

0001dac9 <set_cursor>:

// 设置显示光标.
// 根据光标对应显示内存位置pos,设置显示控制器光标的显示位置.
static inline void set_cursor(int currcons)
{
   1dac9:	53                   	push   %ebx
   1daca:	e8 68 ef fe ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1dacf:	81 c1 31 45 01 00    	add    $0x14531,%ecx
	// 既然我们需要设置显示光标,说明有键盘操作,因此需要恢复进行黑屏操作的延时计数值.
	// 另外,显示光标的控制台必须是当前控制台,因此若当前处理的台号currocons不是前台控制台就立刻返回.
	blankcount = blankinterval;						// 复位黑屏操作的计数值.
   1dad5:	8b 81 a4 1e 01 00    	mov    0x11ea4(%ecx),%eax
   1dadb:	89 81 a8 1e 01 00    	mov    %eax,0x11ea8(%ecx)
	if (currcons != fg_console)
   1dae1:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
   1dae7:	8b 00                	mov    (%eax),%eax
   1dae9:	39 44 24 08          	cmp    %eax,0x8(%esp)
   1daed:	0f 85 93 00 00 00    	jne    1db86 <set_cursor+0xbd>
		return;
	// 然后使用索引寄存器端口选择显示控制数据寄存器r14(光标当前显示位置高字节),接着写入光标当前位置高字节(向右移动9位表示高字节移到低字节再除以2),
	// 相对于默认显示内存操作的.再使用索引寄存器选择r15,并将光标当前位置低字节写入其中.
	cli();
   1daf3:	fa                   	cli    
	outb_p(14, video_port_reg);
   1daf4:	0f b7 91 ca 1e 01 00 	movzwl 0x11eca(%ecx),%edx
   1dafb:	b8 0e 00 00 00       	mov    $0xe,%eax
   1db00:	ee                   	out    %al,(%dx)
   1db01:	eb 00                	jmp    1db03 <set_cursor+0x3a>
   1db03:	eb 00                	jmp    1db05 <set_cursor+0x3c>
	outb_p(0xff & ((pos - video_mem_base) >> 9), video_port_val);
   1db05:	8b 54 24 08          	mov    0x8(%esp),%edx
   1db09:	8d 99 e0 1e 01 00    	lea    0x11ee0(%ecx),%ebx
   1db0f:	89 d0                	mov    %edx,%eax
   1db11:	c1 e0 03             	shl    $0x3,%eax
   1db14:	01 d0                	add    %edx,%eax
   1db16:	c1 e0 04             	shl    $0x4,%eax
   1db19:	01 d8                	add    %ebx,%eax
   1db1b:	83 c0 20             	add    $0x20,%eax
   1db1e:	8b 10                	mov    (%eax),%edx
   1db20:	8b 81 b8 1e 01 00    	mov    0x11eb8(%ecx),%eax
   1db26:	29 c2                	sub    %eax,%edx
   1db28:	89 d0                	mov    %edx,%eax
   1db2a:	c1 e8 09             	shr    $0x9,%eax
   1db2d:	0f b6 c0             	movzbl %al,%eax
   1db30:	0f b7 91 cc 1e 01 00 	movzwl 0x11ecc(%ecx),%edx
   1db37:	ee                   	out    %al,(%dx)
   1db38:	eb 00                	jmp    1db3a <set_cursor+0x71>
   1db3a:	eb 00                	jmp    1db3c <set_cursor+0x73>
	outb_p(15, video_port_reg);
   1db3c:	0f b7 91 ca 1e 01 00 	movzwl 0x11eca(%ecx),%edx
   1db43:	b8 0f 00 00 00       	mov    $0xf,%eax
   1db48:	ee                   	out    %al,(%dx)
   1db49:	eb 00                	jmp    1db4b <set_cursor+0x82>
   1db4b:	eb 00                	jmp    1db4d <set_cursor+0x84>
	outb_p(0xff & ((pos - video_mem_base) >> 1), video_port_val);
   1db4d:	8b 54 24 08          	mov    0x8(%esp),%edx
   1db51:	8d 99 e0 1e 01 00    	lea    0x11ee0(%ecx),%ebx
   1db57:	89 d0                	mov    %edx,%eax
   1db59:	c1 e0 03             	shl    $0x3,%eax
   1db5c:	01 d0                	add    %edx,%eax
   1db5e:	c1 e0 04             	shl    $0x4,%eax
   1db61:	01 d8                	add    %ebx,%eax
   1db63:	83 c0 20             	add    $0x20,%eax
   1db66:	8b 10                	mov    (%eax),%edx
   1db68:	8b 81 b8 1e 01 00    	mov    0x11eb8(%ecx),%eax
   1db6e:	29 c2                	sub    %eax,%edx
   1db70:	89 d0                	mov    %edx,%eax
   1db72:	d1 e8                	shr    %eax
   1db74:	0f b6 c0             	movzbl %al,%eax
   1db77:	0f b7 91 cc 1e 01 00 	movzwl 0x11ecc(%ecx),%edx
   1db7e:	ee                   	out    %al,(%dx)
   1db7f:	eb 00                	jmp    1db81 <set_cursor+0xb8>
   1db81:	eb 00                	jmp    1db83 <set_cursor+0xba>
	sti();
   1db83:	fb                   	sti    
   1db84:	eb 01                	jmp    1db87 <set_cursor+0xbe>
		return;
   1db86:	90                   	nop
}
   1db87:	5b                   	pop    %ebx
   1db88:	c3                   	ret    

0001db89 <respond>:
// 发送对VT100的响应序列.
// 即为响应主机请求终端向主机发送设备属性(DA).主机通过发送不带参数或参数是0的DA控制序列('ESC [ 0c'或'ESC Z']要求终端发送一个设备属性(DA)控制
// 序列,终端则发送第85行上定义的应答序列(即'ESC [?];2c']来主机的序列,该序列告诉主机本终端是具有高级视频功能的VT100兼容终端.处理过程是将应答序列
// 放入读缓冲队列中,并使用copy_to_cooked()函数处理后放入辅助队列中.
static void respond(int currcons, struct tty_struct * tty)
{
   1db89:	53                   	push   %ebx
   1db8a:	83 ec 18             	sub    $0x18,%esp
   1db8d:	e8 60 91 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1db92:	05 6e 44 01 00       	add    $0x1446e,%eax
	char * p = RESPONSE;
   1db97:	8d 90 b4 64 ff ff    	lea    -0x9b4c(%eax),%edx
   1db9d:	89 54 24 0c          	mov    %edx,0xc(%esp)

	cli();
   1dba1:	fa                   	cli    
	while (*p) {									// 将应答序列放入读队列.
   1dba2:	eb 3e                	jmp    1dbe2 <respond+0x59>
		PUTCH(*p, tty->read_q);						// 逐字符放入.include/linux/tty.h
   1dba4:	8b 54 24 24          	mov    0x24(%esp),%edx
   1dba8:	8b 4a 34             	mov    0x34(%edx),%ecx
   1dbab:	8b 54 24 24          	mov    0x24(%esp),%edx
   1dbaf:	8b 52 34             	mov    0x34(%edx),%edx
   1dbb2:	8b 52 04             	mov    0x4(%edx),%edx
   1dbb5:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   1dbb9:	0f b6 1b             	movzbl (%ebx),%ebx
   1dbbc:	88 5c 11 10          	mov    %bl,0x10(%ecx,%edx,1)
   1dbc0:	8b 54 24 24          	mov    0x24(%esp),%edx
   1dbc4:	8b 52 34             	mov    0x34(%edx),%edx
   1dbc7:	8b 52 04             	mov    0x4(%edx),%edx
   1dbca:	8d 4a 01             	lea    0x1(%edx),%ecx
   1dbcd:	8b 54 24 24          	mov    0x24(%esp),%edx
   1dbd1:	8b 52 34             	mov    0x34(%edx),%edx
   1dbd4:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
   1dbda:	89 4a 04             	mov    %ecx,0x4(%edx)
		p++;
   1dbdd:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
	while (*p) {									// 将应答序列放入读队列.
   1dbe2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1dbe6:	0f b6 12             	movzbl (%edx),%edx
   1dbe9:	84 d2                	test   %dl,%dl
   1dbeb:	75 b7                	jne    1dba4 <respond+0x1b>
	}
	sti();
   1dbed:	fb                   	sti    
	copy_to_cooked(tty);							// 转换成规范模式(放入辅助队列中).tty_io.c
   1dbee:	83 ec 0c             	sub    $0xc,%esp
   1dbf1:	ff 74 24 30          	pushl  0x30(%esp)
   1dbf5:	89 c3                	mov    %eax,%ebx
   1dbf7:	e8 2f d0 ff ff       	call   1ac2b <copy_to_cooked>
   1dbfc:	83 c4 10             	add    $0x10,%esp
}
   1dbff:	90                   	nop
   1dc00:	83 c4 18             	add    $0x18,%esp
   1dc03:	5b                   	pop    %ebx
   1dc04:	c3                   	ret    

0001dc05 <insert_char>:

// 在光标处插入一空格字符.
// 把光标开始处的所有字符右移一格,并将擦除字符插入在光标所在处.
static void insert_char(int currcons)
{
   1dc05:	53                   	push   %ebx
   1dc06:	83 ec 10             	sub    $0x10,%esp
   1dc09:	e8 e8 90 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   1dc0e:	81 c2 f2 43 01 00    	add    $0x143f2,%edx
	int i = x;
   1dc14:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1dc18:	8d 9a e4 1e 01 00    	lea    0x11ee4(%edx),%ebx
   1dc1e:	89 c8                	mov    %ecx,%eax
   1dc20:	c1 e0 03             	shl    $0x3,%eax
   1dc23:	01 c8                	add    %ecx,%eax
   1dc25:	c1 e0 04             	shl    $0x4,%eax
   1dc28:	01 d8                	add    %ebx,%eax
   1dc2a:	83 c0 20             	add    $0x20,%eax
   1dc2d:	8b 00                	mov    (%eax),%eax
   1dc2f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned short tmp, old = video_erase_char;		// 擦除字符(加属性)
   1dc33:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1dc37:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1dc3d:	89 c8                	mov    %ecx,%eax
   1dc3f:	c1 e0 03             	shl    $0x3,%eax
   1dc42:	01 c8                	add    %ecx,%eax
   1dc44:	c1 e0 04             	shl    $0x4,%eax
   1dc47:	01 d8                	add    %ebx,%eax
   1dc49:	0f b7 00             	movzwl (%eax),%eax
   1dc4c:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
	unsigned short * p = (unsigned short *) pos;	// 光标对应内存位置.
   1dc51:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1dc55:	8d 9a e0 1e 01 00    	lea    0x11ee0(%edx),%ebx
   1dc5b:	89 c8                	mov    %ecx,%eax
   1dc5d:	c1 e0 03             	shl    $0x3,%eax
   1dc60:	01 c8                	add    %ecx,%eax
   1dc62:	c1 e0 04             	shl    $0x4,%eax
   1dc65:	01 d8                	add    %ebx,%eax
   1dc67:	83 c0 20             	add    $0x20,%eax
   1dc6a:	8b 00                	mov    (%eax),%eax
   1dc6c:	89 44 24 04          	mov    %eax,0x4(%esp)

	while (i++ < video_num_columns) {
   1dc70:	eb 27                	jmp    1dc99 <insert_char+0x94>
		tmp = *p;
   1dc72:	8b 44 24 04          	mov    0x4(%esp),%eax
   1dc76:	0f b7 00             	movzwl (%eax),%eax
   1dc79:	66 89 44 24 02       	mov    %ax,0x2(%esp)
		*p = old;
   1dc7e:	8b 44 24 04          	mov    0x4(%esp),%eax
   1dc82:	0f b7 4c 24 0a       	movzwl 0xa(%esp),%ecx
   1dc87:	66 89 08             	mov    %cx,(%eax)
		old = tmp;
   1dc8a:	0f b7 44 24 02       	movzwl 0x2(%esp),%eax
   1dc8f:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
		p++;
   1dc94:	83 44 24 04 02       	addl   $0x2,0x4(%esp)
	while (i++ < video_num_columns) {
   1dc99:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1dc9d:	8d 48 01             	lea    0x1(%eax),%ecx
   1dca0:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
   1dca4:	89 c1                	mov    %eax,%ecx
   1dca6:	8b 82 b4 1e 01 00    	mov    0x11eb4(%edx),%eax
   1dcac:	39 c1                	cmp    %eax,%ecx
   1dcae:	72 c2                	jb     1dc72 <insert_char+0x6d>
	}
}
   1dcb0:	90                   	nop
   1dcb1:	83 c4 10             	add    $0x10,%esp
   1dcb4:	5b                   	pop    %ebx
   1dcb5:	c3                   	ret    

0001dcb6 <insert_line>:

// 在光标处插入一行.
// 将屏幕窗口从光标所在行到窗口底的内容向下卷动一行.光标将处在新的空行上.
static void insert_line(int currcons)
{
   1dcb6:	56                   	push   %esi
   1dcb7:	53                   	push   %ebx
   1dcb8:	83 ec 10             	sub    $0x10,%esp
   1dcbb:	e8 3a 90 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1dcc0:	81 c3 40 43 01 00    	add    $0x14340,%ebx
	int oldtop, oldbottom;

	// 首先保存屏幕窗口卷动开始行top和最后行bottom值,然后从光标所在行让屏幕内容向下滚动一行.最后恢复屏幕窗口卷动开始行top和最后行bottom
	// 的原来值.
	oldtop = top;
   1dcc6:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dcca:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1dcd0:	89 d0                	mov    %edx,%eax
   1dcd2:	c1 e0 03             	shl    $0x3,%eax
   1dcd5:	01 d0                	add    %edx,%eax
   1dcd7:	c1 e0 04             	shl    $0x4,%eax
   1dcda:	01 c8                	add    %ecx,%eax
   1dcdc:	83 c0 20             	add    $0x20,%eax
   1dcdf:	8b 00                	mov    (%eax),%eax
   1dce1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	oldbottom = bottom;
   1dce5:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dce9:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1dcef:	89 d0                	mov    %edx,%eax
   1dcf1:	c1 e0 03             	shl    $0x3,%eax
   1dcf4:	01 d0                	add    %edx,%eax
   1dcf6:	c1 e0 04             	shl    $0x4,%eax
   1dcf9:	01 c8                	add    %ecx,%eax
   1dcfb:	83 c0 30             	add    $0x30,%eax
   1dcfe:	8b 00                	mov    (%eax),%eax
   1dd00:	89 44 24 08          	mov    %eax,0x8(%esp)
	top = y;										// 设置屏幕卷动开始行和结束行.
   1dd04:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dd08:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1dd0e:	89 d0                	mov    %edx,%eax
   1dd10:	c1 e0 03             	shl    $0x3,%eax
   1dd13:	01 d0                	add    %edx,%eax
   1dd15:	c1 e0 04             	shl    $0x4,%eax
   1dd18:	01 c8                	add    %ecx,%eax
   1dd1a:	83 c0 20             	add    $0x20,%eax
   1dd1d:	8b 08                	mov    (%eax),%ecx
   1dd1f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dd23:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1dd29:	89 d0                	mov    %edx,%eax
   1dd2b:	c1 e0 03             	shl    $0x3,%eax
   1dd2e:	01 d0                	add    %edx,%eax
   1dd30:	c1 e0 04             	shl    $0x4,%eax
   1dd33:	01 f0                	add    %esi,%eax
   1dd35:	83 c0 20             	add    $0x20,%eax
   1dd38:	89 08                	mov    %ecx,(%eax)
	bottom = video_num_lines;
   1dd3a:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1dd40:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dd44:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1dd4a:	89 d0                	mov    %edx,%eax
   1dd4c:	c1 e0 03             	shl    $0x3,%eax
   1dd4f:	01 d0                	add    %edx,%eax
   1dd51:	c1 e0 04             	shl    $0x4,%eax
   1dd54:	01 f0                	add    %esi,%eax
   1dd56:	83 c0 30             	add    $0x30,%eax
   1dd59:	89 08                	mov    %ecx,(%eax)
	scrdown(currcons);								// 从光标开始处,屏幕内容向下滚动一行.
   1dd5b:	ff 74 24 1c          	pushl  0x1c(%esp)
   1dd5f:	e8 15 ee ff ff       	call   1cb79 <scrdown>
   1dd64:	83 c4 04             	add    $0x4,%esp
	top = oldtop;
   1dd67:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1dd6b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dd6f:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1dd75:	89 d0                	mov    %edx,%eax
   1dd77:	c1 e0 03             	shl    $0x3,%eax
   1dd7a:	01 d0                	add    %edx,%eax
   1dd7c:	c1 e0 04             	shl    $0x4,%eax
   1dd7f:	01 f0                	add    %esi,%eax
   1dd81:	83 c0 20             	add    $0x20,%eax
   1dd84:	89 08                	mov    %ecx,(%eax)
	bottom = oldbottom;
   1dd86:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1dd8a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dd8e:	8d 9b e0 1e 01 00    	lea    0x11ee0(%ebx),%ebx
   1dd94:	89 d0                	mov    %edx,%eax
   1dd96:	c1 e0 03             	shl    $0x3,%eax
   1dd99:	01 d0                	add    %edx,%eax
   1dd9b:	c1 e0 04             	shl    $0x4,%eax
   1dd9e:	01 d8                	add    %ebx,%eax
   1dda0:	83 c0 30             	add    $0x30,%eax
   1dda3:	89 08                	mov    %ecx,(%eax)
}
   1dda5:	90                   	nop
   1dda6:	83 c4 10             	add    $0x10,%esp
   1dda9:	5b                   	pop    %ebx
   1ddaa:	5e                   	pop    %esi
   1ddab:	c3                   	ret    

0001ddac <delete_char>:

// 删除一个字符
// 删除光标处的一个字符,光标右边的所有字符左移一格.
static void delete_char(int currcons)
{
   1ddac:	53                   	push   %ebx
   1ddad:	83 ec 10             	sub    $0x10,%esp
   1ddb0:	e8 3d 8f fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1ddb5:	05 4b 42 01 00       	add    $0x1424b,%eax
	int i;
	unsigned short * p = (unsigned short *) pos;
   1ddba:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1ddbe:	8d 98 e0 1e 01 00    	lea    0x11ee0(%eax),%ebx
   1ddc4:	89 ca                	mov    %ecx,%edx
   1ddc6:	c1 e2 03             	shl    $0x3,%edx
   1ddc9:	01 ca                	add    %ecx,%edx
   1ddcb:	c1 e2 04             	shl    $0x4,%edx
   1ddce:	01 da                	add    %ebx,%edx
   1ddd0:	83 c2 20             	add    $0x20,%edx
   1ddd3:	8b 12                	mov    (%edx),%edx
   1ddd5:	89 54 24 08          	mov    %edx,0x8(%esp)

	// 如果光标的当前列位置x走出屏幕最右列,则返回.否则从光标右一个字符开始到行末所有字符左移一格.然后在最后一个字符处填入擦除字符.
	if (x >= video_num_columns)
   1ddd9:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1dddd:	8d 98 e4 1e 01 00    	lea    0x11ee4(%eax),%ebx
   1dde3:	89 ca                	mov    %ecx,%edx
   1dde5:	c1 e2 03             	shl    $0x3,%edx
   1dde8:	01 ca                	add    %ecx,%edx
   1ddea:	c1 e2 04             	shl    $0x4,%edx
   1dded:	01 da                	add    %ebx,%edx
   1ddef:	83 c2 20             	add    $0x20,%edx
   1ddf2:	8b 0a                	mov    (%edx),%ecx
   1ddf4:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1ddfa:	39 d1                	cmp    %edx,%ecx
   1ddfc:	73 6a                	jae    1de68 <delete_char+0xbc>
		return;
	i = x;
   1ddfe:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   1de02:	8d 98 e4 1e 01 00    	lea    0x11ee4(%eax),%ebx
   1de08:	89 ca                	mov    %ecx,%edx
   1de0a:	c1 e2 03             	shl    $0x3,%edx
   1de0d:	01 ca                	add    %ecx,%edx
   1de0f:	c1 e2 04             	shl    $0x4,%edx
   1de12:	01 da                	add    %ebx,%edx
   1de14:	83 c2 20             	add    $0x20,%edx
   1de17:	8b 12                	mov    (%edx),%edx
   1de19:	89 54 24 0c          	mov    %edx,0xc(%esp)
	while (++i < video_num_columns) {				// 光标右所有字符左移1格.
   1de1d:	eb 14                	jmp    1de33 <delete_char+0x87>
		*p = *(p + 1);
   1de1f:	8b 54 24 08          	mov    0x8(%esp),%edx
   1de23:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
   1de27:	8b 54 24 08          	mov    0x8(%esp),%edx
   1de2b:	66 89 0a             	mov    %cx,(%edx)
		p++;
   1de2e:	83 44 24 08 02       	addl   $0x2,0x8(%esp)
	while (++i < video_num_columns) {				// 光标右所有字符左移1格.
   1de33:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1de38:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1de3c:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1de42:	39 d1                	cmp    %edx,%ecx
   1de44:	72 d9                	jb     1de1f <delete_char+0x73>
	}
	*p = video_erase_char;							// 最后填入擦除字符.
   1de46:	8b 54 24 18          	mov    0x18(%esp),%edx
   1de4a:	8d 88 e0 1e 01 00    	lea    0x11ee0(%eax),%ecx
   1de50:	89 d0                	mov    %edx,%eax
   1de52:	c1 e0 03             	shl    $0x3,%eax
   1de55:	01 d0                	add    %edx,%eax
   1de57:	c1 e0 04             	shl    $0x4,%eax
   1de5a:	01 c8                	add    %ecx,%eax
   1de5c:	0f b7 10             	movzwl (%eax),%edx
   1de5f:	8b 44 24 08          	mov    0x8(%esp),%eax
   1de63:	66 89 10             	mov    %dx,(%eax)
   1de66:	eb 01                	jmp    1de69 <delete_char+0xbd>
		return;
   1de68:	90                   	nop
}
   1de69:	83 c4 10             	add    $0x10,%esp
   1de6c:	5b                   	pop    %ebx
   1de6d:	c3                   	ret    

0001de6e <delete_line>:

// 删除光标所在行
// 删除光标所在的一行,并从光标所在行开始屏幕内容上巻一行.
static void delete_line(int currcons)
{
   1de6e:	56                   	push   %esi
   1de6f:	53                   	push   %ebx
   1de70:	83 ec 10             	sub    $0x10,%esp
   1de73:	e8 82 8e fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1de78:	81 c3 88 41 01 00    	add    $0x14188,%ebx
	int oldtop, oldbottom;

	// 首先保存屏幕窗口卷动开始行top和最后行bottom值,然后从光标所在行让屏幕内容向上滚动一行.最后恢复屏幕窗口卷动开始行top和最后行bottom
	// 的原来值.
	oldtop = top;
   1de7e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1de82:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1de88:	89 d0                	mov    %edx,%eax
   1de8a:	c1 e0 03             	shl    $0x3,%eax
   1de8d:	01 d0                	add    %edx,%eax
   1de8f:	c1 e0 04             	shl    $0x4,%eax
   1de92:	01 c8                	add    %ecx,%eax
   1de94:	83 c0 20             	add    $0x20,%eax
   1de97:	8b 00                	mov    (%eax),%eax
   1de99:	89 44 24 0c          	mov    %eax,0xc(%esp)
	oldbottom = bottom;
   1de9d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dea1:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1dea7:	89 d0                	mov    %edx,%eax
   1dea9:	c1 e0 03             	shl    $0x3,%eax
   1deac:	01 d0                	add    %edx,%eax
   1deae:	c1 e0 04             	shl    $0x4,%eax
   1deb1:	01 c8                	add    %ecx,%eax
   1deb3:	83 c0 30             	add    $0x30,%eax
   1deb6:	8b 00                	mov    (%eax),%eax
   1deb8:	89 44 24 08          	mov    %eax,0x8(%esp)
	top = y;										// 设置屏幕卷动开始行和最后行.
   1debc:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dec0:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1dec6:	89 d0                	mov    %edx,%eax
   1dec8:	c1 e0 03             	shl    $0x3,%eax
   1decb:	01 d0                	add    %edx,%eax
   1decd:	c1 e0 04             	shl    $0x4,%eax
   1ded0:	01 c8                	add    %ecx,%eax
   1ded2:	83 c0 20             	add    $0x20,%eax
   1ded5:	8b 08                	mov    (%eax),%ecx
   1ded7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1dedb:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1dee1:	89 d0                	mov    %edx,%eax
   1dee3:	c1 e0 03             	shl    $0x3,%eax
   1dee6:	01 d0                	add    %edx,%eax
   1dee8:	c1 e0 04             	shl    $0x4,%eax
   1deeb:	01 f0                	add    %esi,%eax
   1deed:	83 c0 20             	add    $0x20,%eax
   1def0:	89 08                	mov    %ecx,(%eax)
	bottom = video_num_lines;
   1def2:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1def8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1defc:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1df02:	89 d0                	mov    %edx,%eax
   1df04:	c1 e0 03             	shl    $0x3,%eax
   1df07:	01 d0                	add    %edx,%eax
   1df09:	c1 e0 04             	shl    $0x4,%eax
   1df0c:	01 f0                	add    %esi,%eax
   1df0e:	83 c0 30             	add    $0x30,%eax
   1df11:	89 08                	mov    %ecx,(%eax)
	scrup(currcons);								// 从光标开始处,屏幕内容向上滚动一行.
   1df13:	ff 74 24 1c          	pushl  0x1c(%esp)
   1df17:	e8 b0 e6 ff ff       	call   1c5cc <scrup>
   1df1c:	83 c4 04             	add    $0x4,%esp
	top = oldtop;
   1df1f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1df23:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1df27:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1df2d:	89 d0                	mov    %edx,%eax
   1df2f:	c1 e0 03             	shl    $0x3,%eax
   1df32:	01 d0                	add    %edx,%eax
   1df34:	c1 e0 04             	shl    $0x4,%eax
   1df37:	01 f0                	add    %esi,%eax
   1df39:	83 c0 20             	add    $0x20,%eax
   1df3c:	89 08                	mov    %ecx,(%eax)
	bottom = oldbottom;
   1df3e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1df42:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1df46:	8d 9b e0 1e 01 00    	lea    0x11ee0(%ebx),%ebx
   1df4c:	89 d0                	mov    %edx,%eax
   1df4e:	c1 e0 03             	shl    $0x3,%eax
   1df51:	01 d0                	add    %edx,%eax
   1df53:	c1 e0 04             	shl    $0x4,%eax
   1df56:	01 d8                	add    %ebx,%eax
   1df58:	83 c0 30             	add    $0x30,%eax
   1df5b:	89 08                	mov    %ecx,(%eax)
}
   1df5d:	90                   	nop
   1df5e:	83 c4 10             	add    $0x10,%esp
   1df61:	5b                   	pop    %ebx
   1df62:	5e                   	pop    %esi
   1df63:	c3                   	ret    

0001df64 <csi_at>:
// 在光标处插入nr个字符
// ANSI转义字符序列:'ESC [ Pn @'.在当前光标处插入1个或多个安全空格字符.Pn是插入的字符数.默认是1.光标将仍然处于第1个插入的空格字符处.在光标与右边界
// 的字符将右移.超过右边界的字符将被丢失.
// 参数 nr = 转义字符序列中的参数Pn.
static void csi_at(int currcons, unsigned int nr)
{
   1df64:	e8 89 8d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1df69:	05 97 40 01 00       	add    $0x14097,%eax
	// 如果插入的字符数大于一行字符数,则截为一行字符数;若插入字符数nr为0,则插入1个字符.然后循环插入指定个空格字符.
	if (nr > video_num_columns)
   1df6e:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1df74:	39 54 24 08          	cmp    %edx,0x8(%esp)
   1df78:	76 0c                	jbe    1df86 <csi_at+0x22>
		nr = video_num_columns;
   1df7a:	8b 80 b4 1e 01 00    	mov    0x11eb4(%eax),%eax
   1df80:	89 44 24 08          	mov    %eax,0x8(%esp)
   1df84:	eb 1d                	jmp    1dfa3 <csi_at+0x3f>
	else if (!nr)
   1df86:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1df8b:	75 16                	jne    1dfa3 <csi_at+0x3f>
		nr = 1;
   1df8d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   1df94:	00 
	while (nr--)
   1df95:	eb 0c                	jmp    1dfa3 <csi_at+0x3f>
		insert_char(currcons);
   1df97:	ff 74 24 04          	pushl  0x4(%esp)
   1df9b:	e8 65 fc ff ff       	call   1dc05 <insert_char>
   1dfa0:	83 c4 04             	add    $0x4,%esp
	while (nr--)
   1dfa3:	8b 44 24 08          	mov    0x8(%esp),%eax
   1dfa7:	8d 50 ff             	lea    -0x1(%eax),%edx
   1dfaa:	89 54 24 08          	mov    %edx,0x8(%esp)
   1dfae:	85 c0                	test   %eax,%eax
   1dfb0:	75 e5                	jne    1df97 <csi_at+0x33>
}
   1dfb2:	90                   	nop
   1dfb3:	c3                   	ret    

0001dfb4 <csi_L>:
// 在光标位置处插入nr行.
// ANSI转义字符序列: 'ESC [ Pn L'.该控制序列在光标处插入1行或多行空行.操作完成后光标位置不变.当空行被插入时,光标以下滚动区域内的行向下移动.滚动超出显示页的
// 行就丢失.
// 参数nr = 转义字符序列中的参数Pn.
static void csi_L(int currcons, unsigned int nr)
{
   1dfb4:	e8 39 8d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1dfb9:	05 47 40 01 00       	add    $0x14047,%eax
	// 如果插入的行数大于屏最多行数,则截为屏幕显示行数;若插入行数nr为0,则插入1行.然后循环插入指定行数nr的空行.
	if (nr > video_num_lines)
   1dfbe:	8b 90 c4 1e 01 00    	mov    0x11ec4(%eax),%edx
   1dfc4:	39 54 24 08          	cmp    %edx,0x8(%esp)
   1dfc8:	76 0c                	jbe    1dfd6 <csi_L+0x22>
		nr = video_num_lines;
   1dfca:	8b 80 c4 1e 01 00    	mov    0x11ec4(%eax),%eax
   1dfd0:	89 44 24 08          	mov    %eax,0x8(%esp)
   1dfd4:	eb 1d                	jmp    1dff3 <csi_L+0x3f>
	else if (!nr)
   1dfd6:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1dfdb:	75 16                	jne    1dff3 <csi_L+0x3f>
		nr = 1;
   1dfdd:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   1dfe4:	00 
	while (nr--)
   1dfe5:	eb 0c                	jmp    1dff3 <csi_L+0x3f>
		insert_line(currcons);
   1dfe7:	ff 74 24 04          	pushl  0x4(%esp)
   1dfeb:	e8 c6 fc ff ff       	call   1dcb6 <insert_line>
   1dff0:	83 c4 04             	add    $0x4,%esp
	while (nr--)
   1dff3:	8b 44 24 08          	mov    0x8(%esp),%eax
   1dff7:	8d 50 ff             	lea    -0x1(%eax),%edx
   1dffa:	89 54 24 08          	mov    %edx,0x8(%esp)
   1dffe:	85 c0                	test   %eax,%eax
   1e000:	75 e5                	jne    1dfe7 <csi_L+0x33>
}
   1e002:	90                   	nop
   1e003:	c3                   	ret    

0001e004 <csi_P>:
// 删除光标处的nr个字符.
// ANSI转义序列:'ESC [ Pn P'.该控制序列从光标处删除Pn个字符.当一个字符被删除时,光标右所有字符都左移,这会在右边界处产生一个空字符.其属性应该与最后一个左移字符
// 相同,但这里作了简化处理,仅使用字符的默认属性(黑底白字空格0x0720)来设置空字符.
// 参数nr = 转义字符序列中的参数Pn.
static void csi_P(int currcons, unsigned int nr)
{
   1e004:	e8 e9 8c fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1e009:	05 f7 3f 01 00       	add    $0x13ff7,%eax
	// 如果删除的字符数大于一行字符数,则截为一行字符数;若删除字符数nr为0,则删除1个字符.然后循环删除光标处指定字符数nr.
	if (nr > video_num_columns)
   1e00e:	8b 90 b4 1e 01 00    	mov    0x11eb4(%eax),%edx
   1e014:	39 54 24 08          	cmp    %edx,0x8(%esp)
   1e018:	76 0c                	jbe    1e026 <csi_P+0x22>
		nr = video_num_columns;
   1e01a:	8b 80 b4 1e 01 00    	mov    0x11eb4(%eax),%eax
   1e020:	89 44 24 08          	mov    %eax,0x8(%esp)
   1e024:	eb 1d                	jmp    1e043 <csi_P+0x3f>
	else if (!nr)
   1e026:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1e02b:	75 16                	jne    1e043 <csi_P+0x3f>
		nr = 1;
   1e02d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   1e034:	00 
	while (nr--)
   1e035:	eb 0c                	jmp    1e043 <csi_P+0x3f>
		delete_char(currcons);
   1e037:	ff 74 24 04          	pushl  0x4(%esp)
   1e03b:	e8 6c fd ff ff       	call   1ddac <delete_char>
   1e040:	83 c4 04             	add    $0x4,%esp
	while (nr--)
   1e043:	8b 44 24 08          	mov    0x8(%esp),%eax
   1e047:	8d 50 ff             	lea    -0x1(%eax),%edx
   1e04a:	89 54 24 08          	mov    %edx,0x8(%esp)
   1e04e:	85 c0                	test   %eax,%eax
   1e050:	75 e5                	jne    1e037 <csi_P+0x33>
}
   1e052:	90                   	nop
   1e053:	c3                   	ret    

0001e054 <csi_M>:
// 删除光标处的nr行.
// ANSI转义序列: 'ESC [ Pn M'.该控制序列在滚动区域内,从光标所在行开始删除1行或多行.当行被删除时,滚动区域内的被删行以下的行会向上移动,并且会在最底行添加1空行.若
// Pn大于显示页上剩余行数,则本序列仅删除这些剩余行,并对滚动区域处不起作用.
// 参数nr = 转义字符序列中的参数Pn.
static void csi_M(int currcons, unsigned int nr)
{
   1e054:	e8 99 8c fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1e059:	05 a7 3f 01 00       	add    $0x13fa7,%eax
	// 如果删除的行数大于屏幕最大行数,则截为屏幕显示行数;若欲删除的行数nr为0,则删除1行.然后循环删除指定行数nr.
	if (nr > video_num_lines)
   1e05e:	8b 90 c4 1e 01 00    	mov    0x11ec4(%eax),%edx
   1e064:	39 54 24 08          	cmp    %edx,0x8(%esp)
   1e068:	76 0c                	jbe    1e076 <csi_M+0x22>
		nr = video_num_lines;
   1e06a:	8b 80 c4 1e 01 00    	mov    0x11ec4(%eax),%eax
   1e070:	89 44 24 08          	mov    %eax,0x8(%esp)
   1e074:	eb 1d                	jmp    1e093 <csi_M+0x3f>
	else if (!nr)
   1e076:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1e07b:	75 16                	jne    1e093 <csi_M+0x3f>
		nr=1;
   1e07d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   1e084:	00 
	while (nr--)
   1e085:	eb 0c                	jmp    1e093 <csi_M+0x3f>
		delete_line(currcons);
   1e087:	ff 74 24 04          	pushl  0x4(%esp)
   1e08b:	e8 de fd ff ff       	call   1de6e <delete_line>
   1e090:	83 c4 04             	add    $0x4,%esp
	while (nr--)
   1e093:	8b 44 24 08          	mov    0x8(%esp),%eax
   1e097:	8d 50 ff             	lea    -0x1(%eax),%edx
   1e09a:	89 54 24 08          	mov    %edx,0x8(%esp)
   1e09e:	85 c0                	test   %eax,%eax
   1e0a0:	75 e5                	jne    1e087 <csi_M+0x33>
}
   1e0a2:	90                   	nop
   1e0a3:	c3                   	ret    

0001e0a4 <save_cur>:

//// 保存当前光标位置
static void save_cur(int currcons)
{
   1e0a4:	56                   	push   %esi
   1e0a5:	53                   	push   %ebx
   1e0a6:	e8 4b 8c fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   1e0ab:	81 c2 55 3f 01 00    	add    $0x13f55,%edx
	saved_x = x;
   1e0b1:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1e0b5:	8d 9a e4 1e 01 00    	lea    0x11ee4(%edx),%ebx
   1e0bb:	89 c8                	mov    %ecx,%eax
   1e0bd:	c1 e0 03             	shl    $0x3,%eax
   1e0c0:	01 c8                	add    %ecx,%eax
   1e0c2:	c1 e0 04             	shl    $0x4,%eax
   1e0c5:	01 d8                	add    %ebx,%eax
   1e0c7:	83 c0 20             	add    $0x20,%eax
   1e0ca:	8b 18                	mov    (%eax),%ebx
   1e0cc:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1e0d0:	8d b2 e0 1e 01 00    	lea    0x11ee0(%edx),%esi
   1e0d6:	89 c8                	mov    %ecx,%eax
   1e0d8:	c1 e0 03             	shl    $0x3,%eax
   1e0db:	01 c8                	add    %ecx,%eax
   1e0dd:	c1 e0 04             	shl    $0x4,%eax
   1e0e0:	01 f0                	add    %esi,%eax
   1e0e2:	83 e8 80             	sub    $0xffffff80,%eax
   1e0e5:	89 18                	mov    %ebx,(%eax)
	saved_y = y;
   1e0e7:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1e0eb:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   1e0f1:	89 c8                	mov    %ecx,%eax
   1e0f3:	c1 e0 03             	shl    $0x3,%eax
   1e0f6:	01 c8                	add    %ecx,%eax
   1e0f8:	c1 e0 04             	shl    $0x4,%eax
   1e0fb:	01 d8                	add    %ebx,%eax
   1e0fd:	83 c0 20             	add    $0x20,%eax
   1e100:	8b 18                	mov    (%eax),%ebx
   1e102:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1e106:	8d 92 e4 1e 01 00    	lea    0x11ee4(%edx),%edx
   1e10c:	89 c8                	mov    %ecx,%eax
   1e10e:	c1 e0 03             	shl    $0x3,%eax
   1e111:	01 c8                	add    %ecx,%eax
   1e113:	c1 e0 04             	shl    $0x4,%eax
   1e116:	01 d0                	add    %edx,%eax
   1e118:	83 e8 80             	sub    $0xffffff80,%eax
   1e11b:	89 18                	mov    %ebx,(%eax)
}
   1e11d:	90                   	nop
   1e11e:	5b                   	pop    %ebx
   1e11f:	5e                   	pop    %esi
   1e120:	c3                   	ret    

0001e121 <restore_cur>:

// 恢复保存的光标位置
static void restore_cur(int currcons)
{
   1e121:	53                   	push   %ebx
   1e122:	e8 cf 8b fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   1e127:	81 c2 d9 3e 01 00    	add    $0x13ed9,%edx
	gotoxy(currcons, saved_x, saved_y);
   1e12d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1e131:	8d 9a e4 1e 01 00    	lea    0x11ee4(%edx),%ebx
   1e137:	89 c8                	mov    %ecx,%eax
   1e139:	c1 e0 03             	shl    $0x3,%eax
   1e13c:	01 c8                	add    %ecx,%eax
   1e13e:	c1 e0 04             	shl    $0x4,%eax
   1e141:	01 d8                	add    %ebx,%eax
   1e143:	83 e8 80             	sub    $0xffffff80,%eax
   1e146:	8b 18                	mov    (%eax),%ebx
   1e148:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1e14c:	8d 92 e0 1e 01 00    	lea    0x11ee0(%edx),%edx
   1e152:	89 c8                	mov    %ecx,%eax
   1e154:	c1 e0 03             	shl    $0x3,%eax
   1e157:	01 c8                	add    %ecx,%eax
   1e159:	c1 e0 04             	shl    $0x4,%eax
   1e15c:	01 d0                	add    %edx,%eax
   1e15e:	83 e8 80             	sub    $0xffffff80,%eax
   1e161:	8b 00                	mov    (%eax),%eax
   1e163:	53                   	push   %ebx
   1e164:	50                   	push   %eax
   1e165:	ff 74 24 10          	pushl  0x10(%esp)
   1e169:	e8 9e e2 ff ff       	call   1c40c <gotoxy>
   1e16e:	83 c4 0c             	add    $0xc,%esp
}
   1e171:	90                   	nop
   1e172:	5b                   	pop    %ebx
   1e173:	c3                   	ret    

0001e174 <con_write>:
// 控制台写函数
// 从终端对应的tty写缓冲队列中取字符针对每个字符进行分析.若是控制字符或转义或控制序列,则进行光标定位,字符删除等的控制处理;对于普通字符就直接在光标处
// 显示.
// 参数:tty是当前控制台使用的tty结构指针.
void con_write(struct tty_struct * tty)
{
   1e174:	57                   	push   %edi
   1e175:	56                   	push   %esi
   1e176:	53                   	push   %ebx
   1e177:	83 ec 10             	sub    $0x10,%esp
   1e17a:	e8 7b 8b fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1e17f:	81 c3 81 3e 01 00    	add    $0x13e81,%ebx

	// 该函数首先根据当前控制台使用的tty在tty表的项位置取得对应控制台号currcons,然后计算出(CHARS())目前tty写队列中含有的字符数nr,并循环取出其中的每个
	// 字符进行处理.不过如果当前控制台由于接收键盘或发出的暂停命令(如按键Ctrl-S)而处于停止状态,那么本函数就停止处理写队列中的字符,退出函数.另外,如果取出的
	// 是控制字符CAN(24)或SUB(6),那么若是在转义或控制序列期间收到的,则序列不会执行而立刻终止,同时显示随后的字符.注意,con_write()函数只处理取队列字符数
	// 时写队列中当前含有的字符.这有可能在一个序列被放到写队列期间读取字符数,因此本函数前一次退出时state有可能处于处理转义或控制序列的其他状态上.
	currcons = tty - tty_table;
   1e185:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e189:	c7 c2 a0 68 04 00    	mov    $0x468a0,%edx
   1e18f:	29 d0                	sub    %edx,%eax
   1e191:	c1 f8 06             	sar    $0x6,%eax
   1e194:	89 44 24 08          	mov    %eax,0x8(%esp)
	if ((currcons >= MAX_CONSOLES) || (currcons < 0))
   1e198:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
   1e19d:	7f 07                	jg     1e1a6 <con_write+0x32>
   1e19f:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1e1a4:	79 12                	jns    1e1b8 <con_write+0x44>
		panic("con_write: illegal tty");
   1e1a6:	83 ec 0c             	sub    $0xc,%esp
   1e1a9:	8d 83 bc 64 ff ff    	lea    -0x9b44(%ebx),%eax
   1e1af:	50                   	push   %eax
   1e1b0:	e8 29 b1 fe ff       	call   92de <panic>
   1e1b5:	83 c4 10             	add    $0x10,%esp

	nr = CHARS(tty->write_q);										// 取写队列中字符数,在tty.h文件中
   1e1b8:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e1bc:	8b 40 38             	mov    0x38(%eax),%eax
   1e1bf:	8b 50 04             	mov    0x4(%eax),%edx
   1e1c2:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e1c6:	8b 40 38             	mov    0x38(%eax),%eax
   1e1c9:	8b 40 08             	mov    0x8(%eax),%eax
   1e1cc:	29 c2                	sub    %eax,%edx
   1e1ce:	89 d0                	mov    %edx,%eax
   1e1d0:	25 ff 03 00 00       	and    $0x3ff,%eax
   1e1d5:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (nr--) {
   1e1d9:	e9 e2 16 00 00       	jmp    1f8c0 <.L127>
		if (tty->stopped)
   1e1de:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e1e2:	8b 40 2c             	mov    0x2c(%eax),%eax
   1e1e5:	85 c0                	test   %eax,%eax
   1e1e7:	0f 85 e8 16 00 00    	jne    1f8d5 <.L127+0x15>
			break;
		GETCH(tty->write_q, c);										// 取1字符到c中
   1e1ed:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e1f1:	8b 50 38             	mov    0x38(%eax),%edx
   1e1f4:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e1f8:	8b 40 38             	mov    0x38(%eax),%eax
   1e1fb:	8b 40 08             	mov    0x8(%eax),%eax
   1e1fe:	0f b6 44 02 10       	movzbl 0x10(%edx,%eax,1),%eax
   1e203:	88 44 24 07          	mov    %al,0x7(%esp)
   1e207:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e20b:	8b 40 38             	mov    0x38(%eax),%eax
   1e20e:	8b 40 08             	mov    0x8(%eax),%eax
   1e211:	8d 50 01             	lea    0x1(%eax),%edx
   1e214:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e218:	8b 40 38             	mov    0x38(%eax),%eax
   1e21b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1e221:	89 50 08             	mov    %edx,0x8(%eax)
		if (c == 24 || c == 26)										// 控制字符CAN,SUB - 取消,替换
   1e224:	80 7c 24 07 18       	cmpb   $0x18,0x7(%esp)
   1e229:	74 07                	je     1e232 <con_write+0xbe>
   1e22b:	80 7c 24 07 1a       	cmpb   $0x1a,0x7(%esp)
   1e230:	75 1c                	jne    1e24e <con_write+0xda>
			state = ESnormal;
   1e232:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e236:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e23c:	89 d0                	mov    %edx,%eax
   1e23e:	c1 e0 03             	shl    $0x3,%eax
   1e241:	01 d0                	add    %edx,%eax
   1e243:	c1 e0 04             	shl    $0x4,%eax
   1e246:	01 c8                	add    %ecx,%eax
   1e248:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		switch(state) {
   1e24e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e252:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e258:	89 d0                	mov    %edx,%eax
   1e25a:	c1 e0 03             	shl    $0x3,%eax
   1e25d:	01 d0                	add    %edx,%eax
   1e25f:	c1 e0 04             	shl    $0x4,%eax
   1e262:	01 c8                	add    %ecx,%eax
   1e264:	8b 00                	mov    (%eax),%eax
   1e266:	83 f8 07             	cmp    $0x7,%eax
   1e269:	0f 87 35 16 00 00    	ja     1f8a4 <.L141+0x70>
   1e26f:	c1 e0 02             	shl    $0x2,%eax
   1e272:	8b 84 18 e8 64 ff ff 	mov    -0x9b18(%eax,%ebx,1),%eax
   1e279:	01 d8                	add    %ebx,%eax
   1e27b:	ff e0                	jmp    *%eax

0001e27d <.L133>:
			//          标位置进行设置.当刚处理完一个转义或控制序列,程序也会返回到本状态.
			// 如果从写队列中取出的字符是普通显示字符代码,就直接从当前映射字符集中取出对应的显示字符,并放到当前光标所处的显示内存位置处,即直接显示该字符.然后把光标
			// 位置右移一个字符位置.具体地,如果字符不是控制字符也不是扩展字符,即(31<c<127),那么,若当前光标处在行末端或末端以外,则将光标移到下行头列.并调整光标位置
			// 对应的内存指针pos.然后将字符c写到显示内存中pos处,并将光标右移1列,同时也将pos对应地移动2个字节.
			case ESnormal:
				if (c > 31 && c < 127) {							// 是普通显示字符
   1e27d:	80 7c 24 07 1f       	cmpb   $0x1f,0x7(%esp)
   1e282:	0f 8e 9d 01 00 00    	jle    1e425 <.L133+0x1a8>
   1e288:	80 7c 24 07 7f       	cmpb   $0x7f,0x7(%esp)
   1e28d:	0f 84 92 01 00 00    	je     1e425 <.L133+0x1a8>
					if (x >= video_num_columns) {					// 要换行?
   1e293:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e297:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e29d:	89 d0                	mov    %edx,%eax
   1e29f:	c1 e0 03             	shl    $0x3,%eax
   1e2a2:	01 d0                	add    %edx,%eax
   1e2a4:	c1 e0 04             	shl    $0x4,%eax
   1e2a7:	01 c8                	add    %ecx,%eax
   1e2a9:	83 c0 20             	add    $0x20,%eax
   1e2ac:	8b 10                	mov    (%eax),%edx
   1e2ae:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   1e2b4:	39 c2                	cmp    %eax,%edx
   1e2b6:	0f 82 8f 00 00 00    	jb     1e34b <.L133+0xce>
						x -= video_num_columns;
   1e2bc:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e2c0:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e2c6:	89 d0                	mov    %edx,%eax
   1e2c8:	c1 e0 03             	shl    $0x3,%eax
   1e2cb:	01 d0                	add    %edx,%eax
   1e2cd:	c1 e0 04             	shl    $0x4,%eax
   1e2d0:	01 c8                	add    %ecx,%eax
   1e2d2:	83 c0 20             	add    $0x20,%eax
   1e2d5:	8b 10                	mov    (%eax),%edx
   1e2d7:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   1e2dd:	89 d1                	mov    %edx,%ecx
   1e2df:	29 c1                	sub    %eax,%ecx
   1e2e1:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e2e5:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1e2eb:	89 d0                	mov    %edx,%eax
   1e2ed:	c1 e0 03             	shl    $0x3,%eax
   1e2f0:	01 d0                	add    %edx,%eax
   1e2f2:	c1 e0 04             	shl    $0x4,%eax
   1e2f5:	01 f0                	add    %esi,%eax
   1e2f7:	83 c0 20             	add    $0x20,%eax
   1e2fa:	89 08                	mov    %ecx,(%eax)
						pos -= video_size_row;
   1e2fc:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e300:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1e306:	89 d0                	mov    %edx,%eax
   1e308:	c1 e0 03             	shl    $0x3,%eax
   1e30b:	01 d0                	add    %edx,%eax
   1e30d:	c1 e0 04             	shl    $0x4,%eax
   1e310:	01 c8                	add    %ecx,%eax
   1e312:	83 c0 20             	add    $0x20,%eax
   1e315:	8b 10                	mov    (%eax),%edx
   1e317:	8b 83 c0 1e 01 00    	mov    0x11ec0(%ebx),%eax
   1e31d:	89 d1                	mov    %edx,%ecx
   1e31f:	29 c1                	sub    %eax,%ecx
   1e321:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e325:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1e32b:	89 d0                	mov    %edx,%eax
   1e32d:	c1 e0 03             	shl    $0x3,%eax
   1e330:	01 d0                	add    %edx,%eax
   1e332:	c1 e0 04             	shl    $0x4,%eax
   1e335:	01 f0                	add    %esi,%eax
   1e337:	83 c0 20             	add    $0x20,%eax
   1e33a:	89 08                	mov    %ecx,(%eax)
						lf(currcons);
   1e33c:	83 ec 0c             	sub    $0xc,%esp
   1e33f:	ff 74 24 14          	pushl  0x14(%esp)
   1e343:	e8 b5 ea ff ff       	call   1cdfd <lf>
   1e348:	83 c4 10             	add    $0x10,%esp
					}
					__asm__("movb %2, %%ah\n\t"						// 写字符
						"movw %%ax, %1\n\t"
						::"a" (translate[c - 32]),
   1e34b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e34f:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e355:	89 d0                	mov    %edx,%eax
   1e357:	c1 e0 03             	shl    $0x3,%eax
   1e35a:	01 d0                	add    %edx,%eax
   1e35c:	c1 e0 04             	shl    $0x4,%eax
   1e35f:	01 c8                	add    %ecx,%eax
   1e361:	83 e8 80             	sub    $0xffffff80,%eax
   1e364:	8b 00                	mov    (%eax),%eax
   1e366:	0f be 54 24 07       	movsbl 0x7(%esp),%edx
   1e36b:	83 ea 20             	sub    $0x20,%edx
   1e36e:	01 d0                	add    %edx,%eax
   1e370:	0f b6 08             	movzbl (%eax),%ecx
						"m" (*(short *)pos),
   1e373:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e377:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1e37d:	89 d0                	mov    %edx,%eax
   1e37f:	c1 e0 03             	shl    $0x3,%eax
   1e382:	01 d0                	add    %edx,%eax
   1e384:	c1 e0 04             	shl    $0x4,%eax
   1e387:	01 f0                	add    %esi,%eax
   1e389:	83 c0 20             	add    $0x20,%eax
   1e38c:	8b 00                	mov    (%eax),%eax
   1e38e:	89 c7                	mov    %eax,%edi
					__asm__("movb %2, %%ah\n\t"						// 写字符
   1e390:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e394:	8d b3 e2 1e 01 00    	lea    0x11ee2(%ebx),%esi
   1e39a:	89 d0                	mov    %edx,%eax
   1e39c:	c1 e0 03             	shl    $0x3,%eax
   1e39f:	01 d0                	add    %edx,%eax
   1e3a1:	c1 e0 04             	shl    $0x4,%eax
   1e3a4:	8d 14 30             	lea    (%eax,%esi,1),%edx
   1e3a7:	89 c8                	mov    %ecx,%eax
   1e3a9:	8a 22                	mov    (%edx),%ah
   1e3ab:	66 89 07             	mov    %ax,(%edi)
						"m" (attr)
						:);
					pos += 2;
   1e3ae:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e3b2:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1e3b8:	89 d0                	mov    %edx,%eax
   1e3ba:	c1 e0 03             	shl    $0x3,%eax
   1e3bd:	01 d0                	add    %edx,%eax
   1e3bf:	c1 e0 04             	shl    $0x4,%eax
   1e3c2:	01 c8                	add    %ecx,%eax
   1e3c4:	83 c0 20             	add    $0x20,%eax
   1e3c7:	8b 00                	mov    (%eax),%eax
   1e3c9:	8d 48 02             	lea    0x2(%eax),%ecx
   1e3cc:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e3d0:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1e3d6:	89 d0                	mov    %edx,%eax
   1e3d8:	c1 e0 03             	shl    $0x3,%eax
   1e3db:	01 d0                	add    %edx,%eax
   1e3dd:	c1 e0 04             	shl    $0x4,%eax
   1e3e0:	01 f0                	add    %esi,%eax
   1e3e2:	83 c0 20             	add    $0x20,%eax
   1e3e5:	89 08                	mov    %ecx,(%eax)
					x++;
   1e3e7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e3eb:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e3f1:	89 d0                	mov    %edx,%eax
   1e3f3:	c1 e0 03             	shl    $0x3,%eax
   1e3f6:	01 d0                	add    %edx,%eax
   1e3f8:	c1 e0 04             	shl    $0x4,%eax
   1e3fb:	01 c8                	add    %ecx,%eax
   1e3fd:	83 c0 20             	add    $0x20,%eax
   1e400:	8b 00                	mov    (%eax),%eax
   1e402:	8d 48 01             	lea    0x1(%eax),%ecx
   1e405:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e409:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1e40f:	89 d0                	mov    %edx,%eax
   1e411:	c1 e0 03             	shl    $0x3,%eax
   1e414:	01 d0                	add    %edx,%eax
   1e416:	c1 e0 04             	shl    $0x4,%eax
   1e419:	01 f0                	add    %esi,%eax
   1e41b:	83 c0 20             	add    $0x20,%eax
   1e41e:	89 08                	mov    %ecx,(%eax)
   1e420:	e9 19 03 00 00       	jmp    1e73e <.L133+0x4c1>
				// 如果字符c是转义字符ESC,则转换状态state到ESesc
				} else if (c == 27)									// ESC - 转义控制字符
   1e425:	80 7c 24 07 1b       	cmpb   $0x1b,0x7(%esp)
   1e42a:	75 21                	jne    1e44d <.L133+0x1d0>
					state = ESesc;
   1e42c:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e430:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e436:	89 d0                	mov    %edx,%eax
   1e438:	c1 e0 03             	shl    $0x3,%eax
   1e43b:	01 d0                	add    %edx,%eax
   1e43d:	c1 e0 04             	shl    $0x4,%eax
   1e440:	01 c8                	add    %ecx,%eax
   1e442:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
   1e448:	e9 73 14 00 00       	jmp    1f8c0 <.L127>
				// 如果c是换行符LF(10),或垂直制表符VT(11),或换页符FF(12),则光标移动到下1行.
				else if (c == 10 || c == 11 || c == 12)
   1e44d:	80 7c 24 07 0a       	cmpb   $0xa,0x7(%esp)
   1e452:	74 0e                	je     1e462 <.L133+0x1e5>
   1e454:	80 7c 24 07 0b       	cmpb   $0xb,0x7(%esp)
   1e459:	74 07                	je     1e462 <.L133+0x1e5>
   1e45b:	80 7c 24 07 0c       	cmpb   $0xc,0x7(%esp)
   1e460:	75 14                	jne    1e476 <.L133+0x1f9>
					lf(currcons);
   1e462:	83 ec 0c             	sub    $0xc,%esp
   1e465:	ff 74 24 14          	pushl  0x14(%esp)
   1e469:	e8 8f e9 ff ff       	call   1cdfd <lf>
   1e46e:	83 c4 10             	add    $0x10,%esp
   1e471:	e9 c8 02 00 00       	jmp    1e73e <.L133+0x4c1>
				// 如果c是回车符CR(13),则将光标移动到头列(0列)
				else if (c == 13)									// CR - 回车
   1e476:	80 7c 24 07 0d       	cmpb   $0xd,0x7(%esp)
   1e47b:	75 14                	jne    1e491 <.L133+0x214>
					cr(currcons);
   1e47d:	83 ec 0c             	sub    $0xc,%esp
   1e480:	ff 74 24 14          	pushl  0x14(%esp)
   1e484:	e8 13 eb ff ff       	call   1cf9c <cr>
   1e489:	83 c4 10             	add    $0x10,%esp
   1e48c:	e9 2f 14 00 00       	jmp    1f8c0 <.L127>
				// 如果c是DEL(127),则将光标左边字符擦除(用空格字符替代),并将光标移到被擦除位置.
				else if (c == ERASE_CHAR(tty))
   1e491:	0f be 54 24 07       	movsbl 0x7(%esp),%edx
   1e496:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e49a:	0f b6 40 13          	movzbl 0x13(%eax),%eax
   1e49e:	0f b6 c0             	movzbl %al,%eax
   1e4a1:	39 c2                	cmp    %eax,%edx
   1e4a3:	75 14                	jne    1e4b9 <.L133+0x23c>
					del(currcons);
   1e4a5:	83 ec 0c             	sub    $0xc,%esp
   1e4a8:	ff 74 24 14          	pushl  0x14(%esp)
   1e4ac:	e8 70 eb ff ff       	call   1d021 <del>
   1e4b1:	83 c4 10             	add    $0x10,%esp
   1e4b4:	e9 07 14 00 00       	jmp    1f8c0 <.L127>
				// 如果c是BS(backspace,8),则将光标左移1格,并相应调整光标对应内存位置指针pos.
				else if (c == 8) {									// BS - 后退.
   1e4b9:	80 7c 24 07 08       	cmpb   $0x8,0x7(%esp)
   1e4be:	0f 85 9a 00 00 00    	jne    1e55e <.L133+0x2e1>
					if (x) {
   1e4c4:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e4c8:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e4ce:	89 d0                	mov    %edx,%eax
   1e4d0:	c1 e0 03             	shl    $0x3,%eax
   1e4d3:	01 d0                	add    %edx,%eax
   1e4d5:	c1 e0 04             	shl    $0x4,%eax
   1e4d8:	01 c8                	add    %ecx,%eax
   1e4da:	83 c0 20             	add    $0x20,%eax
   1e4dd:	8b 00                	mov    (%eax),%eax
   1e4df:	85 c0                	test   %eax,%eax
   1e4e1:	0f 84 d9 13 00 00    	je     1f8c0 <.L127>
						x--;
   1e4e7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e4eb:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e4f1:	89 d0                	mov    %edx,%eax
   1e4f3:	c1 e0 03             	shl    $0x3,%eax
   1e4f6:	01 d0                	add    %edx,%eax
   1e4f8:	c1 e0 04             	shl    $0x4,%eax
   1e4fb:	01 c8                	add    %ecx,%eax
   1e4fd:	83 c0 20             	add    $0x20,%eax
   1e500:	8b 00                	mov    (%eax),%eax
   1e502:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1e505:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e509:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1e50f:	89 d0                	mov    %edx,%eax
   1e511:	c1 e0 03             	shl    $0x3,%eax
   1e514:	01 d0                	add    %edx,%eax
   1e516:	c1 e0 04             	shl    $0x4,%eax
   1e519:	01 f0                	add    %esi,%eax
   1e51b:	83 c0 20             	add    $0x20,%eax
   1e51e:	89 08                	mov    %ecx,(%eax)
						pos -= 2;
   1e520:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e524:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1e52a:	89 d0                	mov    %edx,%eax
   1e52c:	c1 e0 03             	shl    $0x3,%eax
   1e52f:	01 d0                	add    %edx,%eax
   1e531:	c1 e0 04             	shl    $0x4,%eax
   1e534:	01 c8                	add    %ecx,%eax
   1e536:	83 c0 20             	add    $0x20,%eax
   1e539:	8b 00                	mov    (%eax),%eax
   1e53b:	8d 48 fe             	lea    -0x2(%eax),%ecx
   1e53e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e542:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1e548:	89 d0                	mov    %edx,%eax
   1e54a:	c1 e0 03             	shl    $0x3,%eax
   1e54d:	01 d0                	add    %edx,%eax
   1e54f:	c1 e0 04             	shl    $0x4,%eax
   1e552:	01 f0                	add    %esi,%eax
   1e554:	83 c0 20             	add    $0x20,%eax
   1e557:	89 08                	mov    %ecx,(%eax)
   1e559:	e9 62 13 00 00       	jmp    1f8c0 <.L127>
					}
				// 如果字符c是水平制表符HT(9),则将光标移到8的位数列上.若此时光标列数超出屏幕最大列数,则将光标移到下一行上.
				} else if (c == 9) {								// HT - 水平制表
   1e55e:	80 7c 24 07 09       	cmpb   $0x9,0x7(%esp)
   1e563:	0f 85 6b 01 00 00    	jne    1e6d4 <.L133+0x457>
					c = 8 - (x & 7);
   1e569:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e56d:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e573:	89 d0                	mov    %edx,%eax
   1e575:	c1 e0 03             	shl    $0x3,%eax
   1e578:	01 d0                	add    %edx,%eax
   1e57a:	c1 e0 04             	shl    $0x4,%eax
   1e57d:	01 c8                	add    %ecx,%eax
   1e57f:	83 c0 20             	add    $0x20,%eax
   1e582:	8b 00                	mov    (%eax),%eax
   1e584:	83 e0 07             	and    $0x7,%eax
   1e587:	ba 08 00 00 00       	mov    $0x8,%edx
   1e58c:	29 c2                	sub    %eax,%edx
   1e58e:	89 d0                	mov    %edx,%eax
   1e590:	88 44 24 07          	mov    %al,0x7(%esp)
					x += c;
   1e594:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e598:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e59e:	89 d0                	mov    %edx,%eax
   1e5a0:	c1 e0 03             	shl    $0x3,%eax
   1e5a3:	01 d0                	add    %edx,%eax
   1e5a5:	c1 e0 04             	shl    $0x4,%eax
   1e5a8:	01 c8                	add    %ecx,%eax
   1e5aa:	83 c0 20             	add    $0x20,%eax
   1e5ad:	8b 10                	mov    (%eax),%edx
   1e5af:	0f be 44 24 07       	movsbl 0x7(%esp),%eax
   1e5b4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1e5b7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e5bb:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1e5c1:	89 d0                	mov    %edx,%eax
   1e5c3:	c1 e0 03             	shl    $0x3,%eax
   1e5c6:	01 d0                	add    %edx,%eax
   1e5c8:	c1 e0 04             	shl    $0x4,%eax
   1e5cb:	01 f0                	add    %esi,%eax
   1e5cd:	83 c0 20             	add    $0x20,%eax
   1e5d0:	89 08                	mov    %ecx,(%eax)
					pos += c << 1;
   1e5d2:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e5d6:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1e5dc:	89 d0                	mov    %edx,%eax
   1e5de:	c1 e0 03             	shl    $0x3,%eax
   1e5e1:	01 d0                	add    %edx,%eax
   1e5e3:	c1 e0 04             	shl    $0x4,%eax
   1e5e6:	01 c8                	add    %ecx,%eax
   1e5e8:	83 c0 20             	add    $0x20,%eax
   1e5eb:	8b 00                	mov    (%eax),%eax
   1e5ed:	0f be 54 24 07       	movsbl 0x7(%esp),%edx
   1e5f2:	01 d2                	add    %edx,%edx
   1e5f4:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1e5f7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e5fb:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1e601:	89 d0                	mov    %edx,%eax
   1e603:	c1 e0 03             	shl    $0x3,%eax
   1e606:	01 d0                	add    %edx,%eax
   1e608:	c1 e0 04             	shl    $0x4,%eax
   1e60b:	01 f0                	add    %esi,%eax
   1e60d:	83 c0 20             	add    $0x20,%eax
   1e610:	89 08                	mov    %ecx,(%eax)
					if (x > video_num_columns) {
   1e612:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e616:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e61c:	89 d0                	mov    %edx,%eax
   1e61e:	c1 e0 03             	shl    $0x3,%eax
   1e621:	01 d0                	add    %edx,%eax
   1e623:	c1 e0 04             	shl    $0x4,%eax
   1e626:	01 c8                	add    %ecx,%eax
   1e628:	83 c0 20             	add    $0x20,%eax
   1e62b:	8b 10                	mov    (%eax),%edx
   1e62d:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   1e633:	39 c2                	cmp    %eax,%edx
   1e635:	0f 86 8f 00 00 00    	jbe    1e6ca <.L133+0x44d>
						x -= video_num_columns;
   1e63b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e63f:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e645:	89 d0                	mov    %edx,%eax
   1e647:	c1 e0 03             	shl    $0x3,%eax
   1e64a:	01 d0                	add    %edx,%eax
   1e64c:	c1 e0 04             	shl    $0x4,%eax
   1e64f:	01 c8                	add    %ecx,%eax
   1e651:	83 c0 20             	add    $0x20,%eax
   1e654:	8b 10                	mov    (%eax),%edx
   1e656:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   1e65c:	89 d1                	mov    %edx,%ecx
   1e65e:	29 c1                	sub    %eax,%ecx
   1e660:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e664:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1e66a:	89 d0                	mov    %edx,%eax
   1e66c:	c1 e0 03             	shl    $0x3,%eax
   1e66f:	01 d0                	add    %edx,%eax
   1e671:	c1 e0 04             	shl    $0x4,%eax
   1e674:	01 f0                	add    %esi,%eax
   1e676:	83 c0 20             	add    $0x20,%eax
   1e679:	89 08                	mov    %ecx,(%eax)
						pos -= video_size_row;
   1e67b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e67f:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1e685:	89 d0                	mov    %edx,%eax
   1e687:	c1 e0 03             	shl    $0x3,%eax
   1e68a:	01 d0                	add    %edx,%eax
   1e68c:	c1 e0 04             	shl    $0x4,%eax
   1e68f:	01 c8                	add    %ecx,%eax
   1e691:	83 c0 20             	add    $0x20,%eax
   1e694:	8b 10                	mov    (%eax),%edx
   1e696:	8b 83 c0 1e 01 00    	mov    0x11ec0(%ebx),%eax
   1e69c:	89 d1                	mov    %edx,%ecx
   1e69e:	29 c1                	sub    %eax,%ecx
   1e6a0:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e6a4:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1e6aa:	89 d0                	mov    %edx,%eax
   1e6ac:	c1 e0 03             	shl    $0x3,%eax
   1e6af:	01 d0                	add    %edx,%eax
   1e6b1:	c1 e0 04             	shl    $0x4,%eax
   1e6b4:	01 f0                	add    %esi,%eax
   1e6b6:	83 c0 20             	add    $0x20,%eax
   1e6b9:	89 08                	mov    %ecx,(%eax)
						lf(currcons);
   1e6bb:	83 ec 0c             	sub    $0xc,%esp
   1e6be:	ff 74 24 14          	pushl  0x14(%esp)
   1e6c2:	e8 36 e7 ff ff       	call   1cdfd <lf>
   1e6c7:	83 c4 10             	add    $0x10,%esp
					}
					c = 9;
   1e6ca:	c6 44 24 07 09       	movb   $0x9,0x7(%esp)
   1e6cf:	e9 ec 11 00 00       	jmp    1f8c0 <.L127>
				// 如果字符c是响铃符BEL(7),则调用蜂鸣函数,使扬声器发声.
				} else if (c == 7)									// BEL - 响铃
   1e6d4:	80 7c 24 07 07       	cmpb   $0x7,0x7(%esp)
   1e6d9:	75 0a                	jne    1e6e5 <.L133+0x468>
					sysbeep();
   1e6db:	e8 d2 18 00 00       	call   1ffb2 <sysbeep>
   1e6e0:	e9 db 11 00 00       	jmp    1f8c0 <.L127>
				// 如果c是控制字符SO(14)或SI(15),则相应选择字符集G1或G0作为显示字符集.
			  	else if (c == 14)									// SO - 换出,使用G1.
   1e6e5:	80 7c 24 07 0e       	cmpb   $0xe,0x7(%esp)
   1e6ea:	75 26                	jne    1e712 <.L133+0x495>
			  		translate = GRAF_TRANS;
   1e6ec:	8b 8b c4 15 00 00    	mov    0x15c4(%ebx),%ecx
   1e6f2:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e6f6:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1e6fc:	89 d0                	mov    %edx,%eax
   1e6fe:	c1 e0 03             	shl    $0x3,%eax
   1e701:	01 d0                	add    %edx,%eax
   1e703:	c1 e0 04             	shl    $0x4,%eax
   1e706:	01 f0                	add    %esi,%eax
   1e708:	83 e8 80             	sub    $0xffffff80,%eax
   1e70b:	89 08                	mov    %ecx,(%eax)
   1e70d:	e9 ae 11 00 00       	jmp    1f8c0 <.L127>
			  	else if (c == 15)									// SI - 换进,使用G0.
   1e712:	80 7c 24 07 0f       	cmpb   $0xf,0x7(%esp)
   1e717:	0f 85 a3 11 00 00    	jne    1f8c0 <.L127>
					translate = NORM_TRANS;
   1e71d:	8b 8b c0 15 00 00    	mov    0x15c0(%ebx),%ecx
   1e723:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e727:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1e72d:	89 d0                	mov    %edx,%eax
   1e72f:	c1 e0 03             	shl    $0x3,%eax
   1e732:	01 d0                	add    %edx,%eax
   1e734:	c1 e0 04             	shl    $0x4,%eax
   1e737:	01 f0                	add    %esi,%eax
   1e739:	83 e8 80             	sub    $0xffffff80,%eax
   1e73c:	89 08                	mov    %ecx,(%eax)
				break;
   1e73e:	e9 7d 11 00 00       	jmp    1f8c0 <.L127>

0001e743 <.L135>:
			//       ESsquare去处理.否则就把接收到的字符作为转义序列来处理.对于选择字符集转义序列'ESC ('和'ESC )',使用单独的状态ESsetgraph
			//       来处理;对于设备控制字符串序列'ESC P',使用单独的状态ESsetterm来处理
			// 如果在ESnormal状态收到转义字符ESC(0x1b = 033 = 27),则转到本状态处理.该状态对C1中控制字符或转义字符进行处理.处理完后默认的
			// 状态将是ESnormal.
			case ESesc:
				state = ESnormal;
   1e743:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e747:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e74d:	89 d0                	mov    %edx,%eax
   1e74f:	c1 e0 03             	shl    $0x3,%eax
   1e752:	01 d0                	add    %edx,%eax
   1e754:	c1 e0 04             	shl    $0x4,%eax
   1e757:	01 c8                	add    %ecx,%eax
   1e759:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				switch (c)
   1e75f:	0f be 44 24 07       	movsbl 0x7(%esp),%eax
   1e764:	83 e8 23             	sub    $0x23,%eax
   1e767:	83 f8 40             	cmp    $0x40,%eax
   1e76a:	0f 87 50 11 00 00    	ja     1f8c0 <.L127>
   1e770:	c1 e0 02             	shl    $0x2,%eax
   1e773:	8b 84 18 08 65 ff ff 	mov    -0x9af8(%eax,%ebx,1),%eax
   1e77a:	01 d8                	add    %ebx,%eax
   1e77c:	ff e0                	jmp    *%eax

0001e77e <.L167>:
				{
				  case '[':											// ESC [ - 是CSI序列.
					state = ESsquare;
   1e77e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e782:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e788:	89 d0                	mov    %edx,%eax
   1e78a:	c1 e0 03             	shl    $0x3,%eax
   1e78d:	01 d0                	add    %edx,%eax
   1e78f:	c1 e0 04             	shl    $0x4,%eax
   1e792:	01 c8                	add    %ecx,%eax
   1e794:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
					break;
   1e79a:	e9 17 02 00 00       	jmp    1e9b6 <.L168+0x117>

0001e79f <.L163>:
				  case 'E':											// ESC E - 光标下移1行回0列.
					gotoxy(currcons, 0, y + 1);
   1e79f:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e7a3:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1e7a9:	89 d0                	mov    %edx,%eax
   1e7ab:	c1 e0 03             	shl    $0x3,%eax
   1e7ae:	01 d0                	add    %edx,%eax
   1e7b0:	c1 e0 04             	shl    $0x4,%eax
   1e7b3:	01 c8                	add    %ecx,%eax
   1e7b5:	83 c0 20             	add    $0x20,%eax
   1e7b8:	8b 00                	mov    (%eax),%eax
   1e7ba:	83 c0 01             	add    $0x1,%eax
   1e7bd:	83 ec 04             	sub    $0x4,%esp
   1e7c0:	50                   	push   %eax
   1e7c1:	6a 00                	push   $0x0
   1e7c3:	ff 74 24 14          	pushl  0x14(%esp)
   1e7c7:	e8 40 dc ff ff       	call   1c40c <gotoxy>
   1e7cc:	83 c4 10             	add    $0x10,%esp
					break;
   1e7cf:	e9 e2 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e7d4 <.L164>:
				  case 'M':											// ESC M - 光标上移一行.
					ri(currcons);
   1e7d4:	83 ec 0c             	sub    $0xc,%esp
   1e7d7:	ff 74 24 14          	pushl  0x14(%esp)
   1e7db:	e8 ee e6 ff ff       	call   1cece <ri>
   1e7e0:	83 c4 10             	add    $0x10,%esp
					break;
   1e7e3:	e9 ce 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e7e8 <.L162>:
				  case 'D':											// ESC D - 光标下移一行
					lf(currcons);
   1e7e8:	83 ec 0c             	sub    $0xc,%esp
   1e7eb:	ff 74 24 14          	pushl  0x14(%esp)
   1e7ef:	e8 09 e6 ff ff       	call   1cdfd <lf>
   1e7f4:	83 c4 10             	add    $0x10,%esp
					break;
   1e7f7:	e9 ba 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e7fc <.L166>:
				  case 'Z':											// ESC Z - 设备属性查询
					respond(currcons, tty);
   1e7fc:	83 ec 08             	sub    $0x8,%esp
   1e7ff:	ff 74 24 28          	pushl  0x28(%esp)
   1e803:	ff 74 24 14          	pushl  0x14(%esp)
   1e807:	e8 7d f3 ff ff       	call   1db89 <respond>
   1e80c:	83 c4 10             	add    $0x10,%esp
					break;
   1e80f:	e9 a2 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e814 <.L160>:
				  case '7':											// ESC 7 - 保存光标位置
					save_cur(currcons);
   1e814:	83 ec 0c             	sub    $0xc,%esp
   1e817:	ff 74 24 14          	pushl  0x14(%esp)
   1e81b:	e8 84 f8 ff ff       	call   1e0a4 <save_cur>
   1e820:	83 c4 10             	add    $0x10,%esp
					break;
   1e823:	e9 8e 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e828 <.L161>:
				  case '8':											// ESC 8 - 恢复光标位置
					restore_cur(currcons);
   1e828:	83 ec 0c             	sub    $0xc,%esp
   1e82b:	ff 74 24 14          	pushl  0x14(%esp)
   1e82f:	e8 ed f8 ff ff       	call   1e121 <restore_cur>
   1e834:	83 c4 10             	add    $0x10,%esp
					break;
   1e837:	e9 7a 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e83c <.L159>:
				  case '(':  case ')':								// ESC(,ESC) - 选择字符集
				    	state = ESsetgraph;
   1e83c:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e840:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e846:	89 d0                	mov    %edx,%eax
   1e848:	c1 e0 03             	shl    $0x3,%eax
   1e84b:	01 d0                	add    %edx,%eax
   1e84d:	c1 e0 04             	shl    $0x4,%eax
   1e850:	01 c8                	add    %ecx,%eax
   1e852:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
					break;
   1e858:	e9 59 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e85d <.L165>:
				  case 'P':											// ESC P - 设置终端参数
				    	state = ESsetterm;
   1e85d:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e861:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e867:	89 d0                	mov    %edx,%eax
   1e869:	c1 e0 03             	shl    $0x3,%eax
   1e86c:	01 d0                	add    %edx,%eax
   1e86e:	c1 e0 04             	shl    $0x4,%eax
   1e871:	01 c8                	add    %ecx,%eax
   1e873:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
				    	break;
   1e879:	e9 38 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e87e <.L157>:
				  case '#':											// ESC # - 修改整行属性
				  	state = -1;
   1e87e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e882:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e888:	89 d0                	mov    %edx,%eax
   1e88a:	c1 e0 03             	shl    $0x3,%eax
   1e88d:	01 d0                	add    %edx,%eax
   1e88f:	c1 e0 04             	shl    $0x4,%eax
   1e892:	01 c8                	add    %ecx,%eax
   1e894:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
				  	break;
   1e89a:	e9 17 01 00 00       	jmp    1e9b6 <.L168+0x117>

0001e89f <.L168>:
				  case 'c':											// ESC c - 复位到终端初始设置
					tty->termios = DEF_TERMIOS;
   1e89f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e8a3:	c7 00 00 01 00 00    	movl   $0x100,(%eax)
   1e8a9:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e8ad:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%eax)
   1e8b4:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e8b8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   1e8bf:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e8c3:	c7 40 0c 0b 0e 00 00 	movl   $0xe0b,0xc(%eax)
   1e8ca:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e8ce:	c6 40 10 00          	movb   $0x0,0x10(%eax)
   1e8d2:	8b 44 24 20          	mov    0x20(%esp),%eax
   1e8d6:	8b 93 d3 64 ff ff    	mov    -0x9b2d(%ebx),%edx
   1e8dc:	89 50 11             	mov    %edx,0x11(%eax)
   1e8df:	8b 93 d7 64 ff ff    	mov    -0x9b29(%ebx),%edx
   1e8e5:	89 50 15             	mov    %edx,0x15(%eax)
   1e8e8:	8b 93 db 64 ff ff    	mov    -0x9b25(%ebx),%edx
   1e8ee:	89 50 19             	mov    %edx,0x19(%eax)
   1e8f1:	8b 93 df 64 ff ff    	mov    -0x9b21(%ebx),%edx
   1e8f7:	89 50 1d             	mov    %edx,0x1d(%eax)
   1e8fa:	0f b6 93 e3 64 ff ff 	movzbl -0x9b1d(%ebx),%edx
   1e901:	88 50 21             	mov    %dl,0x21(%eax)
				  	state = restate = ESnormal;
   1e904:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e908:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1e90e:	89 d0                	mov    %edx,%eax
   1e910:	c1 e0 03             	shl    $0x3,%eax
   1e913:	01 d0                	add    %edx,%eax
   1e915:	c1 e0 04             	shl    $0x4,%eax
   1e918:	01 c8                	add    %ecx,%eax
   1e91a:	83 c0 10             	add    $0x10,%eax
   1e91d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1e923:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e927:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1e92d:	89 d0                	mov    %edx,%eax
   1e92f:	c1 e0 03             	shl    $0x3,%eax
   1e932:	01 d0                	add    %edx,%eax
   1e934:	c1 e0 04             	shl    $0x4,%eax
   1e937:	01 c8                	add    %ecx,%eax
   1e939:	83 c0 10             	add    $0x10,%eax
   1e93c:	8b 08                	mov    (%eax),%ecx
   1e93e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e942:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1e948:	89 d0                	mov    %edx,%eax
   1e94a:	c1 e0 03             	shl    $0x3,%eax
   1e94d:	01 d0                	add    %edx,%eax
   1e94f:	c1 e0 04             	shl    $0x4,%eax
   1e952:	01 f0                	add    %esi,%eax
   1e954:	89 08                	mov    %ecx,(%eax)
					checkin = 0;
   1e956:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e95a:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e960:	89 d0                	mov    %edx,%eax
   1e962:	c1 e0 03             	shl    $0x3,%eax
   1e965:	01 d0                	add    %edx,%eax
   1e967:	c1 e0 04             	shl    $0x4,%eax
   1e96a:	01 c8                	add    %ecx,%eax
   1e96c:	83 c0 10             	add    $0x10,%eax
   1e96f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
					top = 0;
   1e975:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e979:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1e97f:	89 d0                	mov    %edx,%eax
   1e981:	c1 e0 03             	shl    $0x3,%eax
   1e984:	01 d0                	add    %edx,%eax
   1e986:	c1 e0 04             	shl    $0x4,%eax
   1e989:	01 c8                	add    %ecx,%eax
   1e98b:	83 c0 20             	add    $0x20,%eax
   1e98e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
					bottom = video_num_lines;
   1e994:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1e99a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e99e:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1e9a4:	89 d0                	mov    %edx,%eax
   1e9a6:	c1 e0 03             	shl    $0x3,%eax
   1e9a9:	01 d0                	add    %edx,%eax
   1e9ab:	c1 e0 04             	shl    $0x4,%eax
   1e9ae:	01 f0                	add    %esi,%eax
   1e9b0:	83 c0 30             	add    $0x30,%eax
   1e9b3:	89 08                	mov    %ecx,(%eax)
					break;
   1e9b5:	90                   	nop
				 /* case '>':   Numeric keypad */
				 /* case '=':   Appl. keypad */
				}
				break;
   1e9b6:	e9 05 0f 00 00       	jmp    1f8c0 <.L127>

0001e9bb <.L136>:
			// 如果在状态ESesc(是转义字符ESC)时收到的字符'[',则表明是CSI控制序列,于是转到状态Essequare来处理.首先对ESC转义序列保存参数数组par[]清零,
			// 索引变量npar指向首项,并且设置开始处于参数状态ESgetpars.如果接收到的字符不是'?',则直接转到状态ESgetpars去处理,若接收到的字符是'?',说明这
			// 个序列是终端设备私有序列,后面会有一个功能字符.于是去读下一字符,再到状态ESgetpars去处理代码处.如果此时接收到字符还是'[',那么表明收到了键盘功能
			// 键发出的序列,于是设置下一状态为ESfunckey.否则直接进入ESgetpars状态继续处理.
			case ESsquare:
				for(npar = 0; npar < NPAR; npar++)					// 初始化参数数组.
   1e9bb:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e9bf:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e9c5:	89 d0                	mov    %edx,%eax
   1e9c7:	c1 e0 03             	shl    $0x3,%eax
   1e9ca:	01 d0                	add    %edx,%eax
   1e9cc:	c1 e0 04             	shl    $0x4,%eax
   1e9cf:	01 c8                	add    %ecx,%eax
   1e9d1:	83 c0 30             	add    $0x30,%eax
   1e9d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1e9da:	eb 72                	jmp    1ea4e <.L136+0x93>
					par[npar] = 0;
   1e9dc:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e9e0:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1e9e6:	89 d0                	mov    %edx,%eax
   1e9e8:	c1 e0 03             	shl    $0x3,%eax
   1e9eb:	01 d0                	add    %edx,%eax
   1e9ed:	c1 e0 04             	shl    $0x4,%eax
   1e9f0:	01 c8                	add    %ecx,%eax
   1e9f2:	83 c0 30             	add    $0x30,%eax
   1e9f5:	8b 08                	mov    (%eax),%ecx
   1e9f7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1e9fb:	89 d0                	mov    %edx,%eax
   1e9fd:	c1 e0 03             	shl    $0x3,%eax
   1ea00:	01 d0                	add    %edx,%eax
   1ea02:	c1 e0 02             	shl    $0x2,%eax
   1ea05:	01 c8                	add    %ecx,%eax
   1ea07:	83 c0 0c             	add    $0xc,%eax
   1ea0a:	c7 84 83 e8 1e 01 00 	movl   $0x0,0x11ee8(%ebx,%eax,4)
   1ea11:	00 00 00 00 
				for(npar = 0; npar < NPAR; npar++)					// 初始化参数数组.
   1ea15:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ea19:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1ea1f:	89 d0                	mov    %edx,%eax
   1ea21:	c1 e0 03             	shl    $0x3,%eax
   1ea24:	01 d0                	add    %edx,%eax
   1ea26:	c1 e0 04             	shl    $0x4,%eax
   1ea29:	01 c8                	add    %ecx,%eax
   1ea2b:	83 c0 30             	add    $0x30,%eax
   1ea2e:	8b 00                	mov    (%eax),%eax
   1ea30:	8d 48 01             	lea    0x1(%eax),%ecx
   1ea33:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ea37:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1ea3d:	89 d0                	mov    %edx,%eax
   1ea3f:	c1 e0 03             	shl    $0x3,%eax
   1ea42:	01 d0                	add    %edx,%eax
   1ea44:	c1 e0 04             	shl    $0x4,%eax
   1ea47:	01 f0                	add    %esi,%eax
   1ea49:	83 c0 30             	add    $0x30,%eax
   1ea4c:	89 08                	mov    %ecx,(%eax)
   1ea4e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ea52:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1ea58:	89 d0                	mov    %edx,%eax
   1ea5a:	c1 e0 03             	shl    $0x3,%eax
   1ea5d:	01 d0                	add    %edx,%eax
   1ea5f:	c1 e0 04             	shl    $0x4,%eax
   1ea62:	01 c8                	add    %ecx,%eax
   1ea64:	83 c0 30             	add    $0x30,%eax
   1ea67:	8b 00                	mov    (%eax),%eax
   1ea69:	83 f8 0f             	cmp    $0xf,%eax
   1ea6c:	0f 86 6a ff ff ff    	jbe    1e9dc <.L136+0x21>
				npar = 0;
   1ea72:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ea76:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1ea7c:	89 d0                	mov    %edx,%eax
   1ea7e:	c1 e0 03             	shl    $0x3,%eax
   1ea81:	01 d0                	add    %edx,%eax
   1ea83:	c1 e0 04             	shl    $0x4,%eax
   1ea86:	01 c8                	add    %ecx,%eax
   1ea88:	83 c0 30             	add    $0x30,%eax
   1ea8b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				state = ESgetpars;
   1ea91:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ea95:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1ea9b:	89 d0                	mov    %edx,%eax
   1ea9d:	c1 e0 03             	shl    $0x3,%eax
   1eaa0:	01 d0                	add    %edx,%eax
   1eaa2:	c1 e0 04             	shl    $0x4,%eax
   1eaa5:	01 c8                	add    %ecx,%eax
   1eaa7:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
				if (c == '[')  										/* Function key */	// 'ESC [['是功能键.
   1eaad:	80 7c 24 07 5b       	cmpb   $0x5b,0x7(%esp)
   1eab2:	75 21                	jne    1ead5 <.L136+0x11a>
				{
					state = ESfunckey;
   1eab4:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eab8:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1eabe:	89 d0                	mov    %edx,%eax
   1eac0:	c1 e0 03             	shl    $0x3,%eax
   1eac3:	01 d0                	add    %edx,%eax
   1eac5:	c1 e0 04             	shl    $0x4,%eax
   1eac8:	01 c8                	add    %ecx,%eax
   1eaca:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
					break;
   1ead0:	e9 eb 0d 00 00       	jmp    1f8c0 <.L127>
				}
				if (ques = (c == '?'))
   1ead5:	80 7c 24 07 3f       	cmpb   $0x3f,0x7(%esp)
   1eada:	0f 94 c0             	sete   %al
   1eadd:	0f b6 c8             	movzbl %al,%ecx
   1eae0:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eae4:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1eaea:	89 d0                	mov    %edx,%eax
   1eaec:	c1 e0 03             	shl    $0x3,%eax
   1eaef:	01 d0                	add    %edx,%eax
   1eaf1:	c1 e0 04             	shl    $0x4,%eax
   1eaf4:	01 f0                	add    %esi,%eax
   1eaf6:	89 08                	mov    %ecx,(%eax)
   1eaf8:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eafc:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1eb02:	89 d0                	mov    %edx,%eax
   1eb04:	c1 e0 03             	shl    $0x3,%eax
   1eb07:	01 d0                	add    %edx,%eax
   1eb09:	c1 e0 04             	shl    $0x4,%eax
   1eb0c:	01 c8                	add    %ecx,%eax
   1eb0e:	8b 00                	mov    (%eax),%eax
   1eb10:	85 c0                	test   %eax,%eax
   1eb12:	74 05                	je     1eb19 <.L137>
					break;
   1eb14:	e9 a7 0d 00 00       	jmp    1f8c0 <.L127>

0001eb19 <.L137>:
			//            则还是维持在本状态,并把接收到的参数值保存在数据par[]下一项中.若不是数字字符或分号,说明已取得所有参数,那么就转移到状态
			//            ESgotparts去处理.
			// 该状态表示此时要接收控制序列的参数值.参数用十进制数表示,把接收到的数字字符转换成数值并保存到par[]数组中.如果收到一个分号';',则还是维持在本状态,并
			// 把接收到的参数值保存在数据par[]下一项中.若不是数字字符或分号,说明已取得所有参数,那么就转移到状态ESgotpars去处理.
			case ESgetpars:
				if (c == ';' && npar < NPAR - 1) {
   1eb19:	80 7c 24 07 3b       	cmpb   $0x3b,0x7(%esp)
   1eb1e:	75 5e                	jne    1eb7e <.L137+0x65>
   1eb20:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eb24:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1eb2a:	89 d0                	mov    %edx,%eax
   1eb2c:	c1 e0 03             	shl    $0x3,%eax
   1eb2f:	01 d0                	add    %edx,%eax
   1eb31:	c1 e0 04             	shl    $0x4,%eax
   1eb34:	01 c8                	add    %ecx,%eax
   1eb36:	83 c0 30             	add    $0x30,%eax
   1eb39:	8b 00                	mov    (%eax),%eax
   1eb3b:	83 f8 0e             	cmp    $0xe,%eax
   1eb3e:	77 3e                	ja     1eb7e <.L137+0x65>
					npar++;
   1eb40:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eb44:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1eb4a:	89 d0                	mov    %edx,%eax
   1eb4c:	c1 e0 03             	shl    $0x3,%eax
   1eb4f:	01 d0                	add    %edx,%eax
   1eb51:	c1 e0 04             	shl    $0x4,%eax
   1eb54:	01 c8                	add    %ecx,%eax
   1eb56:	83 c0 30             	add    $0x30,%eax
   1eb59:	8b 00                	mov    (%eax),%eax
   1eb5b:	8d 48 01             	lea    0x1(%eax),%ecx
   1eb5e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eb62:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1eb68:	89 d0                	mov    %edx,%eax
   1eb6a:	c1 e0 03             	shl    $0x3,%eax
   1eb6d:	01 d0                	add    %edx,%eax
   1eb6f:	c1 e0 04             	shl    $0x4,%eax
   1eb72:	01 f0                	add    %esi,%eax
   1eb74:	83 c0 30             	add    $0x30,%eax
   1eb77:	89 08                	mov    %ecx,(%eax)
					break;
   1eb79:	e9 42 0d 00 00       	jmp    1f8c0 <.L127>
				} else if (c >= '0' && c <= '9') {
   1eb7e:	80 7c 24 07 2f       	cmpb   $0x2f,0x7(%esp)
   1eb83:	0f 8e 90 00 00 00    	jle    1ec19 <.L137+0x100>
   1eb89:	80 7c 24 07 39       	cmpb   $0x39,0x7(%esp)
   1eb8e:	0f 8f 85 00 00 00    	jg     1ec19 <.L137+0x100>
					par[npar] = 10 * par[npar] + c - '0';
   1eb94:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eb98:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1eb9e:	89 d0                	mov    %edx,%eax
   1eba0:	c1 e0 03             	shl    $0x3,%eax
   1eba3:	01 d0                	add    %edx,%eax
   1eba5:	c1 e0 04             	shl    $0x4,%eax
   1eba8:	01 c8                	add    %ecx,%eax
   1ebaa:	83 c0 30             	add    $0x30,%eax
   1ebad:	8b 08                	mov    (%eax),%ecx
   1ebaf:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ebb3:	89 d0                	mov    %edx,%eax
   1ebb5:	c1 e0 03             	shl    $0x3,%eax
   1ebb8:	01 d0                	add    %edx,%eax
   1ebba:	c1 e0 02             	shl    $0x2,%eax
   1ebbd:	01 c8                	add    %ecx,%eax
   1ebbf:	83 c0 0c             	add    $0xc,%eax
   1ebc2:	8b 94 83 e8 1e 01 00 	mov    0x11ee8(%ebx,%eax,4),%edx
   1ebc9:	89 d0                	mov    %edx,%eax
   1ebcb:	c1 e0 02             	shl    $0x2,%eax
   1ebce:	01 d0                	add    %edx,%eax
   1ebd0:	01 c0                	add    %eax,%eax
   1ebd2:	89 c2                	mov    %eax,%edx
   1ebd4:	0f be 44 24 07       	movsbl 0x7(%esp),%eax
   1ebd9:	8d 3c 02             	lea    (%edx,%eax,1),%edi
   1ebdc:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ebe0:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1ebe6:	89 d0                	mov    %edx,%eax
   1ebe8:	c1 e0 03             	shl    $0x3,%eax
   1ebeb:	01 d0                	add    %edx,%eax
   1ebed:	c1 e0 04             	shl    $0x4,%eax
   1ebf0:	01 c8                	add    %ecx,%eax
   1ebf2:	83 c0 30             	add    $0x30,%eax
   1ebf5:	8b 30                	mov    (%eax),%esi
   1ebf7:	8d 4f d0             	lea    -0x30(%edi),%ecx
   1ebfa:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ebfe:	89 d0                	mov    %edx,%eax
   1ec00:	c1 e0 03             	shl    $0x3,%eax
   1ec03:	01 d0                	add    %edx,%eax
   1ec05:	c1 e0 02             	shl    $0x2,%eax
   1ec08:	01 f0                	add    %esi,%eax
   1ec0a:	83 c0 0c             	add    $0xc,%eax
   1ec0d:	89 8c 83 e8 1e 01 00 	mov    %ecx,0x11ee8(%ebx,%eax,4)
					break;
   1ec14:	e9 a7 0c 00 00       	jmp    1f8c0 <.L127>
				} else state = ESgotpars;
   1ec19:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ec1d:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1ec23:	89 d0                	mov    %edx,%eax
   1ec25:	c1 e0 03             	shl    $0x3,%eax
   1ec28:	01 d0                	add    %edx,%eax
   1ec2a:	c1 e0 04             	shl    $0x4,%eax
   1ec2d:	01 c8                	add    %ecx,%eax
   1ec2f:	c7 00 04 00 00 00    	movl   $0x4,(%eax)

0001ec35 <.L138>:
			//           收到过'?',说明这个序列是终端设备私有序列.本内核不对支持对这种序列的处理,于是直接恢复到ESnormal状态.否则就去执行相应控制序列.
			//           待序列处理完后就把状态恢复到ESnormal.
			// ESgotpars状态表示我们已经接收到一个完整的控制序列.此时可以根据本状态接收到的结尾字符对相应控制序列进行处理.不过在处理之前,如果在ESsquare状态收到过'?',
			// 说明这个序列是终端设备私有序列.本内核不支持对这种序列的处理,于是直接恢复到ESnormal状态.否则就去执行相应控制序列.待序列处理完后就把状态恢复到ESnormal.
			case ESgotpars:
				state = ESnormal;
   1ec35:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ec39:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1ec3f:	89 d0                	mov    %edx,%eax
   1ec41:	c1 e0 03             	shl    $0x3,%eax
   1ec44:	01 d0                	add    %edx,%eax
   1ec46:	c1 e0 04             	shl    $0x4,%eax
   1ec49:	01 c8                	add    %ecx,%eax
   1ec4b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				if (ques)
   1ec51:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ec55:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ec5b:	89 d0                	mov    %edx,%eax
   1ec5d:	c1 e0 03             	shl    $0x3,%eax
   1ec60:	01 d0                	add    %edx,%eax
   1ec62:	c1 e0 04             	shl    $0x4,%eax
   1ec65:	01 c8                	add    %ecx,%eax
   1ec67:	8b 00                	mov    (%eax),%eax
   1ec69:	85 c0                	test   %eax,%eax
   1ec6b:	74 21                	je     1ec8e <.L138+0x59>
				{ ques =0;
   1ec6d:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ec71:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ec77:	89 d0                	mov    %edx,%eax
   1ec79:	c1 e0 03             	shl    $0x3,%eax
   1ec7c:	01 d0                	add    %edx,%eax
   1ec7e:	c1 e0 04             	shl    $0x4,%eax
   1ec81:	01 c8                	add    %ecx,%eax
   1ec83:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				  break;
   1ec89:	e9 32 0c 00 00       	jmp    1f8c0 <.L127>
				}
				switch(c) {
   1ec8e:	0f be 44 24 07       	movsbl 0x7(%esp),%eax
   1ec93:	83 e8 40             	sub    $0x40,%eax
   1ec96:	83 f8 35             	cmp    $0x35,%eax
   1ec99:	0f 87 21 0c 00 00    	ja     1f8c0 <.L127>
   1ec9f:	c1 e0 02             	shl    $0x2,%eax
   1eca2:	8b 84 18 0c 66 ff ff 	mov    -0x99f4(%eax,%ebx,1),%eax
   1eca9:	01 d8                	add    %ebx,%eax
   1ecab:	ff e0                	jmp    *%eax

0001ecad <.L184>:
					// 如果c是字符'G'或'`',则par[]中第1个参数代表列号,若列号不为零,则将光标左移1格.
					case 'G': case '`':							// CSI Pn G - 光标水平移动.
						if (par[0]) par[0]--;
   1ecad:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ecb1:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ecb7:	89 d0                	mov    %edx,%eax
   1ecb9:	c1 e0 03             	shl    $0x3,%eax
   1ecbc:	01 d0                	add    %edx,%eax
   1ecbe:	c1 e0 04             	shl    $0x4,%eax
   1ecc1:	01 c8                	add    %ecx,%eax
   1ecc3:	83 c0 30             	add    $0x30,%eax
   1ecc6:	8b 00                	mov    (%eax),%eax
   1ecc8:	85 c0                	test   %eax,%eax
   1ecca:	74 39                	je     1ed05 <.L184+0x58>
   1eccc:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ecd0:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ecd6:	89 d0                	mov    %edx,%eax
   1ecd8:	c1 e0 03             	shl    $0x3,%eax
   1ecdb:	01 d0                	add    %edx,%eax
   1ecdd:	c1 e0 04             	shl    $0x4,%eax
   1ece0:	01 c8                	add    %ecx,%eax
   1ece2:	83 c0 30             	add    $0x30,%eax
   1ece5:	8b 00                	mov    (%eax),%eax
   1ece7:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1ecea:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ecee:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1ecf4:	89 d0                	mov    %edx,%eax
   1ecf6:	c1 e0 03             	shl    $0x3,%eax
   1ecf9:	01 d0                	add    %edx,%eax
   1ecfb:	c1 e0 04             	shl    $0x4,%eax
   1ecfe:	01 f0                	add    %esi,%eax
   1ed00:	83 c0 30             	add    $0x30,%eax
   1ed03:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, par[0], y);
   1ed05:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ed09:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ed0f:	89 d0                	mov    %edx,%eax
   1ed11:	c1 e0 03             	shl    $0x3,%eax
   1ed14:	01 d0                	add    %edx,%eax
   1ed16:	c1 e0 04             	shl    $0x4,%eax
   1ed19:	01 c8                	add    %ecx,%eax
   1ed1b:	83 c0 20             	add    $0x20,%eax
   1ed1e:	8b 08                	mov    (%eax),%ecx
   1ed20:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ed24:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1ed2a:	89 d0                	mov    %edx,%eax
   1ed2c:	c1 e0 03             	shl    $0x3,%eax
   1ed2f:	01 d0                	add    %edx,%eax
   1ed31:	c1 e0 04             	shl    $0x4,%eax
   1ed34:	01 f0                	add    %esi,%eax
   1ed36:	83 c0 30             	add    $0x30,%eax
   1ed39:	8b 00                	mov    (%eax),%eax
   1ed3b:	83 ec 04             	sub    $0x4,%esp
   1ed3e:	51                   	push   %ecx
   1ed3f:	50                   	push   %eax
   1ed40:	ff 74 24 14          	pushl  0x14(%esp)
   1ed44:	e8 c3 d6 ff ff       	call   1c40c <gotoxy>
   1ed49:	83 c4 10             	add    $0x10,%esp
						break;
   1ed4c:	e9 08 0a 00 00       	jmp    1f759 <.L191+0x146>

0001ed51 <.L178>:
					// 如果c是'A',则第1个参数代表光标上移的行数.若参数为0则上移1行.
					case 'A':									// CSI Pn A - 光标上移.
						if (!par[0]) par[0]++;
   1ed51:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ed55:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ed5b:	89 d0                	mov    %edx,%eax
   1ed5d:	c1 e0 03             	shl    $0x3,%eax
   1ed60:	01 d0                	add    %edx,%eax
   1ed62:	c1 e0 04             	shl    $0x4,%eax
   1ed65:	01 c8                	add    %ecx,%eax
   1ed67:	83 c0 30             	add    $0x30,%eax
   1ed6a:	8b 00                	mov    (%eax),%eax
   1ed6c:	85 c0                	test   %eax,%eax
   1ed6e:	75 39                	jne    1eda9 <.L178+0x58>
   1ed70:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ed74:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ed7a:	89 d0                	mov    %edx,%eax
   1ed7c:	c1 e0 03             	shl    $0x3,%eax
   1ed7f:	01 d0                	add    %edx,%eax
   1ed81:	c1 e0 04             	shl    $0x4,%eax
   1ed84:	01 c8                	add    %ecx,%eax
   1ed86:	83 c0 30             	add    $0x30,%eax
   1ed89:	8b 00                	mov    (%eax),%eax
   1ed8b:	8d 48 01             	lea    0x1(%eax),%ecx
   1ed8e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ed92:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1ed98:	89 d0                	mov    %edx,%eax
   1ed9a:	c1 e0 03             	shl    $0x3,%eax
   1ed9d:	01 d0                	add    %edx,%eax
   1ed9f:	c1 e0 04             	shl    $0x4,%eax
   1eda2:	01 f0                	add    %esi,%eax
   1eda4:	83 c0 30             	add    $0x30,%eax
   1eda7:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, x, y - par[0]);
   1eda9:	8b 54 24 08          	mov    0x8(%esp),%edx
   1edad:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1edb3:	89 d0                	mov    %edx,%eax
   1edb5:	c1 e0 03             	shl    $0x3,%eax
   1edb8:	01 d0                	add    %edx,%eax
   1edba:	c1 e0 04             	shl    $0x4,%eax
   1edbd:	01 c8                	add    %ecx,%eax
   1edbf:	83 c0 20             	add    $0x20,%eax
   1edc2:	8b 08                	mov    (%eax),%ecx
   1edc4:	8b 54 24 08          	mov    0x8(%esp),%edx
   1edc8:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1edce:	89 d0                	mov    %edx,%eax
   1edd0:	c1 e0 03             	shl    $0x3,%eax
   1edd3:	01 d0                	add    %edx,%eax
   1edd5:	c1 e0 04             	shl    $0x4,%eax
   1edd8:	01 f0                	add    %esi,%eax
   1edda:	83 c0 30             	add    $0x30,%eax
   1eddd:	8b 00                	mov    (%eax),%eax
   1eddf:	29 c1                	sub    %eax,%ecx
   1ede1:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ede5:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1edeb:	89 d0                	mov    %edx,%eax
   1eded:	c1 e0 03             	shl    $0x3,%eax
   1edf0:	01 d0                	add    %edx,%eax
   1edf2:	c1 e0 04             	shl    $0x4,%eax
   1edf5:	01 f0                	add    %esi,%eax
   1edf7:	83 c0 20             	add    $0x20,%eax
   1edfa:	8b 00                	mov    (%eax),%eax
   1edfc:	83 ec 04             	sub    $0x4,%esp
   1edff:	51                   	push   %ecx
   1ee00:	50                   	push   %eax
   1ee01:	ff 74 24 14          	pushl  0x14(%esp)
   1ee05:	e8 02 d6 ff ff       	call   1c40c <gotoxy>
   1ee0a:	83 c4 10             	add    $0x10,%esp
						break;
   1ee0d:	e9 47 09 00 00       	jmp    1f759 <.L191+0x146>

0001ee12 <.L179>:
					// 如果c是'B'或'e',则第1个代表光标右移的格数.若参数为0则下移一行.
					case 'B': case 'e':							// CSI Pn B - 光标下移.
						if (!par[0]) par[0]++;
   1ee12:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ee16:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ee1c:	89 d0                	mov    %edx,%eax
   1ee1e:	c1 e0 03             	shl    $0x3,%eax
   1ee21:	01 d0                	add    %edx,%eax
   1ee23:	c1 e0 04             	shl    $0x4,%eax
   1ee26:	01 c8                	add    %ecx,%eax
   1ee28:	83 c0 30             	add    $0x30,%eax
   1ee2b:	8b 00                	mov    (%eax),%eax
   1ee2d:	85 c0                	test   %eax,%eax
   1ee2f:	75 39                	jne    1ee6a <.L179+0x58>
   1ee31:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ee35:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ee3b:	89 d0                	mov    %edx,%eax
   1ee3d:	c1 e0 03             	shl    $0x3,%eax
   1ee40:	01 d0                	add    %edx,%eax
   1ee42:	c1 e0 04             	shl    $0x4,%eax
   1ee45:	01 c8                	add    %ecx,%eax
   1ee47:	83 c0 30             	add    $0x30,%eax
   1ee4a:	8b 00                	mov    (%eax),%eax
   1ee4c:	8d 48 01             	lea    0x1(%eax),%ecx
   1ee4f:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ee53:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1ee59:	89 d0                	mov    %edx,%eax
   1ee5b:	c1 e0 03             	shl    $0x3,%eax
   1ee5e:	01 d0                	add    %edx,%eax
   1ee60:	c1 e0 04             	shl    $0x4,%eax
   1ee63:	01 f0                	add    %esi,%eax
   1ee65:	83 c0 30             	add    $0x30,%eax
   1ee68:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, x, y + par[0]);
   1ee6a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ee6e:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ee74:	89 d0                	mov    %edx,%eax
   1ee76:	c1 e0 03             	shl    $0x3,%eax
   1ee79:	01 d0                	add    %edx,%eax
   1ee7b:	c1 e0 04             	shl    $0x4,%eax
   1ee7e:	01 c8                	add    %ecx,%eax
   1ee80:	83 c0 20             	add    $0x20,%eax
   1ee83:	8b 08                	mov    (%eax),%ecx
   1ee85:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ee89:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1ee8f:	89 d0                	mov    %edx,%eax
   1ee91:	c1 e0 03             	shl    $0x3,%eax
   1ee94:	01 d0                	add    %edx,%eax
   1ee96:	c1 e0 04             	shl    $0x4,%eax
   1ee99:	01 f0                	add    %esi,%eax
   1ee9b:	83 c0 30             	add    $0x30,%eax
   1ee9e:	8b 00                	mov    (%eax),%eax
   1eea0:	01 c1                	add    %eax,%ecx
   1eea2:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eea6:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1eeac:	89 d0                	mov    %edx,%eax
   1eeae:	c1 e0 03             	shl    $0x3,%eax
   1eeb1:	01 d0                	add    %edx,%eax
   1eeb3:	c1 e0 04             	shl    $0x4,%eax
   1eeb6:	01 f0                	add    %esi,%eax
   1eeb8:	83 c0 20             	add    $0x20,%eax
   1eebb:	8b 00                	mov    (%eax),%eax
   1eebd:	83 ec 04             	sub    $0x4,%esp
   1eec0:	51                   	push   %ecx
   1eec1:	50                   	push   %eax
   1eec2:	ff 74 24 14          	pushl  0x14(%esp)
   1eec6:	e8 41 d5 ff ff       	call   1c40c <gotoxy>
   1eecb:	83 c4 10             	add    $0x10,%esp
						break;
   1eece:	e9 86 08 00 00       	jmp    1f759 <.L191+0x146>

0001eed3 <.L180>:
					// 如果c是'C'或'a',则第1个参数代表光标右移的格数.若参数为0则右移1格.
					case 'C': case 'a':							// CSI Pn C - 光标右移.
						if (!par[0]) par[0]++;
   1eed3:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eed7:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1eedd:	89 d0                	mov    %edx,%eax
   1eedf:	c1 e0 03             	shl    $0x3,%eax
   1eee2:	01 d0                	add    %edx,%eax
   1eee4:	c1 e0 04             	shl    $0x4,%eax
   1eee7:	01 c8                	add    %ecx,%eax
   1eee9:	83 c0 30             	add    $0x30,%eax
   1eeec:	8b 00                	mov    (%eax),%eax
   1eeee:	85 c0                	test   %eax,%eax
   1eef0:	75 39                	jne    1ef2b <.L180+0x58>
   1eef2:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eef6:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1eefc:	89 d0                	mov    %edx,%eax
   1eefe:	c1 e0 03             	shl    $0x3,%eax
   1ef01:	01 d0                	add    %edx,%eax
   1ef03:	c1 e0 04             	shl    $0x4,%eax
   1ef06:	01 c8                	add    %ecx,%eax
   1ef08:	83 c0 30             	add    $0x30,%eax
   1ef0b:	8b 00                	mov    (%eax),%eax
   1ef0d:	8d 48 01             	lea    0x1(%eax),%ecx
   1ef10:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ef14:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1ef1a:	89 d0                	mov    %edx,%eax
   1ef1c:	c1 e0 03             	shl    $0x3,%eax
   1ef1f:	01 d0                	add    %edx,%eax
   1ef21:	c1 e0 04             	shl    $0x4,%eax
   1ef24:	01 f0                	add    %esi,%eax
   1ef26:	83 c0 30             	add    $0x30,%eax
   1ef29:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, x + par[0], y);
   1ef2b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ef2f:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ef35:	89 d0                	mov    %edx,%eax
   1ef37:	c1 e0 03             	shl    $0x3,%eax
   1ef3a:	01 d0                	add    %edx,%eax
   1ef3c:	c1 e0 04             	shl    $0x4,%eax
   1ef3f:	01 c8                	add    %ecx,%eax
   1ef41:	83 c0 20             	add    $0x20,%eax
   1ef44:	8b 08                	mov    (%eax),%ecx
   1ef46:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ef4a:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1ef50:	89 d0                	mov    %edx,%eax
   1ef52:	c1 e0 03             	shl    $0x3,%eax
   1ef55:	01 d0                	add    %edx,%eax
   1ef57:	c1 e0 04             	shl    $0x4,%eax
   1ef5a:	01 f0                	add    %esi,%eax
   1ef5c:	83 c0 20             	add    $0x20,%eax
   1ef5f:	8b 30                	mov    (%eax),%esi
   1ef61:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ef65:	8d bb e8 1e 01 00    	lea    0x11ee8(%ebx),%edi
   1ef6b:	89 d0                	mov    %edx,%eax
   1ef6d:	c1 e0 03             	shl    $0x3,%eax
   1ef70:	01 d0                	add    %edx,%eax
   1ef72:	c1 e0 04             	shl    $0x4,%eax
   1ef75:	01 f8                	add    %edi,%eax
   1ef77:	83 c0 30             	add    $0x30,%eax
   1ef7a:	8b 00                	mov    (%eax),%eax
   1ef7c:	01 f0                	add    %esi,%eax
   1ef7e:	83 ec 04             	sub    $0x4,%esp
   1ef81:	51                   	push   %ecx
   1ef82:	50                   	push   %eax
   1ef83:	ff 74 24 14          	pushl  0x14(%esp)
   1ef87:	e8 80 d4 ff ff       	call   1c40c <gotoxy>
   1ef8c:	83 c4 10             	add    $0x10,%esp
						break;
   1ef8f:	e9 c5 07 00 00       	jmp    1f759 <.L191+0x146>

0001ef94 <.L181>:
					// 如果c是'D',则第1个参数代表光标左移的格数.若参数为0则左移1格.
					case 'D':									// CSI Pn D - 光标左移.
						if (!par[0]) par[0]++;
   1ef94:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ef98:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1ef9e:	89 d0                	mov    %edx,%eax
   1efa0:	c1 e0 03             	shl    $0x3,%eax
   1efa3:	01 d0                	add    %edx,%eax
   1efa5:	c1 e0 04             	shl    $0x4,%eax
   1efa8:	01 c8                	add    %ecx,%eax
   1efaa:	83 c0 30             	add    $0x30,%eax
   1efad:	8b 00                	mov    (%eax),%eax
   1efaf:	85 c0                	test   %eax,%eax
   1efb1:	75 39                	jne    1efec <.L181+0x58>
   1efb3:	8b 54 24 08          	mov    0x8(%esp),%edx
   1efb7:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1efbd:	89 d0                	mov    %edx,%eax
   1efbf:	c1 e0 03             	shl    $0x3,%eax
   1efc2:	01 d0                	add    %edx,%eax
   1efc4:	c1 e0 04             	shl    $0x4,%eax
   1efc7:	01 c8                	add    %ecx,%eax
   1efc9:	83 c0 30             	add    $0x30,%eax
   1efcc:	8b 00                	mov    (%eax),%eax
   1efce:	8d 48 01             	lea    0x1(%eax),%ecx
   1efd1:	8b 54 24 08          	mov    0x8(%esp),%edx
   1efd5:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1efdb:	89 d0                	mov    %edx,%eax
   1efdd:	c1 e0 03             	shl    $0x3,%eax
   1efe0:	01 d0                	add    %edx,%eax
   1efe2:	c1 e0 04             	shl    $0x4,%eax
   1efe5:	01 f0                	add    %esi,%eax
   1efe7:	83 c0 30             	add    $0x30,%eax
   1efea:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, x - par[0], y);
   1efec:	8b 54 24 08          	mov    0x8(%esp),%edx
   1eff0:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1eff6:	89 d0                	mov    %edx,%eax
   1eff8:	c1 e0 03             	shl    $0x3,%eax
   1effb:	01 d0                	add    %edx,%eax
   1effd:	c1 e0 04             	shl    $0x4,%eax
   1f000:	01 c8                	add    %ecx,%eax
   1f002:	83 c0 20             	add    $0x20,%eax
   1f005:	8b 08                	mov    (%eax),%ecx
   1f007:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f00b:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1f011:	89 d0                	mov    %edx,%eax
   1f013:	c1 e0 03             	shl    $0x3,%eax
   1f016:	01 d0                	add    %edx,%eax
   1f018:	c1 e0 04             	shl    $0x4,%eax
   1f01b:	01 f0                	add    %esi,%eax
   1f01d:	83 c0 20             	add    $0x20,%eax
   1f020:	8b 30                	mov    (%eax),%esi
   1f022:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f026:	8d bb e8 1e 01 00    	lea    0x11ee8(%ebx),%edi
   1f02c:	89 d0                	mov    %edx,%eax
   1f02e:	c1 e0 03             	shl    $0x3,%eax
   1f031:	01 d0                	add    %edx,%eax
   1f033:	c1 e0 04             	shl    $0x4,%eax
   1f036:	01 f8                	add    %edi,%eax
   1f038:	83 c0 30             	add    $0x30,%eax
   1f03b:	8b 00                	mov    (%eax),%eax
   1f03d:	29 c6                	sub    %eax,%esi
   1f03f:	89 f0                	mov    %esi,%eax
   1f041:	83 ec 04             	sub    $0x4,%esp
   1f044:	51                   	push   %ecx
   1f045:	50                   	push   %eax
   1f046:	ff 74 24 14          	pushl  0x14(%esp)
   1f04a:	e8 bd d3 ff ff       	call   1c40c <gotoxy>
   1f04f:	83 c4 10             	add    $0x10,%esp
						break;
   1f052:	e9 02 07 00 00       	jmp    1f759 <.L191+0x146>

0001f057 <.L182>:
					// 如果c是'E',则第1个参数代表光标向下移动的行数,并回到0列.若参数为0则下移1行.
					case 'E':									// CSI Pn E - 光标下移回0列
						if (!par[0]) par[0]++;
   1f057:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f05b:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f061:	89 d0                	mov    %edx,%eax
   1f063:	c1 e0 03             	shl    $0x3,%eax
   1f066:	01 d0                	add    %edx,%eax
   1f068:	c1 e0 04             	shl    $0x4,%eax
   1f06b:	01 c8                	add    %ecx,%eax
   1f06d:	83 c0 30             	add    $0x30,%eax
   1f070:	8b 00                	mov    (%eax),%eax
   1f072:	85 c0                	test   %eax,%eax
   1f074:	75 39                	jne    1f0af <.L182+0x58>
   1f076:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f07a:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f080:	89 d0                	mov    %edx,%eax
   1f082:	c1 e0 03             	shl    $0x3,%eax
   1f085:	01 d0                	add    %edx,%eax
   1f087:	c1 e0 04             	shl    $0x4,%eax
   1f08a:	01 c8                	add    %ecx,%eax
   1f08c:	83 c0 30             	add    $0x30,%eax
   1f08f:	8b 00                	mov    (%eax),%eax
   1f091:	8d 48 01             	lea    0x1(%eax),%ecx
   1f094:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f098:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f09e:	89 d0                	mov    %edx,%eax
   1f0a0:	c1 e0 03             	shl    $0x3,%eax
   1f0a3:	01 d0                	add    %edx,%eax
   1f0a5:	c1 e0 04             	shl    $0x4,%eax
   1f0a8:	01 f0                	add    %esi,%eax
   1f0aa:	83 c0 30             	add    $0x30,%eax
   1f0ad:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, 0, y + par[0]);
   1f0af:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f0b3:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f0b9:	89 d0                	mov    %edx,%eax
   1f0bb:	c1 e0 03             	shl    $0x3,%eax
   1f0be:	01 d0                	add    %edx,%eax
   1f0c0:	c1 e0 04             	shl    $0x4,%eax
   1f0c3:	01 c8                	add    %ecx,%eax
   1f0c5:	83 c0 20             	add    $0x20,%eax
   1f0c8:	8b 08                	mov    (%eax),%ecx
   1f0ca:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f0ce:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f0d4:	89 d0                	mov    %edx,%eax
   1f0d6:	c1 e0 03             	shl    $0x3,%eax
   1f0d9:	01 d0                	add    %edx,%eax
   1f0db:	c1 e0 04             	shl    $0x4,%eax
   1f0de:	01 f0                	add    %esi,%eax
   1f0e0:	83 c0 30             	add    $0x30,%eax
   1f0e3:	8b 00                	mov    (%eax),%eax
   1f0e5:	01 c8                	add    %ecx,%eax
   1f0e7:	83 ec 04             	sub    $0x4,%esp
   1f0ea:	50                   	push   %eax
   1f0eb:	6a 00                	push   $0x0
   1f0ed:	ff 74 24 14          	pushl  0x14(%esp)
   1f0f1:	e8 16 d3 ff ff       	call   1c40c <gotoxy>
   1f0f6:	83 c4 10             	add    $0x10,%esp
						break;
   1f0f9:	e9 5b 06 00 00       	jmp    1f759 <.L191+0x146>

0001f0fe <.L183>:
					// 如果c是'F',则第1个参数代表光标向上移动的行数,并回到0列.若参数为0则上移1行.
					case 'F':									// CSI Pn F - 光标上移回0列.
						if (!par[0]) par[0]++;
   1f0fe:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f102:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f108:	89 d0                	mov    %edx,%eax
   1f10a:	c1 e0 03             	shl    $0x3,%eax
   1f10d:	01 d0                	add    %edx,%eax
   1f10f:	c1 e0 04             	shl    $0x4,%eax
   1f112:	01 c8                	add    %ecx,%eax
   1f114:	83 c0 30             	add    $0x30,%eax
   1f117:	8b 00                	mov    (%eax),%eax
   1f119:	85 c0                	test   %eax,%eax
   1f11b:	75 39                	jne    1f156 <.L183+0x58>
   1f11d:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f121:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f127:	89 d0                	mov    %edx,%eax
   1f129:	c1 e0 03             	shl    $0x3,%eax
   1f12c:	01 d0                	add    %edx,%eax
   1f12e:	c1 e0 04             	shl    $0x4,%eax
   1f131:	01 c8                	add    %ecx,%eax
   1f133:	83 c0 30             	add    $0x30,%eax
   1f136:	8b 00                	mov    (%eax),%eax
   1f138:	8d 48 01             	lea    0x1(%eax),%ecx
   1f13b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f13f:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f145:	89 d0                	mov    %edx,%eax
   1f147:	c1 e0 03             	shl    $0x3,%eax
   1f14a:	01 d0                	add    %edx,%eax
   1f14c:	c1 e0 04             	shl    $0x4,%eax
   1f14f:	01 f0                	add    %esi,%eax
   1f151:	83 c0 30             	add    $0x30,%eax
   1f154:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, 0, y - par[0]);
   1f156:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f15a:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f160:	89 d0                	mov    %edx,%eax
   1f162:	c1 e0 03             	shl    $0x3,%eax
   1f165:	01 d0                	add    %edx,%eax
   1f167:	c1 e0 04             	shl    $0x4,%eax
   1f16a:	01 c8                	add    %ecx,%eax
   1f16c:	83 c0 20             	add    $0x20,%eax
   1f16f:	8b 08                	mov    (%eax),%ecx
   1f171:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f175:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f17b:	89 d0                	mov    %edx,%eax
   1f17d:	c1 e0 03             	shl    $0x3,%eax
   1f180:	01 d0                	add    %edx,%eax
   1f182:	c1 e0 04             	shl    $0x4,%eax
   1f185:	01 f0                	add    %esi,%eax
   1f187:	83 c0 30             	add    $0x30,%eax
   1f18a:	8b 00                	mov    (%eax),%eax
   1f18c:	29 c1                	sub    %eax,%ecx
   1f18e:	89 c8                	mov    %ecx,%eax
   1f190:	83 ec 04             	sub    $0x4,%esp
   1f193:	50                   	push   %eax
   1f194:	6a 00                	push   $0x0
   1f196:	ff 74 24 14          	pushl  0x14(%esp)
   1f19a:	e8 6d d2 ff ff       	call   1c40c <gotoxy>
   1f19f:	83 c4 10             	add    $0x10,%esp
						break;
   1f1a2:	e9 b2 05 00 00       	jmp    1f759 <.L191+0x146>

0001f1a7 <.L192>:
					// 如果c是'd',则第1个参数代表光标所需在的行号(从0计数).
					case 'd':									// CSI Pn d - 在当前列置行位置
						if (par[0]) par[0]--;
   1f1a7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f1ab:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f1b1:	89 d0                	mov    %edx,%eax
   1f1b3:	c1 e0 03             	shl    $0x3,%eax
   1f1b6:	01 d0                	add    %edx,%eax
   1f1b8:	c1 e0 04             	shl    $0x4,%eax
   1f1bb:	01 c8                	add    %ecx,%eax
   1f1bd:	83 c0 30             	add    $0x30,%eax
   1f1c0:	8b 00                	mov    (%eax),%eax
   1f1c2:	85 c0                	test   %eax,%eax
   1f1c4:	74 39                	je     1f1ff <.L192+0x58>
   1f1c6:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f1ca:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f1d0:	89 d0                	mov    %edx,%eax
   1f1d2:	c1 e0 03             	shl    $0x3,%eax
   1f1d5:	01 d0                	add    %edx,%eax
   1f1d7:	c1 e0 04             	shl    $0x4,%eax
   1f1da:	01 c8                	add    %ecx,%eax
   1f1dc:	83 c0 30             	add    $0x30,%eax
   1f1df:	8b 00                	mov    (%eax),%eax
   1f1e1:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1f1e4:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f1e8:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f1ee:	89 d0                	mov    %edx,%eax
   1f1f0:	c1 e0 03             	shl    $0x3,%eax
   1f1f3:	01 d0                	add    %edx,%eax
   1f1f5:	c1 e0 04             	shl    $0x4,%eax
   1f1f8:	01 f0                	add    %esi,%eax
   1f1fa:	83 c0 30             	add    $0x30,%eax
   1f1fd:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, x, par[0]);
   1f1ff:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f203:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f209:	89 d0                	mov    %edx,%eax
   1f20b:	c1 e0 03             	shl    $0x3,%eax
   1f20e:	01 d0                	add    %edx,%eax
   1f210:	c1 e0 04             	shl    $0x4,%eax
   1f213:	01 c8                	add    %ecx,%eax
   1f215:	83 c0 30             	add    $0x30,%eax
   1f218:	8b 08                	mov    (%eax),%ecx
   1f21a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f21e:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   1f224:	89 d0                	mov    %edx,%eax
   1f226:	c1 e0 03             	shl    $0x3,%eax
   1f229:	01 d0                	add    %edx,%eax
   1f22b:	c1 e0 04             	shl    $0x4,%eax
   1f22e:	01 f0                	add    %esi,%eax
   1f230:	83 c0 20             	add    $0x20,%eax
   1f233:	8b 00                	mov    (%eax),%eax
   1f235:	83 ec 04             	sub    $0x4,%esp
   1f238:	51                   	push   %ecx
   1f239:	50                   	push   %eax
   1f23a:	ff 74 24 14          	pushl  0x14(%esp)
   1f23e:	e8 c9 d1 ff ff       	call   1c40c <gotoxy>
   1f243:	83 c4 10             	add    $0x10,%esp
						break;
   1f246:	e9 0e 05 00 00       	jmp    1f759 <.L191+0x146>

0001f24b <.L185>:
					// 如果c是'H'或'f',则第1个参数代表光标移到的行号,第2个参数代表光标移到的列号.
					case 'H': case 'f':							// CSI Pn H - 光标定位.
						if (par[0]) par[0]--;
   1f24b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f24f:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f255:	89 d0                	mov    %edx,%eax
   1f257:	c1 e0 03             	shl    $0x3,%eax
   1f25a:	01 d0                	add    %edx,%eax
   1f25c:	c1 e0 04             	shl    $0x4,%eax
   1f25f:	01 c8                	add    %ecx,%eax
   1f261:	83 c0 30             	add    $0x30,%eax
   1f264:	8b 00                	mov    (%eax),%eax
   1f266:	85 c0                	test   %eax,%eax
   1f268:	74 39                	je     1f2a3 <.L185+0x58>
   1f26a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f26e:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f274:	89 d0                	mov    %edx,%eax
   1f276:	c1 e0 03             	shl    $0x3,%eax
   1f279:	01 d0                	add    %edx,%eax
   1f27b:	c1 e0 04             	shl    $0x4,%eax
   1f27e:	01 c8                	add    %ecx,%eax
   1f280:	83 c0 30             	add    $0x30,%eax
   1f283:	8b 00                	mov    (%eax),%eax
   1f285:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1f288:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f28c:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f292:	89 d0                	mov    %edx,%eax
   1f294:	c1 e0 03             	shl    $0x3,%eax
   1f297:	01 d0                	add    %edx,%eax
   1f299:	c1 e0 04             	shl    $0x4,%eax
   1f29c:	01 f0                	add    %esi,%eax
   1f29e:	83 c0 30             	add    $0x30,%eax
   1f2a1:	89 08                	mov    %ecx,(%eax)
						if (par[1]) par[1]--;
   1f2a3:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f2a7:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f2ad:	89 d0                	mov    %edx,%eax
   1f2af:	c1 e0 03             	shl    $0x3,%eax
   1f2b2:	01 d0                	add    %edx,%eax
   1f2b4:	c1 e0 04             	shl    $0x4,%eax
   1f2b7:	01 c8                	add    %ecx,%eax
   1f2b9:	83 c0 34             	add    $0x34,%eax
   1f2bc:	8b 00                	mov    (%eax),%eax
   1f2be:	85 c0                	test   %eax,%eax
   1f2c0:	74 39                	je     1f2fb <.L185+0xb0>
   1f2c2:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f2c6:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f2cc:	89 d0                	mov    %edx,%eax
   1f2ce:	c1 e0 03             	shl    $0x3,%eax
   1f2d1:	01 d0                	add    %edx,%eax
   1f2d3:	c1 e0 04             	shl    $0x4,%eax
   1f2d6:	01 c8                	add    %ecx,%eax
   1f2d8:	83 c0 34             	add    $0x34,%eax
   1f2db:	8b 00                	mov    (%eax),%eax
   1f2dd:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1f2e0:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f2e4:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f2ea:	89 d0                	mov    %edx,%eax
   1f2ec:	c1 e0 03             	shl    $0x3,%eax
   1f2ef:	01 d0                	add    %edx,%eax
   1f2f1:	c1 e0 04             	shl    $0x4,%eax
   1f2f4:	01 f0                	add    %esi,%eax
   1f2f6:	83 c0 34             	add    $0x34,%eax
   1f2f9:	89 08                	mov    %ecx,(%eax)
						gotoxy(currcons, par[1], par[0]);
   1f2fb:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f2ff:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f305:	89 d0                	mov    %edx,%eax
   1f307:	c1 e0 03             	shl    $0x3,%eax
   1f30a:	01 d0                	add    %edx,%eax
   1f30c:	c1 e0 04             	shl    $0x4,%eax
   1f30f:	01 c8                	add    %ecx,%eax
   1f311:	83 c0 30             	add    $0x30,%eax
   1f314:	8b 08                	mov    (%eax),%ecx
   1f316:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f31a:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f320:	89 d0                	mov    %edx,%eax
   1f322:	c1 e0 03             	shl    $0x3,%eax
   1f325:	01 d0                	add    %edx,%eax
   1f327:	c1 e0 04             	shl    $0x4,%eax
   1f32a:	01 f0                	add    %esi,%eax
   1f32c:	83 c0 34             	add    $0x34,%eax
   1f32f:	8b 00                	mov    (%eax),%eax
   1f331:	83 ec 04             	sub    $0x4,%esp
   1f334:	51                   	push   %ecx
   1f335:	50                   	push   %eax
   1f336:	ff 74 24 14          	pushl  0x14(%esp)
   1f33a:	e8 cd d0 ff ff       	call   1c40c <gotoxy>
   1f33f:	83 c4 10             	add    $0x10,%esp
						break;
   1f342:	e9 12 04 00 00       	jmp    1f759 <.L191+0x146>

0001f347 <.L186>:
					// 如果字符c是'J',则第1个参数代表以光标所处位置清屏的方式:
					// 序列: 'ESC [ Ps J'(Ps=0删除光标到屏幕底端;Ps=1删除屏幕开始到光标处;Ps=2整屏删除).
					case 'J':									// CSI Pn J - 屏幕擦除字符.
						csi_J(currcons, par[0]);
   1f347:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f34b:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f351:	89 d0                	mov    %edx,%eax
   1f353:	c1 e0 03             	shl    $0x3,%eax
   1f356:	01 d0                	add    %edx,%eax
   1f358:	c1 e0 04             	shl    $0x4,%eax
   1f35b:	01 c8                	add    %ecx,%eax
   1f35d:	83 c0 30             	add    $0x30,%eax
   1f360:	8b 00                	mov    (%eax),%eax
   1f362:	83 ec 08             	sub    $0x8,%esp
   1f365:	50                   	push   %eax
   1f366:	ff 74 24 14          	pushl  0x14(%esp)
   1f36a:	e8 90 dd ff ff       	call   1d0ff <csi_J>
   1f36f:	83 c4 10             	add    $0x10,%esp
						break;
   1f372:	e9 e2 03 00 00       	jmp    1f759 <.L191+0x146>

0001f377 <.L187>:
					// 如果字符c是'K',则第1个参数代表以光标所在位置对行中字符进行删除处理的方式:
					// 序列: 'ESC [ Ps K'(Ps=0删除到行尾;Ps=1从开始删除;Ps=2整行都删除).
					case 'K':									// CSI Pn K - 行内擦除字符.
						csi_K(currcons,par[0]);
   1f377:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f37b:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f381:	89 d0                	mov    %edx,%eax
   1f383:	c1 e0 03             	shl    $0x3,%eax
   1f386:	01 d0                	add    %edx,%eax
   1f388:	c1 e0 04             	shl    $0x4,%eax
   1f38b:	01 c8                	add    %ecx,%eax
   1f38d:	83 c0 30             	add    $0x30,%eax
   1f390:	8b 00                	mov    (%eax),%eax
   1f392:	83 ec 08             	sub    $0x8,%esp
   1f395:	50                   	push   %eax
   1f396:	ff 74 24 14          	pushl  0x14(%esp)
   1f39a:	e8 b3 de ff ff       	call   1d252 <csi_K>
   1f39f:	83 c4 10             	add    $0x10,%esp
						break;
   1f3a2:	e9 b2 03 00 00       	jmp    1f759 <.L191+0x146>

0001f3a7 <.L188>:
					// 如果字符c是'L',表示在光标位置处插入n行(控制序列 'ESC [ Pn L')
					case 'L':									// CSI Pn L - 插入行.
						csi_L(currcons, par[0]);
   1f3a7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f3ab:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f3b1:	89 d0                	mov    %edx,%eax
   1f3b3:	c1 e0 03             	shl    $0x3,%eax
   1f3b6:	01 d0                	add    %edx,%eax
   1f3b8:	c1 e0 04             	shl    $0x4,%eax
   1f3bb:	01 c8                	add    %ecx,%eax
   1f3bd:	83 c0 30             	add    $0x30,%eax
   1f3c0:	8b 00                	mov    (%eax),%eax
   1f3c2:	83 ec 08             	sub    $0x8,%esp
   1f3c5:	50                   	push   %eax
   1f3c6:	ff 74 24 14          	pushl  0x14(%esp)
   1f3ca:	e8 e5 eb ff ff       	call   1dfb4 <csi_L>
   1f3cf:	83 c4 10             	add    $0x10,%esp
						break;
   1f3d2:	e9 82 03 00 00       	jmp    1f759 <.L191+0x146>

0001f3d7 <.L189>:
					// 如果字符c是'M',表示在光标位置处删除n行(控制序列 'ESC [ Pn M')
					case 'M':									// 删除行
						csi_M(currcons, par[0]);
   1f3d7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f3db:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f3e1:	89 d0                	mov    %edx,%eax
   1f3e3:	c1 e0 03             	shl    $0x3,%eax
   1f3e6:	01 d0                	add    %edx,%eax
   1f3e8:	c1 e0 04             	shl    $0x4,%eax
   1f3eb:	01 c8                	add    %ecx,%eax
   1f3ed:	83 c0 30             	add    $0x30,%eax
   1f3f0:	8b 00                	mov    (%eax),%eax
   1f3f2:	83 ec 08             	sub    $0x8,%esp
   1f3f5:	50                   	push   %eax
   1f3f6:	ff 74 24 14          	pushl  0x14(%esp)
   1f3fa:	e8 55 ec ff ff       	call   1e054 <csi_M>
   1f3ff:	83 c4 10             	add    $0x10,%esp
						break;
   1f402:	e9 52 03 00 00       	jmp    1f759 <.L191+0x146>

0001f407 <.L190>:
					// 如果字符c是'P',表示在光标位置处删除n个字符(控制序列 'ESC [ Pn P')
					case 'P':									// 删除字符.
						csi_P(currcons, par[0]);
   1f407:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f40b:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f411:	89 d0                	mov    %edx,%eax
   1f413:	c1 e0 03             	shl    $0x3,%eax
   1f416:	01 d0                	add    %edx,%eax
   1f418:	c1 e0 04             	shl    $0x4,%eax
   1f41b:	01 c8                	add    %ecx,%eax
   1f41d:	83 c0 30             	add    $0x30,%eax
   1f420:	8b 00                	mov    (%eax),%eax
   1f422:	83 ec 08             	sub    $0x8,%esp
   1f425:	50                   	push   %eax
   1f426:	ff 74 24 14          	pushl  0x14(%esp)
   1f42a:	e8 d5 eb ff ff       	call   1e004 <csi_P>
   1f42f:	83 c4 10             	add    $0x10,%esp
						break;
   1f432:	e9 22 03 00 00       	jmp    1f759 <.L191+0x146>

0001f437 <.L176>:
					// 如果字符c是'@',表示在光标位置处插入n个字符(控制序列 'ESC [ Pn @')
					case '@':									// 插入字符.
						csi_at(currcons, par[0]);
   1f437:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f43b:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f441:	89 d0                	mov    %edx,%eax
   1f443:	c1 e0 03             	shl    $0x3,%eax
   1f446:	01 d0                	add    %edx,%eax
   1f448:	c1 e0 04             	shl    $0x4,%eax
   1f44b:	01 c8                	add    %ecx,%eax
   1f44d:	83 c0 30             	add    $0x30,%eax
   1f450:	8b 00                	mov    (%eax),%eax
   1f452:	83 ec 08             	sub    $0x8,%esp
   1f455:	50                   	push   %eax
   1f456:	ff 74 24 14          	pushl  0x14(%esp)
   1f45a:	e8 05 eb ff ff       	call   1df64 <csi_at>
   1f45f:	83 c4 10             	add    $0x10,%esp
						break;
   1f462:	e9 f2 02 00 00       	jmp    1f759 <.L191+0x146>

0001f467 <.L193>:
					// 如果字符c是'm',表示改变光标处字符的显示属性,比如加粗,加下划线,闪烁,反显等.
					// 转义序列: 'ESC [ Pn m'.n=0正常显示;1加粗;4加下划线;7反显;27正常显示等.
					case 'm':									// CSI Ps m - 设置显示字符属性.
						csi_m(currcons);
   1f467:	83 ec 0c             	sub    $0xc,%esp
   1f46a:	ff 74 24 14          	pushl  0x14(%esp)
   1f46e:	e8 6e df ff ff       	call   1d3e1 <csi_m>
   1f473:	83 c4 10             	add    $0x10,%esp
						break;
   1f476:	e9 de 02 00 00       	jmp    1f759 <.L191+0x146>

0001f47b <.L194>:
					// 如果字符c是'r',则表示两个参数设置滚屏的起始行号和终止行号.
					case 'r':									// CSI Pn r - 设置滚屏上下界.
						if (par[0]) par[0]--;
   1f47b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f47f:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f485:	89 d0                	mov    %edx,%eax
   1f487:	c1 e0 03             	shl    $0x3,%eax
   1f48a:	01 d0                	add    %edx,%eax
   1f48c:	c1 e0 04             	shl    $0x4,%eax
   1f48f:	01 c8                	add    %ecx,%eax
   1f491:	83 c0 30             	add    $0x30,%eax
   1f494:	8b 00                	mov    (%eax),%eax
   1f496:	85 c0                	test   %eax,%eax
   1f498:	74 39                	je     1f4d3 <.L194+0x58>
   1f49a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f49e:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f4a4:	89 d0                	mov    %edx,%eax
   1f4a6:	c1 e0 03             	shl    $0x3,%eax
   1f4a9:	01 d0                	add    %edx,%eax
   1f4ab:	c1 e0 04             	shl    $0x4,%eax
   1f4ae:	01 c8                	add    %ecx,%eax
   1f4b0:	83 c0 30             	add    $0x30,%eax
   1f4b3:	8b 00                	mov    (%eax),%eax
   1f4b5:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1f4b8:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f4bc:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f4c2:	89 d0                	mov    %edx,%eax
   1f4c4:	c1 e0 03             	shl    $0x3,%eax
   1f4c7:	01 d0                	add    %edx,%eax
   1f4c9:	c1 e0 04             	shl    $0x4,%eax
   1f4cc:	01 f0                	add    %esi,%eax
   1f4ce:	83 c0 30             	add    $0x30,%eax
   1f4d1:	89 08                	mov    %ecx,(%eax)
						if (!par[1]) par[1] = video_num_lines;
   1f4d3:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f4d7:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f4dd:	89 d0                	mov    %edx,%eax
   1f4df:	c1 e0 03             	shl    $0x3,%eax
   1f4e2:	01 d0                	add    %edx,%eax
   1f4e4:	c1 e0 04             	shl    $0x4,%eax
   1f4e7:	01 c8                	add    %ecx,%eax
   1f4e9:	83 c0 34             	add    $0x34,%eax
   1f4ec:	8b 00                	mov    (%eax),%eax
   1f4ee:	85 c0                	test   %eax,%eax
   1f4f0:	75 21                	jne    1f513 <.L194+0x98>
   1f4f2:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1f4f8:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f4fc:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f502:	89 d0                	mov    %edx,%eax
   1f504:	c1 e0 03             	shl    $0x3,%eax
   1f507:	01 d0                	add    %edx,%eax
   1f509:	c1 e0 04             	shl    $0x4,%eax
   1f50c:	01 f0                	add    %esi,%eax
   1f50e:	83 c0 34             	add    $0x34,%eax
   1f511:	89 08                	mov    %ecx,(%eax)
						if (par[0] < par[1] &&
   1f513:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f517:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f51d:	89 d0                	mov    %edx,%eax
   1f51f:	c1 e0 03             	shl    $0x3,%eax
   1f522:	01 d0                	add    %edx,%eax
   1f524:	c1 e0 04             	shl    $0x4,%eax
   1f527:	01 c8                	add    %ecx,%eax
   1f529:	83 c0 30             	add    $0x30,%eax
   1f52c:	8b 08                	mov    (%eax),%ecx
   1f52e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f532:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1f538:	89 d0                	mov    %edx,%eax
   1f53a:	c1 e0 03             	shl    $0x3,%eax
   1f53d:	01 d0                	add    %edx,%eax
   1f53f:	c1 e0 04             	shl    $0x4,%eax
   1f542:	01 f0                	add    %esi,%eax
   1f544:	83 c0 34             	add    $0x34,%eax
   1f547:	8b 00                	mov    (%eax),%eax
   1f549:	39 c1                	cmp    %eax,%ecx
   1f54b:	0f 83 07 02 00 00    	jae    1f758 <.L191+0x145>
						    par[1] <= video_num_lines) {
   1f551:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f555:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f55b:	89 d0                	mov    %edx,%eax
   1f55d:	c1 e0 03             	shl    $0x3,%eax
   1f560:	01 d0                	add    %edx,%eax
   1f562:	c1 e0 04             	shl    $0x4,%eax
   1f565:	01 c8                	add    %ecx,%eax
   1f567:	83 c0 34             	add    $0x34,%eax
   1f56a:	8b 10                	mov    (%eax),%edx
   1f56c:	8b 83 c4 1e 01 00    	mov    0x11ec4(%ebx),%eax
						if (par[0] < par[1] &&
   1f572:	39 c2                	cmp    %eax,%edx
   1f574:	0f 87 de 01 00 00    	ja     1f758 <.L191+0x145>
							top = par[0];
   1f57a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f57e:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f584:	89 d0                	mov    %edx,%eax
   1f586:	c1 e0 03             	shl    $0x3,%eax
   1f589:	01 d0                	add    %edx,%eax
   1f58b:	c1 e0 04             	shl    $0x4,%eax
   1f58e:	01 c8                	add    %ecx,%eax
   1f590:	83 c0 30             	add    $0x30,%eax
   1f593:	8b 08                	mov    (%eax),%ecx
   1f595:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f599:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1f59f:	89 d0                	mov    %edx,%eax
   1f5a1:	c1 e0 03             	shl    $0x3,%eax
   1f5a4:	01 d0                	add    %edx,%eax
   1f5a6:	c1 e0 04             	shl    $0x4,%eax
   1f5a9:	01 f0                	add    %esi,%eax
   1f5ab:	83 c0 20             	add    $0x20,%eax
   1f5ae:	89 08                	mov    %ecx,(%eax)
							bottom = par[1];
   1f5b0:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f5b4:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f5ba:	89 d0                	mov    %edx,%eax
   1f5bc:	c1 e0 03             	shl    $0x3,%eax
   1f5bf:	01 d0                	add    %edx,%eax
   1f5c1:	c1 e0 04             	shl    $0x4,%eax
   1f5c4:	01 c8                	add    %ecx,%eax
   1f5c6:	83 c0 34             	add    $0x34,%eax
   1f5c9:	8b 08                	mov    (%eax),%ecx
   1f5cb:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f5cf:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1f5d5:	89 d0                	mov    %edx,%eax
   1f5d7:	c1 e0 03             	shl    $0x3,%eax
   1f5da:	01 d0                	add    %edx,%eax
   1f5dc:	c1 e0 04             	shl    $0x4,%eax
   1f5df:	01 f0                	add    %esi,%eax
   1f5e1:	83 c0 30             	add    $0x30,%eax
   1f5e4:	89 08                	mov    %ecx,(%eax)
						}
						break;
   1f5e6:	e9 6d 01 00 00       	jmp    1f758 <.L191+0x145>

0001f5eb <.L195>:
					// 如果字符c是's',则表示保存当前光标所在位置.
					case 's':									// CSI s - 保存光标位置.
						save_cur(currcons);
   1f5eb:	83 ec 0c             	sub    $0xc,%esp
   1f5ee:	ff 74 24 14          	pushl  0x14(%esp)
   1f5f2:	e8 ad ea ff ff       	call   1e0a4 <save_cur>
   1f5f7:	83 c4 10             	add    $0x10,%esp
						break;
   1f5fa:	e9 5a 01 00 00       	jmp    1f759 <.L191+0x146>

0001f5ff <.L196>:
					// 如果字符c是'u',则表示恢复光标到原保存的位置处.
					case 'u':									// CSI u - 恢复保存的光标位置.
						restore_cur(currcons);
   1f5ff:	83 ec 0c             	sub    $0xc,%esp
   1f602:	ff 74 24 14          	pushl  0x14(%esp)
   1f606:	e8 16 eb ff ff       	call   1e121 <restore_cur>
   1f60b:	83 c4 10             	add    $0x10,%esp
						break;
   1f60e:	e9 46 01 00 00       	jmp    1f759 <.L191+0x146>

0001f613 <.L191>:
					// 如果字符c是'l'或'b',则分别表示设置屏幕黑屏间隔时间和设置粗体字符显示.此时参数数组中par[1]和par[2]是特征值,它们分别必须par[1]=par[0]+13;
					// par[2]=par[0]+17.在这个条件下,如果c是字符'l',那么par[0]中是开始黑屏时延迟的分钟数;如果c是字符'b',那么par[0]中是设置的粗体字符属性值.
					case 'l': 									/* blank interval */
					case 'b': 									/* bold attribute */
						  if (!((npar >= 2) &&
   1f613:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f617:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1f61d:	89 d0                	mov    %edx,%eax
   1f61f:	c1 e0 03             	shl    $0x3,%eax
   1f622:	01 d0                	add    %edx,%eax
   1f624:	c1 e0 04             	shl    $0x4,%eax
   1f627:	01 c8                	add    %ecx,%eax
   1f629:	83 c0 30             	add    $0x30,%eax
   1f62c:	8b 00                	mov    (%eax),%eax
   1f62e:	83 f8 01             	cmp    $0x1,%eax
   1f631:	0f 86 89 02 00 00    	jbe    1f8c0 <.L127>
						  ((par[1] - 13) == par[0]) &&
   1f637:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f63b:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f641:	89 d0                	mov    %edx,%eax
   1f643:	c1 e0 03             	shl    $0x3,%eax
   1f646:	01 d0                	add    %edx,%eax
   1f648:	c1 e0 04             	shl    $0x4,%eax
   1f64b:	01 c8                	add    %ecx,%eax
   1f64d:	83 c0 34             	add    $0x34,%eax
   1f650:	8b 00                	mov    (%eax),%eax
   1f652:	8d 70 f3             	lea    -0xd(%eax),%esi
   1f655:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f659:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f65f:	89 d0                	mov    %edx,%eax
   1f661:	c1 e0 03             	shl    $0x3,%eax
   1f664:	01 d0                	add    %edx,%eax
   1f666:	c1 e0 04             	shl    $0x4,%eax
   1f669:	01 c8                	add    %ecx,%eax
   1f66b:	83 c0 30             	add    $0x30,%eax
   1f66e:	8b 00                	mov    (%eax),%eax
						  if (!((npar >= 2) &&
   1f670:	39 c6                	cmp    %eax,%esi
   1f672:	0f 85 48 02 00 00    	jne    1f8c0 <.L127>
						  ((par[2] - 17) == par[0])))
   1f678:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f67c:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f682:	89 d0                	mov    %edx,%eax
   1f684:	c1 e0 03             	shl    $0x3,%eax
   1f687:	01 d0                	add    %edx,%eax
   1f689:	c1 e0 04             	shl    $0x4,%eax
   1f68c:	01 c8                	add    %ecx,%eax
   1f68e:	83 c0 38             	add    $0x38,%eax
   1f691:	8b 00                	mov    (%eax),%eax
   1f693:	8d 70 ef             	lea    -0x11(%eax),%esi
   1f696:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f69a:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f6a0:	89 d0                	mov    %edx,%eax
   1f6a2:	c1 e0 03             	shl    $0x3,%eax
   1f6a5:	01 d0                	add    %edx,%eax
   1f6a7:	c1 e0 04             	shl    $0x4,%eax
   1f6aa:	01 c8                	add    %ecx,%eax
   1f6ac:	83 c0 30             	add    $0x30,%eax
   1f6af:	8b 00                	mov    (%eax),%eax
						  if (!((npar >= 2) &&
   1f6b1:	39 c6                	cmp    %eax,%esi
   1f6b3:	0f 85 07 02 00 00    	jne    1f8c0 <.L127>
						    break;
						if ((c == 'l') && (par[0] >= 0) && (par[0] <= 60))
   1f6b9:	80 7c 24 07 6c       	cmpb   $0x6c,0x7(%esp)
   1f6be:	75 53                	jne    1f713 <.L191+0x100>
   1f6c0:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f6c4:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f6ca:	89 d0                	mov    %edx,%eax
   1f6cc:	c1 e0 03             	shl    $0x3,%eax
   1f6cf:	01 d0                	add    %edx,%eax
   1f6d1:	c1 e0 04             	shl    $0x4,%eax
   1f6d4:	01 c8                	add    %ecx,%eax
   1f6d6:	83 c0 30             	add    $0x30,%eax
   1f6d9:	8b 00                	mov    (%eax),%eax
   1f6db:	83 f8 3c             	cmp    $0x3c,%eax
   1f6de:	77 33                	ja     1f713 <.L191+0x100>
						{
						  blankinterval = HZ * 60 * par[0];
   1f6e0:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f6e4:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f6ea:	89 d0                	mov    %edx,%eax
   1f6ec:	c1 e0 03             	shl    $0x3,%eax
   1f6ef:	01 d0                	add    %edx,%eax
   1f6f1:	c1 e0 04             	shl    $0x4,%eax
   1f6f4:	01 c8                	add    %ecx,%eax
   1f6f6:	83 c0 30             	add    $0x30,%eax
   1f6f9:	8b 00                	mov    (%eax),%eax
   1f6fb:	69 c0 70 17 00 00    	imul   $0x1770,%eax,%eax
   1f701:	89 83 a4 1e 01 00    	mov    %eax,0x11ea4(%ebx)
						  blankcount = blankinterval;
   1f707:	8b 83 a4 1e 01 00    	mov    0x11ea4(%ebx),%eax
   1f70d:	89 83 a8 1e 01 00    	mov    %eax,0x11ea8(%ebx)
						}
						if (c == 'b')
   1f713:	80 7c 24 07 62       	cmpb   $0x62,0x7(%esp)
   1f718:	0f 85 a2 01 00 00    	jne    1f8c0 <.L127>
						  vc_cons[currcons].vc_bold_attr = par[0];
   1f71e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f722:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1f728:	89 d0                	mov    %edx,%eax
   1f72a:	c1 e0 03             	shl    $0x3,%eax
   1f72d:	01 d0                	add    %edx,%eax
   1f72f:	c1 e0 04             	shl    $0x4,%eax
   1f732:	01 c8                	add    %ecx,%eax
   1f734:	83 c0 30             	add    $0x30,%eax
   1f737:	8b 00                	mov    (%eax),%eax
   1f739:	89 c6                	mov    %eax,%esi
   1f73b:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f73f:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1f745:	89 d0                	mov    %edx,%eax
   1f747:	c1 e0 03             	shl    $0x3,%eax
   1f74a:	01 d0                	add    %edx,%eax
   1f74c:	c1 e0 04             	shl    $0x4,%eax
   1f74f:	01 c8                	add    %ecx,%eax
   1f751:	89 30                	mov    %esi,(%eax)
   1f753:	e9 68 01 00 00       	jmp    1f8c0 <.L127>
						break;
   1f758:	90                   	nop
				}
				break;
   1f759:	e9 62 01 00 00       	jmp    1f8c0 <.L127>

0001f75e <.L139>:
			// ESfunckey:表示接收到了键盘上功能键发出的一个序列,不用显示.于是恢复到正常状态ESnormal.
			// 状态ESfunckey表示接收到了键盘上功能键发出的一个序列,不用显示.于是恢复到正常状态ESnormal.
			case ESfunckey:									// 键盘功能键码.
				state = ESnormal;
   1f75e:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f762:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1f768:	89 d0                	mov    %edx,%eax
   1f76a:	c1 e0 03             	shl    $0x3,%eax
   1f76d:	01 d0                	add    %edx,%eax
   1f76f:	c1 e0 04             	shl    $0x4,%eax
   1f772:	01 c8                	add    %ecx,%eax
   1f774:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				break;
   1f77a:	e9 41 01 00 00       	jmp    1f8c0 <.L127>

0001f77f <.L140>:
			// ESsetterm:表示处于设备控制字符串序列状态(DCS).此时收到字符'S',则恢复初始的显示字符属性.若收到的字符是'L'或'l',则开启或关折行显示方式.
			// 状态ESsetterm表示处于设备控制字符串序列状态(DCS).此时若收到字符'S',则恢复初始的显示字符属性.若收到的字符是'L'或'l',则开启或关闭折行显示方式.
			case ESsetterm:  								/* Setterm functions. */
				state = ESnormal;
   1f77f:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f783:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1f789:	89 d0                	mov    %edx,%eax
   1f78b:	c1 e0 03             	shl    $0x3,%eax
   1f78e:	01 d0                	add    %edx,%eax
   1f790:	c1 e0 04             	shl    $0x4,%eax
   1f793:	01 c8                	add    %ecx,%eax
   1f795:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				if (c == 'S') {
   1f79b:	80 7c 24 07 53       	cmpb   $0x53,0x7(%esp)
   1f7a0:	0f 85 1a 01 00 00    	jne    1f8c0 <.L127>
					def_attr = attr;
   1f7a6:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f7aa:	8d 8b e2 1e 01 00    	lea    0x11ee2(%ebx),%ecx
   1f7b0:	89 d0                	mov    %edx,%eax
   1f7b2:	c1 e0 03             	shl    $0x3,%eax
   1f7b5:	01 d0                	add    %edx,%eax
   1f7b7:	c1 e0 04             	shl    $0x4,%eax
   1f7ba:	01 c8                	add    %ecx,%eax
   1f7bc:	0f b6 08             	movzbl (%eax),%ecx
   1f7bf:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f7c3:	8d b3 e3 1e 01 00    	lea    0x11ee3(%ebx),%esi
   1f7c9:	89 d0                	mov    %edx,%eax
   1f7cb:	c1 e0 03             	shl    $0x3,%eax
   1f7ce:	01 d0                	add    %edx,%eax
   1f7d0:	c1 e0 04             	shl    $0x4,%eax
   1f7d3:	01 f0                	add    %esi,%eax
   1f7d5:	88 08                	mov    %cl,(%eax)
					video_erase_char = (video_erase_char & 0x0ff) | (def_attr << 8);
   1f7d7:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f7db:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1f7e1:	89 d0                	mov    %edx,%eax
   1f7e3:	c1 e0 03             	shl    $0x3,%eax
   1f7e6:	01 d0                	add    %edx,%eax
   1f7e8:	c1 e0 04             	shl    $0x4,%eax
   1f7eb:	01 c8                	add    %ecx,%eax
   1f7ed:	0f b7 00             	movzwl (%eax),%eax
   1f7f0:	0f b6 c8             	movzbl %al,%ecx
   1f7f3:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f7f7:	8d b3 e3 1e 01 00    	lea    0x11ee3(%ebx),%esi
   1f7fd:	89 d0                	mov    %edx,%eax
   1f7ff:	c1 e0 03             	shl    $0x3,%eax
   1f802:	01 d0                	add    %edx,%eax
   1f804:	c1 e0 04             	shl    $0x4,%eax
   1f807:	01 f0                	add    %esi,%eax
   1f809:	0f b6 00             	movzbl (%eax),%eax
   1f80c:	0f b6 c0             	movzbl %al,%eax
   1f80f:	c1 e0 08             	shl    $0x8,%eax
   1f812:	09 c8                	or     %ecx,%eax
   1f814:	89 c6                	mov    %eax,%esi
   1f816:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f81a:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1f820:	89 d0                	mov    %edx,%eax
   1f822:	c1 e0 03             	shl    $0x3,%eax
   1f825:	01 d0                	add    %edx,%eax
   1f827:	c1 e0 04             	shl    $0x4,%eax
   1f82a:	01 c8                	add    %ecx,%eax
   1f82c:	66 89 30             	mov    %si,(%eax)
				} else if (c == 'L')
					; 										/*linewrap on*/
				else if (c == 'l')
					; 										/*linewrap off*/
				break;
   1f82f:	e9 8c 00 00 00       	jmp    1f8c0 <.L127>

0001f834 <.L141>:
			// ESsetgraph:表示收到设置字符转移序列'ESC ('或'ESC )'.它们分别用于指定G0和G1所用的字符集.此时若收到字符'0',则选择图形字符集作为G0和G1,
			//            若收到的字符是'B',这选择普通ASCII字符集作为G0和G1的字符集.
			// 状态ESsetgraph表示收到设置字符集转移序列'ESC ('或'ESC )'.它们分别用于指定G0和G1所用的字符集.此时若收到字符'0',则选择图形字符集作为G0和G1,若收
			// 到的字符是'B',则选择普通ASCII字符集作为G0和G1的字符集.
			case ESsetgraph:								// 'CSI ( 0'或'CSI ( B' - 选择字符集
				state = ESnormal;
   1f834:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f838:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1f83e:	89 d0                	mov    %edx,%eax
   1f840:	c1 e0 03             	shl    $0x3,%eax
   1f843:	01 d0                	add    %edx,%eax
   1f845:	c1 e0 04             	shl    $0x4,%eax
   1f848:	01 c8                	add    %ecx,%eax
   1f84a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				if (c == '0')
   1f850:	80 7c 24 07 30       	cmpb   $0x30,0x7(%esp)
   1f855:	75 23                	jne    1f87a <.L141+0x46>
					translate = GRAF_TRANS;
   1f857:	8b 8b c4 15 00 00    	mov    0x15c4(%ebx),%ecx
   1f85d:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f861:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1f867:	89 d0                	mov    %edx,%eax
   1f869:	c1 e0 03             	shl    $0x3,%eax
   1f86c:	01 d0                	add    %edx,%eax
   1f86e:	c1 e0 04             	shl    $0x4,%eax
   1f871:	01 f0                	add    %esi,%eax
   1f873:	83 e8 80             	sub    $0xffffff80,%eax
   1f876:	89 08                	mov    %ecx,(%eax)
   1f878:	eb 46                	jmp    1f8c0 <.L127>
				else if (c == 'B')
   1f87a:	80 7c 24 07 42       	cmpb   $0x42,0x7(%esp)
   1f87f:	75 3f                	jne    1f8c0 <.L127>
					translate = NORM_TRANS;
   1f881:	8b 8b c0 15 00 00    	mov    0x15c0(%ebx),%ecx
   1f887:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f88b:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1f891:	89 d0                	mov    %edx,%eax
   1f893:	c1 e0 03             	shl    $0x3,%eax
   1f896:	01 d0                	add    %edx,%eax
   1f898:	c1 e0 04             	shl    $0x4,%eax
   1f89b:	01 f0                	add    %esi,%eax
   1f89d:	83 e8 80             	sub    $0xffffff80,%eax
   1f8a0:	89 08                	mov    %ecx,(%eax)
				break;
   1f8a2:	eb 1c                	jmp    1f8c0 <.L127>
			default:
				state = ESnormal;
   1f8a4:	8b 54 24 08          	mov    0x8(%esp),%edx
   1f8a8:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1f8ae:	89 d0                	mov    %edx,%eax
   1f8b0:	c1 e0 03             	shl    $0x3,%eax
   1f8b3:	01 d0                	add    %edx,%eax
   1f8b5:	c1 e0 04             	shl    $0x4,%eax
   1f8b8:	01 c8                	add    %ecx,%eax
   1f8ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

0001f8c0 <.L127>:
	while (nr--) {
   1f8c0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1f8c4:	8d 50 ff             	lea    -0x1(%eax),%edx
   1f8c7:	89 54 24 0c          	mov    %edx,0xc(%esp)
   1f8cb:	85 c0                	test   %eax,%eax
   1f8cd:	0f 85 0b e9 ff ff    	jne    1e1de <con_write+0x6a>
   1f8d3:	eb 01                	jmp    1f8d6 <.L127+0x16>
			break;
   1f8d5:	90                   	nop
        }
    }
	set_cursor(currcons);									// 最后根据上面设置的光标位置,设置显示控制器中光标位置.
   1f8d6:	83 ec 0c             	sub    $0xc,%esp
   1f8d9:	ff 74 24 14          	pushl  0x14(%esp)
   1f8dd:	e8 e7 e1 ff ff       	call   1dac9 <set_cursor>
   1f8e2:	83 c4 10             	add    $0x10,%esp
}
   1f8e5:	90                   	nop
   1f8e6:	83 c4 10             	add    $0x10,%esp
   1f8e9:	5b                   	pop    %ebx
   1f8ea:	5e                   	pop    %esi
   1f8eb:	5f                   	pop    %edi
   1f8ec:	c3                   	ret    

0001f8ed <con_init>:
 *
 * 这个子程序初始化控制台中断,其他什么都不做.如果你想让屏幕干净的话,就使用适当的转义字符序列调用tty_write()函数.
 * 读取setup.s程序保存的信息,用以确定当前显示器类型,并且设置所有相关参数.
 */
void con_init(void)
{
   1f8ed:	57                   	push   %edi
   1f8ee:	56                   	push   %esi
   1f8ef:	53                   	push   %ebx
   1f8f0:	83 ec 20             	sub    $0x20,%esp
   1f8f3:	e8 02 74 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1f8f8:	81 c3 08 27 01 00    	add    $0x12708,%ebx
	register unsigned char a;
	char *display_desc = "????";
   1f8fe:	8d 83 e4 66 ff ff    	lea    -0x991c(%ebx),%eax
   1f904:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	char *display_ptr;
	int currcons = 0;								// 当前虚拟控制台号.
   1f908:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   1f90f:	00 
	long base, term;
	long video_memory;

	// 初始化屏幕的列数
	video_num_columns = ORIG_VIDEO_COLS;
   1f910:	b8 06 00 09 00       	mov    $0x90006,%eax
   1f915:	0f b7 00             	movzwl (%eax),%eax
   1f918:	66 c1 e8 08          	shr    $0x8,%ax
   1f91c:	0f b7 c0             	movzwl %ax,%eax
   1f91f:	89 83 b4 1e 01 00    	mov    %eax,0x11eb4(%ebx)
	// 屏幕每行的字节数等于屏幕列数乘以2，因为一个显示字节需要一个控制字节
	video_size_row = video_num_columns * 2;
   1f925:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   1f92b:	01 c0                	add    %eax,%eax
   1f92d:	89 83 c0 1e 01 00    	mov    %eax,0x11ec0(%ebx)
	// 初始化屏幕的行数
	video_num_lines = ORIG_VIDEO_LINES;
   1f933:	b8 0e 00 09 00       	mov    $0x9000e,%eax
   1f938:	0f b7 00             	movzwl (%eax),%eax
   1f93b:	0f b7 c0             	movzwl %ax,%eax
   1f93e:	0f b6 c0             	movzbl %al,%eax
   1f941:	89 83 c4 1e 01 00    	mov    %eax,0x11ec4(%ebx)
	// 初始化显示页数
	video_page = ORIG_VIDEO_PAGE;
   1f947:	b8 04 00 09 00       	mov    $0x90004,%eax
   1f94c:	0f b7 00             	movzwl (%eax),%eax
   1f94f:	88 83 c8 1e 01 00    	mov    %al,0x11ec8(%ebx)
	// 设置此时第0个(currcons)显示终端的擦除字符属性及字符
	video_erase_char = 0x0720;
   1f955:	8b 54 24 14          	mov    0x14(%esp),%edx
   1f959:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1f95f:	89 d0                	mov    %edx,%eax
   1f961:	c1 e0 03             	shl    $0x3,%eax
   1f964:	01 d0                	add    %edx,%eax
   1f966:	c1 e0 04             	shl    $0x4,%eax
   1f969:	01 c8                	add    %ecx,%eax
   1f96b:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// 初始化黑屏时间计数
	blankcount = blankinterval;
   1f970:	8b 83 a4 1e 01 00    	mov    0x11ea4(%ebx),%eax
   1f976:	89 83 a8 1e 01 00    	mov    %eax,0x11ea8(%ebx)

	// 然后根据显示模式是单色还是彩色,分别设置所使用的显示内存起始位置以及显示寄存器索引端口号和显示寄存器数据端口号.如果获得的BIOS显示方式等于7,
	// 则表示是单色显示卡.
	if (ORIG_VIDEO_MODE == 7)					/* Is this a monochrome display? */
   1f97c:	b8 06 00 09 00       	mov    $0x90006,%eax
   1f981:	0f b7 00             	movzwl (%eax),%eax
   1f984:	0f b7 c0             	movzwl %ax,%eax
   1f987:	0f b6 c0             	movzbl %al,%eax
   1f98a:	83 f8 07             	cmp    $0x7,%eax
   1f98d:	75 6c                	jne    1f9fb <con_init+0x10e>
	{
		video_mem_base = 0xb0000;				// 设置单显映像内存起始地址.
   1f98f:	c7 83 b8 1e 01 00 00 	movl   $0xb0000,0x11eb8(%ebx)
   1f996:	00 0b 00 
		video_port_reg = 0x3b4;					// 设置单显索引寄存器端口.
   1f999:	66 c7 83 ca 1e 01 00 	movw   $0x3b4,0x11eca(%ebx)
   1f9a0:	b4 03 
		video_port_val = 0x3b5;					// 设置单显数据寄存器端口.
   1f9a2:	66 c7 83 cc 1e 01 00 	movw   $0x3b5,0x11ecc(%ebx)
   1f9a9:	b5 03 
		// 0x10,则说明是EGA卡.因此初始显示类型为EGA单色.虽然EGA卡上有较多显示内存,但在单色方式下最多只能利用地址范围在0xb0000~xb8000之间的显示内存.
		// 然后置显示器描述字符串为'EGAm'.
		// 并会在系统初始化期间显示器描述符字符串将显示在屏幕的右上角.
		// 注意,这里使用了bx在调用中断int 0x10前后是否被改变的方法来判断卡的类型.若BL在中断调用后值被改变,表示显示卡支持ah=12h功能调用,是EGA或后推
		// 出来的VGA等类型显示卡.若中断调用返回值末变,表示显示卡不支持这个功能,则说明是一般单色显示卡.
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   1f9ab:	b8 0a 00 09 00       	mov    $0x9000a,%eax
   1f9b0:	0f b7 00             	movzwl (%eax),%eax
   1f9b3:	0f b7 c0             	movzwl %ax,%eax
   1f9b6:	0f b6 c0             	movzbl %al,%eax
   1f9b9:	83 f8 10             	cmp    $0x10,%eax
   1f9bc:	74 20                	je     1f9de <con_init+0xf1>
		{
			video_type = VIDEO_TYPE_EGAM;		// 设置显示类型(EGA单色).
   1f9be:	c6 83 b0 1e 01 00 20 	movb   $0x20,0x11eb0(%ebx)
			video_mem_term = 0xb8000;			// 设置显示内存末端地址.
   1f9c5:	c7 83 bc 1e 01 00 00 	movl   $0xb8000,0x11ebc(%ebx)
   1f9cc:	80 0b 00 
			display_desc = "EGAm";				// 设置显示描述字符串.
   1f9cf:	8d 83 e9 66 ff ff    	lea    -0x9917(%ebx),%eax
   1f9d5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1f9d9:	e9 8e 00 00 00       	jmp    1fa6c <con_init+0x17f>
		}
		// 如果BX寄存器的值等于0x10,则说明是单色显示卡MDA,仅有8KB显示内存.
		else
		{
			video_type = VIDEO_TYPE_MDA;		// 设置显示类型(MDA单色).
   1f9de:	c6 83 b0 1e 01 00 10 	movb   $0x10,0x11eb0(%ebx)
			video_mem_term = 0xb2000;			// 设置显示内存末端地址.
   1f9e5:	c7 83 bc 1e 01 00 00 	movl   $0xb2000,0x11ebc(%ebx)
   1f9ec:	20 0b 00 
			display_desc = "*MDA";				// 设置显示描述字符串.
   1f9ef:	8d 83 ee 66 ff ff    	lea    -0x9912(%ebx),%eax
   1f9f5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1f9f9:	eb 71                	jmp    1fa6c <con_init+0x17f>
		}
	}
	// 如果显示方式不为7,说明是彩色显示卡.此时文本方式下所用显示内存起始地址为0xb8000;显示控制索引寄存器端口地址为0x3d4;数据寄存器端口地址为0x3d5.
	else										/* If not, it is color. */
	{
		can_do_colour = 1;						// 设置彩色显示标志.
   1f9fb:	c7 83 d0 1e 01 00 01 	movl   $0x1,0x11ed0(%ebx)
   1fa02:	00 00 00 
		video_mem_base = 0xb8000;				// 显示内存起始地址.
   1fa05:	c7 83 b8 1e 01 00 00 	movl   $0xb8000,0x11eb8(%ebx)
   1fa0c:	80 0b 00 
		video_port_reg	= 0x3d4;				// 设置彩色显示索引寄存器端口.
   1fa0f:	66 c7 83 ca 1e 01 00 	movw   $0x3d4,0x11eca(%ebx)
   1fa16:	d4 03 
		video_port_val	= 0x3d5;				// 设置彩色显示数据寄存器端口.
   1fa18:	66 c7 83 cc 1e 01 00 	movw   $0x3d5,0x11ecc(%ebx)
   1fa1f:	d5 03 
		// 再判断显示卡类别.如果BX不等于0x10,则说明是EGA显示卡,此时共有32KB显示内存可用(0xb8000~0xc0000).否则说明是CGA显示卡,只能使用8KB显示内存(
		// 0xb8000~0xba000).
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   1fa21:	b8 0a 00 09 00       	mov    $0x9000a,%eax
   1fa26:	0f b7 00             	movzwl (%eax),%eax
   1fa29:	0f b7 c0             	movzwl %ax,%eax
   1fa2c:	0f b6 c0             	movzbl %al,%eax
   1fa2f:	83 f8 10             	cmp    $0x10,%eax
   1fa32:	74 1d                	je     1fa51 <con_init+0x164>
		{
			video_type = VIDEO_TYPE_EGAC;		// 设置显示类型(EGA彩色).
   1fa34:	c6 83 b0 1e 01 00 21 	movb   $0x21,0x11eb0(%ebx)
			video_mem_term = 0xc0000;			// 设置显示内存末端地址.
   1fa3b:	c7 83 bc 1e 01 00 00 	movl   $0xc0000,0x11ebc(%ebx)
   1fa42:	00 0c 00 
			display_desc = "EGAc";				// 设置显示描述字符串.
   1fa45:	8d 83 f3 66 ff ff    	lea    -0x990d(%ebx),%eax
   1fa4b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1fa4f:	eb 1b                	jmp    1fa6c <con_init+0x17f>
		}
		else
		{
			video_type = VIDEO_TYPE_CGA;		// 设置显示类型(CGA).
   1fa51:	c6 83 b0 1e 01 00 11 	movb   $0x11,0x11eb0(%ebx)
			video_mem_term = 0xba000;			// 设置显示内存末端地址.
   1fa58:	c7 83 bc 1e 01 00 00 	movl   $0xba000,0x11ebc(%ebx)
   1fa5f:	a0 0b 00 
			display_desc = "*CGA";				// 设置显示描述字符串.
   1fa62:	8d 83 f8 66 ff ff    	lea    -0x9908(%ebx),%eax
   1fa68:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	// 现在来计算当前显示卡内存上可以开设的虚拟控制台数量.硬件允许的虚拟控制台数量等于总显示内存量video_memory除以每个虚拟控制台占用的
	// 字节数.每个虚拟控制台占用的显示内存数等于屏幕显示数video_num_lines乘上每行字符占有的字节数video_size_row.
	// 如果硬件允许开设的虚拟控制台数量大于系统既定的数量MAX_CONSOLES,就把虚拟控制台数量设置为MAX_CONSOLES.若这样计算出的虚拟控制台
	// 数量为0,则设置为1.
	// 最后用显示内存数除以判断出的虚拟控制台数即得到每个虚拟控制台占用显示内存字节数.
	video_memory = video_mem_term - video_mem_base;
   1fa6c:	8b 93 bc 1e 01 00    	mov    0x11ebc(%ebx),%edx
   1fa72:	8b 83 b8 1e 01 00    	mov    0x11eb8(%ebx),%eax
   1fa78:	29 c2                	sub    %eax,%edx
   1fa7a:	89 d0                	mov    %edx,%eax
   1fa7c:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 根据实际的显示内存的大小计算显示控制终端的实际数量
	NR_CONSOLES = video_memory / (video_num_lines * video_size_row);
   1fa80:	8b 44 24 08          	mov    0x8(%esp),%eax
   1fa84:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1fa8a:	8b 93 c0 1e 01 00    	mov    0x11ec0(%ebx),%edx
   1fa90:	89 d7                	mov    %edx,%edi
   1fa92:	0f af f9             	imul   %ecx,%edi
   1fa95:	ba 00 00 00 00       	mov    $0x0,%edx
   1fa9a:	f7 f7                	div    %edi
   1fa9c:	89 83 a0 1e 01 00    	mov    %eax,0x11ea0(%ebx)
	// 显示终端的最大数量是MAX_CONSOLES,设置在tty.h头文件中
	if (NR_CONSOLES > MAX_CONSOLES)
   1faa2:	8b 83 a0 1e 01 00    	mov    0x11ea0(%ebx),%eax
   1faa8:	83 f8 08             	cmp    $0x8,%eax
   1faab:	7e 0a                	jle    1fab7 <con_init+0x1ca>
		NR_CONSOLES = MAX_CONSOLES;
   1faad:	c7 83 a0 1e 01 00 08 	movl   $0x8,0x11ea0(%ebx)
   1fab4:	00 00 00 
	// 如果计算出来的显示终端数量为0，则将显示终端数量设置为1
	if (!NR_CONSOLES)
   1fab7:	8b 83 a0 1e 01 00    	mov    0x11ea0(%ebx),%eax
   1fabd:	85 c0                	test   %eax,%eax
   1fabf:	75 0a                	jne    1facb <con_init+0x1de>
		NR_CONSOLES = 1;
   1fac1:	c7 83 a0 1e 01 00 01 	movl   $0x1,0x11ea0(%ebx)
   1fac8:	00 00 00 
	video_memory /= NR_CONSOLES;				// 每个虚拟控制台占用显示内存字节数.
   1facb:	8b bb a0 1e 01 00    	mov    0x11ea0(%ebx),%edi
   1fad1:	8b 44 24 08          	mov    0x8(%esp),%eax
   1fad5:	99                   	cltd   
   1fad6:	f7 ff                	idiv   %edi
   1fad8:	89 44 24 08          	mov    %eax,0x8(%esp)

	/* Let the user known what kind of display driver we are using */

	// 然后我们在屏幕的右上角显示描述字符串.采用的方法是直接将字符串写到显示内存的相应位置处.首先将显示指针display_ptr指到屏幕第1行右端差
	// 4个字符处(每个字符需2个字节,因此减8),然后循环复制字符串的字符,并且每复制1个字符都空开1个属性字节.
	display_ptr = ((char *)video_mem_base) + video_size_row - 8;
   1fadc:	8b 93 c0 1e 01 00    	mov    0x11ec0(%ebx),%edx
   1fae2:	8b 83 b8 1e 01 00    	mov    0x11eb8(%ebx),%eax
   1fae8:	01 d0                	add    %edx,%eax
   1faea:	83 e8 08             	sub    $0x8,%eax
   1faed:	89 44 24 18          	mov    %eax,0x18(%esp)
	while (*display_desc)
   1faf1:	eb 20                	jmp    1fb13 <con_init+0x226>
	{
		*display_ptr++ = *display_desc++;
   1faf3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1faf7:	8d 42 01             	lea    0x1(%edx),%eax
   1fafa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1fafe:	8b 44 24 18          	mov    0x18(%esp),%eax
   1fb02:	8d 48 01             	lea    0x1(%eax),%ecx
   1fb05:	89 4c 24 18          	mov    %ecx,0x18(%esp)
   1fb09:	0f b6 12             	movzbl (%edx),%edx
   1fb0c:	88 10                	mov    %dl,(%eax)
		display_ptr++;
   1fb0e:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
	while (*display_desc)
   1fb13:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1fb17:	0f b6 00             	movzbl (%eax),%eax
   1fb1a:	84 c0                	test   %al,%al
   1fb1c:	75 d5                	jne    1faf3 <con_init+0x206>
	/* 初始化用于滚屏的变量(主要用于EGA/VGA) */

	// 注意,此时当前虚拟控制台号curcons已经被初始化0.因此下面实际上是初始化0号虚拟控制台的结构vc_cons[0]中的所有字段值.下面首先设置0号控制台
	// 的默认滚屏开始位置video_mem_start和默认滚屏末行内存位置,实际上它们也就是0号控制台占用的部分显示内存区域.然后初始化设置0号虚拟控制台的
	// 其它属性和标志值.
	base = origin = video_mem_start = video_mem_base;						// 默认滚屏开始内存位置.
   1fb1e:	8b 8b b8 1e 01 00    	mov    0x11eb8(%ebx),%ecx
   1fb24:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fb28:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1fb2e:	89 d0                	mov    %edx,%eax
   1fb30:	c1 e0 03             	shl    $0x3,%eax
   1fb33:	01 d0                	add    %edx,%eax
   1fb35:	c1 e0 04             	shl    $0x4,%eax
   1fb38:	01 f0                	add    %esi,%eax
   1fb3a:	83 c0 70             	add    $0x70,%eax
   1fb3d:	89 08                	mov    %ecx,(%eax)
   1fb3f:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fb43:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1fb49:	89 d0                	mov    %edx,%eax
   1fb4b:	c1 e0 03             	shl    $0x3,%eax
   1fb4e:	01 d0                	add    %edx,%eax
   1fb50:	c1 e0 04             	shl    $0x4,%eax
   1fb53:	01 c8                	add    %ecx,%eax
   1fb55:	83 c0 70             	add    $0x70,%eax
   1fb58:	8b 08                	mov    (%eax),%ecx
   1fb5a:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fb5e:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1fb64:	89 d0                	mov    %edx,%eax
   1fb66:	c1 e0 03             	shl    $0x3,%eax
   1fb69:	01 d0                	add    %edx,%eax
   1fb6b:	c1 e0 04             	shl    $0x4,%eax
   1fb6e:	01 f0                	add    %esi,%eax
   1fb70:	83 c0 10             	add    $0x10,%eax
   1fb73:	89 08                	mov    %ecx,(%eax)
   1fb75:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fb79:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1fb7f:	89 d0                	mov    %edx,%eax
   1fb81:	c1 e0 03             	shl    $0x3,%eax
   1fb84:	01 d0                	add    %edx,%eax
   1fb86:	c1 e0 04             	shl    $0x4,%eax
   1fb89:	01 c8                	add    %ecx,%eax
   1fb8b:	83 c0 10             	add    $0x10,%eax
   1fb8e:	8b 00                	mov    (%eax),%eax
   1fb90:	89 44 24 10          	mov    %eax,0x10(%esp)
	term = video_mem_end = base + video_memory;								// 0号屏幕内存末端位置.
   1fb94:	8b 54 24 10          	mov    0x10(%esp),%edx
   1fb98:	8b 44 24 08          	mov    0x8(%esp),%eax
   1fb9c:	01 d0                	add    %edx,%eax
   1fb9e:	89 c6                	mov    %eax,%esi
   1fba0:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fba4:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1fbaa:	89 d0                	mov    %edx,%eax
   1fbac:	c1 e0 03             	shl    $0x3,%eax
   1fbaf:	01 d0                	add    %edx,%eax
   1fbb1:	c1 e0 04             	shl    $0x4,%eax
   1fbb4:	01 c8                	add    %ecx,%eax
   1fbb6:	83 c0 70             	add    $0x70,%eax
   1fbb9:	89 30                	mov    %esi,(%eax)
   1fbbb:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fbbf:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1fbc5:	89 d0                	mov    %edx,%eax
   1fbc7:	c1 e0 03             	shl    $0x3,%eax
   1fbca:	01 d0                	add    %edx,%eax
   1fbcc:	c1 e0 04             	shl    $0x4,%eax
   1fbcf:	01 c8                	add    %ecx,%eax
   1fbd1:	83 c0 70             	add    $0x70,%eax
   1fbd4:	8b 00                	mov    (%eax),%eax
   1fbd6:	89 44 24 0c          	mov    %eax,0xc(%esp)
	scr_end	= video_mem_start + video_num_lines * video_size_row;			// 滚屏末端位置.
   1fbda:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fbde:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1fbe4:	89 d0                	mov    %edx,%eax
   1fbe6:	c1 e0 03             	shl    $0x3,%eax
   1fbe9:	01 d0                	add    %edx,%eax
   1fbeb:	c1 e0 04             	shl    $0x4,%eax
   1fbee:	01 c8                	add    %ecx,%eax
   1fbf0:	83 c0 70             	add    $0x70,%eax
   1fbf3:	8b 10                	mov    (%eax),%edx
   1fbf5:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1fbfb:	8b 83 c0 1e 01 00    	mov    0x11ec0(%ebx),%eax
   1fc01:	0f af c1             	imul   %ecx,%eax
   1fc04:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1fc07:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fc0b:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1fc11:	89 d0                	mov    %edx,%eax
   1fc13:	c1 e0 03             	shl    $0x3,%eax
   1fc16:	01 d0                	add    %edx,%eax
   1fc18:	c1 e0 04             	shl    $0x4,%eax
   1fc1b:	01 f0                	add    %esi,%eax
   1fc1d:	83 c0 10             	add    $0x10,%eax
   1fc20:	89 08                	mov    %ecx,(%eax)
	top	= 0;																// 初始设置滚动时顶行行号.
   1fc22:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fc26:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1fc2c:	89 d0                	mov    %edx,%eax
   1fc2e:	c1 e0 03             	shl    $0x3,%eax
   1fc31:	01 d0                	add    %edx,%eax
   1fc33:	c1 e0 04             	shl    $0x4,%eax
   1fc36:	01 c8                	add    %ecx,%eax
   1fc38:	83 c0 20             	add    $0x20,%eax
   1fc3b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	bottom	= video_num_lines;												// 初始设置滚动时底行行号.
   1fc41:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1fc47:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fc4b:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1fc51:	89 d0                	mov    %edx,%eax
   1fc53:	c1 e0 03             	shl    $0x3,%eax
   1fc56:	01 d0                	add    %edx,%eax
   1fc58:	c1 e0 04             	shl    $0x4,%eax
   1fc5b:	01 f0                	add    %esi,%eax
   1fc5d:	83 c0 30             	add    $0x30,%eax
   1fc60:	89 08                	mov    %ecx,(%eax)
	attr = 0x07;															// 初始设置显示字符属性(黑底白字).
   1fc62:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fc66:	8d 8b e2 1e 01 00    	lea    0x11ee2(%ebx),%ecx
   1fc6c:	89 d0                	mov    %edx,%eax
   1fc6e:	c1 e0 03             	shl    $0x3,%eax
   1fc71:	01 d0                	add    %edx,%eax
   1fc73:	c1 e0 04             	shl    $0x4,%eax
   1fc76:	01 c8                	add    %ecx,%eax
   1fc78:	c6 00 07             	movb   $0x7,(%eax)
	def_attr = 0x07;														// 设置默认显示字符属性.
   1fc7b:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fc7f:	8d 8b e3 1e 01 00    	lea    0x11ee3(%ebx),%ecx
   1fc85:	89 d0                	mov    %edx,%eax
   1fc87:	c1 e0 03             	shl    $0x3,%eax
   1fc8a:	01 d0                	add    %edx,%eax
   1fc8c:	c1 e0 04             	shl    $0x4,%eax
   1fc8f:	01 c8                	add    %ecx,%eax
   1fc91:	c6 00 07             	movb   $0x7,(%eax)
	restate = state = ESnormal;												// 初始化转义序列操作的前和下一状态.
   1fc94:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fc98:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1fc9e:	89 d0                	mov    %edx,%eax
   1fca0:	c1 e0 03             	shl    $0x3,%eax
   1fca3:	01 d0                	add    %edx,%eax
   1fca5:	c1 e0 04             	shl    $0x4,%eax
   1fca8:	01 c8                	add    %ecx,%eax
   1fcaa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1fcb0:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fcb4:	8d 8b ec 1e 01 00    	lea    0x11eec(%ebx),%ecx
   1fcba:	89 d0                	mov    %edx,%eax
   1fcbc:	c1 e0 03             	shl    $0x3,%eax
   1fcbf:	01 d0                	add    %edx,%eax
   1fcc1:	c1 e0 04             	shl    $0x4,%eax
   1fcc4:	01 c8                	add    %ecx,%eax
   1fcc6:	8b 08                	mov    (%eax),%ecx
   1fcc8:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fccc:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   1fcd2:	89 d0                	mov    %edx,%eax
   1fcd4:	c1 e0 03             	shl    $0x3,%eax
   1fcd7:	01 d0                	add    %edx,%eax
   1fcd9:	c1 e0 04             	shl    $0x4,%eax
   1fcdc:	01 f0                	add    %esi,%eax
   1fcde:	83 c0 10             	add    $0x10,%eax
   1fce1:	89 08                	mov    %ecx,(%eax)
	checkin = 0;
   1fce3:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fce7:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   1fced:	89 d0                	mov    %edx,%eax
   1fcef:	c1 e0 03             	shl    $0x3,%eax
   1fcf2:	01 d0                	add    %edx,%eax
   1fcf4:	c1 e0 04             	shl    $0x4,%eax
   1fcf7:	01 c8                	add    %ecx,%eax
   1fcf9:	83 c0 10             	add    $0x10,%eax
   1fcfc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	ques = 0;																// 收到问号字符标志.
   1fd02:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fd06:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1fd0c:	89 d0                	mov    %edx,%eax
   1fd0e:	c1 e0 03             	shl    $0x3,%eax
   1fd11:	01 d0                	add    %edx,%eax
   1fd13:	c1 e0 04             	shl    $0x4,%eax
   1fd16:	01 c8                	add    %ecx,%eax
   1fd18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	iscolor = 0;															// 彩色显示标志.
   1fd1e:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fd22:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1fd28:	89 d0                	mov    %edx,%eax
   1fd2a:	c1 e0 03             	shl    $0x3,%eax
   1fd2d:	01 d0                	add    %edx,%eax
   1fd2f:	c1 e0 04             	shl    $0x4,%eax
   1fd32:	01 c8                	add    %ecx,%eax
   1fd34:	83 e8 80             	sub    $0xffffff80,%eax
   1fd37:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	translate = NORM_TRANS;													// 使用的字符集(普通ASCII码表).
   1fd3d:	8b 8b c0 15 00 00    	mov    0x15c0(%ebx),%ecx
   1fd43:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fd47:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1fd4d:	89 d0                	mov    %edx,%eax
   1fd4f:	c1 e0 03             	shl    $0x3,%eax
   1fd52:	01 d0                	add    %edx,%eax
   1fd54:	c1 e0 04             	shl    $0x4,%eax
   1fd57:	01 f0                	add    %esi,%eax
   1fd59:	83 e8 80             	sub    $0xffffff80,%eax
   1fd5c:	89 08                	mov    %ecx,(%eax)
	vc_cons[0].vc_bold_attr = -1;											// 粗体字符属性标志(-1表示不用).
   1fd5e:	c7 83 e4 1e 01 00 ff 	movl   $0xffffffff,0x11ee4(%ebx)
   1fd65:	ff ff ff 

	// 在设置了0号控制台当前光标所有位置和光标对应的内存位置pos后,循环设置其余的几个虚拟控制台结构的参数值.除了各自占用的显示内存开始和结束位置不同,
	// 它们的初始值基本上都与0号控制台相同.
	gotoxy(currcons, ORIG_X, ORIG_Y);
   1fd68:	b8 01 00 09 00       	mov    $0x90001,%eax
   1fd6d:	0f b6 00             	movzbl (%eax),%eax
   1fd70:	0f b6 d0             	movzbl %al,%edx
   1fd73:	b8 00 00 09 00       	mov    $0x90000,%eax
   1fd78:	0f b6 00             	movzbl (%eax),%eax
   1fd7b:	0f b6 c0             	movzbl %al,%eax
   1fd7e:	52                   	push   %edx
   1fd7f:	50                   	push   %eax
   1fd80:	ff 74 24 1c          	pushl  0x1c(%esp)
   1fd84:	e8 83 c6 ff ff       	call   1c40c <gotoxy>
   1fd89:	83 c4 0c             	add    $0xc,%esp
  	for (currcons = 1; currcons < NR_CONSOLES; currcons++) {
   1fd8c:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
   1fd93:	00 
   1fd94:	e9 0a 01 00 00       	jmp    1fea3 <con_init+0x5b6>
		vc_cons[currcons] = vc_cons[0];         							// 复制0号结构的参数.
   1fd99:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fd9d:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   1fda3:	89 d0                	mov    %edx,%eax
   1fda5:	c1 e0 03             	shl    $0x3,%eax
   1fda8:	01 d0                	add    %edx,%eax
   1fdaa:	c1 e0 04             	shl    $0x4,%eax
   1fdad:	01 c8                	add    %ecx,%eax
   1fdaf:	89 c7                	mov    %eax,%edi
   1fdb1:	8d 83 e0 1e 01 00    	lea    0x11ee0(%ebx),%eax
   1fdb7:	ba 24 00 00 00       	mov    $0x24,%edx
   1fdbc:	89 c6                	mov    %eax,%esi
   1fdbe:	89 d1                	mov    %edx,%ecx
   1fdc0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		origin = video_mem_start = (base += video_memory);
   1fdc2:	8b 44 24 08          	mov    0x8(%esp),%eax
   1fdc6:	01 44 24 10          	add    %eax,0x10(%esp)
   1fdca:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1fdce:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fdd2:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1fdd8:	89 d0                	mov    %edx,%eax
   1fdda:	c1 e0 03             	shl    $0x3,%eax
   1fddd:	01 d0                	add    %edx,%eax
   1fddf:	c1 e0 04             	shl    $0x4,%eax
   1fde2:	01 f0                	add    %esi,%eax
   1fde4:	83 c0 70             	add    $0x70,%eax
   1fde7:	89 08                	mov    %ecx,(%eax)
   1fde9:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fded:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1fdf3:	89 d0                	mov    %edx,%eax
   1fdf5:	c1 e0 03             	shl    $0x3,%eax
   1fdf8:	01 d0                	add    %edx,%eax
   1fdfa:	c1 e0 04             	shl    $0x4,%eax
   1fdfd:	01 c8                	add    %ecx,%eax
   1fdff:	83 c0 70             	add    $0x70,%eax
   1fe02:	8b 08                	mov    (%eax),%ecx
   1fe04:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fe08:	8d b3 e8 1e 01 00    	lea    0x11ee8(%ebx),%esi
   1fe0e:	89 d0                	mov    %edx,%eax
   1fe10:	c1 e0 03             	shl    $0x3,%eax
   1fe13:	01 d0                	add    %edx,%eax
   1fe15:	c1 e0 04             	shl    $0x4,%eax
   1fe18:	01 f0                	add    %esi,%eax
   1fe1a:	83 c0 10             	add    $0x10,%eax
   1fe1d:	89 08                	mov    %ecx,(%eax)
		scr_end = origin + video_num_lines * video_size_row;
   1fe1f:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fe23:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   1fe29:	89 d0                	mov    %edx,%eax
   1fe2b:	c1 e0 03             	shl    $0x3,%eax
   1fe2e:	01 d0                	add    %edx,%eax
   1fe30:	c1 e0 04             	shl    $0x4,%eax
   1fe33:	01 c8                	add    %ecx,%eax
   1fe35:	83 c0 10             	add    $0x10,%eax
   1fe38:	8b 10                	mov    (%eax),%edx
   1fe3a:	8b 8b c4 1e 01 00    	mov    0x11ec4(%ebx),%ecx
   1fe40:	8b 83 c0 1e 01 00    	mov    0x11ec0(%ebx),%eax
   1fe46:	0f af c1             	imul   %ecx,%eax
   1fe49:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1fe4c:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fe50:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1fe56:	89 d0                	mov    %edx,%eax
   1fe58:	c1 e0 03             	shl    $0x3,%eax
   1fe5b:	01 d0                	add    %edx,%eax
   1fe5d:	c1 e0 04             	shl    $0x4,%eax
   1fe60:	01 f0                	add    %esi,%eax
   1fe62:	83 c0 10             	add    $0x10,%eax
   1fe65:	89 08                	mov    %ecx,(%eax)
		video_mem_end = (term += video_memory);
   1fe67:	8b 44 24 08          	mov    0x8(%esp),%eax
   1fe6b:	01 44 24 0c          	add    %eax,0xc(%esp)
   1fe6f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1fe73:	8b 54 24 14          	mov    0x14(%esp),%edx
   1fe77:	8d b3 ec 1e 01 00    	lea    0x11eec(%ebx),%esi
   1fe7d:	89 d0                	mov    %edx,%eax
   1fe7f:	c1 e0 03             	shl    $0x3,%eax
   1fe82:	01 d0                	add    %edx,%eax
   1fe84:	c1 e0 04             	shl    $0x4,%eax
   1fe87:	01 f0                	add    %esi,%eax
   1fe89:	83 c0 70             	add    $0x70,%eax
   1fe8c:	89 08                	mov    %ecx,(%eax)
		gotoxy(currcons, 0, 0);                           					// 光标都初始化在屏幕左上角位置.
   1fe8e:	6a 00                	push   $0x0
   1fe90:	6a 00                	push   $0x0
   1fe92:	ff 74 24 1c          	pushl  0x1c(%esp)
   1fe96:	e8 71 c5 ff ff       	call   1c40c <gotoxy>
   1fe9b:	83 c4 0c             	add    $0xc,%esp
  	for (currcons = 1; currcons < NR_CONSOLES; currcons++) {
   1fe9e:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
   1fea3:	8b 83 a0 1e 01 00    	mov    0x11ea0(%ebx),%eax
   1fea9:	39 44 24 14          	cmp    %eax,0x14(%esp)
   1fead:	0f 8c e6 fe ff ff    	jl     1fd99 <con_init+0x4ac>
	}
	// 最后设置当前前台控制台的屏幕原点(左上角)位置和显示控制器中光标显示位置,并设置键盘中断0x21陷阱门描述符(&keyboard_inierrupt是键盘中断处理过程
	// 地址).然后取消中断控制芯片8259A中对键盘中断的屏蔽,允许响应键盘发出的IRQ1请求信号.最后复位键盘控制器以允许键盘开始正常工作.
	update_screen();														// 更新前台原点来设置光标位置.
   1feb3:	e8 94 00 00 00       	call   1ff4c <update_screen>
	set_trap_gate(0x21, &keyboard_interrupt);								// 参见system.h,设置键盘的系统中断门
   1feb8:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
   1febe:	8d 88 08 01 00 00    	lea    0x108(%eax),%ecx
   1fec4:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
   1feca:	8d b0 0c 01 00 00    	lea    0x10c(%eax),%esi
   1fed0:	c7 c0 ad 03 02 00    	mov    $0x203ad,%eax
   1fed6:	89 c2                	mov    %eax,%edx
   1fed8:	b8 00 00 08 00       	mov    $0x80000,%eax
   1fedd:	66 89 d0             	mov    %dx,%ax
   1fee0:	66 ba 00 8f          	mov    $0x8f00,%dx
   1fee4:	89 01                	mov    %eax,(%ecx)
   1fee6:	89 16                	mov    %edx,(%esi)
	outb_p(inb_p(0x21) & 0xfd, 0x21);										// 取消对键盘中断的屏蔽,允许IRQ1.
   1fee8:	b8 21 00 00 00       	mov    $0x21,%eax
   1feed:	89 c2                	mov    %eax,%edx
   1feef:	ec                   	in     (%dx),%al
   1fef0:	eb 00                	jmp    1fef2 <con_init+0x605>
   1fef2:	eb 00                	jmp    1fef4 <con_init+0x607>
   1fef4:	88 44 24 07          	mov    %al,0x7(%esp)
   1fef8:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
   1fefd:	0f b6 c0             	movzbl %al,%eax
   1ff00:	25 fd 00 00 00       	and    $0xfd,%eax
   1ff05:	ba 21 00 00 00       	mov    $0x21,%edx
   1ff0a:	ee                   	out    %al,(%dx)
   1ff0b:	eb 00                	jmp    1ff0d <con_init+0x620>
   1ff0d:	eb 00                	jmp    1ff0f <con_init+0x622>
	a = inb_p(0x61);														// 读取键盘端口0x61(8255A端口PB).
   1ff0f:	b8 61 00 00 00       	mov    $0x61,%eax
   1ff14:	89 c2                	mov    %eax,%edx
   1ff16:	ec                   	in     (%dx),%al
   1ff17:	eb 00                	jmp    1ff19 <con_init+0x62c>
   1ff19:	eb 00                	jmp    1ff1b <con_init+0x62e>
   1ff1b:	88 44 24 06          	mov    %al,0x6(%esp)
   1ff1f:	0f b6 44 24 06       	movzbl 0x6(%esp),%eax
   1ff24:	89 c3                	mov    %eax,%ebx
	outb_p(a | 0x80, 0x61);													// 设置禁止键盘工作(位7置位).
   1ff26:	89 d8                	mov    %ebx,%eax
   1ff28:	83 c8 80             	or     $0xffffff80,%eax
   1ff2b:	0f b6 c0             	movzbl %al,%eax
   1ff2e:	ba 61 00 00 00       	mov    $0x61,%edx
   1ff33:	ee                   	out    %al,(%dx)
   1ff34:	eb 00                	jmp    1ff36 <con_init+0x649>
   1ff36:	eb 00                	jmp    1ff38 <con_init+0x64b>
	outb_p(a, 0x61);														// 再允许键盘工作,用以复位键盘.
   1ff38:	ba 61 00 00 00       	mov    $0x61,%edx
   1ff3d:	89 d8                	mov    %ebx,%eax
   1ff3f:	ee                   	out    %al,(%dx)
   1ff40:	eb 00                	jmp    1ff42 <con_init+0x655>
   1ff42:	eb 00                	jmp    1ff44 <con_init+0x657>
}
   1ff44:	90                   	nop
   1ff45:	83 c4 20             	add    $0x20,%esp
   1ff48:	5b                   	pop    %ebx
   1ff49:	5e                   	pop    %esi
   1ff4a:	5f                   	pop    %edi
   1ff4b:	c3                   	ret    

0001ff4c <update_screen>:

// 更新当前控制台.
// 把前台控制台转换为fg_console指定的虚拟控制台.fg_console是设置的前台虚拟控制台号.
// fg_console变量在tty.h头文件中定义，用来启动后默认使用的显示终端
void update_screen(void)
{
   1ff4c:	53                   	push   %ebx
   1ff4d:	e8 a8 6d fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   1ff52:	81 c3 ae 20 01 00    	add    $0x120ae,%ebx
	set_origin(fg_console);													// 设置滚屏起始显示内存地址.
   1ff58:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
   1ff5e:	8b 00                	mov    (%eax),%eax
   1ff60:	50                   	push   %eax
   1ff61:	e8 95 c5 ff ff       	call   1c4fb <set_origin>
   1ff66:	83 c4 04             	add    $0x4,%esp
	set_cursor(fg_console);													// 设置显示控制器中光标显示内存位置.
   1ff69:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
   1ff6f:	8b 00                	mov    (%eax),%eax
   1ff71:	50                   	push   %eax
   1ff72:	e8 52 db ff ff       	call   1dac9 <set_cursor>
   1ff77:	83 c4 04             	add    $0x4,%esp
}
   1ff7a:	90                   	nop
   1ff7b:	5b                   	pop    %ebx
   1ff7c:	c3                   	ret    

0001ff7d <sysbeepstop>:
/* from bsd-net-2: */

// 停止蜂鸣
// 复位8255A PB端口的位1和位0.
void sysbeepstop(void)
{
   1ff7d:	83 ec 10             	sub    $0x10,%esp
   1ff80:	e8 6d 6d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   1ff85:	05 7b 20 01 00       	add    $0x1207b,%eax
	/* disable counter 2 */		/* 禁止定时器2 */
	outb(inb_p(0x61)&0xFC, 0x61);
   1ff8a:	b8 61 00 00 00       	mov    $0x61,%eax
   1ff8f:	89 c2                	mov    %eax,%edx
   1ff91:	ec                   	in     (%dx),%al
   1ff92:	eb 00                	jmp    1ff94 <sysbeepstop+0x17>
   1ff94:	eb 00                	jmp    1ff96 <sysbeepstop+0x19>
   1ff96:	88 44 24 0f          	mov    %al,0xf(%esp)
   1ff9a:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1ff9f:	0f b6 c0             	movzbl %al,%eax
   1ffa2:	25 fc 00 00 00       	and    $0xfc,%eax
   1ffa7:	ba 61 00 00 00       	mov    $0x61,%edx
   1ffac:	ee                   	out    %al,(%dx)
}
   1ffad:	90                   	nop
   1ffae:	83 c4 10             	add    $0x10,%esp
   1ffb1:	c3                   	ret    

0001ffb2 <sysbeep>:

// 开通蜂鸣
// 8255A芯片PB端口的位1用作扬声器的开门信号;位0用作8253定时器2门信号,该定时器的输出脉冲送往扬声器,作为扬声器发声频率.因此要使扬声器
// 发声,需要两步:首先开启PB端口(0x61)位1和位0(置位),然后设置定时器2通道发送一定的定时频率即可.
static void sysbeep(void)
{
   1ffb2:	83 ec 10             	sub    $0x10,%esp
   1ffb5:	e8 7d ca fe ff       	call   ca37 <__x86.get_pc_thunk.cx>
   1ffba:	81 c1 46 20 01 00    	add    $0x12046,%ecx
	/* enable counter 2 */		/* 开启定时器2 */
	outb_p(inb_p(0x61)|3, 0x61);
   1ffc0:	b8 61 00 00 00       	mov    $0x61,%eax
   1ffc5:	89 c2                	mov    %eax,%edx
   1ffc7:	ec                   	in     (%dx),%al
   1ffc8:	eb 00                	jmp    1ffca <sysbeep+0x18>
   1ffca:	eb 00                	jmp    1ffcc <sysbeep+0x1a>
   1ffcc:	88 44 24 0f          	mov    %al,0xf(%esp)
   1ffd0:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1ffd5:	83 c8 03             	or     $0x3,%eax
   1ffd8:	0f b6 c0             	movzbl %al,%eax
   1ffdb:	ba 61 00 00 00       	mov    $0x61,%edx
   1ffe0:	ee                   	out    %al,(%dx)
   1ffe1:	eb 00                	jmp    1ffe3 <sysbeep+0x31>
   1ffe3:	eb 00                	jmp    1ffe5 <sysbeep+0x33>
	/* set command for counter 2, 2 byte write */	/* 送设置定时器2命令 */
	outb_p(0xB6, 0x43);		// 定时器芯片控制字寄存器端口.
   1ffe5:	b8 b6 00 00 00       	mov    $0xb6,%eax
   1ffea:	ba 43 00 00 00       	mov    $0x43,%edx
   1ffef:	ee                   	out    %al,(%dx)
   1fff0:	eb 00                	jmp    1fff2 <sysbeep+0x40>
   1fff2:	eb 00                	jmp    1fff4 <sysbeep+0x42>
	/* send 0x637 for 750 HZ */	/* 设置频率为720Hz,因此送定时值0x637 */
	outb_p(0x37, 0x42);		// 通过2数据端口分别送计数高低字节
   1fff4:	b8 37 00 00 00       	mov    $0x37,%eax
   1fff9:	ba 42 00 00 00       	mov    $0x42,%edx
   1fffe:	ee                   	out    %al,(%dx)
   1ffff:	eb 00                	jmp    20001 <sysbeep+0x4f>
   20001:	eb 00                	jmp    20003 <sysbeep+0x51>
	outb(0x06, 0x42);
   20003:	b8 06 00 00 00       	mov    $0x6,%eax
   20008:	ba 42 00 00 00       	mov    $0x42,%edx
   2000d:	ee                   	out    %al,(%dx)
	/* 1/8 second */		/* 蜂鸣时间为1/8s */
	beepcount = HZ / 8;
   2000e:	c7 81 ac 1e 01 00 0c 	movl   $0xc,0x11eac(%ecx)
   20015:	00 00 00 
}
   20018:	90                   	nop
   20019:	83 c4 10             	add    $0x10,%esp
   2001c:	c3                   	ret    

0002001d <do_screendump>:

// 拷贝屏幕
// 把屏幕内容复制到参数指定的用户缓冲区arg中。
// 参数arg有两个用途：一是用于传递控制台号，二是作为用户缓冲区指针。
int do_screendump(int arg)
{
   2001d:	53                   	push   %ebx
   2001e:	83 ec 18             	sub    $0x18,%esp
   20021:	e8 d4 6c fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   20026:	81 c3 da 1f 01 00    	add    $0x11fda,%ebx
	char *sptr, *buf = (char *)arg;
   2002c:	8b 44 24 20          	mov    0x20(%esp),%eax
   20030:	89 44 24 08          	mov    %eax,0x8(%esp)
	int currcons, l;

	// 函数首先验证用户提供的缓冲区容量，若不够则进行适当扩展。然后从其开始处取出控制台号currcons.
	// 在判断控制台号有效后，就把该控制台屏幕的所有内存内容复制到用户缓冲区中。
	verify_area(buf, video_num_columns * video_num_lines);
   20034:	8b 93 b4 1e 01 00    	mov    0x11eb4(%ebx),%edx
   2003a:	8b 83 c4 1e 01 00    	mov    0x11ec4(%ebx),%eax
   20040:	0f af c2             	imul   %edx,%eax
   20043:	83 ec 08             	sub    $0x8,%esp
   20046:	50                   	push   %eax
   20047:	ff 74 24 14          	pushl  0x14(%esp)
   2004b:	e8 ab 88 fe ff       	call   88fb <verify_area>
   20050:	83 c4 10             	add    $0x10,%esp
	currcons = get_fs_byte(buf);
   20053:	83 ec 0c             	sub    $0xc,%esp
   20056:	ff 74 24 14          	pushl  0x14(%esp)
   2005a:	e8 71 c3 ff ff       	call   1c3d0 <get_fs_byte>
   2005f:	83 c4 10             	add    $0x10,%esp
   20062:	0f b6 c0             	movzbl %al,%eax
   20065:	89 04 24             	mov    %eax,(%esp)
	if ((currcons < 1) || (currcons > NR_CONSOLES))
   20068:	83 3c 24 00          	cmpl   $0x0,(%esp)
   2006c:	7e 0b                	jle    20079 <do_screendump+0x5c>
   2006e:	8b 83 a0 1e 01 00    	mov    0x11ea0(%ebx),%eax
   20074:	39 04 24             	cmp    %eax,(%esp)
   20077:	7e 07                	jle    20080 <do_screendump+0x63>
		return -EIO;
   20079:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   2007e:	eb 71                	jmp    200f1 <do_screendump+0xd4>
	currcons--;
   20080:	83 2c 24 01          	subl   $0x1,(%esp)
	sptr = (char *) origin;
   20084:	8b 14 24             	mov    (%esp),%edx
   20087:	8d 8b e8 1e 01 00    	lea    0x11ee8(%ebx),%ecx
   2008d:	89 d0                	mov    %edx,%eax
   2008f:	c1 e0 03             	shl    $0x3,%eax
   20092:	01 d0                	add    %edx,%eax
   20094:	c1 e0 04             	shl    $0x4,%eax
   20097:	01 c8                	add    %ecx,%eax
   20099:	83 c0 10             	add    $0x10,%eax
   2009c:	8b 00                	mov    (%eax),%eax
   2009e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	for (l = video_num_lines * video_num_columns; l > 0 ; l--)
   200a2:	8b 93 c4 1e 01 00    	mov    0x11ec4(%ebx),%edx
   200a8:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   200ae:	0f af c2             	imul   %edx,%eax
   200b1:	89 44 24 04          	mov    %eax,0x4(%esp)
   200b5:	eb 2e                	jmp    200e5 <do_screendump+0xc8>
		put_fs_byte(*sptr++, buf++);
   200b7:	8b 44 24 08          	mov    0x8(%esp),%eax
   200bb:	8d 50 01             	lea    0x1(%eax),%edx
   200be:	89 54 24 08          	mov    %edx,0x8(%esp)
   200c2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   200c6:	8d 4a 01             	lea    0x1(%edx),%ecx
   200c9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
   200cd:	0f b6 12             	movzbl (%edx),%edx
   200d0:	0f be d2             	movsbl %dl,%edx
   200d3:	83 ec 08             	sub    $0x8,%esp
   200d6:	50                   	push   %eax
   200d7:	52                   	push   %edx
   200d8:	e8 0b c3 ff ff       	call   1c3e8 <put_fs_byte>
   200dd:	83 c4 10             	add    $0x10,%esp
	for (l = video_num_lines * video_num_columns; l > 0 ; l--)
   200e0:	83 6c 24 04 01       	subl   $0x1,0x4(%esp)
   200e5:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   200ea:	7f cb                	jg     200b7 <do_screendump+0x9a>
	return(0);
   200ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
   200f1:	83 c4 18             	add    $0x18,%esp
   200f4:	5b                   	pop    %ebx
   200f5:	c3                   	ret    

000200f6 <blank_screen>:

// 黑屏处理
// 当用户在blankInterval时间间隔内没有按任何按键时就让屏幕黑屏,以保护屏幕.
void blank_screen()
{
   200f6:	e8 f7 6b fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   200fb:	05 05 1f 01 00       	add    $0x11f05,%eax
	if (video_type != VIDEO_TYPE_EGAC && video_type != VIDEO_TYPE_EGAM)
   20100:	0f b6 90 b0 1e 01 00 	movzbl 0x11eb0(%eax),%edx
   20107:	80 fa 21             	cmp    $0x21,%dl
   2010a:	74 09                	je     20115 <blank_screen+0x1f>
   2010c:	0f b6 80 b0 1e 01 00 	movzbl 0x11eb0(%eax),%eax
   20113:	3c 20                	cmp    $0x20,%al
		return;
	/* blank here. I can't find out how to do it, though */
}
   20115:	c3                   	ret    

00020116 <unblank_screen>:

// 恢复黑屏的屏幕
// 当用户按下任何按键时,就恢复处于黑屏状态的屏幕显示内容.
void unblank_screen()
{
   20116:	e8 d7 6b fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   2011b:	05 e5 1e 01 00       	add    $0x11ee5,%eax
	if (video_type != VIDEO_TYPE_EGAC && video_type != VIDEO_TYPE_EGAM)
   20120:	0f b6 90 b0 1e 01 00 	movzbl 0x11eb0(%eax),%edx
   20127:	80 fa 21             	cmp    $0x21,%dl
   2012a:	74 09                	je     20135 <unblank_screen+0x1f>
   2012c:	0f b6 80 b0 1e 01 00 	movzbl 0x11eb0(%eax),%eax
   20133:	3c 20                	cmp    $0x20,%al
		return;
	/* unblank here */
}
   20135:	c3                   	ret    

00020136 <console_print>:
// 控制台显示函数
// 该函数仅用于内核显示函数printk()(kernel/printk.c),用于在当前前台控制台上显示内核信息.
// 处理方法是循环取出缓冲区中的字符,并根据字符的特性控制光标移动或直接显示在屏幕上.
// 参数b是null结尾的字符串缓冲区指针。
void console_print(const char * b)
{
   20136:	57                   	push   %edi
   20137:	56                   	push   %esi
   20138:	53                   	push   %ebx
   20139:	83 ec 10             	sub    $0x10,%esp
   2013c:	e8 b9 6b fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   20141:	81 c3 bf 1e 01 00    	add    $0x11ebf,%ebx
	int currcons = fg_console;
   20147:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
   2014d:	8b 00                	mov    (%eax),%eax
   2014f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	char c;

	// 循环读取缓冲区b中的字符。
	while (c = *(b++)) {
   20153:	e9 a3 01 00 00       	jmp    202fb <console_print+0x1c5>
		// 如果当前字符c是换行符，则对光标执行回车换行操作
		if (c == 10) {
   20158:	80 7c 24 0b 0a       	cmpb   $0xa,0xb(%esp)
   2015d:	75 1d                	jne    2017c <console_print+0x46>
			// 光标回到当前行的第0列
			cr(currcons);
   2015f:	ff 74 24 0c          	pushl  0xc(%esp)
   20163:	e8 34 ce ff ff       	call   1cf9c <cr>
   20168:	83 c4 04             	add    $0x4,%esp
			// 将光标从当前列移动到下一行
			lf(currcons);
   2016b:	ff 74 24 0c          	pushl  0xc(%esp)
   2016f:	e8 89 cc ff ff       	call   1cdfd <lf>
   20174:	83 c4 04             	add    $0x4,%esp
			continue;
   20177:	e9 7f 01 00 00       	jmp    202fb <console_print+0x1c5>
		}
		// 如果是回车符，就直接执行回车动作。然后去处理下一个字符。
		if (c == 13) {
   2017c:	80 7c 24 0b 0d       	cmpb   $0xd,0xb(%esp)
   20181:	75 11                	jne    20194 <console_print+0x5e>
			cr(currcons);
   20183:	ff 74 24 0c          	pushl  0xc(%esp)
   20187:	e8 10 ce ff ff       	call   1cf9c <cr>
   2018c:	83 c4 04             	add    $0x4,%esp
			continue;
   2018f:	e9 67 01 00 00       	jmp    202fb <console_print+0x1c5>
		}
		// 在读取了一个不是回车或换行字符后，如果发现当前光标列位置x已经到达屏幕右末端，则让光标折返到下一行开始处。
		// 然后把字符放到光标所处显示内存位置处，即在屏幕上显示出来。再把光标右移一格位置，为显示下一个字符作准备。
		if (x >= video_num_columns) {
   20194:	8b 54 24 0c          	mov    0xc(%esp),%edx
   20198:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   2019e:	89 d0                	mov    %edx,%eax
   201a0:	c1 e0 03             	shl    $0x3,%eax
   201a3:	01 d0                	add    %edx,%eax
   201a5:	c1 e0 04             	shl    $0x4,%eax
   201a8:	01 c8                	add    %ecx,%eax
   201aa:	83 c0 20             	add    $0x20,%eax
   201ad:	8b 10                	mov    (%eax),%edx
   201af:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   201b5:	39 c2                	cmp    %eax,%edx
   201b7:	0f 82 8c 00 00 00    	jb     20249 <console_print+0x113>
			x -= video_num_columns;
   201bd:	8b 54 24 0c          	mov    0xc(%esp),%edx
   201c1:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   201c7:	89 d0                	mov    %edx,%eax
   201c9:	c1 e0 03             	shl    $0x3,%eax
   201cc:	01 d0                	add    %edx,%eax
   201ce:	c1 e0 04             	shl    $0x4,%eax
   201d1:	01 c8                	add    %ecx,%eax
   201d3:	83 c0 20             	add    $0x20,%eax
   201d6:	8b 10                	mov    (%eax),%edx
   201d8:	8b 83 b4 1e 01 00    	mov    0x11eb4(%ebx),%eax
   201de:	89 d1                	mov    %edx,%ecx
   201e0:	29 c1                	sub    %eax,%ecx
   201e2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   201e6:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   201ec:	89 d0                	mov    %edx,%eax
   201ee:	c1 e0 03             	shl    $0x3,%eax
   201f1:	01 d0                	add    %edx,%eax
   201f3:	c1 e0 04             	shl    $0x4,%eax
   201f6:	01 f0                	add    %esi,%eax
   201f8:	83 c0 20             	add    $0x20,%eax
   201fb:	89 08                	mov    %ecx,(%eax)
			pos -= video_size_row;
   201fd:	8b 54 24 0c          	mov    0xc(%esp),%edx
   20201:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   20207:	89 d0                	mov    %edx,%eax
   20209:	c1 e0 03             	shl    $0x3,%eax
   2020c:	01 d0                	add    %edx,%eax
   2020e:	c1 e0 04             	shl    $0x4,%eax
   20211:	01 c8                	add    %ecx,%eax
   20213:	83 c0 20             	add    $0x20,%eax
   20216:	8b 10                	mov    (%eax),%edx
   20218:	8b 83 c0 1e 01 00    	mov    0x11ec0(%ebx),%eax
   2021e:	89 d1                	mov    %edx,%ecx
   20220:	29 c1                	sub    %eax,%ecx
   20222:	8b 54 24 0c          	mov    0xc(%esp),%edx
   20226:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   2022c:	89 d0                	mov    %edx,%eax
   2022e:	c1 e0 03             	shl    $0x3,%eax
   20231:	01 d0                	add    %edx,%eax
   20233:	c1 e0 04             	shl    $0x4,%eax
   20236:	01 f0                	add    %esi,%eax
   20238:	83 c0 20             	add    $0x20,%eax
   2023b:	89 08                	mov    %ecx,(%eax)
			lf(currcons);
   2023d:	ff 74 24 0c          	pushl  0xc(%esp)
   20241:	e8 b7 cb ff ff       	call   1cdfd <lf>
   20246:	83 c4 04             	add    $0x4,%esp
		}
		// 寄存器al中是需要显示的字符，这里把属性字节放到ah中，然后把ax内容存储到光标内存位置pos处，即在光标处显示字符。
		__asm__("movb %2, %%ah\n\t"              				// 属性字节放到ah中。
			"movw %%ax, %1\n\t"              					// ax内容放到pos处。
			::"a" (c),
			"m" (*(short *)pos),
   20249:	8b 54 24 0c          	mov    0xc(%esp),%edx
   2024d:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   20253:	89 d0                	mov    %edx,%eax
   20255:	c1 e0 03             	shl    $0x3,%eax
   20258:	01 d0                	add    %edx,%eax
   2025a:	c1 e0 04             	shl    $0x4,%eax
   2025d:	01 c8                	add    %ecx,%eax
   2025f:	83 c0 20             	add    $0x20,%eax
   20262:	8b 00                	mov    (%eax),%eax
   20264:	89 c7                	mov    %eax,%edi
		__asm__("movb %2, %%ah\n\t"              				// 属性字节放到ah中。
   20266:	0f b6 4c 24 0b       	movzbl 0xb(%esp),%ecx
   2026b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   2026f:	8d b3 e2 1e 01 00    	lea    0x11ee2(%ebx),%esi
   20275:	89 d0                	mov    %edx,%eax
   20277:	c1 e0 03             	shl    $0x3,%eax
   2027a:	01 d0                	add    %edx,%eax
   2027c:	c1 e0 04             	shl    $0x4,%eax
   2027f:	8d 14 30             	lea    (%eax,%esi,1),%edx
   20282:	89 c8                	mov    %ecx,%eax
   20284:	8a 22                	mov    (%edx),%ah
   20286:	66 89 07             	mov    %ax,(%edi)
			"m" (attr)
			:);
		pos += 2;
   20289:	8b 54 24 0c          	mov    0xc(%esp),%edx
   2028d:	8d 8b e0 1e 01 00    	lea    0x11ee0(%ebx),%ecx
   20293:	89 d0                	mov    %edx,%eax
   20295:	c1 e0 03             	shl    $0x3,%eax
   20298:	01 d0                	add    %edx,%eax
   2029a:	c1 e0 04             	shl    $0x4,%eax
   2029d:	01 c8                	add    %ecx,%eax
   2029f:	83 c0 20             	add    $0x20,%eax
   202a2:	8b 00                	mov    (%eax),%eax
   202a4:	8d 48 02             	lea    0x2(%eax),%ecx
   202a7:	8b 54 24 0c          	mov    0xc(%esp),%edx
   202ab:	8d b3 e0 1e 01 00    	lea    0x11ee0(%ebx),%esi
   202b1:	89 d0                	mov    %edx,%eax
   202b3:	c1 e0 03             	shl    $0x3,%eax
   202b6:	01 d0                	add    %edx,%eax
   202b8:	c1 e0 04             	shl    $0x4,%eax
   202bb:	01 f0                	add    %esi,%eax
   202bd:	83 c0 20             	add    $0x20,%eax
   202c0:	89 08                	mov    %ecx,(%eax)
		x++;
   202c2:	8b 54 24 0c          	mov    0xc(%esp),%edx
   202c6:	8d 8b e4 1e 01 00    	lea    0x11ee4(%ebx),%ecx
   202cc:	89 d0                	mov    %edx,%eax
   202ce:	c1 e0 03             	shl    $0x3,%eax
   202d1:	01 d0                	add    %edx,%eax
   202d3:	c1 e0 04             	shl    $0x4,%eax
   202d6:	01 c8                	add    %ecx,%eax
   202d8:	83 c0 20             	add    $0x20,%eax
   202db:	8b 00                	mov    (%eax),%eax
   202dd:	8d 48 01             	lea    0x1(%eax),%ecx
   202e0:	8b 54 24 0c          	mov    0xc(%esp),%edx
   202e4:	8d b3 e4 1e 01 00    	lea    0x11ee4(%ebx),%esi
   202ea:	89 d0                	mov    %edx,%eax
   202ec:	c1 e0 03             	shl    $0x3,%eax
   202ef:	01 d0                	add    %edx,%eax
   202f1:	c1 e0 04             	shl    $0x4,%eax
   202f4:	01 f0                	add    %esi,%eax
   202f6:	83 c0 20             	add    $0x20,%eax
   202f9:	89 08                	mov    %ecx,(%eax)
	while (c = *(b++)) {
   202fb:	8b 44 24 20          	mov    0x20(%esp),%eax
   202ff:	8d 50 01             	lea    0x1(%eax),%edx
   20302:	89 54 24 20          	mov    %edx,0x20(%esp)
   20306:	0f b6 00             	movzbl (%eax),%eax
   20309:	88 44 24 0b          	mov    %al,0xb(%esp)
   2030d:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
   20312:	0f 85 40 fe ff ff    	jne    20158 <console_print+0x22>
	}
	set_cursor(currcons);           							// 最后设置的光标内存位置，设置显示控制器中光标位置。
   20318:	ff 74 24 0c          	pushl  0xc(%esp)
   2031c:	e8 a8 d7 ff ff       	call   1dac9 <set_cursor>
   20321:	83 c4 04             	add    $0x4,%esp
}
   20324:	90                   	nop
   20325:	83 c4 10             	add    $0x10,%esp
   20328:	5b                   	pop    %ebx
   20329:	5e                   	pop    %esi
   2032a:	5f                   	pop    %edi
   2032b:	c3                   	ret    

0002032c <del_col>:


void del_col(int i){
   2032c:	53                   	push   %ebx
   2032d:	83 ec 10             	sub    $0x10,%esp
   20330:	e8 c1 69 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   20335:	81 c2 cb 1c 01 00    	add    $0x11ccb,%edx
	int currcons = fg_console;
   2033b:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
   20341:	8b 00                	mov    (%eax),%eax
   20343:	89 44 24 0c          	mov    %eax,0xc(%esp)
	gotoxy(currcons, x - i, y);
   20347:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   2034b:	8d 9a e8 1e 01 00    	lea    0x11ee8(%edx),%ebx
   20351:	89 c8                	mov    %ecx,%eax
   20353:	c1 e0 03             	shl    $0x3,%eax
   20356:	01 c8                	add    %ecx,%eax
   20358:	c1 e0 04             	shl    $0x4,%eax
   2035b:	01 d8                	add    %ebx,%eax
   2035d:	83 c0 20             	add    $0x20,%eax
   20360:	8b 18                	mov    (%eax),%ebx
   20362:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   20366:	8d 92 e4 1e 01 00    	lea    0x11ee4(%edx),%edx
   2036c:	89 c8                	mov    %ecx,%eax
   2036e:	c1 e0 03             	shl    $0x3,%eax
   20371:	01 c8                	add    %ecx,%eax
   20373:	c1 e0 04             	shl    $0x4,%eax
   20376:	01 d0                	add    %edx,%eax
   20378:	83 c0 20             	add    $0x20,%eax
   2037b:	8b 10                	mov    (%eax),%edx
   2037d:	8b 44 24 18          	mov    0x18(%esp),%eax
   20381:	29 c2                	sub    %eax,%edx
   20383:	89 d0                	mov    %edx,%eax
   20385:	53                   	push   %ebx
   20386:	50                   	push   %eax
   20387:	ff 74 24 14          	pushl  0x14(%esp)
   2038b:	e8 7c c0 ff ff       	call   1c40c <gotoxy>
   20390:	83 c4 0c             	add    $0xc,%esp
	csi_P(currcons, i);
   20393:	8b 44 24 18          	mov    0x18(%esp),%eax
   20397:	50                   	push   %eax
   20398:	ff 74 24 10          	pushl  0x10(%esp)
   2039c:	e8 63 dc ff ff       	call   1e004 <csi_P>
   203a1:	83 c4 08             	add    $0x8,%esp
}
   203a4:	90                   	nop
   203a5:	83 c4 10             	add    $0x10,%esp
   203a8:	5b                   	pop    %ebx
   203a9:	c3                   	ret    

000203aa <mode>:
	...

000203ab <leds>:
   203ab:	02                   	.byte 0x2

000203ac <e0>:
	...

000203ad <keyboard_interrupt>:
   203ad:	50                   	push   %eax
   203ae:	53                   	push   %ebx
   203af:	51                   	push   %ecx
   203b0:	52                   	push   %edx
   203b1:	1e                   	push   %ds
   203b2:	06                   	push   %es
   203b3:	b8 10 00 00 00       	mov    $0x10,%eax
   203b8:	8e d8                	mov    %eax,%ds
   203ba:	8e c0                	mov    %eax,%es
   203bc:	a1 a4 3e 04 00       	mov    0x43ea4,%eax
   203c1:	a3 a8 3e 04 00       	mov    %eax,0x43ea8
   203c6:	31 c0                	xor    %eax,%eax
   203c8:	e4 60                	in     $0x60,%al
   203ca:	3c e0                	cmp    $0xe0,%al
   203cc:	74 3d                	je     2040b <set_e0>
   203ce:	3c e1                	cmp    $0xe1,%al
   203d0:	74 42                	je     20414 <set_e1>
   203d2:	ff 14 85 8f 07 02 00 	call   *0x2078f(,%eax,4)
   203d9:	c6 05 ac 03 02 00 00 	movb   $0x0,0x203ac

000203e0 <e0_e1>:
   203e0:	e4 61                	in     $0x61,%al
   203e2:	eb 00                	jmp    203e4 <e0_e1+0x4>
   203e4:	eb 00                	jmp    203e6 <e0_e1+0x6>
   203e6:	0c 80                	or     $0x80,%al
   203e8:	eb 00                	jmp    203ea <e0_e1+0xa>
   203ea:	eb 00                	jmp    203ec <e0_e1+0xc>
   203ec:	e6 61                	out    %al,$0x61
   203ee:	eb 00                	jmp    203f0 <e0_e1+0x10>
   203f0:	eb 00                	jmp    203f2 <e0_e1+0x12>
   203f2:	24 7f                	and    $0x7f,%al
   203f4:	e6 61                	out    %al,$0x61
   203f6:	b0 20                	mov    $0x20,%al
   203f8:	e6 20                	out    %al,$0x20
   203fa:	6a 00                	push   $0x0
   203fc:	e8 23 b8 ff ff       	call   1bc24 <do_tty_interrupt>
   20401:	83 c4 04             	add    $0x4,%esp
   20404:	07                   	pop    %es
   20405:	1f                   	pop    %ds
   20406:	5a                   	pop    %edx
   20407:	59                   	pop    %ecx
   20408:	5b                   	pop    %ebx
   20409:	58                   	pop    %eax
   2040a:	cf                   	iret   

0002040b <set_e0>:
   2040b:	c6 05 ac 03 02 00 01 	movb   $0x1,0x203ac
   20412:	eb cc                	jmp    203e0 <e0_e1>

00020414 <set_e1>:
   20414:	c6 05 ac 03 02 00 02 	movb   $0x2,0x203ac
   2041b:	eb c3                	jmp    203e0 <e0_e1>

0002041d <put_queue>:
   2041d:	51                   	push   %ecx
   2041e:	52                   	push   %edx
   2041f:	8b 15 a8 35 03 00    	mov    0x335a8,%edx
   20425:	8b 4a 04             	mov    0x4(%edx),%ecx
   20428:	88 44 0a 10          	mov    %al,0x10(%edx,%ecx,1)
   2042c:	41                   	inc    %ecx
   2042d:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
   20433:	3b 4a 08             	cmp    0x8(%edx),%ecx
   20436:	74 1b                	je     20453 <put_queue+0x36>
   20438:	0f ac d8 08          	shrd   $0x8,%ebx,%eax
   2043c:	74 05                	je     20443 <put_queue+0x26>
   2043e:	c1 eb 08             	shr    $0x8,%ebx
   20441:	eb e5                	jmp    20428 <put_queue+0xb>
   20443:	89 4a 04             	mov    %ecx,0x4(%edx)
   20446:	8b 4a 0c             	mov    0xc(%edx),%ecx
   20449:	85 c9                	test   %ecx,%ecx
   2044b:	74 06                	je     20453 <put_queue+0x36>
   2044d:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
   20453:	5a                   	pop    %edx
   20454:	59                   	pop    %ecx
   20455:	c3                   	ret    

00020456 <ctrl>:
   20456:	b0 04                	mov    $0x4,%al
   20458:	eb 02                	jmp    2045c <alt+0x2>

0002045a <alt>:
   2045a:	b0 10                	mov    $0x10,%al
   2045c:	80 3d ac 03 02 00 00 	cmpb   $0x0,0x203ac
   20463:	74 02                	je     20467 <alt+0xd>
   20465:	00 c0                	add    %al,%al
   20467:	08 05 aa 03 02 00    	or     %al,0x203aa
   2046d:	c3                   	ret    

0002046e <unctrl>:
   2046e:	b0 04                	mov    $0x4,%al
   20470:	eb 02                	jmp    20474 <unalt+0x2>

00020472 <unalt>:
   20472:	b0 10                	mov    $0x10,%al
   20474:	80 3d ac 03 02 00 00 	cmpb   $0x0,0x203ac
   2047b:	74 02                	je     2047f <unalt+0xd>
   2047d:	00 c0                	add    %al,%al
   2047f:	f6 d0                	not    %al
   20481:	20 05 aa 03 02 00    	and    %al,0x203aa
   20487:	c3                   	ret    

00020488 <lshift>:
   20488:	80 0d aa 03 02 00 01 	orb    $0x1,0x203aa
   2048f:	c3                   	ret    

00020490 <unlshift>:
   20490:	80 25 aa 03 02 00 fe 	andb   $0xfe,0x203aa
   20497:	c3                   	ret    

00020498 <rshift>:
   20498:	80 0d aa 03 02 00 02 	orb    $0x2,0x203aa
   2049f:	c3                   	ret    

000204a0 <unrshift>:
   204a0:	80 25 aa 03 02 00 fd 	andb   $0xfd,0x203aa
   204a7:	c3                   	ret    

000204a8 <caps>:
   204a8:	f6 05 aa 03 02 00 80 	testb  $0x80,0x203aa
   204af:	75 43                	jne    204f4 <scroll+0x10>
   204b1:	80 35 ab 03 02 00 04 	xorb   $0x4,0x203ab
   204b8:	80 35 aa 03 02 00 40 	xorb   $0x40,0x203aa
   204bf:	80 0d aa 03 02 00 80 	orb    $0x80,0x203aa

000204c6 <set_leds>:
   204c6:	e8 c4 06 00 00       	call   20b8f <kb_wait>
   204cb:	b0 ed                	mov    $0xed,%al
   204cd:	e6 60                	out    %al,$0x60
   204cf:	e8 bb 06 00 00       	call   20b8f <kb_wait>
   204d4:	a0 ab 03 02 00       	mov    0x203ab,%al
   204d9:	e6 60                	out    %al,$0x60
   204db:	c3                   	ret    

000204dc <uncaps>:
   204dc:	80 25 aa 03 02 00 7f 	andb   $0x7f,0x203aa
   204e3:	c3                   	ret    

000204e4 <scroll>:
   204e4:	f6 05 aa 03 02 00 03 	testb  $0x3,0x203aa
   204eb:	74 07                	je     204f4 <scroll+0x10>
   204ed:	e8 20 d3 fe ff       	call   d812 <show_mem>
   204f2:	eb 05                	jmp    204f9 <scroll+0x15>
   204f4:	e8 7b 69 fe ff       	call   6e74 <show_state>
   204f9:	80 35 ab 03 02 00 01 	xorb   $0x1,0x203ab
   20500:	eb c4                	jmp    204c6 <set_leds>

00020502 <num>:
   20502:	80 35 ab 03 02 00 02 	xorb   $0x2,0x203ab
   20509:	eb bb                	jmp    204c6 <set_leds>

0002050b <cursor>:
   2050b:	2c 47                	sub    $0x47,%al
   2050d:	72 44                	jb     20553 <cur2+0x28>
   2050f:	3c 0c                	cmp    $0xc,%al
   20511:	77 40                	ja     20553 <cur2+0x28>
   20513:	75 16                	jne    2052b <cur2>
   20515:	f6 05 aa 03 02 00 0c 	testb  $0xc,0x203aa
   2051c:	74 0d                	je     2052b <cur2>
   2051e:	f6 05 aa 03 02 00 30 	testb  $0x30,0x203aa
   20525:	0f 85 6d 06 00 00    	jne    20b98 <reboot>

0002052b <cur2>:
   2052b:	80 3d ac 03 02 00 01 	cmpb   $0x1,0x203ac
   20532:	74 20                	je     20554 <cur>
   20534:	f6 05 ab 03 02 00 02 	testb  $0x2,0x203ab
   2053b:	74 17                	je     20554 <cur>
   2053d:	f6 05 aa 03 02 00 03 	testb  $0x3,0x203aa
   20544:	75 0e                	jne    20554 <cur>
   20546:	31 db                	xor    %ebx,%ebx
   20548:	8a 80 6e 05 02 00    	mov    0x2056e(%eax),%al
   2054e:	e9 ca fe ff ff       	jmp    2041d <put_queue>
   20553:	c3                   	ret    

00020554 <cur>:
   20554:	8a 80 7b 05 02 00    	mov    0x2057b(%eax),%al
   2055a:	3c 39                	cmp    $0x39,%al
   2055c:	77 02                	ja     20560 <ok_cur>
   2055e:	b4 7e                	mov    $0x7e,%ah

00020560 <ok_cur>:
   20560:	c1 e0 10             	shl    $0x10,%eax
   20563:	66 b8 1b 5b          	mov    $0x5b1b,%ax
   20567:	31 db                	xor    %ebx,%ebx
   20569:	e9 af fe ff ff       	jmp    2041d <put_queue>

0002056e <num_table>:
   2056e:	37                   	aaa    
   2056f:	38 39                	cmp    %bh,(%ecx)
   20571:	20 34 35 36 20 31 32 	and    %dh,0x32312036(,%esi,1)
   20578:	33 30                	xor    (%eax),%esi
   2057a:	2c                   	.byte 0x2c

0002057b <cur_table>:
   2057b:	48                   	dec    %eax
   2057c:	41                   	inc    %ecx
   2057d:	35 20 44 47 43       	xor    $0x43474420,%eax
   20582:	20 59 42             	and    %bl,0x42(%ecx)
   20585:	36 32 33             	xor    %ss:(%ebx),%dh

00020588 <func>:
   20588:	2c 3b                	sub    $0x3b,%al
   2058a:	72 31                	jb     205bd <end_func>
   2058c:	3c 09                	cmp    $0x9,%al
   2058e:	76 0a                	jbe    2059a <ok_func>
   20590:	2c 12                	sub    $0x12,%al
   20592:	3c 0a                	cmp    $0xa,%al
   20594:	72 27                	jb     205bd <end_func>
   20596:	3c 0b                	cmp    $0xb,%al
   20598:	77 23                	ja     205bd <end_func>

0002059a <ok_func>:
   2059a:	f6 05 aa 03 02 00 10 	testb  $0x10,0x203aa
   205a1:	75 13                	jne    205b6 <alt_func>
   205a3:	83 f9 04             	cmp    $0x4,%ecx
   205a6:	7c 15                	jl     205bd <end_func>
   205a8:	8b 04 85 be 05 02 00 	mov    0x205be(,%eax,4),%eax
   205af:	31 db                	xor    %ebx,%ebx
   205b1:	e9 67 fe ff ff       	jmp    2041d <put_queue>

000205b6 <alt_func>:
   205b6:	50                   	push   %eax
   205b7:	e8 d3 a4 ff ff       	call   1aa8f <change_console>
   205bc:	58                   	pop    %eax

000205bd <end_func>:
   205bd:	c3                   	ret    

000205be <func_table>:
   205be:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205c1:	41                   	inc    %ecx
   205c2:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205c5:	42                   	inc    %edx
   205c6:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205c9:	43                   	inc    %ebx
   205ca:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205cd:	44                   	inc    %esp
   205ce:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205d1:	45                   	inc    %ebp
   205d2:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205d5:	46                   	inc    %esi
   205d6:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205d9:	47                   	inc    %edi
   205da:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205dd:	48                   	dec    %eax
   205de:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205e1:	49                   	dec    %ecx
   205e2:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205e5:	4a                   	dec    %edx
   205e6:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205e9:	4b                   	dec    %ebx
   205ea:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   205ed:	4c                   	dec    %esp

000205ee <key_map>:
   205ee:	00 1b                	add    %bl,(%ebx)
   205f0:	31 32                	xor    %esi,(%edx)
   205f2:	33 34 35 36 37 38 39 	xor    0x39383736(,%esi,1),%esi
   205f9:	30 2d 3d 7f 09 71    	xor    %ch,0x71097f3d
   205ff:	77 65                	ja     20666 <shift_map+0x17>
   20601:	72 74                	jb     20677 <shift_map+0x28>
   20603:	79 75                	jns    2067a <shift_map+0x2b>
   20605:	69 6f 70 5b 5d 0d 00 	imul   $0xd5d5b,0x70(%edi),%ebp
   2060c:	61                   	popa   
   2060d:	73 64                	jae    20673 <shift_map+0x24>
   2060f:	66 67 68 6a 6b       	addr16 pushw $0x6b6a
   20614:	6c                   	insb   (%dx),%es:(%edi)
   20615:	3b 27                	cmp    (%edi),%esp
   20617:	60                   	pusha  
   20618:	00 5c 7a 78          	add    %bl,0x78(%edx,%edi,2)
   2061c:	63 76 62             	arpl   %si,0x62(%esi)
   2061f:	6e                   	outsb  %ds:(%esi),(%dx)
   20620:	6d                   	insl   (%dx),%es:(%edi)
   20621:	2c 2e                	sub    $0x2e,%al
   20623:	2f                   	das    
   20624:	00 2a                	add    %ch,(%edx)
   20626:	00 20                	add    %ah,(%eax)
	...
   20638:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   2063d:	00 00                	add    %al,(%eax)
   2063f:	00 00                	add    %al,(%eax)
   20641:	00 00                	add    %al,(%eax)
   20643:	00 3c 00             	add    %bh,(%eax,%eax,1)
	...

0002064f <shift_map>:
   2064f:	00 1b                	add    %bl,(%ebx)
   20651:	21 40 23             	and    %eax,0x23(%eax)
   20654:	24 25                	and    $0x25,%al
   20656:	5e                   	pop    %esi
   20657:	26 2a 28             	sub    %es:(%eax),%ch
   2065a:	29 5f 2b             	sub    %ebx,0x2b(%edi)
   2065d:	7f 09                	jg     20668 <shift_map+0x19>
   2065f:	51                   	push   %ecx
   20660:	57                   	push   %edi
   20661:	45                   	inc    %ebp
   20662:	52                   	push   %edx
   20663:	54                   	push   %esp
   20664:	59                   	pop    %ecx
   20665:	55                   	push   %ebp
   20666:	49                   	dec    %ecx
   20667:	4f                   	dec    %edi
   20668:	50                   	push   %eax
   20669:	7b 7d                	jnp    206e8 <alt_map+0x38>
   2066b:	0d 00 41 53 44       	or     $0x44534100,%eax
   20670:	46                   	inc    %esi
   20671:	47                   	inc    %edi
   20672:	48                   	dec    %eax
   20673:	4a                   	dec    %edx
   20674:	4b                   	dec    %ebx
   20675:	4c                   	dec    %esp
   20676:	3a 22                	cmp    (%edx),%ah
   20678:	7e 00                	jle    2067a <shift_map+0x2b>
   2067a:	7c 5a                	jl     206d6 <alt_map+0x26>
   2067c:	58                   	pop    %eax
   2067d:	43                   	inc    %ebx
   2067e:	56                   	push   %esi
   2067f:	42                   	inc    %edx
   20680:	4e                   	dec    %esi
   20681:	4d                   	dec    %ebp
   20682:	3c 3e                	cmp    $0x3e,%al
   20684:	3f                   	aas    
   20685:	00 2a                	add    %ch,(%edx)
   20687:	00 20                	add    %ah,(%eax)
	...
   20699:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   2069e:	00 00                	add    %al,(%eax)
   206a0:	00 00                	add    %al,(%eax)
   206a2:	00 00                	add    %al,(%eax)
   206a4:	00 3e                	add    %bh,(%esi)
	...

000206b0 <alt_map>:
   206b0:	00 00                	add    %al,(%eax)
   206b2:	00 40 00             	add    %al,0x0(%eax)
   206b5:	24 00                	and    $0x0,%al
   206b7:	00 7b 5b             	add    %bh,0x5b(%ebx)
   206ba:	5d                   	pop    %ebp
   206bb:	7d 5c                	jge    20719 <do_self+0x8>
	...
   206c9:	00 00                	add    %al,(%eax)
   206cb:	7e 0d                	jle    206da <alt_map+0x2a>
	...
   20705:	00 7c 00 00          	add    %bh,0x0(%eax,%eax,1)
	...

00020711 <do_self>:
   20711:	8d 1d b0 06 02 00    	lea    0x206b0,%ebx
   20717:	f6 05 aa 03 02 00 20 	testb  $0x20,0x203aa
   2071e:	75 15                	jne    20735 <do_self+0x24>
   20720:	8d 1d 4f 06 02 00    	lea    0x2064f,%ebx
   20726:	f6 05 aa 03 02 00 03 	testb  $0x3,0x203aa
   2072d:	75 06                	jne    20735 <do_self+0x24>
   2072f:	8d 1d ee 05 02 00    	lea    0x205ee,%ebx
   20735:	8a 04 03             	mov    (%ebx,%eax,1),%al
   20738:	08 c0                	or     %al,%al
   2073a:	74 3d                	je     20779 <none>
   2073c:	f6 05 aa 03 02 00 4c 	testb  $0x4c,0x203aa
   20743:	74 0a                	je     2074f <do_self+0x3e>
   20745:	3c 61                	cmp    $0x61,%al
   20747:	72 06                	jb     2074f <do_self+0x3e>
   20749:	3c 7d                	cmp    $0x7d,%al
   2074b:	77 02                	ja     2074f <do_self+0x3e>
   2074d:	2c 20                	sub    $0x20,%al
   2074f:	f6 05 aa 03 02 00 0c 	testb  $0xc,0x203aa
   20756:	74 0a                	je     20762 <do_self+0x51>
   20758:	3c 40                	cmp    $0x40,%al
   2075a:	72 06                	jb     20762 <do_self+0x51>
   2075c:	3c 60                	cmp    $0x60,%al
   2075e:	73 02                	jae    20762 <do_self+0x51>
   20760:	2c 40                	sub    $0x40,%al
   20762:	f6 05 aa 03 02 00 10 	testb  $0x10,0x203aa
   20769:	74 02                	je     2076d <do_self+0x5c>
   2076b:	0c 80                	or     $0x80,%al
   2076d:	25 ff 00 00 00       	and    $0xff,%eax
   20772:	31 db                	xor    %ebx,%ebx
   20774:	e8 a4 fc ff ff       	call   2041d <put_queue>

00020779 <none>:
   20779:	c3                   	ret    

0002077a <minus>:
   2077a:	80 3d ac 03 02 00 01 	cmpb   $0x1,0x203ac
   20781:	75 8e                	jne    20711 <do_self>
   20783:	b8 2f 00 00 00       	mov    $0x2f,%eax
   20788:	31 db                	xor    %ebx,%ebx
   2078a:	e9 8e fc ff ff       	jmp    2041d <put_queue>

0002078f <key_table>:
   2078f:	79 07                	jns    20798 <key_table+0x9>
   20791:	02 00                	add    (%eax),%al
   20793:	11 07                	adc    %eax,(%edi)
   20795:	02 00                	add    (%eax),%al
   20797:	11 07                	adc    %eax,(%edi)
   20799:	02 00                	add    (%eax),%al
   2079b:	11 07                	adc    %eax,(%edi)
   2079d:	02 00                	add    (%eax),%al
   2079f:	11 07                	adc    %eax,(%edi)
   207a1:	02 00                	add    (%eax),%al
   207a3:	11 07                	adc    %eax,(%edi)
   207a5:	02 00                	add    (%eax),%al
   207a7:	11 07                	adc    %eax,(%edi)
   207a9:	02 00                	add    (%eax),%al
   207ab:	11 07                	adc    %eax,(%edi)
   207ad:	02 00                	add    (%eax),%al
   207af:	11 07                	adc    %eax,(%edi)
   207b1:	02 00                	add    (%eax),%al
   207b3:	11 07                	adc    %eax,(%edi)
   207b5:	02 00                	add    (%eax),%al
   207b7:	11 07                	adc    %eax,(%edi)
   207b9:	02 00                	add    (%eax),%al
   207bb:	11 07                	adc    %eax,(%edi)
   207bd:	02 00                	add    (%eax),%al
   207bf:	11 07                	adc    %eax,(%edi)
   207c1:	02 00                	add    (%eax),%al
   207c3:	11 07                	adc    %eax,(%edi)
   207c5:	02 00                	add    (%eax),%al
   207c7:	11 07                	adc    %eax,(%edi)
   207c9:	02 00                	add    (%eax),%al
   207cb:	11 07                	adc    %eax,(%edi)
   207cd:	02 00                	add    (%eax),%al
   207cf:	11 07                	adc    %eax,(%edi)
   207d1:	02 00                	add    (%eax),%al
   207d3:	11 07                	adc    %eax,(%edi)
   207d5:	02 00                	add    (%eax),%al
   207d7:	11 07                	adc    %eax,(%edi)
   207d9:	02 00                	add    (%eax),%al
   207db:	11 07                	adc    %eax,(%edi)
   207dd:	02 00                	add    (%eax),%al
   207df:	11 07                	adc    %eax,(%edi)
   207e1:	02 00                	add    (%eax),%al
   207e3:	11 07                	adc    %eax,(%edi)
   207e5:	02 00                	add    (%eax),%al
   207e7:	11 07                	adc    %eax,(%edi)
   207e9:	02 00                	add    (%eax),%al
   207eb:	11 07                	adc    %eax,(%edi)
   207ed:	02 00                	add    (%eax),%al
   207ef:	11 07                	adc    %eax,(%edi)
   207f1:	02 00                	add    (%eax),%al
   207f3:	11 07                	adc    %eax,(%edi)
   207f5:	02 00                	add    (%eax),%al
   207f7:	11 07                	adc    %eax,(%edi)
   207f9:	02 00                	add    (%eax),%al
   207fb:	11 07                	adc    %eax,(%edi)
   207fd:	02 00                	add    (%eax),%al
   207ff:	11 07                	adc    %eax,(%edi)
   20801:	02 00                	add    (%eax),%al
   20803:	56                   	push   %esi
   20804:	04 02                	add    $0x2,%al
   20806:	00 11                	add    %dl,(%ecx)
   20808:	07                   	pop    %es
   20809:	02 00                	add    (%eax),%al
   2080b:	11 07                	adc    %eax,(%edi)
   2080d:	02 00                	add    (%eax),%al
   2080f:	11 07                	adc    %eax,(%edi)
   20811:	02 00                	add    (%eax),%al
   20813:	11 07                	adc    %eax,(%edi)
   20815:	02 00                	add    (%eax),%al
   20817:	11 07                	adc    %eax,(%edi)
   20819:	02 00                	add    (%eax),%al
   2081b:	11 07                	adc    %eax,(%edi)
   2081d:	02 00                	add    (%eax),%al
   2081f:	11 07                	adc    %eax,(%edi)
   20821:	02 00                	add    (%eax),%al
   20823:	11 07                	adc    %eax,(%edi)
   20825:	02 00                	add    (%eax),%al
   20827:	11 07                	adc    %eax,(%edi)
   20829:	02 00                	add    (%eax),%al
   2082b:	11 07                	adc    %eax,(%edi)
   2082d:	02 00                	add    (%eax),%al
   2082f:	11 07                	adc    %eax,(%edi)
   20831:	02 00                	add    (%eax),%al
   20833:	11 07                	adc    %eax,(%edi)
   20835:	02 00                	add    (%eax),%al
   20837:	88 04 02             	mov    %al,(%edx,%eax,1)
   2083a:	00 11                	add    %dl,(%ecx)
   2083c:	07                   	pop    %es
   2083d:	02 00                	add    (%eax),%al
   2083f:	11 07                	adc    %eax,(%edi)
   20841:	02 00                	add    (%eax),%al
   20843:	11 07                	adc    %eax,(%edi)
   20845:	02 00                	add    (%eax),%al
   20847:	11 07                	adc    %eax,(%edi)
   20849:	02 00                	add    (%eax),%al
   2084b:	11 07                	adc    %eax,(%edi)
   2084d:	02 00                	add    (%eax),%al
   2084f:	11 07                	adc    %eax,(%edi)
   20851:	02 00                	add    (%eax),%al
   20853:	11 07                	adc    %eax,(%edi)
   20855:	02 00                	add    (%eax),%al
   20857:	11 07                	adc    %eax,(%edi)
   20859:	02 00                	add    (%eax),%al
   2085b:	11 07                	adc    %eax,(%edi)
   2085d:	02 00                	add    (%eax),%al
   2085f:	11 07                	adc    %eax,(%edi)
   20861:	02 00                	add    (%eax),%al
   20863:	7a 07                	jp     2086c <key_table+0xdd>
   20865:	02 00                	add    (%eax),%al
   20867:	98                   	cwtl   
   20868:	04 02                	add    $0x2,%al
   2086a:	00 11                	add    %dl,(%ecx)
   2086c:	07                   	pop    %es
   2086d:	02 00                	add    (%eax),%al
   2086f:	5a                   	pop    %edx
   20870:	04 02                	add    $0x2,%al
   20872:	00 11                	add    %dl,(%ecx)
   20874:	07                   	pop    %es
   20875:	02 00                	add    (%eax),%al
   20877:	a8 04                	test   $0x4,%al
   20879:	02 00                	add    (%eax),%al
   2087b:	88 05 02 00 88 05    	mov    %al,0x5880002
   20881:	02 00                	add    (%eax),%al
   20883:	88 05 02 00 88 05    	mov    %al,0x5880002
   20889:	02 00                	add    (%eax),%al
   2088b:	88 05 02 00 88 05    	mov    %al,0x5880002
   20891:	02 00                	add    (%eax),%al
   20893:	88 05 02 00 88 05    	mov    %al,0x5880002
   20899:	02 00                	add    (%eax),%al
   2089b:	88 05 02 00 88 05    	mov    %al,0x5880002
   208a1:	02 00                	add    (%eax),%al
   208a3:	02 05 02 00 e4 04    	add    0x4e40002,%al
   208a9:	02 00                	add    (%eax),%al
   208ab:	0b 05 02 00 0b 05    	or     0x50b0002,%eax
   208b1:	02 00                	add    (%eax),%al
   208b3:	0b 05 02 00 11 07    	or     0x7110002,%eax
   208b9:	02 00                	add    (%eax),%al
   208bb:	0b 05 02 00 0b 05    	or     0x50b0002,%eax
   208c1:	02 00                	add    (%eax),%al
   208c3:	0b 05 02 00 11 07    	or     0x7110002,%eax
   208c9:	02 00                	add    (%eax),%al
   208cb:	0b 05 02 00 0b 05    	or     0x50b0002,%eax
   208d1:	02 00                	add    (%eax),%al
   208d3:	0b 05 02 00 0b 05    	or     0x50b0002,%eax
   208d9:	02 00                	add    (%eax),%al
   208db:	0b 05 02 00 79 07    	or     0x7790002,%eax
   208e1:	02 00                	add    (%eax),%al
   208e3:	79 07                	jns    208ec <key_table+0x15d>
   208e5:	02 00                	add    (%eax),%al
   208e7:	11 07                	adc    %eax,(%edi)
   208e9:	02 00                	add    (%eax),%al
   208eb:	88 05 02 00 88 05    	mov    %al,0x5880002
   208f1:	02 00                	add    (%eax),%al
   208f3:	79 07                	jns    208fc <key_table+0x16d>
   208f5:	02 00                	add    (%eax),%al
   208f7:	79 07                	jns    20900 <key_table+0x171>
   208f9:	02 00                	add    (%eax),%al
   208fb:	79 07                	jns    20904 <key_table+0x175>
   208fd:	02 00                	add    (%eax),%al
   208ff:	79 07                	jns    20908 <key_table+0x179>
   20901:	02 00                	add    (%eax),%al
   20903:	79 07                	jns    2090c <key_table+0x17d>
   20905:	02 00                	add    (%eax),%al
   20907:	79 07                	jns    20910 <key_table+0x181>
   20909:	02 00                	add    (%eax),%al
   2090b:	79 07                	jns    20914 <key_table+0x185>
   2090d:	02 00                	add    (%eax),%al
   2090f:	79 07                	jns    20918 <key_table+0x189>
   20911:	02 00                	add    (%eax),%al
   20913:	79 07                	jns    2091c <key_table+0x18d>
   20915:	02 00                	add    (%eax),%al
   20917:	79 07                	jns    20920 <key_table+0x191>
   20919:	02 00                	add    (%eax),%al
   2091b:	79 07                	jns    20924 <key_table+0x195>
   2091d:	02 00                	add    (%eax),%al
   2091f:	79 07                	jns    20928 <key_table+0x199>
   20921:	02 00                	add    (%eax),%al
   20923:	79 07                	jns    2092c <key_table+0x19d>
   20925:	02 00                	add    (%eax),%al
   20927:	79 07                	jns    20930 <key_table+0x1a1>
   20929:	02 00                	add    (%eax),%al
   2092b:	79 07                	jns    20934 <key_table+0x1a5>
   2092d:	02 00                	add    (%eax),%al
   2092f:	79 07                	jns    20938 <key_table+0x1a9>
   20931:	02 00                	add    (%eax),%al
   20933:	79 07                	jns    2093c <key_table+0x1ad>
   20935:	02 00                	add    (%eax),%al
   20937:	79 07                	jns    20940 <key_table+0x1b1>
   20939:	02 00                	add    (%eax),%al
   2093b:	79 07                	jns    20944 <key_table+0x1b5>
   2093d:	02 00                	add    (%eax),%al
   2093f:	79 07                	jns    20948 <key_table+0x1b9>
   20941:	02 00                	add    (%eax),%al
   20943:	79 07                	jns    2094c <key_table+0x1bd>
   20945:	02 00                	add    (%eax),%al
   20947:	79 07                	jns    20950 <key_table+0x1c1>
   20949:	02 00                	add    (%eax),%al
   2094b:	79 07                	jns    20954 <key_table+0x1c5>
   2094d:	02 00                	add    (%eax),%al
   2094f:	79 07                	jns    20958 <key_table+0x1c9>
   20951:	02 00                	add    (%eax),%al
   20953:	79 07                	jns    2095c <key_table+0x1cd>
   20955:	02 00                	add    (%eax),%al
   20957:	79 07                	jns    20960 <key_table+0x1d1>
   20959:	02 00                	add    (%eax),%al
   2095b:	79 07                	jns    20964 <key_table+0x1d5>
   2095d:	02 00                	add    (%eax),%al
   2095f:	79 07                	jns    20968 <key_table+0x1d9>
   20961:	02 00                	add    (%eax),%al
   20963:	79 07                	jns    2096c <key_table+0x1dd>
   20965:	02 00                	add    (%eax),%al
   20967:	79 07                	jns    20970 <key_table+0x1e1>
   20969:	02 00                	add    (%eax),%al
   2096b:	79 07                	jns    20974 <key_table+0x1e5>
   2096d:	02 00                	add    (%eax),%al
   2096f:	79 07                	jns    20978 <key_table+0x1e9>
   20971:	02 00                	add    (%eax),%al
   20973:	79 07                	jns    2097c <key_table+0x1ed>
   20975:	02 00                	add    (%eax),%al
   20977:	79 07                	jns    20980 <key_table+0x1f1>
   20979:	02 00                	add    (%eax),%al
   2097b:	79 07                	jns    20984 <key_table+0x1f5>
   2097d:	02 00                	add    (%eax),%al
   2097f:	79 07                	jns    20988 <key_table+0x1f9>
   20981:	02 00                	add    (%eax),%al
   20983:	79 07                	jns    2098c <key_table+0x1fd>
   20985:	02 00                	add    (%eax),%al
   20987:	79 07                	jns    20990 <key_table+0x201>
   20989:	02 00                	add    (%eax),%al
   2098b:	79 07                	jns    20994 <key_table+0x205>
   2098d:	02 00                	add    (%eax),%al
   2098f:	79 07                	jns    20998 <key_table+0x209>
   20991:	02 00                	add    (%eax),%al
   20993:	79 07                	jns    2099c <key_table+0x20d>
   20995:	02 00                	add    (%eax),%al
   20997:	79 07                	jns    209a0 <key_table+0x211>
   20999:	02 00                	add    (%eax),%al
   2099b:	79 07                	jns    209a4 <key_table+0x215>
   2099d:	02 00                	add    (%eax),%al
   2099f:	79 07                	jns    209a8 <key_table+0x219>
   209a1:	02 00                	add    (%eax),%al
   209a3:	79 07                	jns    209ac <key_table+0x21d>
   209a5:	02 00                	add    (%eax),%al
   209a7:	79 07                	jns    209b0 <key_table+0x221>
   209a9:	02 00                	add    (%eax),%al
   209ab:	79 07                	jns    209b4 <key_table+0x225>
   209ad:	02 00                	add    (%eax),%al
   209af:	79 07                	jns    209b8 <key_table+0x229>
   209b1:	02 00                	add    (%eax),%al
   209b3:	79 07                	jns    209bc <key_table+0x22d>
   209b5:	02 00                	add    (%eax),%al
   209b7:	79 07                	jns    209c0 <key_table+0x231>
   209b9:	02 00                	add    (%eax),%al
   209bb:	79 07                	jns    209c4 <key_table+0x235>
   209bd:	02 00                	add    (%eax),%al
   209bf:	79 07                	jns    209c8 <key_table+0x239>
   209c1:	02 00                	add    (%eax),%al
   209c3:	79 07                	jns    209cc <key_table+0x23d>
   209c5:	02 00                	add    (%eax),%al
   209c7:	79 07                	jns    209d0 <key_table+0x241>
   209c9:	02 00                	add    (%eax),%al
   209cb:	79 07                	jns    209d4 <key_table+0x245>
   209cd:	02 00                	add    (%eax),%al
   209cf:	79 07                	jns    209d8 <key_table+0x249>
   209d1:	02 00                	add    (%eax),%al
   209d3:	79 07                	jns    209dc <key_table+0x24d>
   209d5:	02 00                	add    (%eax),%al
   209d7:	79 07                	jns    209e0 <key_table+0x251>
   209d9:	02 00                	add    (%eax),%al
   209db:	79 07                	jns    209e4 <key_table+0x255>
   209dd:	02 00                	add    (%eax),%al
   209df:	79 07                	jns    209e8 <key_table+0x259>
   209e1:	02 00                	add    (%eax),%al
   209e3:	79 07                	jns    209ec <key_table+0x25d>
   209e5:	02 00                	add    (%eax),%al
   209e7:	79 07                	jns    209f0 <key_table+0x261>
   209e9:	02 00                	add    (%eax),%al
   209eb:	79 07                	jns    209f4 <key_table+0x265>
   209ed:	02 00                	add    (%eax),%al
   209ef:	79 07                	jns    209f8 <key_table+0x269>
   209f1:	02 00                	add    (%eax),%al
   209f3:	79 07                	jns    209fc <key_table+0x26d>
   209f5:	02 00                	add    (%eax),%al
   209f7:	79 07                	jns    20a00 <key_table+0x271>
   209f9:	02 00                	add    (%eax),%al
   209fb:	79 07                	jns    20a04 <key_table+0x275>
   209fd:	02 00                	add    (%eax),%al
   209ff:	79 07                	jns    20a08 <key_table+0x279>
   20a01:	02 00                	add    (%eax),%al
   20a03:	6e                   	outsb  %ds:(%esi),(%dx)
   20a04:	04 02                	add    $0x2,%al
   20a06:	00 79 07             	add    %bh,0x7(%ecx)
   20a09:	02 00                	add    (%eax),%al
   20a0b:	79 07                	jns    20a14 <key_table+0x285>
   20a0d:	02 00                	add    (%eax),%al
   20a0f:	79 07                	jns    20a18 <key_table+0x289>
   20a11:	02 00                	add    (%eax),%al
   20a13:	79 07                	jns    20a1c <key_table+0x28d>
   20a15:	02 00                	add    (%eax),%al
   20a17:	79 07                	jns    20a20 <key_table+0x291>
   20a19:	02 00                	add    (%eax),%al
   20a1b:	79 07                	jns    20a24 <key_table+0x295>
   20a1d:	02 00                	add    (%eax),%al
   20a1f:	79 07                	jns    20a28 <key_table+0x299>
   20a21:	02 00                	add    (%eax),%al
   20a23:	79 07                	jns    20a2c <key_table+0x29d>
   20a25:	02 00                	add    (%eax),%al
   20a27:	79 07                	jns    20a30 <key_table+0x2a1>
   20a29:	02 00                	add    (%eax),%al
   20a2b:	79 07                	jns    20a34 <key_table+0x2a5>
   20a2d:	02 00                	add    (%eax),%al
   20a2f:	79 07                	jns    20a38 <key_table+0x2a9>
   20a31:	02 00                	add    (%eax),%al
   20a33:	79 07                	jns    20a3c <key_table+0x2ad>
   20a35:	02 00                	add    (%eax),%al
   20a37:	90                   	nop
   20a38:	04 02                	add    $0x2,%al
   20a3a:	00 79 07             	add    %bh,0x7(%ecx)
   20a3d:	02 00                	add    (%eax),%al
   20a3f:	79 07                	jns    20a48 <key_table+0x2b9>
   20a41:	02 00                	add    (%eax),%al
   20a43:	79 07                	jns    20a4c <key_table+0x2bd>
   20a45:	02 00                	add    (%eax),%al
   20a47:	79 07                	jns    20a50 <key_table+0x2c1>
   20a49:	02 00                	add    (%eax),%al
   20a4b:	79 07                	jns    20a54 <key_table+0x2c5>
   20a4d:	02 00                	add    (%eax),%al
   20a4f:	79 07                	jns    20a58 <key_table+0x2c9>
   20a51:	02 00                	add    (%eax),%al
   20a53:	79 07                	jns    20a5c <key_table+0x2cd>
   20a55:	02 00                	add    (%eax),%al
   20a57:	79 07                	jns    20a60 <key_table+0x2d1>
   20a59:	02 00                	add    (%eax),%al
   20a5b:	79 07                	jns    20a64 <key_table+0x2d5>
   20a5d:	02 00                	add    (%eax),%al
   20a5f:	79 07                	jns    20a68 <key_table+0x2d9>
   20a61:	02 00                	add    (%eax),%al
   20a63:	79 07                	jns    20a6c <key_table+0x2dd>
   20a65:	02 00                	add    (%eax),%al
   20a67:	a0 04 02 00 79       	mov    0x79000204,%al
   20a6c:	07                   	pop    %es
   20a6d:	02 00                	add    (%eax),%al
   20a6f:	72 04                	jb     20a75 <key_table+0x2e6>
   20a71:	02 00                	add    (%eax),%al
   20a73:	79 07                	jns    20a7c <key_table+0x2ed>
   20a75:	02 00                	add    (%eax),%al
   20a77:	dc 04 02             	faddl  (%edx,%eax,1)
   20a7a:	00 79 07             	add    %bh,0x7(%ecx)
   20a7d:	02 00                	add    (%eax),%al
   20a7f:	79 07                	jns    20a88 <key_table+0x2f9>
   20a81:	02 00                	add    (%eax),%al
   20a83:	79 07                	jns    20a8c <key_table+0x2fd>
   20a85:	02 00                	add    (%eax),%al
   20a87:	79 07                	jns    20a90 <key_table+0x301>
   20a89:	02 00                	add    (%eax),%al
   20a8b:	79 07                	jns    20a94 <key_table+0x305>
   20a8d:	02 00                	add    (%eax),%al
   20a8f:	79 07                	jns    20a98 <key_table+0x309>
   20a91:	02 00                	add    (%eax),%al
   20a93:	79 07                	jns    20a9c <key_table+0x30d>
   20a95:	02 00                	add    (%eax),%al
   20a97:	79 07                	jns    20aa0 <key_table+0x311>
   20a99:	02 00                	add    (%eax),%al
   20a9b:	79 07                	jns    20aa4 <key_table+0x315>
   20a9d:	02 00                	add    (%eax),%al
   20a9f:	79 07                	jns    20aa8 <key_table+0x319>
   20aa1:	02 00                	add    (%eax),%al
   20aa3:	79 07                	jns    20aac <key_table+0x31d>
   20aa5:	02 00                	add    (%eax),%al
   20aa7:	79 07                	jns    20ab0 <key_table+0x321>
   20aa9:	02 00                	add    (%eax),%al
   20aab:	79 07                	jns    20ab4 <key_table+0x325>
   20aad:	02 00                	add    (%eax),%al
   20aaf:	79 07                	jns    20ab8 <key_table+0x329>
   20ab1:	02 00                	add    (%eax),%al
   20ab3:	79 07                	jns    20abc <key_table+0x32d>
   20ab5:	02 00                	add    (%eax),%al
   20ab7:	79 07                	jns    20ac0 <key_table+0x331>
   20ab9:	02 00                	add    (%eax),%al
   20abb:	79 07                	jns    20ac4 <key_table+0x335>
   20abd:	02 00                	add    (%eax),%al
   20abf:	79 07                	jns    20ac8 <key_table+0x339>
   20ac1:	02 00                	add    (%eax),%al
   20ac3:	79 07                	jns    20acc <key_table+0x33d>
   20ac5:	02 00                	add    (%eax),%al
   20ac7:	79 07                	jns    20ad0 <key_table+0x341>
   20ac9:	02 00                	add    (%eax),%al
   20acb:	79 07                	jns    20ad4 <key_table+0x345>
   20acd:	02 00                	add    (%eax),%al
   20acf:	79 07                	jns    20ad8 <key_table+0x349>
   20ad1:	02 00                	add    (%eax),%al
   20ad3:	79 07                	jns    20adc <key_table+0x34d>
   20ad5:	02 00                	add    (%eax),%al
   20ad7:	79 07                	jns    20ae0 <key_table+0x351>
   20ad9:	02 00                	add    (%eax),%al
   20adb:	79 07                	jns    20ae4 <key_table+0x355>
   20add:	02 00                	add    (%eax),%al
   20adf:	79 07                	jns    20ae8 <key_table+0x359>
   20ae1:	02 00                	add    (%eax),%al
   20ae3:	79 07                	jns    20aec <key_table+0x35d>
   20ae5:	02 00                	add    (%eax),%al
   20ae7:	79 07                	jns    20af0 <key_table+0x361>
   20ae9:	02 00                	add    (%eax),%al
   20aeb:	79 07                	jns    20af4 <key_table+0x365>
   20aed:	02 00                	add    (%eax),%al
   20aef:	79 07                	jns    20af8 <key_table+0x369>
   20af1:	02 00                	add    (%eax),%al
   20af3:	79 07                	jns    20afc <key_table+0x36d>
   20af5:	02 00                	add    (%eax),%al
   20af7:	79 07                	jns    20b00 <key_table+0x371>
   20af9:	02 00                	add    (%eax),%al
   20afb:	79 07                	jns    20b04 <key_table+0x375>
   20afd:	02 00                	add    (%eax),%al
   20aff:	79 07                	jns    20b08 <key_table+0x379>
   20b01:	02 00                	add    (%eax),%al
   20b03:	79 07                	jns    20b0c <key_table+0x37d>
   20b05:	02 00                	add    (%eax),%al
   20b07:	79 07                	jns    20b10 <key_table+0x381>
   20b09:	02 00                	add    (%eax),%al
   20b0b:	79 07                	jns    20b14 <key_table+0x385>
   20b0d:	02 00                	add    (%eax),%al
   20b0f:	79 07                	jns    20b18 <key_table+0x389>
   20b11:	02 00                	add    (%eax),%al
   20b13:	79 07                	jns    20b1c <key_table+0x38d>
   20b15:	02 00                	add    (%eax),%al
   20b17:	79 07                	jns    20b20 <key_table+0x391>
   20b19:	02 00                	add    (%eax),%al
   20b1b:	79 07                	jns    20b24 <key_table+0x395>
   20b1d:	02 00                	add    (%eax),%al
   20b1f:	79 07                	jns    20b28 <key_table+0x399>
   20b21:	02 00                	add    (%eax),%al
   20b23:	79 07                	jns    20b2c <key_table+0x39d>
   20b25:	02 00                	add    (%eax),%al
   20b27:	79 07                	jns    20b30 <key_table+0x3a1>
   20b29:	02 00                	add    (%eax),%al
   20b2b:	79 07                	jns    20b34 <key_table+0x3a5>
   20b2d:	02 00                	add    (%eax),%al
   20b2f:	79 07                	jns    20b38 <key_table+0x3a9>
   20b31:	02 00                	add    (%eax),%al
   20b33:	79 07                	jns    20b3c <key_table+0x3ad>
   20b35:	02 00                	add    (%eax),%al
   20b37:	79 07                	jns    20b40 <key_table+0x3b1>
   20b39:	02 00                	add    (%eax),%al
   20b3b:	79 07                	jns    20b44 <key_table+0x3b5>
   20b3d:	02 00                	add    (%eax),%al
   20b3f:	79 07                	jns    20b48 <key_table+0x3b9>
   20b41:	02 00                	add    (%eax),%al
   20b43:	79 07                	jns    20b4c <key_table+0x3bd>
   20b45:	02 00                	add    (%eax),%al
   20b47:	79 07                	jns    20b50 <key_table+0x3c1>
   20b49:	02 00                	add    (%eax),%al
   20b4b:	79 07                	jns    20b54 <key_table+0x3c5>
   20b4d:	02 00                	add    (%eax),%al
   20b4f:	79 07                	jns    20b58 <key_table+0x3c9>
   20b51:	02 00                	add    (%eax),%al
   20b53:	79 07                	jns    20b5c <key_table+0x3cd>
   20b55:	02 00                	add    (%eax),%al
   20b57:	79 07                	jns    20b60 <key_table+0x3d1>
   20b59:	02 00                	add    (%eax),%al
   20b5b:	79 07                	jns    20b64 <key_table+0x3d5>
   20b5d:	02 00                	add    (%eax),%al
   20b5f:	79 07                	jns    20b68 <key_table+0x3d9>
   20b61:	02 00                	add    (%eax),%al
   20b63:	79 07                	jns    20b6c <key_table+0x3dd>
   20b65:	02 00                	add    (%eax),%al
   20b67:	79 07                	jns    20b70 <key_table+0x3e1>
   20b69:	02 00                	add    (%eax),%al
   20b6b:	79 07                	jns    20b74 <key_table+0x3e5>
   20b6d:	02 00                	add    (%eax),%al
   20b6f:	79 07                	jns    20b78 <key_table+0x3e9>
   20b71:	02 00                	add    (%eax),%al
   20b73:	79 07                	jns    20b7c <key_table+0x3ed>
   20b75:	02 00                	add    (%eax),%al
   20b77:	79 07                	jns    20b80 <key_table+0x3f1>
   20b79:	02 00                	add    (%eax),%al
   20b7b:	79 07                	jns    20b84 <key_table+0x3f5>
   20b7d:	02 00                	add    (%eax),%al
   20b7f:	79 07                	jns    20b88 <key_table+0x3f9>
   20b81:	02 00                	add    (%eax),%al
   20b83:	79 07                	jns    20b8c <key_table+0x3fd>
   20b85:	02 00                	add    (%eax),%al
   20b87:	79 07                	jns    20b90 <kb_wait+0x1>
   20b89:	02 00                	add    (%eax),%al
   20b8b:	79 07                	jns    20b94 <kb_wait+0x5>
   20b8d:	02 00                	add    (%eax),%al

00020b8f <kb_wait>:
   20b8f:	50                   	push   %eax
   20b90:	e4 64                	in     $0x64,%al
   20b92:	a8 02                	test   $0x2,%al
   20b94:	75 fa                	jne    20b90 <kb_wait+0x1>
   20b96:	58                   	pop    %eax
   20b97:	c3                   	ret    

00020b98 <reboot>:
   20b98:	e8 f2 ff ff ff       	call   20b8f <kb_wait>
   20b9d:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
   20ba4:	34 12 
   20ba6:	b0 fc                	mov    $0xfc,%al
   20ba8:	e6 64                	out    %al,$0x64

00020baa <die>:
   20baa:	eb fe                	jmp    20baa <die>

00020bac <init>:
// 初始化串行端口。
// 设置指定串行端口的传输波特率（2400bps）并允许除了写保持寄存器空以外所有中断源。另外，在输出2字节的波特率因子时，须
// 首先设置线路控制寄存器的DLAB位（位7）。
// 参数：port是串行端口基地址，串口1 - 0x3F8；串口2 - 0x2F8。
static void init(int port)
{
   20bac:	83 ec 10             	sub    $0x10,%esp
   20baf:	e8 3e 61 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20bb4:	05 4c 14 01 00       	add    $0x1144c,%eax
	outb_p(0x80, port + 3);										/* set DLAB of line control reg */
   20bb9:	8b 44 24 14          	mov    0x14(%esp),%eax
   20bbd:	8d 50 03             	lea    0x3(%eax),%edx
   20bc0:	b8 80 00 00 00       	mov    $0x80,%eax
   20bc5:	ee                   	out    %al,(%dx)
   20bc6:	eb 00                	jmp    20bc8 <init+0x1c>
   20bc8:	eb 00                	jmp    20bca <init+0x1e>
	outb_p(0x30, port);											/* LS of divisor (48 -> 2400 bps */
   20bca:	b8 30 00 00 00       	mov    $0x30,%eax
   20bcf:	8b 54 24 14          	mov    0x14(%esp),%edx
   20bd3:	ee                   	out    %al,(%dx)
   20bd4:	eb 00                	jmp    20bd6 <init+0x2a>
   20bd6:	eb 00                	jmp    20bd8 <init+0x2c>
	outb_p(0x00, port + 1);										/* MS of divisor */
   20bd8:	8b 44 24 14          	mov    0x14(%esp),%eax
   20bdc:	8d 50 01             	lea    0x1(%eax),%edx
   20bdf:	b8 00 00 00 00       	mov    $0x0,%eax
   20be4:	ee                   	out    %al,(%dx)
   20be5:	eb 00                	jmp    20be7 <init+0x3b>
   20be7:	eb 00                	jmp    20be9 <init+0x3d>
	outb_p(0x03, port + 3);										/* reset DLAB */
   20be9:	8b 44 24 14          	mov    0x14(%esp),%eax
   20bed:	8d 50 03             	lea    0x3(%eax),%edx
   20bf0:	b8 03 00 00 00       	mov    $0x3,%eax
   20bf5:	ee                   	out    %al,(%dx)
   20bf6:	eb 00                	jmp    20bf8 <init+0x4c>
   20bf8:	eb 00                	jmp    20bfa <init+0x4e>
	outb_p(0x0b, port + 4);										/* set DTR,RTS, OUT_2 */
   20bfa:	8b 44 24 14          	mov    0x14(%esp),%eax
   20bfe:	8d 50 04             	lea    0x4(%eax),%edx
   20c01:	b8 0b 00 00 00       	mov    $0xb,%eax
   20c06:	ee                   	out    %al,(%dx)
   20c07:	eb 00                	jmp    20c09 <init+0x5d>
   20c09:	eb 00                	jmp    20c0b <init+0x5f>
	outb_p(0x0d, port + 1);										/* enable all intrs but writes */
   20c0b:	8b 44 24 14          	mov    0x14(%esp),%eax
   20c0f:	8d 50 01             	lea    0x1(%eax),%edx
   20c12:	b8 0d 00 00 00       	mov    $0xd,%eax
   20c17:	ee                   	out    %al,(%dx)
   20c18:	eb 00                	jmp    20c1a <init+0x6e>
   20c1a:	eb 00                	jmp    20c1c <init+0x70>
	(void)inb(port);											/* read data port to reset things (?) */
   20c1c:	8b 44 24 14          	mov    0x14(%esp),%eax
   20c20:	89 c2                	mov    %eax,%edx
   20c22:	ec                   	in     (%dx),%al
   20c23:	88 44 24 0f          	mov    %al,0xf(%esp)
}
   20c27:	90                   	nop
   20c28:	83 c4 10             	add    $0x10,%esp
   20c2b:	c3                   	ret    

00020c2c <rs_init>:

// 初始化串行中断程序和串行接口。
// 中断描述符表IDT中的门描述符设置宏set_intr_gate()在include/asm/system.h中实现。
void rs_init(void)
{
   20c2c:	56                   	push   %esi
   20c2d:	53                   	push   %ebx
   20c2e:	83 ec 10             	sub    $0x10,%esp
   20c31:	e8 c4 60 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   20c36:	81 c3 ca 13 01 00    	add    $0x113ca,%ebx
	// 下面两句用于设置两个串行口的中断门描述符。rs1_interrupt是口串1的中断处理过程指针。
	// 串口1使用的中断是int 0x24，串口2的是int 0x23。
	set_intr_gate(0x24, rs1_interrupt);      					// 设置串行口1的中断向量（IRQ4信号）。
   20c3c:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
   20c42:	8d 88 20 01 00 00    	lea    0x120(%eax),%ecx
   20c48:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
   20c4e:	8d b0 24 01 00 00    	lea    0x124(%eax),%esi
   20c54:	c7 c0 50 0d 02 00    	mov    $0x20d50,%eax
   20c5a:	89 c2                	mov    %eax,%edx
   20c5c:	b8 00 00 08 00       	mov    $0x80000,%eax
   20c61:	66 89 d0             	mov    %dx,%ax
   20c64:	66 ba 00 8e          	mov    $0x8e00,%dx
   20c68:	89 01                	mov    %eax,(%ecx)
   20c6a:	89 16                	mov    %edx,(%esi)
	set_intr_gate(0x23, rs2_interrupt);      					// 设置串行口2的中断向量（IRQ3信号）。
   20c6c:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
   20c72:	8d 88 18 01 00 00    	lea    0x118(%eax),%ecx
   20c78:	c7 c0 b8 54 00 00    	mov    $0x54b8,%eax
   20c7e:	8d b0 1c 01 00 00    	lea    0x11c(%eax),%esi
   20c84:	c7 c0 58 0d 02 00    	mov    $0x20d58,%eax
   20c8a:	89 c2                	mov    %eax,%edx
   20c8c:	b8 00 00 08 00       	mov    $0x80000,%eax
   20c91:	66 89 d0             	mov    %dx,%ax
   20c94:	66 ba 00 8e          	mov    $0x8e00,%dx
   20c98:	89 01                	mov    %eax,(%ecx)
   20c9a:	89 16                	mov    %edx,(%esi)
	init(tty_table[64].read_q->data);       					// 初始化串行口1（.data是端口基地址）。
   20c9c:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   20ca2:	8b 80 34 10 00 00    	mov    0x1034(%eax),%eax
   20ca8:	8b 00                	mov    (%eax),%eax
   20caa:	50                   	push   %eax
   20cab:	e8 fc fe ff ff       	call   20bac <init>
   20cb0:	83 c4 04             	add    $0x4,%esp
	init(tty_table[65].read_q->data);       					// 初始化串行口2.
   20cb3:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   20cb9:	8b 80 74 10 00 00    	mov    0x1074(%eax),%eax
   20cbf:	8b 00                	mov    (%eax),%eax
   20cc1:	50                   	push   %eax
   20cc2:	e8 e5 fe ff ff       	call   20bac <init>
   20cc7:	83 c4 04             	add    $0x4,%esp
	outb(inb_p(0x21) & 0xE7, 0x21);            					// 允许主8259A响应IRQ3、IRQ4中断请求。
   20cca:	b8 21 00 00 00       	mov    $0x21,%eax
   20ccf:	89 c2                	mov    %eax,%edx
   20cd1:	ec                   	in     (%dx),%al
   20cd2:	eb 00                	jmp    20cd4 <rs_init+0xa8>
   20cd4:	eb 00                	jmp    20cd6 <rs_init+0xaa>
   20cd6:	88 44 24 0f          	mov    %al,0xf(%esp)
   20cda:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   20cdf:	0f b6 c0             	movzbl %al,%eax
   20ce2:	25 e7 00 00 00       	and    $0xe7,%eax
   20ce7:	ba 21 00 00 00       	mov    $0x21,%edx
   20cec:	ee                   	out    %al,(%dx)
}
   20ced:	90                   	nop
   20cee:	83 c4 10             	add    $0x10,%esp
   20cf1:	5b                   	pop    %ebx
   20cf2:	5e                   	pop    %esi
   20cf3:	c3                   	ret    

00020cf4 <rs_write>:
// 串行数据发送输出。
// 该函数实际上只是开启发送保持寄存器已空中断标志。此后当发送保持寄存器空时，UART就会产生中断请求。而在该串行中断
// 处理过程中，程序会取出写队列尾指针处的字符，并输出到发送保持寄存器中。一旦UART把该字符发送出去，发送保持寄存器
// 中断允许标志复位掉，从而再次禁止发送保持寄存器空引发中断请求。此次“循环”发送操作也随之结束。
void rs_write(struct tty_struct * tty)
{
   20cf4:	83 ec 10             	sub    $0x10,%esp
   20cf7:	e8 f6 5f fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20cfc:	05 04 13 01 00       	add    $0x11304,%eax
	// 如果写队列不空，则首先从0x3f9（或0x2f9）读取中断允许寄存器内容，添上发送保持寄存器中断允许标志（位1）后，再写
	// 回该寄存器。这样，当发送保持寄存器空时UART就能够因期望获得欲发送的字符而引发中断。write_q.data中是串行端口基
	// 地址。
	cli();
   20d01:	fa                   	cli    
	if (!EMPTY(tty->write_q))
   20d02:	8b 44 24 14          	mov    0x14(%esp),%eax
   20d06:	8b 40 38             	mov    0x38(%eax),%eax
   20d09:	8b 50 04             	mov    0x4(%eax),%edx
   20d0c:	8b 44 24 14          	mov    0x14(%esp),%eax
   20d10:	8b 40 38             	mov    0x38(%eax),%eax
   20d13:	8b 40 08             	mov    0x8(%eax),%eax
   20d16:	39 c2                	cmp    %eax,%edx
   20d18:	74 2f                	je     20d49 <rs_write+0x55>
		outb(inb_p(tty->write_q->data + 1) | 0x02, tty->write_q->data + 1);
   20d1a:	8b 44 24 14          	mov    0x14(%esp),%eax
   20d1e:	8b 40 38             	mov    0x38(%eax),%eax
   20d21:	8b 00                	mov    (%eax),%eax
   20d23:	83 c0 01             	add    $0x1,%eax
   20d26:	89 c2                	mov    %eax,%edx
   20d28:	ec                   	in     (%dx),%al
   20d29:	eb 00                	jmp    20d2b <rs_write+0x37>
   20d2b:	eb 00                	jmp    20d2d <rs_write+0x39>
   20d2d:	88 44 24 0f          	mov    %al,0xf(%esp)
   20d31:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   20d36:	83 c8 02             	or     $0x2,%eax
   20d39:	0f b6 c0             	movzbl %al,%eax
   20d3c:	8b 54 24 14          	mov    0x14(%esp),%edx
   20d40:	8b 52 38             	mov    0x38(%edx),%edx
   20d43:	8b 12                	mov    (%edx),%edx
   20d45:	83 c2 01             	add    $0x1,%edx
   20d48:	ee                   	out    %al,(%dx)
	sti();
   20d49:	fb                   	sti    
}
   20d4a:	90                   	nop
   20d4b:	83 c4 10             	add    $0x10,%esp
   20d4e:	c3                   	ret    
   20d4f:	90                   	nop

00020d50 <rs1_interrupt>:
   20d50:	68 b0 35 03 00       	push   $0x335b0
   20d55:	eb 06                	jmp    20d5d <rs_int>
   20d57:	90                   	nop

00020d58 <rs2_interrupt>:
   20d58:	68 b8 35 03 00       	push   $0x335b8

00020d5d <rs_int>:
   20d5d:	52                   	push   %edx
   20d5e:	51                   	push   %ecx
   20d5f:	53                   	push   %ebx
   20d60:	50                   	push   %eax
   20d61:	06                   	push   %es
   20d62:	1e                   	push   %ds
   20d63:	6a 10                	push   $0x10
   20d65:	1f                   	pop    %ds
   20d66:	6a 10                	push   $0x10
   20d68:	07                   	pop    %es
   20d69:	8b 54 24 18          	mov    0x18(%esp),%edx
   20d6d:	8b 12                	mov    (%edx),%edx
   20d6f:	8b 12                	mov    (%edx),%edx
   20d71:	83 c2 02             	add    $0x2,%edx

00020d74 <rep_int>:
   20d74:	31 c0                	xor    %eax,%eax
   20d76:	ec                   	in     (%dx),%al
   20d77:	a8 01                	test   $0x1,%al
   20d79:	75 16                	jne    20d91 <end>
   20d7b:	3c 06                	cmp    $0x6,%al
   20d7d:	77 12                	ja     20d91 <end>
   20d7f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   20d83:	52                   	push   %edx
   20d84:	83 ea 02             	sub    $0x2,%edx
   20d87:	ff 14 45 9f 0d 02 00 	call   *0x20d9f(,%eax,2)
   20d8e:	5a                   	pop    %edx
   20d8f:	eb e3                	jmp    20d74 <rep_int>

00020d91 <end>:
   20d91:	b0 20                	mov    $0x20,%al
   20d93:	e6 20                	out    %al,$0x20
   20d95:	1f                   	pop    %ds
   20d96:	07                   	pop    %es
   20d97:	58                   	pop    %eax
   20d98:	5b                   	pop    %ebx
   20d99:	59                   	pop    %ecx
   20d9a:	5a                   	pop    %edx
   20d9b:	83 c4 04             	add    $0x4,%esp
   20d9e:	cf                   	iret   

00020d9f <jmp_table>:
   20d9f:	b0 0d                	mov    $0xd,%al
   20da1:	02 00                	add    (%eax),%al
   20da3:	f4                   	hlt    
   20da4:	0d 02 00 c0 0d       	or     $0xdc00002,%eax
   20da9:	02 00                	add    (%eax),%al
   20dab:	b8 0d 02 00 90       	mov    $0x9000020d,%eax

00020db0 <modem_status>:
   20db0:	83 c2 06             	add    $0x6,%edx
   20db3:	ec                   	in     (%dx),%al
   20db4:	c3                   	ret    
   20db5:	8d 76 00             	lea    0x0(%esi),%esi

00020db8 <line_status>:
   20db8:	83 c2 05             	add    $0x5,%edx
   20dbb:	ec                   	in     (%dx),%al
   20dbc:	c3                   	ret    
   20dbd:	8d 76 00             	lea    0x0(%esi),%esi

00020dc0 <read_char>:
   20dc0:	ec                   	in     (%dx),%al
   20dc1:	89 ca                	mov    %ecx,%edx
   20dc3:	81 ea a8 35 03 00    	sub    $0x335a8,%edx
   20dc9:	c1 ea 03             	shr    $0x3,%edx
   20dcc:	8b 09                	mov    (%ecx),%ecx
   20dce:	8b 59 04             	mov    0x4(%ecx),%ebx
   20dd1:	88 44 19 10          	mov    %al,0x10(%ecx,%ebx,1)
   20dd5:	43                   	inc    %ebx
   20dd6:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   20ddc:	3b 59 08             	cmp    0x8(%ecx),%ebx
   20ddf:	74 03                	je     20de4 <read_char+0x24>
   20de1:	89 59 04             	mov    %ebx,0x4(%ecx)
   20de4:	83 c2 3f             	add    $0x3f,%edx
   20de7:	52                   	push   %edx
   20de8:	e8 37 ae ff ff       	call   1bc24 <do_tty_interrupt>
   20ded:	83 c4 04             	add    $0x4,%esp
   20df0:	c3                   	ret    
   20df1:	8d 76 00             	lea    0x0(%esi),%esi

00020df4 <write_char>:
   20df4:	8b 49 04             	mov    0x4(%ecx),%ecx
   20df7:	8b 59 04             	mov    0x4(%ecx),%ebx
   20dfa:	2b 59 08             	sub    0x8(%ecx),%ebx
   20dfd:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   20e03:	74 2f                	je     20e34 <write_buffer_empty>
   20e05:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
   20e0b:	77 0d                	ja     20e1a <write_char+0x26>
   20e0d:	8b 59 0c             	mov    0xc(%ecx),%ebx
   20e10:	85 db                	test   %ebx,%ebx
   20e12:	74 06                	je     20e1a <write_char+0x26>
   20e14:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   20e1a:	8b 59 08             	mov    0x8(%ecx),%ebx
   20e1d:	8a 44 19 10          	mov    0x10(%ecx,%ebx,1),%al
   20e21:	ee                   	out    %al,(%dx)
   20e22:	43                   	inc    %ebx
   20e23:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   20e29:	89 59 08             	mov    %ebx,0x8(%ecx)
   20e2c:	3b 59 04             	cmp    0x4(%ecx),%ebx
   20e2f:	74 03                	je     20e34 <write_buffer_empty>
   20e31:	c3                   	ret    
   20e32:	66 90                	xchg   %ax,%ax

00020e34 <write_buffer_empty>:
   20e34:	8b 59 0c             	mov    0xc(%ecx),%ebx
   20e37:	85 db                	test   %ebx,%ebx
   20e39:	74 06                	je     20e41 <write_buffer_empty+0xd>
   20e3b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   20e41:	42                   	inc    %edx
   20e42:	ec                   	in     (%dx),%al
   20e43:	eb 00                	jmp    20e45 <write_buffer_empty+0x11>
   20e45:	eb 00                	jmp    20e47 <write_buffer_empty+0x13>
   20e47:	24 0d                	and    $0xd,%al
   20e49:	ee                   	out    %al,(%dx)
   20e4a:	c3                   	ret    

00020e4b <get_fs_byte>:
{
   20e4b:	53                   	push   %ebx
   20e4c:	e8 a1 5e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20e51:	05 af 11 01 00       	add    $0x111af,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   20e56:	8b 44 24 08          	mov    0x8(%esp),%eax
   20e5a:	64 8a 00             	mov    %fs:(%eax),%al
   20e5d:	89 c3                	mov    %eax,%ebx
	return _v;
   20e5f:	89 d8                	mov    %ebx,%eax
}
   20e61:	5b                   	pop    %ebx
   20e62:	c3                   	ret    

00020e63 <get_fs_long>:
{
   20e63:	83 ec 10             	sub    $0x10,%esp
   20e66:	e8 87 5e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20e6b:	05 95 11 01 00       	add    $0x11195,%eax
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   20e70:	8b 44 24 14          	mov    0x14(%esp),%eax
   20e74:	64 8b 00             	mov    %fs:(%eax),%eax
   20e77:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
   20e7b:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   20e7f:	83 c4 10             	add    $0x10,%esp
   20e82:	c3                   	ret    

00020e83 <put_fs_byte>:
{
   20e83:	83 ec 04             	sub    $0x4,%esp
   20e86:	e8 67 5e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20e8b:	05 75 11 01 00       	add    $0x11175,%eax
   20e90:	8b 44 24 08          	mov    0x8(%esp),%eax
   20e94:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   20e97:	0f b6 04 24          	movzbl (%esp),%eax
   20e9b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   20e9f:	64 88 02             	mov    %al,%fs:(%edx)
}
   20ea2:	90                   	nop
   20ea3:	83 c4 04             	add    $0x4,%esp
   20ea6:	c3                   	ret    

00020ea7 <put_fs_long>:

//// 将一长字存放在fs段中指定内存地址处.
// 参数:val - 长字值;addr - 内存地址.
// %0 - 寄存器(长字值val);%1 - (内存地址addr).
static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
   20ea7:	e8 46 5e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20eac:	05 54 11 01 00       	add    $0x11154,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   20eb1:	8b 44 24 04          	mov    0x4(%esp),%eax
   20eb5:	8b 54 24 08          	mov    0x8(%esp),%edx
   20eb9:	64 89 02             	mov    %eax,%fs:(%edx)
}
   20ebc:	90                   	nop
   20ebd:	c3                   	ret    

00020ebe <change_speed>:
// 修改传输波特率。
// 参数：tty - 终端对应的tty数据结构。
// 在除数锁存标志DLAB置位情况下，通过端口0x3f8和0x3f9向UART分别写入波特率因子低字节和高字节。写完后再复位DLAB
// 位。对于串口2,这两个端口分别是0x2f8和0x2f9。
static void change_speed(struct tty_struct * tty)
{
   20ebe:	83 ec 10             	sub    $0x10,%esp
   20ec1:	e8 2c 5e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20ec6:	05 3a 11 01 00       	add    $0x1113a,%eax

	// 函数首先检查参数tty指定的终端是否是串行终端，若不是则退出。对于串口终端的tty结构，其读缓冲队列data字段存放着
	// 串行端口基址（0x3f8或0x2f8），而一般控制台终端的tty结构的read_q.data字段值为0。然后从终端termios结构的控制
	// 模式标志集中取得已设置的波特率索引号，并据此从波特率因子数组quotient[]中取得对应的波特率因子值quot。CBAUD是
	// 控制模式标志集中波特率位屏蔽码。
	if (!(port = tty->read_q->data))
   20ecb:	8b 54 24 14          	mov    0x14(%esp),%edx
   20ecf:	8b 52 34             	mov    0x34(%edx),%edx
   20ed2:	8b 12                	mov    (%edx),%edx
   20ed4:	66 89 54 24 0e       	mov    %dx,0xe(%esp)
   20ed9:	66 83 7c 24 0e 00    	cmpw   $0x0,0xe(%esp)
   20edf:	74 66                	je     20f47 <change_speed+0x89>
		return;
	quot = quotient[tty->termios.c_cflag & CBAUD];
   20ee1:	8b 54 24 14          	mov    0x14(%esp),%edx
   20ee5:	8b 52 08             	mov    0x8(%edx),%edx
   20ee8:	83 e2 0f             	and    $0xf,%edx
   20eeb:	0f b7 84 50 e0 15 00 	movzwl 0x15e0(%eax,%edx,2),%eax
   20ef2:	00 
   20ef3:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	// 接着把波特率因子quot写入串行端口对应UART芯片的波特率因子锁存器中。在写之前我们先要把线路控制寄存器LCR的除数锁存
	// 访问位DLAB（位7）置1。然后把16位的波特率因子低、高字节分别写入端口0x3f8、0x3f9（分别对应波特率因子低、高字节
	// 锁存器）。最后再复位LCR的DLAB标志位。
	cli();
   20ef8:	fa                   	cli    
	outb_p(0x80, port + 3);									/* set DLAB */          // 首先设置除数锁定标志DLAB。
   20ef9:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
   20efe:	8d 50 03             	lea    0x3(%eax),%edx
   20f01:	b8 80 00 00 00       	mov    $0x80,%eax
   20f06:	ee                   	out    %al,(%dx)
   20f07:	eb 00                	jmp    20f09 <change_speed+0x4b>
   20f09:	eb 00                	jmp    20f0b <change_speed+0x4d>
	outb_p(quot & 0xff, port);								/* LS of divisor */     // 输出因子低字节。
   20f0b:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   20f10:	0f b6 c0             	movzbl %al,%eax
   20f13:	0f b7 54 24 0e       	movzwl 0xe(%esp),%edx
   20f18:	ee                   	out    %al,(%dx)
   20f19:	eb 00                	jmp    20f1b <change_speed+0x5d>
   20f1b:	eb 00                	jmp    20f1d <change_speed+0x5f>
	outb_p(quot >> 8, port + 1);							/* MS of divisor */     // 输出因子高字节。
   20f1d:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   20f22:	66 c1 e8 08          	shr    $0x8,%ax
   20f26:	0f b7 c0             	movzwl %ax,%eax
   20f29:	0f b7 54 24 0e       	movzwl 0xe(%esp),%edx
   20f2e:	83 c2 01             	add    $0x1,%edx
   20f31:	ee                   	out    %al,(%dx)
   20f32:	eb 00                	jmp    20f34 <change_speed+0x76>
   20f34:	eb 00                	jmp    20f36 <change_speed+0x78>
	outb(0x03, port + 3);									/* reset DLAB */        // 复位DLAB。
   20f36:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
   20f3b:	8d 50 03             	lea    0x3(%eax),%edx
   20f3e:	b8 03 00 00 00       	mov    $0x3,%eax
   20f43:	ee                   	out    %al,(%dx)
	sti();
   20f44:	fb                   	sti    
   20f45:	eb 01                	jmp    20f48 <change_speed+0x8a>
		return;
   20f47:	90                   	nop
}
   20f48:	83 c4 10             	add    $0x10,%esp
   20f4b:	c3                   	ret    

00020f4c <flush>:

// 刷新tty缓冲队列。
// 参数：queue - 指定的缓冲队列指针。
// 令缓冲队列的头指针等于尾指针，从而达到清空缓冲区的目的。
static void flush(struct tty_queue * queue)
{
   20f4c:	e8 a1 5d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20f51:	05 af 10 01 00       	add    $0x110af,%eax
	cli();
   20f56:	fa                   	cli    
	queue->head = queue->tail;
   20f57:	8b 44 24 04          	mov    0x4(%esp),%eax
   20f5b:	8b 50 08             	mov    0x8(%eax),%edx
   20f5e:	8b 44 24 04          	mov    0x4(%esp),%eax
   20f62:	89 50 04             	mov    %edx,0x4(%eax)
	sti();
   20f65:	fb                   	sti    
}
   20f66:	90                   	nop
   20f67:	c3                   	ret    

00020f68 <wait_until_sent>:

// 等待字符发送出去。
static void wait_until_sent(struct tty_struct * tty)
{
   20f68:	e8 85 5d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20f6d:	05 93 10 01 00       	add    $0x11093,%eax
	/* do nothing - not implemented */      /* 什么都没做 - 还未实现 */
}
   20f72:	90                   	nop
   20f73:	c3                   	ret    

00020f74 <send_break>:

// 发送BREAK控制符。
static void send_break(struct tty_struct * tty)
{
   20f74:	e8 79 5d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20f79:	05 87 10 01 00       	add    $0x11087,%eax
	/* do nothing - not implemented */      /* 什么都没做 - 还未实现 */
}
   20f7e:	90                   	nop
   20f7f:	c3                   	ret    

00020f80 <get_termios>:

// 取终端termios结构信息。
// 参数：tty - 指定终端的tty结构指针；termios - 存放termios结构的用户缓冲区。
static int get_termios(struct tty_struct * tty, struct termios * termios)
{
   20f80:	53                   	push   %ebx
   20f81:	83 ec 18             	sub    $0x18,%esp
   20f84:	e8 69 5d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20f89:	05 77 10 01 00       	add    $0x11077,%eax
	int i;

	// 首先验证用户缓冲区指针所指内存区容量是否足够，如不够则分配内存。然后复制指定终端的termios结构信息到用户缓冲区中。
	// 最后返回0.
	verify_area(termios, sizeof (*termios));
   20f8e:	83 ec 08             	sub    $0x8,%esp
   20f91:	6a 24                	push   $0x24
   20f93:	ff 74 24 30          	pushl  0x30(%esp)
   20f97:	89 c3                	mov    %eax,%ebx
   20f99:	e8 5d 79 fe ff       	call   88fb <verify_area>
   20f9e:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < (sizeof (*termios)) ; i++)
   20fa1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   20fa8:	00 
   20fa9:	eb 2c                	jmp    20fd7 <get_termios+0x57>
		put_fs_byte( ((char *) & tty->termios)[i] , i + (char *)termios );
   20fab:	8b 54 24 0c          	mov    0xc(%esp),%edx
   20faf:	8b 44 24 24          	mov    0x24(%esp),%eax
   20fb3:	01 c2                	add    %eax,%edx
   20fb5:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   20fb9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   20fbd:	01 c8                	add    %ecx,%eax
   20fbf:	0f b6 00             	movzbl (%eax),%eax
   20fc2:	0f be c0             	movsbl %al,%eax
   20fc5:	83 ec 08             	sub    $0x8,%esp
   20fc8:	52                   	push   %edx
   20fc9:	50                   	push   %eax
   20fca:	e8 b4 fe ff ff       	call   20e83 <put_fs_byte>
   20fcf:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < (sizeof (*termios)) ; i++)
   20fd2:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   20fd7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   20fdb:	83 f8 23             	cmp    $0x23,%eax
   20fde:	76 cb                	jbe    20fab <get_termios+0x2b>
	return 0;
   20fe0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   20fe5:	83 c4 18             	add    $0x18,%esp
   20fe8:	5b                   	pop    %ebx
   20fe9:	c3                   	ret    

00020fea <set_termios>:

// 设置终端termios结构信息。
// 参数：tty - 指定终端的tty结构指针；termios - 用户数据区termios结构指针。
static int set_termios(struct tty_struct * tty, struct termios * termios,
			int channel)
{
   20fea:	53                   	push   %ebx
   20feb:	83 ec 18             	sub    $0x18,%esp
   20fee:	e8 ff 5c fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   20ff3:	05 0d 10 01 00       	add    $0x1100d,%eax
     * 如果试图设置终端的状态但此时终端不在前台，那么我们就需要发送一个SIGTTOU
     * 信号。如果该信号被进程屏蔽或者忽略了，就直接执行本次操作。POSIX 7.2 */
	// 如果当前进程使用的tty终端的进程组号与进程的进程组号不同，即当前进程终端不在前台，表示当前进程试图修改不受控制的终端
	// 的termios结构。因此根据POSIX标准的要求这里需要发送SIGTTOU信号让使用这个终端的进程暂时停止执行，让我们先修改termios
	// 结构。如果发送信号函数tty_signal()返回值是ERESTARTSYS或EINTR，则等一会儿再执行本次操作。
	if ((current->tty == channel) && (tty->pgrp != current->pgrp)) {
   20ff8:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   20ffe:	8b 12                	mov    (%edx),%edx
   21000:	8b 92 2c 03 00 00    	mov    0x32c(%edx),%edx
   21006:	39 54 24 28          	cmp    %edx,0x28(%esp)
   2100a:	75 47                	jne    21053 <set_termios+0x69>
   2100c:	8b 54 24 20          	mov    0x20(%esp),%edx
   21010:	8b 4a 24             	mov    0x24(%edx),%ecx
   21013:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   21019:	8b 12                	mov    (%edx),%edx
   2101b:	8b 92 30 02 00 00    	mov    0x230(%edx),%edx
   21021:	39 d1                	cmp    %edx,%ecx
   21023:	74 2e                	je     21053 <set_termios+0x69>
		retsig = tty_signal(SIGTTOU, tty);
   21025:	83 ec 08             	sub    $0x8,%esp
   21028:	ff 74 24 28          	pushl  0x28(%esp)
   2102c:	6a 16                	push   $0x16
   2102e:	89 c3                	mov    %eax,%ebx
   21030:	e8 84 a3 ff ff       	call   1b3b9 <tty_signal>
   21035:	83 c4 10             	add    $0x10,%esp
   21038:	89 44 24 08          	mov    %eax,0x8(%esp)
		if (retsig == -ERESTARTSYS || retsig == -EINTR)
   2103c:	81 7c 24 08 00 fe ff 	cmpl   $0xfffffe00,0x8(%esp)
   21043:	ff 
   21044:	74 07                	je     2104d <set_termios+0x63>
   21046:	83 7c 24 08 fc       	cmpl   $0xfffffffc,0x8(%esp)
   2104b:	75 06                	jne    21053 <set_termios+0x69>
			return retsig;
   2104d:	8b 44 24 08          	mov    0x8(%esp),%eax
   21051:	eb 52                	jmp    210a5 <set_termios+0xbb>
	}
	// 接着把用户数据区中termios结构信息复制到指定终端tty结构的termios结构中。因为用户有可能已修改了终端串行口传输波特率，
	// 所以这里再根据termios结构中的控制模式标志c_cflag中的波特率信息修改串行UART芯片内的传输波特率。最后返回0。
	for (i = 0 ; i < (sizeof (*termios)) ; i++)
   21053:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   2105a:	00 
   2105b:	eb 2b                	jmp    21088 <set_termios+0x9e>
		((char *) & tty->termios)[i] = get_fs_byte(i + (char *)termios);
   2105d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   21061:	8b 44 24 24          	mov    0x24(%esp),%eax
   21065:	01 d0                	add    %edx,%eax
   21067:	83 ec 0c             	sub    $0xc,%esp
   2106a:	50                   	push   %eax
   2106b:	e8 db fd ff ff       	call   20e4b <get_fs_byte>
   21070:	83 c4 10             	add    $0x10,%esp
   21073:	89 c1                	mov    %eax,%ecx
   21075:	8b 54 24 20          	mov    0x20(%esp),%edx
   21079:	8b 44 24 0c          	mov    0xc(%esp),%eax
   2107d:	01 d0                	add    %edx,%eax
   2107f:	89 ca                	mov    %ecx,%edx
   21081:	88 10                	mov    %dl,(%eax)
	for (i = 0 ; i < (sizeof (*termios)) ; i++)
   21083:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   21088:	8b 44 24 0c          	mov    0xc(%esp),%eax
   2108c:	83 f8 23             	cmp    $0x23,%eax
   2108f:	76 cc                	jbe    2105d <set_termios+0x73>
	change_speed(tty);
   21091:	83 ec 0c             	sub    $0xc,%esp
   21094:	ff 74 24 2c          	pushl  0x2c(%esp)
   21098:	e8 21 fe ff ff       	call   20ebe <change_speed>
   2109d:	83 c4 10             	add    $0x10,%esp
	return 0;
   210a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   210a5:	83 c4 18             	add    $0x18,%esp
   210a8:	5b                   	pop    %ebx
   210a9:	c3                   	ret    

000210aa <get_termio>:

// 读取termio结构中的信息。
// 参数：tty - 指定终端的tty结构指针；termio - 保存termio结构信息的用户缓冲区。
static int get_termio(struct tty_struct * tty, struct termio * termio)
{
   210aa:	53                   	push   %ebx
   210ab:	83 ec 28             	sub    $0x28,%esp
   210ae:	e8 3f 5c fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   210b3:	05 4d 0f 01 00       	add    $0x10f4d,%eax
	struct termio tmp_termio;

	// 首先验证用户的缓冲区指针所指内存区容量是否足够，如不够则分配内存。然后将termios结构的信息复制到临时termio结构中，
	// 这两个结构基本相同，输入、输出、控制和本地标志集数据类型不同。前者的是long，而后者的是short。因此先复制到临时
	// termio结构中目的是为了进行数据类型转换。
	verify_area(termio, sizeof (*termio));
   210b8:	83 ec 08             	sub    $0x8,%esp
   210bb:	6a 12                	push   $0x12
   210bd:	ff 74 24 40          	pushl  0x40(%esp)
   210c1:	89 c3                	mov    %eax,%ebx
   210c3:	e8 33 78 fe ff       	call   88fb <verify_area>
   210c8:	83 c4 10             	add    $0x10,%esp
	tmp_termio.c_iflag = tty->termios.c_iflag;
   210cb:	8b 44 24 30          	mov    0x30(%esp),%eax
   210cf:	8b 00                	mov    (%eax),%eax
   210d1:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
	tmp_termio.c_oflag = tty->termios.c_oflag;
   210d6:	8b 44 24 30          	mov    0x30(%esp),%eax
   210da:	8b 40 04             	mov    0x4(%eax),%eax
   210dd:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	tmp_termio.c_cflag = tty->termios.c_cflag;
   210e2:	8b 44 24 30          	mov    0x30(%esp),%eax
   210e6:	8b 40 08             	mov    0x8(%eax),%eax
   210e9:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	tmp_termio.c_lflag = tty->termios.c_lflag;
   210ee:	8b 44 24 30          	mov    0x30(%esp),%eax
   210f2:	8b 40 0c             	mov    0xc(%eax),%eax
   210f5:	66 89 44 24 10       	mov    %ax,0x10(%esp)
	tmp_termio.c_line = tty->termios.c_line;
   210fa:	8b 44 24 30          	mov    0x30(%esp),%eax
   210fe:	0f b6 40 10          	movzbl 0x10(%eax),%eax
   21102:	88 44 24 12          	mov    %al,0x12(%esp)
	for(i = 0 ; i < NCC ; i++)
   21106:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   2110d:	00 
   2110e:	eb 21                	jmp    21131 <get_termio+0x87>
		tmp_termio.c_cc[i] = tty->termios.c_cc[i];
   21110:	8b 54 24 30          	mov    0x30(%esp),%edx
   21114:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   21118:	01 d0                	add    %edx,%eax
   2111a:	83 c0 11             	add    $0x11,%eax
   2111d:	0f b6 00             	movzbl (%eax),%eax
   21120:	8d 4c 24 13          	lea    0x13(%esp),%ecx
   21124:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   21128:	01 ca                	add    %ecx,%edx
   2112a:	88 02                	mov    %al,(%edx)
	for(i = 0 ; i < NCC ; i++)
   2112c:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   21131:	83 7c 24 1c 07       	cmpl   $0x7,0x1c(%esp)
   21136:	7e d8                	jle    21110 <get_termio+0x66>
	// 然后逐字节地把临时termio结构中的信息复制到用户termio结构缓冲区中。并返回0。
	for (i = 0 ; i < (sizeof (*termio)) ; i++)
   21138:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   2113f:	00 
   21140:	eb 2c                	jmp    2116e <get_termio+0xc4>
		put_fs_byte( ((char *) & tmp_termio)[i] , i + (char *)termio );
   21142:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   21146:	8b 44 24 34          	mov    0x34(%esp),%eax
   2114a:	01 c2                	add    %eax,%edx
   2114c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   21150:	8d 4c 24 0a          	lea    0xa(%esp),%ecx
   21154:	01 c8                	add    %ecx,%eax
   21156:	0f b6 00             	movzbl (%eax),%eax
   21159:	0f be c0             	movsbl %al,%eax
   2115c:	83 ec 08             	sub    $0x8,%esp
   2115f:	52                   	push   %edx
   21160:	50                   	push   %eax
   21161:	e8 1d fd ff ff       	call   20e83 <put_fs_byte>
   21166:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < (sizeof (*termio)) ; i++)
   21169:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   2116e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   21172:	83 f8 11             	cmp    $0x11,%eax
   21175:	76 cb                	jbe    21142 <get_termio+0x98>
	return 0;
   21177:	b8 00 00 00 00       	mov    $0x0,%eax
}
   2117c:	83 c4 28             	add    $0x28,%esp
   2117f:	5b                   	pop    %ebx
   21180:	c3                   	ret    

00021181 <set_termio>:
// 设置终端termio结构信息。
// 参数：tty - 指定终端的tty结构指针；termio - 用户数据区中termio结构。
// 将用户缓冲区termio的信息复制到终端的termios结构中。返回0。
static int set_termio(struct tty_struct * tty, struct termio * termio,
			int channel)
{
   21181:	53                   	push   %ebx
   21182:	83 ec 28             	sub    $0x28,%esp
   21185:	e8 68 5b fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   2118a:	05 76 0e 01 00       	add    $0x10e76,%eax

	// 与set_termios()一样，如果进程使用的终端的进程组号的进程组号与进程的进程组号不同，即当前进程终端不在前台，表示当前
	// 进程试图修改不受控制的终端的termios结构。因此根据POSIX标准的要求这里需要发送SIGTTOU信号让使用这个终端的进程先暂
	// 时停止执行，以让我们先修改termios结构。如果发送信号函数tty_signal()返回值是ERESTARTSYS或EINTR，则等一会再执行
	// 本次操作。
	if ((current->tty == channel) && (tty->pgrp != current->pgrp)) {
   2118f:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   21195:	8b 12                	mov    (%edx),%edx
   21197:	8b 92 2c 03 00 00    	mov    0x32c(%edx),%edx
   2119d:	39 54 24 38          	cmp    %edx,0x38(%esp)
   211a1:	75 4a                	jne    211ed <set_termio+0x6c>
   211a3:	8b 54 24 30          	mov    0x30(%esp),%edx
   211a7:	8b 4a 24             	mov    0x24(%edx),%ecx
   211aa:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   211b0:	8b 12                	mov    (%edx),%edx
   211b2:	8b 92 30 02 00 00    	mov    0x230(%edx),%edx
   211b8:	39 d1                	cmp    %edx,%ecx
   211ba:	74 31                	je     211ed <set_termio+0x6c>
		retsig = tty_signal(SIGTTOU, tty);
   211bc:	83 ec 08             	sub    $0x8,%esp
   211bf:	ff 74 24 38          	pushl  0x38(%esp)
   211c3:	6a 16                	push   $0x16
   211c5:	89 c3                	mov    %eax,%ebx
   211c7:	e8 ed a1 ff ff       	call   1b3b9 <tty_signal>
   211cc:	83 c4 10             	add    $0x10,%esp
   211cf:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (retsig == -ERESTARTSYS || retsig == -EINTR)
   211d3:	81 7c 24 18 00 fe ff 	cmpl   $0xfffffe00,0x18(%esp)
   211da:	ff 
   211db:	74 07                	je     211e4 <set_termio+0x63>
   211dd:	83 7c 24 18 fc       	cmpl   $0xfffffffc,0x18(%esp)
   211e2:	75 09                	jne    211ed <set_termio+0x6c>
			return retsig;
   211e4:	8b 44 24 18          	mov    0x18(%esp),%eax
   211e8:	e9 c9 00 00 00       	jmp    212b6 <set_termio+0x135>
	}
	// 接着复制用户数据区中termio结构信息到临时termio结构中。然后再将termio结构的信息复制到tty的termios结构中。这样做
	// 的目的是为了对其中模式标志集的类型进行转换，即从termio的短整数类型转换成termios的长整数类型。但两种结构的c_line和
	// c_cc[]字段是完全相同的。
	for (i = 0 ; i< (sizeof (*termio)) ; i++)
   211ed:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   211f4:	00 
   211f5:	eb 2b                	jmp    21222 <set_termio+0xa1>
		((char *)&tmp_termio)[i] = get_fs_byte(i + (char *)termio);
   211f7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   211fb:	8b 44 24 34          	mov    0x34(%esp),%eax
   211ff:	01 d0                	add    %edx,%eax
   21201:	83 ec 0c             	sub    $0xc,%esp
   21204:	50                   	push   %eax
   21205:	e8 41 fc ff ff       	call   20e4b <get_fs_byte>
   2120a:	83 c4 10             	add    $0x10,%esp
   2120d:	89 c1                	mov    %eax,%ecx
   2120f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   21213:	8d 54 24 06          	lea    0x6(%esp),%edx
   21217:	01 d0                	add    %edx,%eax
   21219:	89 ca                	mov    %ecx,%edx
   2121b:	88 10                	mov    %dl,(%eax)
	for (i = 0 ; i< (sizeof (*termio)) ; i++)
   2121d:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   21222:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   21226:	83 f8 11             	cmp    $0x11,%eax
   21229:	76 cc                	jbe    211f7 <set_termio+0x76>
	*(unsigned short *)&tty->termios.c_iflag = tmp_termio.c_iflag;
   2122b:	8b 44 24 30          	mov    0x30(%esp),%eax
   2122f:	0f b7 54 24 06       	movzwl 0x6(%esp),%edx
   21234:	66 89 10             	mov    %dx,(%eax)
	*(unsigned short *)&tty->termios.c_oflag = tmp_termio.c_oflag;
   21237:	8b 44 24 30          	mov    0x30(%esp),%eax
   2123b:	8d 50 04             	lea    0x4(%eax),%edx
   2123e:	0f b7 44 24 08       	movzwl 0x8(%esp),%eax
   21243:	66 89 02             	mov    %ax,(%edx)
	*(unsigned short *)&tty->termios.c_cflag = tmp_termio.c_cflag;
   21246:	8b 44 24 30          	mov    0x30(%esp),%eax
   2124a:	8d 50 08             	lea    0x8(%eax),%edx
   2124d:	0f b7 44 24 0a       	movzwl 0xa(%esp),%eax
   21252:	66 89 02             	mov    %ax,(%edx)
	*(unsigned short *)&tty->termios.c_lflag = tmp_termio.c_lflag;
   21255:	8b 44 24 30          	mov    0x30(%esp),%eax
   21259:	8d 50 0c             	lea    0xc(%eax),%edx
   2125c:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   21261:	66 89 02             	mov    %ax,(%edx)
	tty->termios.c_line = tmp_termio.c_line;
   21264:	0f b6 54 24 0e       	movzbl 0xe(%esp),%edx
   21269:	8b 44 24 30          	mov    0x30(%esp),%eax
   2126d:	88 50 10             	mov    %dl,0x10(%eax)
	for(i = 0 ; i < NCC ; i++)
   21270:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   21277:	00 
   21278:	eb 21                	jmp    2129b <set_termio+0x11a>
		tty->termios.c_cc[i] = tmp_termio.c_cc[i];
   2127a:	8d 54 24 0f          	lea    0xf(%esp),%edx
   2127e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   21282:	01 d0                	add    %edx,%eax
   21284:	0f b6 00             	movzbl (%eax),%eax
   21287:	8b 4c 24 30          	mov    0x30(%esp),%ecx
   2128b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   2128f:	01 ca                	add    %ecx,%edx
   21291:	83 c2 11             	add    $0x11,%edx
   21294:	88 02                	mov    %al,(%edx)
	for(i = 0 ; i < NCC ; i++)
   21296:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   2129b:	83 7c 24 1c 07       	cmpl   $0x7,0x1c(%esp)
   212a0:	7e d8                	jle    2127a <set_termio+0xf9>
	// 最后因为用户有可能已修改了终端串行口传输波特率，所以这里再根据termios结构中的控制模式标志c_cflag中的波特率信息修改
	// 串行UART芯片内的传输波特率，并返回0。
	change_speed(tty);
   212a2:	83 ec 0c             	sub    $0xc,%esp
   212a5:	ff 74 24 3c          	pushl  0x3c(%esp)
   212a9:	e8 10 fc ff ff       	call   20ebe <change_speed>
   212ae:	83 c4 10             	add    $0x10,%esp
	return 0;
   212b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   212b6:	83 c4 28             	add    $0x28,%esp
   212b9:	5b                   	pop    %ebx
   212ba:	c3                   	ret    

000212bb <tty_ioctl>:

// tty终端设备输入输出控制函数。
// 参数：dev - 设备号；cmd - ioctl命令；arg - 操作参数指针。
// 该函数首先根据参数给出的设备号找出对应终端的tty结构，然后根据控制命令cmd分别进行处理。
int tty_ioctl(int dev, int cmd, int arg)
{
   212bb:	53                   	push   %ebx
   212bc:	83 ec 18             	sub    $0x18,%esp
   212bf:	e8 36 5a fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   212c4:	81 c3 3c 0d 01 00    	add    $0x10d3c,%ebx
	int	pgrp;

	// 首先根据设备号取得tty子设备号，从而取得终端的tty结构。若主设备号是5（控制终端），则进程的tty字段即是tty子设备
	// 号。此时如果进程的tty子设备号是负数，表明该进程没有控制终端，即不能发出该ioctl调用，于是显示出错信息并停机。如果
	// 主设备号不是5而是4,我们就可以从设备号中取出子设备号。子设备号可以是0（控制台终端）、1（串口1终端）、2（串口2终端）。
	if (MAJOR(dev) == 5) {
   212ca:	8b 44 24 20          	mov    0x20(%esp),%eax
   212ce:	c1 e8 08             	shr    $0x8,%eax
   212d1:	83 f8 05             	cmp    $0x5,%eax
   212d4:	75 2d                	jne    21303 <tty_ioctl+0x48>
		dev = current->tty;
   212d6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   212dc:	8b 00                	mov    (%eax),%eax
   212de:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
   212e4:	89 44 24 20          	mov    %eax,0x20(%esp)
		if (dev < 0)
   212e8:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   212ed:	79 1c                	jns    2130b <tty_ioctl+0x50>
			panic("tty_ioctl: dev<0");
   212ef:	83 ec 0c             	sub    $0xc,%esp
   212f2:	8d 83 00 67 ff ff    	lea    -0x9900(%ebx),%eax
   212f8:	50                   	push   %eax
   212f9:	e8 e0 7f fe ff       	call   92de <panic>
   212fe:	83 c4 10             	add    $0x10,%esp
   21301:	eb 08                	jmp    2130b <tty_ioctl+0x50>
	} else
		dev = MINOR(dev);
   21303:	81 64 24 20 ff 00 00 	andl   $0xff,0x20(%esp)
   2130a:	00 
	// ioctl命令cmd进行分别处理。144行后半部分用于根据子设备号dev在tty_table[]表中选择对应的tty结构。如果dev = 0，表示
	// 正在使用前台终端，因此直接使用终端号fg_console作为tty_table[]项索引取tty结构。如果dev大于0,那么就要分两种情况考虑：
	// 1、dev是虚拟终端号；2、dev是串行终端号或者伪终端号。对于虚拟终端其tty结构在tty_table[]中索引项是dev-1（0--63）。
	// 对于其他类型终端，则它们的tty结构索引项就是dev。例如，如果dev = 64，表示是一个串行终端1,则其tty结构就是tty_table[dev]
	// 如果dev = 1，则对应终端的tty结构是tty_table[0]。
	tty = tty_table + (dev ? ((dev < 64)? dev - 1 : dev) : fg_console);
   2130b:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   21310:	74 30                	je     21342 <tty_ioctl+0x87>
   21312:	83 7c 24 20 3f       	cmpl   $0x3f,0x20(%esp)
   21317:	7f 16                	jg     2132f <tty_ioctl+0x74>
   21319:	8b 44 24 20          	mov    0x20(%esp),%eax
   2131d:	83 e8 01             	sub    $0x1,%eax
   21320:	c1 e0 06             	shl    $0x6,%eax
   21323:	89 c2                	mov    %eax,%edx
   21325:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   2132b:	01 d0                	add    %edx,%eax
   2132d:	eb 28                	jmp    21357 <tty_ioctl+0x9c>
   2132f:	8b 44 24 20          	mov    0x20(%esp),%eax
   21333:	c1 e0 06             	shl    $0x6,%eax
   21336:	89 c2                	mov    %eax,%edx
   21338:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   2133e:	01 d0                	add    %edx,%eax
   21340:	eb 15                	jmp    21357 <tty_ioctl+0x9c>
   21342:	c7 c0 00 63 03 00    	mov    $0x36300,%eax
   21348:	8b 00                	mov    (%eax),%eax
   2134a:	c1 e0 06             	shl    $0x6,%eax
   2134d:	89 c2                	mov    %eax,%edx
   2134f:	c7 c0 a0 68 04 00    	mov    $0x468a0,%eax
   21355:	01 d0                	add    %edx,%eax
   21357:	89 44 24 0c          	mov    %eax,0xc(%esp)
	switch (cmd) {
   2135b:	8b 44 24 24          	mov    0x24(%esp),%eax
   2135f:	2d 01 54 00 00       	sub    $0x5401,%eax
   21364:	83 f8 1a             	cmp    $0x1a,%eax
   21367:	0f 87 60 04 00 00    	ja     217cd <.L74+0x7>
   2136d:	c1 e0 02             	shl    $0x2,%eax
   21370:	8b 84 18 14 67 ff ff 	mov    -0x98ec(%eax,%ebx,1),%eax
   21377:	01 d8                	add    %ebx,%eax
   21379:	ff e0                	jmp    *%eax

0002137b <.L48>:
		// 取相应终端termios结构信息。此时参数arg是用户缓冲区指针。
		case TCGETS:
			return get_termios(tty, (struct termios *) arg);
   2137b:	8b 44 24 28          	mov    0x28(%esp),%eax
   2137f:	83 ec 08             	sub    $0x8,%esp
   21382:	50                   	push   %eax
   21383:	ff 74 24 18          	pushl  0x18(%esp)
   21387:	e8 f4 fb ff ff       	call   20f80 <get_termios>
   2138c:	83 c4 10             	add    $0x10,%esp
   2138f:	e9 3e 04 00 00       	jmp    217d2 <.L74+0xc>

00021394 <.L52>:
		// 在设置termios结构信息之前，需要先等待输出队列中所有数据处理完毕，并且刷新（清空）输入队列。再接着执行下面的设置终端termios
		// 结构的操作。
		case TCSETSF:
			flush(tty->read_q); 							/* fallthrough */
   21394:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21398:	8b 40 34             	mov    0x34(%eax),%eax
   2139b:	83 ec 0c             	sub    $0xc,%esp
   2139e:	50                   	push   %eax
   2139f:	e8 a8 fb ff ff       	call   20f4c <flush>
   213a4:	83 c4 10             	add    $0x10,%esp

000213a7 <.L51>:
		// 在设置终端termios的信息之前，需要先等待输出队列中所有数据处理完（耗尽）。对于修改参数会影响输出的情况，就需要使用这种形式。
		case TCSETSW:
			wait_until_sent(tty); 							/* fallthrough */
   213a7:	83 ec 0c             	sub    $0xc,%esp
   213aa:	ff 74 24 18          	pushl  0x18(%esp)
   213ae:	e8 b5 fb ff ff       	call   20f68 <wait_until_sent>
   213b3:	83 c4 10             	add    $0x10,%esp

000213b6 <.L50>:
		// 设置相应终端termios结构信息。此时参数arg是保存termios结构的用户缓冲区指针。
		case TCSETS:
			return set_termios(tty,(struct termios *) arg, dev);
   213b6:	8b 44 24 28          	mov    0x28(%esp),%eax
   213ba:	83 ec 04             	sub    $0x4,%esp
   213bd:	ff 74 24 24          	pushl  0x24(%esp)
   213c1:	50                   	push   %eax
   213c2:	ff 74 24 18          	pushl  0x18(%esp)
   213c6:	e8 1f fc ff ff       	call   20fea <set_termios>
   213cb:	83 c4 10             	add    $0x10,%esp
   213ce:	e9 ff 03 00 00       	jmp    217d2 <.L74+0xc>

000213d3 <.L53>:
		// 取相应终端termio结构中的信息。此时参数arg是用户缓冲区指针。
		case TCGETA:
			return get_termio(tty,(struct termio *) arg);
   213d3:	8b 44 24 28          	mov    0x28(%esp),%eax
   213d7:	83 ec 08             	sub    $0x8,%esp
   213da:	50                   	push   %eax
   213db:	ff 74 24 18          	pushl  0x18(%esp)
   213df:	e8 c6 fc ff ff       	call   210aa <get_termio>
   213e4:	83 c4 10             	add    $0x10,%esp
   213e7:	e9 e6 03 00 00       	jmp    217d2 <.L74+0xc>

000213ec <.L56>:
		// 在设置termio结构信息之前，需要先等待输出队列中所有数据处理完毕，并且刷新（清空）输入队列。再接着执行下面的设置终端termio
		// 结构的操作。
		case TCSETAF:
			flush(tty->read_q); 							/* fallthrough */
   213ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
   213f0:	8b 40 34             	mov    0x34(%eax),%eax
   213f3:	83 ec 0c             	sub    $0xc,%esp
   213f6:	50                   	push   %eax
   213f7:	e8 50 fb ff ff       	call   20f4c <flush>
   213fc:	83 c4 10             	add    $0x10,%esp

000213ff <.L55>:
		// 在设置终端termios的信息之前，需要先等待输出队列中所有数据处理完（耗尽）。对于修改参数会影响输出的情况，就需要使用这种形式。
		case TCSETAW:
			wait_until_sent(tty); 							/* fallthrough */
   213ff:	83 ec 0c             	sub    $0xc,%esp
   21402:	ff 74 24 18          	pushl  0x18(%esp)
   21406:	e8 5d fb ff ff       	call   20f68 <wait_until_sent>
   2140b:	83 c4 10             	add    $0x10,%esp

0002140e <.L54>:
		// 设置相应终端termio结构信息。此时参数arg是保存termio结构的用户缓冲区指针。
		case TCSETA:
			return set_termio(tty,(struct termio *) arg, dev);
   2140e:	8b 44 24 28          	mov    0x28(%esp),%eax
   21412:	83 ec 04             	sub    $0x4,%esp
   21415:	ff 74 24 24          	pushl  0x24(%esp)
   21419:	50                   	push   %eax
   2141a:	ff 74 24 18          	pushl  0x18(%esp)
   2141e:	e8 5e fd ff ff       	call   21181 <set_termio>
   21423:	83 c4 10             	add    $0x10,%esp
   21426:	e9 a7 03 00 00       	jmp    217d2 <.L74+0xc>

0002142b <.L57>:
		// 如果参数arg值是0，则等待输出队列处理完毕（空），并发送一个break。
		case TCSBRK:
			if (!arg) {
   2142b:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   21430:	75 1e                	jne    21450 <.L57+0x25>
				wait_until_sent(tty);
   21432:	83 ec 0c             	sub    $0xc,%esp
   21435:	ff 74 24 18          	pushl  0x18(%esp)
   21439:	e8 2a fb ff ff       	call   20f68 <wait_until_sent>
   2143e:	83 c4 10             	add    $0x10,%esp
				send_break(tty);
   21441:	83 ec 0c             	sub    $0xc,%esp
   21444:	ff 74 24 18          	pushl  0x18(%esp)
   21448:	e8 27 fb ff ff       	call   20f74 <send_break>
   2144d:	83 c4 10             	add    $0x10,%esp
			}
			return 0;
   21450:	b8 00 00 00 00       	mov    $0x0,%eax
   21455:	e9 78 03 00 00       	jmp    217d2 <.L74+0xc>

0002145a <.L58>:
		// 开始/停止流控制。如果参数arg是TCOOFF（Terminal Control Output OFF），则挂起输出；如果是TCOON，则恢复挂起的输出。在挂
		// 起或恢复输出同时需要把写队列中的字符输出，以加快用户交互响应速度。如果arg是TCIOFF（Terminal Control Input ON），则挂起
		// 输入；如果是TCION，则重新开启挂起的输入。
		case TCXONC:
			switch (arg) {
   2145a:	8b 44 24 28          	mov    0x28(%esp),%eax
   2145e:	83 f8 01             	cmp    $0x1,%eax
   21461:	74 49                	je     214ac <.L58+0x52>
   21463:	83 f8 01             	cmp    $0x1,%eax
   21466:	7f 09                	jg     21471 <.L58+0x17>
   21468:	85 c0                	test   %eax,%eax
   2146a:	74 18                	je     21484 <.L58+0x2a>
   2146c:	e9 03 01 00 00       	jmp    21574 <.L58+0x11a>
   21471:	83 f8 02             	cmp    $0x2,%eax
   21474:	74 5e                	je     214d4 <.L58+0x7a>
   21476:	83 f8 03             	cmp    $0x3,%eax
   21479:	0f 84 a5 00 00 00    	je     21524 <.L58+0xca>
   2147f:	e9 f0 00 00 00       	jmp    21574 <.L58+0x11a>
			case TCOOFF:
				tty->stopped = 1;       					// 停止终端输出。
   21484:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21488:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
				tty->write(tty);        					// 写缓冲队列输出。
   2148f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21493:	8b 40 30             	mov    0x30(%eax),%eax
   21496:	83 ec 0c             	sub    $0xc,%esp
   21499:	ff 74 24 18          	pushl  0x18(%esp)
   2149d:	ff d0                	call   *%eax
   2149f:	83 c4 10             	add    $0x10,%esp
				return 0;
   214a2:	b8 00 00 00 00       	mov    $0x0,%eax
   214a7:	e9 26 03 00 00       	jmp    217d2 <.L74+0xc>
			case TCOON:
				tty->stopped = 0;       					// 恢复终端输出。
   214ac:	8b 44 24 0c          	mov    0xc(%esp),%eax
   214b0:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
				tty->write(tty);
   214b7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   214bb:	8b 40 30             	mov    0x30(%eax),%eax
   214be:	83 ec 0c             	sub    $0xc,%esp
   214c1:	ff 74 24 18          	pushl  0x18(%esp)
   214c5:	ff d0                	call   *%eax
   214c7:	83 c4 10             	add    $0x10,%esp
				return 0;
   214ca:	b8 00 00 00 00       	mov    $0x0,%eax
   214cf:	e9 fe 02 00 00       	jmp    217d2 <.L74+0xc>
			// 如果参数arg是TCIOFF，表示要求终端停止输入，于是我们往终端写队列放入STOP字符。当终端收到该字符时就会暂停输入。如果参数是
			// TCION，表示发送一个START字符，让终端恢复传输。STOP_CHAR(tty)字义为((tty)->termios.c_cc[VSTOP])，即取终端termios
			// 结构控制字符数组对应项值。若内核定义了_POSIX_VDISABLE(\0)，那么当某一项等于_POSIX_VDISABLE的值时，表示禁止使用相应的
			// 特殊字符。因此这里直接判断该值是否为0来确定要不要把停止控制字符放入终端写队列中。以下同。
			case TCIOFF:
				if (STOP_CHAR(tty))
   214d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   214d8:	0f b6 40 1a          	movzbl 0x1a(%eax),%eax
   214dc:	84 c0                	test   %al,%al
   214de:	74 3a                	je     2151a <.L58+0xc0>
					PUTCH(STOP_CHAR(tty), tty->write_q);
   214e0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   214e4:	0f b6 48 1a          	movzbl 0x1a(%eax),%ecx
   214e8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   214ec:	8b 50 38             	mov    0x38(%eax),%edx
   214ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
   214f3:	8b 40 38             	mov    0x38(%eax),%eax
   214f6:	8b 40 04             	mov    0x4(%eax),%eax
   214f9:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   214fd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21501:	8b 40 38             	mov    0x38(%eax),%eax
   21504:	8b 40 04             	mov    0x4(%eax),%eax
   21507:	8d 50 01             	lea    0x1(%eax),%edx
   2150a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   2150e:	8b 40 38             	mov    0x38(%eax),%eax
   21511:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   21517:	89 50 04             	mov    %edx,0x4(%eax)
				return 0;
   2151a:	b8 00 00 00 00       	mov    $0x0,%eax
   2151f:	e9 ae 02 00 00       	jmp    217d2 <.L74+0xc>
			case TCION:
				if (START_CHAR(tty))
   21524:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21528:	0f b6 40 19          	movzbl 0x19(%eax),%eax
   2152c:	84 c0                	test   %al,%al
   2152e:	74 3a                	je     2156a <.L58+0x110>
					PUTCH(START_CHAR(tty), tty->write_q);
   21530:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21534:	0f b6 48 19          	movzbl 0x19(%eax),%ecx
   21538:	8b 44 24 0c          	mov    0xc(%esp),%eax
   2153c:	8b 50 38             	mov    0x38(%eax),%edx
   2153f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21543:	8b 40 38             	mov    0x38(%eax),%eax
   21546:	8b 40 04             	mov    0x4(%eax),%eax
   21549:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   2154d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21551:	8b 40 38             	mov    0x38(%eax),%eax
   21554:	8b 40 04             	mov    0x4(%eax),%eax
   21557:	8d 50 01             	lea    0x1(%eax),%edx
   2155a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   2155e:	8b 40 38             	mov    0x38(%eax),%eax
   21561:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   21567:	89 50 04             	mov    %edx,0x4(%eax)
				return 0;
   2156a:	b8 00 00 00 00       	mov    $0x0,%eax
   2156f:	e9 5e 02 00 00       	jmp    217d2 <.L74+0xc>
			}
			return -EINVAL; 								/* not implemented */
   21574:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   21579:	e9 54 02 00 00       	jmp    217d2 <.L74+0xc>

0002157e <.L59>:
		// 刷新已写输出但还没有发送、或已接收但还没有读的数据。如果参数arg是0，则刷新（清空）输入队列；如果是1，则刷新输出队列；如果
		// 2，则刷新输入和输出队列。
		case TCFLSH:
			if (arg == 0)
   2157e:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   21583:	75 15                	jne    2159a <.L59+0x1c>
				flush(tty->read_q);
   21585:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21589:	8b 40 34             	mov    0x34(%eax),%eax
   2158c:	83 ec 0c             	sub    $0xc,%esp
   2158f:	50                   	push   %eax
   21590:	e8 b7 f9 ff ff       	call   20f4c <flush>
   21595:	83 c4 10             	add    $0x10,%esp
   21598:	eb 55                	jmp    215ef <.L59+0x71>
			else if (arg == 1)
   2159a:	83 7c 24 28 01       	cmpl   $0x1,0x28(%esp)
   2159f:	75 15                	jne    215b6 <.L59+0x38>
				flush(tty->write_q);
   215a1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   215a5:	8b 40 38             	mov    0x38(%eax),%eax
   215a8:	83 ec 0c             	sub    $0xc,%esp
   215ab:	50                   	push   %eax
   215ac:	e8 9b f9 ff ff       	call   20f4c <flush>
   215b1:	83 c4 10             	add    $0x10,%esp
   215b4:	eb 39                	jmp    215ef <.L59+0x71>
			else if (arg == 2) {
   215b6:	83 7c 24 28 02       	cmpl   $0x2,0x28(%esp)
   215bb:	75 28                	jne    215e5 <.L59+0x67>
				flush(tty->read_q);
   215bd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   215c1:	8b 40 34             	mov    0x34(%eax),%eax
   215c4:	83 ec 0c             	sub    $0xc,%esp
   215c7:	50                   	push   %eax
   215c8:	e8 7f f9 ff ff       	call   20f4c <flush>
   215cd:	83 c4 10             	add    $0x10,%esp
				flush(tty->write_q);
   215d0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   215d4:	8b 40 38             	mov    0x38(%eax),%eax
   215d7:	83 ec 0c             	sub    $0xc,%esp
   215da:	50                   	push   %eax
   215db:	e8 6c f9 ff ff       	call   20f4c <flush>
   215e0:	83 c4 10             	add    $0x10,%esp
   215e3:	eb 0a                	jmp    215ef <.L59+0x71>
			} else
				return -EINVAL;
   215e5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   215ea:	e9 e3 01 00 00       	jmp    217d2 <.L74+0xc>
			return 0;
   215ef:	b8 00 00 00 00       	mov    $0x0,%eax
   215f4:	e9 d9 01 00 00       	jmp    217d2 <.L74+0xc>

000215f9 <.L60>:
		// 设置终端串行线路专用模式。
		case TIOCEXCL:
			return -EINVAL; 							/* not implemented */   /* 未实现 */
   215f9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   215fe:	e9 cf 01 00 00       	jmp    217d2 <.L74+0xc>

00021603 <.L61>:
		// 复位终端串行线路专用模式。
		case TIOCNXCL:
			return -EINVAL; 							/* not implemented */
   21603:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   21608:	e9 c5 01 00 00       	jmp    217d2 <.L74+0xc>

0002160d <.L62>:
		// 设置tty为控制终端。（TIOCNOTTY - 不要控制终端）。
		case TIOCSCTTY:
			return -EINVAL; 							/* set controlling term NI */
   2160d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   21612:	e9 bb 01 00 00       	jmp    217d2 <.L74+0xc>

00021617 <.L63>:
		// 读取终端进程组号（即读取前台进程组号）。首先验证用户缓冲区长度，然后复制终端tty的pgrp字段到用户缓冲区。此时参数arg是用户
		// 缓冲区指针。
		case TIOCGPGRP:
			verify_area((void *) arg, 4);            	// 实现库函数tcgetpgrp()。
   21617:	8b 44 24 28          	mov    0x28(%esp),%eax
   2161b:	83 ec 08             	sub    $0x8,%esp
   2161e:	6a 04                	push   $0x4
   21620:	50                   	push   %eax
   21621:	e8 d5 72 fe ff       	call   88fb <verify_area>
   21626:	83 c4 10             	add    $0x10,%esp
			put_fs_long(tty->pgrp, (unsigned long *) arg);
   21629:	8b 44 24 28          	mov    0x28(%esp),%eax
   2162d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   21631:	8b 52 24             	mov    0x24(%edx),%edx
   21634:	83 ec 08             	sub    $0x8,%esp
   21637:	50                   	push   %eax
   21638:	52                   	push   %edx
   21639:	e8 69 f8 ff ff       	call   20ea7 <put_fs_long>
   2163e:	83 c4 10             	add    $0x10,%esp
			return 0;
   21641:	b8 00 00 00 00       	mov    $0x0,%eax
   21646:	e9 87 01 00 00       	jmp    217d2 <.L74+0xc>

0002164b <.L64>:
		// 设置终端进程组号pgrp（即设置前台进程组号）。此时参数arg是用户缓冲区中进程组号pgrp的指针。执行该命令的前提条件是进程必须
		// 有控制终端。如果当前进程没有控制终端，或者dev不是其控制终端，或者控制终端现在的确是正在处理的终端dev，但进程的会话号与该
		// 终端dev的会话号不同，则返回无终端错误信息。
		case TIOCSPGRP:                                 // 实现库函数tcsetpgrp()。
			if ((current->tty < 0) ||
   2164b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21651:	8b 00                	mov    (%eax),%eax
   21653:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
   21659:	85 c0                	test   %eax,%eax
   2165b:	78 2d                	js     2168a <.L64+0x3f>
			    (current->tty != dev) ||
   2165d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21663:	8b 00                	mov    (%eax),%eax
   21665:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
			if ((current->tty < 0) ||
   2166b:	39 44 24 20          	cmp    %eax,0x20(%esp)
   2166f:	75 19                	jne    2168a <.L64+0x3f>
			    (tty->session != current->session))
   21671:	8b 44 24 0c          	mov    0xc(%esp),%eax
   21675:	8b 50 28             	mov    0x28(%eax),%edx
   21678:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   2167e:	8b 00                	mov    (%eax),%eax
   21680:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
			    (current->tty != dev) ||
   21686:	39 c2                	cmp    %eax,%edx
   21688:	74 0a                	je     21694 <.L64+0x49>
				return -ENOTTY;
   2168a:	b8 e7 ff ff ff       	mov    $0xffffffe7,%eax
   2168f:	e9 3e 01 00 00       	jmp    217d2 <.L74+0xc>
			// 然后我们就从用户缓冲区中取得欲设置的进程号，并对该组号的有效性进行验证。如果组号pgrp小于0,则返回无效组号错误信息；如果pgrp
			// 的会话号与当前进程的不同，则返回许可错误信息。否则我们可以设置终端进程组号为pgrp。此时pgrp成为前台进程组。
			pgrp = get_fs_long((unsigned long *) arg);
   21694:	8b 44 24 28          	mov    0x28(%esp),%eax
   21698:	83 ec 0c             	sub    $0xc,%esp
   2169b:	50                   	push   %eax
   2169c:	e8 c2 f7 ff ff       	call   20e63 <get_fs_long>
   216a1:	83 c4 10             	add    $0x10,%esp
   216a4:	89 44 24 08          	mov    %eax,0x8(%esp)
			if (pgrp < 0)
   216a8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   216ad:	79 0a                	jns    216b9 <.L64+0x6e>
				return -EINVAL;
   216af:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   216b4:	e9 19 01 00 00       	jmp    217d2 <.L74+0xc>
			if (session_of_pgrp(pgrp) != current->session)
   216b9:	83 ec 0c             	sub    $0xc,%esp
   216bc:	ff 74 24 14          	pushl  0x14(%esp)
   216c0:	e8 17 9f fe ff       	call   b5dc <session_of_pgrp>
   216c5:	83 c4 10             	add    $0x10,%esp
   216c8:	89 c2                	mov    %eax,%edx
   216ca:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   216d0:	8b 00                	mov    (%eax),%eax
   216d2:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
   216d8:	39 c2                	cmp    %eax,%edx
   216da:	74 0a                	je     216e6 <.L64+0x9b>
				return -EPERM;
   216dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   216e1:	e9 ec 00 00 00       	jmp    217d2 <.L74+0xc>
			tty->pgrp = pgrp;
   216e6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   216ea:	8b 54 24 08          	mov    0x8(%esp),%edx
   216ee:	89 50 24             	mov    %edx,0x24(%eax)
			return 0;
   216f1:	b8 00 00 00 00       	mov    $0x0,%eax
   216f6:	e9 d7 00 00 00       	jmp    217d2 <.L74+0xc>

000216fb <.L65>:
		// 返回输出队列中还未送出的字符数。首先验证用户缓冲区长度，然后复制队列中字符数给用户。此时参数arg是用户缓冲区指针。
		case TIOCOUTQ:
			verify_area((void *) arg, 4);
   216fb:	8b 44 24 28          	mov    0x28(%esp),%eax
   216ff:	83 ec 08             	sub    $0x8,%esp
   21702:	6a 04                	push   $0x4
   21704:	50                   	push   %eax
   21705:	e8 f1 71 fe ff       	call   88fb <verify_area>
   2170a:	83 c4 10             	add    $0x10,%esp
			put_fs_long(CHARS(tty->write_q), (unsigned long *) arg);
   2170d:	8b 44 24 28          	mov    0x28(%esp),%eax
   21711:	8b 54 24 0c          	mov    0xc(%esp),%edx
   21715:	8b 52 38             	mov    0x38(%edx),%edx
   21718:	8b 4a 04             	mov    0x4(%edx),%ecx
   2171b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   2171f:	8b 52 38             	mov    0x38(%edx),%edx
   21722:	8b 52 08             	mov    0x8(%edx),%edx
   21725:	29 d1                	sub    %edx,%ecx
   21727:	89 ca                	mov    %ecx,%edx
   21729:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   2172f:	83 ec 08             	sub    $0x8,%esp
   21732:	50                   	push   %eax
   21733:	52                   	push   %edx
   21734:	e8 6e f7 ff ff       	call   20ea7 <put_fs_long>
   21739:	83 c4 10             	add    $0x10,%esp
			return 0;
   2173c:	b8 00 00 00 00       	mov    $0x0,%eax
   21741:	e9 8c 00 00 00       	jmp    217d2 <.L74+0xc>

00021746 <.L75>:
		// 返回输入队列中还未读取的字符数。首先验证用户缓冲区长度，然后复制队列中字符数给用户。此时参数arg是用户缓冲区指针。
		case TIOCINQ:
			verify_area((void *) arg, 4);
   21746:	8b 44 24 28          	mov    0x28(%esp),%eax
   2174a:	83 ec 08             	sub    $0x8,%esp
   2174d:	6a 04                	push   $0x4
   2174f:	50                   	push   %eax
   21750:	e8 a6 71 fe ff       	call   88fb <verify_area>
   21755:	83 c4 10             	add    $0x10,%esp
			put_fs_long(CHARS(tty->secondary),
   21758:	8b 44 24 28          	mov    0x28(%esp),%eax
   2175c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   21760:	8b 52 3c             	mov    0x3c(%edx),%edx
   21763:	8b 4a 04             	mov    0x4(%edx),%ecx
   21766:	8b 54 24 0c          	mov    0xc(%esp),%edx
   2176a:	8b 52 3c             	mov    0x3c(%edx),%edx
   2176d:	8b 52 08             	mov    0x8(%edx),%edx
   21770:	29 d1                	sub    %edx,%ecx
   21772:	89 ca                	mov    %ecx,%edx
   21774:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   2177a:	83 ec 08             	sub    $0x8,%esp
   2177d:	50                   	push   %eax
   2177e:	52                   	push   %edx
   2177f:	e8 23 f7 ff ff       	call   20ea7 <put_fs_long>
   21784:	83 c4 10             	add    $0x10,%esp
				(unsigned long *) arg);
			return 0;
   21787:	b8 00 00 00 00       	mov    $0x0,%eax
   2178c:	eb 44                	jmp    217d2 <.L74+0xc>

0002178e <.L66>:
		// 模拟终端输入操作。该命令以一个指向字符的指针作为参数，并假设该字符是在终端上键入的。用户终须在该控制终端上具有超级
		// 用户权限或具有读许可权限。
		case TIOCSTI:
			return -EINVAL; 							/* not implemented */
   2178e:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   21793:	eb 3d                	jmp    217d2 <.L74+0xc>

00021795 <.L67>:
		// 读取终端设备窗口大小信息（参见termios.h中的winsize结构）。
		case TIOCGWINSZ:
			return -EINVAL; 							/* not implemented */
   21795:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   2179a:	eb 36                	jmp    217d2 <.L74+0xc>

0002179c <.L68>:
		// 设置终端设备窗口大小信息（参见winsize结构）。
		case TIOCSWINSZ:
			return -EINVAL; 							/* not implemented */
   2179c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   217a1:	eb 2f                	jmp    217d2 <.L74+0xc>

000217a3 <.L69>:
		// 返回MODEM状态控制引线的当前状态位标志集（参见termios.h）。
		case TIOCMGET:
			return -EINVAL; 							/* not implemented */
   217a3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   217a8:	eb 28                	jmp    217d2 <.L74+0xc>

000217aa <.L70>:
		// 设置单个modem状态控制引线的状态（true或false）。
		case TIOCMBIS:
			return -EINVAL; 							/* not implemented */
   217aa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   217af:	eb 21                	jmp    217d2 <.L74+0xc>

000217b1 <.L71>:
		// 复位ujwhMODEM状态控制引线的状态。
		case TIOCMBIC:
			return -EINVAL; 							/* not implemented */
   217b1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   217b6:	eb 1a                	jmp    217d2 <.L74+0xc>

000217b8 <.L72>:
		// 设置MODEM状态引线的状态。如果某一位置位，则modem对应的状态引线将为有效。
		case TIOCMSET:
			return -EINVAL; 							/* not implemented */
   217b8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   217bd:	eb 13                	jmp    217d2 <.L74+0xc>

000217bf <.L73>:
		// 读取软件载波检测标志（1 - 开启；0 - 关闭）。
		case TIOCGSOFTCAR:
			return -EINVAL; 							/* not implemented */
   217bf:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   217c4:	eb 0c                	jmp    217d2 <.L74+0xc>

000217c6 <.L74>:
		// 设置软件载波检测标志（1 - 开启；0 - 关闭）。
		case TIOCSSOFTCAR:
			return -EINVAL; 							/* not implemented */
   217c6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   217cb:	eb 05                	jmp    217d2 <.L74+0xc>
		default:
			return -EINVAL;
   217cd:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
        }
}
   217d2:	83 c4 18             	add    $0x18,%esp
   217d5:	5b                   	pop    %ebx
   217d6:	c3                   	ret    

000217d7 <pty_copy>:
#include <asm/io.h>

// 伪终端写函数。
// 参数：from - 源伪终端结构；to - 目的伪终端结构。
static inline void pty_copy(struct tty_struct * from, struct tty_struct * to)
{
   217d7:	53                   	push   %ebx
   217d8:	83 ec 18             	sub    $0x18,%esp
   217db:	e8 1a 55 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   217e0:	81 c3 20 08 01 00    	add    $0x10820,%ebx
	char c;

	// 判断源终端是否停止或源终端写队列是否为空。如果源终端未停止，并且源终端写队列不为空，则循环处理之。
	while (!from->stopped && !EMPTY(from->write_q)) {
   217e6:	e9 ef 00 00 00       	jmp    218da <pty_copy+0x103>
		// 判断目的终端读队列是否已满，如果已满则先调用copy_to_cooked函数处理目的终端读队列，然后重新循环处理。
		if (FULL(to->read_q)) {
   217eb:	8b 44 24 24          	mov    0x24(%esp),%eax
   217ef:	8b 40 34             	mov    0x34(%eax),%eax
   217f2:	8b 50 08             	mov    0x8(%eax),%edx
   217f5:	8b 44 24 24          	mov    0x24(%esp),%eax
   217f9:	8b 40 34             	mov    0x34(%eax),%eax
   217fc:	8b 40 04             	mov    0x4(%eax),%eax
   217ff:	29 c2                	sub    %eax,%edx
   21801:	89 d0                	mov    %edx,%eax
   21803:	83 e8 01             	sub    $0x1,%eax
   21806:	25 ff 03 00 00       	and    $0x3ff,%eax
   2180b:	85 c0                	test   %eax,%eax
   2180d:	75 3c                	jne    2184b <pty_copy+0x74>
			// 判断目的终端辅助队列是否已满，如果已满则直接退出循环，不再处理源终端写队列中的数据。
			if (FULL(to->secondary))
   2180f:	8b 44 24 24          	mov    0x24(%esp),%eax
   21813:	8b 40 3c             	mov    0x3c(%eax),%eax
   21816:	8b 50 08             	mov    0x8(%eax),%edx
   21819:	8b 44 24 24          	mov    0x24(%esp),%eax
   2181d:	8b 40 3c             	mov    0x3c(%eax),%eax
   21820:	8b 40 04             	mov    0x4(%eax),%eax
   21823:	29 c2                	sub    %eax,%edx
   21825:	89 d0                	mov    %edx,%eax
   21827:	83 e8 01             	sub    $0x1,%eax
   2182a:	25 ff 03 00 00       	and    $0x3ff,%eax
   2182f:	85 c0                	test   %eax,%eax
   21831:	0f 84 cc 00 00 00    	je     21903 <pty_copy+0x12c>
				break;
			copy_to_cooked(to);     						// 把读队列中的字符处理成成规范模式字符序列放入辅助队列。
   21837:	83 ec 0c             	sub    $0xc,%esp
   2183a:	ff 74 24 30          	pushl  0x30(%esp)
   2183e:	e8 e8 93 ff ff       	call   1ac2b <copy_to_cooked>
   21843:	83 c4 10             	add    $0x10,%esp
			continue;
   21846:	e9 8f 00 00 00       	jmp    218da <pty_copy+0x103>
		}
		GETCH(from->write_q, c);         					// 从源终端写队列中取一个字符，放入c，
   2184b:	8b 44 24 20          	mov    0x20(%esp),%eax
   2184f:	8b 50 38             	mov    0x38(%eax),%edx
   21852:	8b 44 24 20          	mov    0x20(%esp),%eax
   21856:	8b 40 38             	mov    0x38(%eax),%eax
   21859:	8b 40 08             	mov    0x8(%eax),%eax
   2185c:	0f b6 44 02 10       	movzbl 0x10(%edx,%eax,1),%eax
   21861:	88 44 24 0f          	mov    %al,0xf(%esp)
   21865:	8b 44 24 20          	mov    0x20(%esp),%eax
   21869:	8b 40 38             	mov    0x38(%eax),%eax
   2186c:	8b 40 08             	mov    0x8(%eax),%eax
   2186f:	8d 50 01             	lea    0x1(%eax),%edx
   21872:	8b 44 24 20          	mov    0x20(%esp),%eax
   21876:	8b 40 38             	mov    0x38(%eax),%eax
   21879:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   2187f:	89 50 08             	mov    %edx,0x8(%eax)
		PUTCH(c, to->read_q);            					// 然后把c中的字符放入目的终端读队列中。
   21882:	8b 44 24 24          	mov    0x24(%esp),%eax
   21886:	8b 50 34             	mov    0x34(%eax),%edx
   21889:	8b 44 24 24          	mov    0x24(%esp),%eax
   2188d:	8b 40 34             	mov    0x34(%eax),%eax
   21890:	8b 40 04             	mov    0x4(%eax),%eax
   21893:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
   21898:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   2189c:	8b 44 24 24          	mov    0x24(%esp),%eax
   218a0:	8b 40 34             	mov    0x34(%eax),%eax
   218a3:	8b 40 04             	mov    0x4(%eax),%eax
   218a6:	8d 50 01             	lea    0x1(%eax),%edx
   218a9:	8b 44 24 24          	mov    0x24(%esp),%eax
   218ad:	8b 40 34             	mov    0x34(%eax),%eax
   218b0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   218b6:	89 50 04             	mov    %edx,0x4(%eax)
		// 判断当前进程是否有信号需要处理，如果有，则退出循环。
		if (current->signal & ~current->blocked)
   218b9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   218bf:	8b 00                	mov    (%eax),%eax
   218c1:	8b 50 0c             	mov    0xc(%eax),%edx
   218c4:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   218ca:	8b 00                	mov    (%eax),%eax
   218cc:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
   218d2:	f7 d0                	not    %eax
   218d4:	21 d0                	and    %edx,%eax
   218d6:	85 c0                	test   %eax,%eax
   218d8:	75 2c                	jne    21906 <pty_copy+0x12f>
	while (!from->stopped && !EMPTY(from->write_q)) {
   218da:	8b 44 24 20          	mov    0x20(%esp),%eax
   218de:	8b 40 2c             	mov    0x2c(%eax),%eax
   218e1:	85 c0                	test   %eax,%eax
   218e3:	75 22                	jne    21907 <pty_copy+0x130>
   218e5:	8b 44 24 20          	mov    0x20(%esp),%eax
   218e9:	8b 40 38             	mov    0x38(%eax),%eax
   218ec:	8b 50 04             	mov    0x4(%eax),%edx
   218ef:	8b 44 24 20          	mov    0x20(%esp),%eax
   218f3:	8b 40 38             	mov    0x38(%eax),%eax
   218f6:	8b 40 08             	mov    0x8(%eax),%eax
   218f9:	39 c2                	cmp    %eax,%edx
   218fb:	0f 85 ea fe ff ff    	jne    217eb <pty_copy+0x14>
   21901:	eb 04                	jmp    21907 <pty_copy+0x130>
				break;
   21903:	90                   	nop
   21904:	eb 01                	jmp    21907 <pty_copy+0x130>
			break;
   21906:	90                   	nop
	}
	copy_to_cooked(to);     								// 把读队列中的字符处理成成规范模式字符序列放入辅助队列。
   21907:	83 ec 0c             	sub    $0xc,%esp
   2190a:	ff 74 24 30          	pushl  0x30(%esp)
   2190e:	e8 18 93 ff ff       	call   1ac2b <copy_to_cooked>
   21913:	83 c4 10             	add    $0x10,%esp
	wake_up(&from->write_q->proc_list);     				// 唤醒等待源终端写队列的进程，如果有。
   21916:	8b 44 24 20          	mov    0x20(%esp),%eax
   2191a:	8b 40 38             	mov    0x38(%eax),%eax
   2191d:	83 c0 0c             	add    $0xc,%eax
   21920:	83 ec 0c             	sub    $0xc,%esp
   21923:	50                   	push   %eax
   21924:	e8 7e 59 fe ff       	call   72a7 <wake_up>
   21929:	83 c4 10             	add    $0x10,%esp
}
   2192c:	90                   	nop
   2192d:	83 c4 18             	add    $0x18,%esp
   21930:	5b                   	pop    %ebx
   21931:	c3                   	ret    

00021932 <mpty_write>:
 * 这个函数被调用时，tty_write函数已经把一些字符放到写队列write_queue中。它将复制这些输入到它的从伪终端的
 * 输出队列中。
 */
// 主伪终端写函数。
void mpty_write(struct tty_struct * tty)
{
   21932:	53                   	push   %ebx
   21933:	83 ec 18             	sub    $0x18,%esp
   21936:	e8 b7 53 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   2193b:	05 c5 06 01 00       	add    $0x106c5,%eax
	int nr = tty - tty_table;       						// 获取终端号
   21940:	8b 54 24 20          	mov    0x20(%esp),%edx
   21944:	c7 c1 a0 68 04 00    	mov    $0x468a0,%ecx
   2194a:	29 ca                	sub    %ecx,%edx
   2194c:	c1 fa 06             	sar    $0x6,%edx
   2194f:	89 54 24 0c          	mov    %edx,0xc(%esp)

	// 终端号除以64取整如果为2则是“主伪终端”，否则显示出错信息。
	if ((nr >> 6) != 2)
   21953:	8b 54 24 0c          	mov    0xc(%esp),%edx
   21957:	c1 fa 06             	sar    $0x6,%edx
   2195a:	83 fa 02             	cmp    $0x2,%edx
   2195d:	74 16                	je     21975 <mpty_write+0x43>
		printk("bad mpty\n\r");
   2195f:	83 ec 0c             	sub    $0xc,%esp
   21962:	8d 90 80 67 ff ff    	lea    -0x9880(%eax),%edx
   21968:	52                   	push   %edx
   21969:	89 c3                	mov    %eax,%ebx
   2196b:	e8 c2 79 fe ff       	call   9332 <printk>
   21970:	83 c4 10             	add    $0x10,%esp
	else
		pty_copy(tty, tty + 64);   							// 调用伪终端写函数。
}
   21973:	eb 19                	jmp    2198e <mpty_write+0x5c>
		pty_copy(tty, tty + 64);   							// 调用伪终端写函数。
   21975:	8b 44 24 20          	mov    0x20(%esp),%eax
   21979:	05 00 10 00 00       	add    $0x1000,%eax
   2197e:	83 ec 08             	sub    $0x8,%esp
   21981:	50                   	push   %eax
   21982:	ff 74 24 2c          	pushl  0x2c(%esp)
   21986:	e8 4c fe ff ff       	call   217d7 <pty_copy>
   2198b:	83 c4 10             	add    $0x10,%esp
}
   2198e:	90                   	nop
   2198f:	83 c4 18             	add    $0x18,%esp
   21992:	5b                   	pop    %ebx
   21993:	c3                   	ret    

00021994 <spty_write>:

// 从伪终端写函数。
void spty_write(struct tty_struct * tty)
{
   21994:	53                   	push   %ebx
   21995:	83 ec 18             	sub    $0x18,%esp
   21998:	e8 55 53 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   2199d:	05 63 06 01 00       	add    $0x10663,%eax
	int nr = tty - tty_table;       						// 获取终端号
   219a2:	8b 54 24 20          	mov    0x20(%esp),%edx
   219a6:	c7 c1 a0 68 04 00    	mov    $0x468a0,%ecx
   219ac:	29 ca                	sub    %ecx,%edx
   219ae:	c1 fa 06             	sar    $0x6,%edx
   219b1:	89 54 24 0c          	mov    %edx,0xc(%esp)

	// 终端号除以64取整如果为3则是“从伪终端”，否则显示出错信息。
	if ((nr >> 6) != 3)
   219b5:	8b 54 24 0c          	mov    0xc(%esp),%edx
   219b9:	c1 fa 06             	sar    $0x6,%edx
   219bc:	83 fa 03             	cmp    $0x3,%edx
   219bf:	74 16                	je     219d7 <spty_write+0x43>
		printk("bad spty\n\r");
   219c1:	83 ec 0c             	sub    $0xc,%esp
   219c4:	8d 90 8b 67 ff ff    	lea    -0x9875(%eax),%edx
   219ca:	52                   	push   %edx
   219cb:	89 c3                	mov    %eax,%ebx
   219cd:	e8 60 79 fe ff       	call   9332 <printk>
   219d2:	83 c4 10             	add    $0x10,%esp
	else
		pty_copy(tty, tty - 64);   							// 调用伪终端写函数。
}
   219d5:	eb 19                	jmp    219f0 <spty_write+0x5c>
		pty_copy(tty, tty - 64);   							// 调用伪终端写函数。
   219d7:	8b 44 24 20          	mov    0x20(%esp),%eax
   219db:	2d 00 10 00 00       	sub    $0x1000,%eax
   219e0:	83 ec 08             	sub    $0x8,%esp
   219e3:	50                   	push   %eax
   219e4:	ff 74 24 2c          	pushl  0x2c(%esp)
   219e8:	e8 ea fd ff ff       	call   217d7 <pty_copy>
   219ed:	83 c4 10             	add    $0x10,%esp
}
   219f0:	90                   	nop
   219f1:	83 c4 18             	add    $0x18,%esp
   219f4:	5b                   	pop    %ebx
   219f5:	c3                   	ret    

000219f6 <get_fs_word>:
//// 读取fs段中指定地址处的字.
// 参数:addr - 指定的内存地址.
// %0 - (返回的字_v);%1 - (内存地址addr)
// 返回:返回内存fs:[addr]处的字.
static inline unsigned short get_fs_word(const unsigned short *addr)
{
   219f6:	83 ec 10             	sub    $0x10,%esp
   219f9:	e8 f4 52 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   219fe:	05 02 06 01 00       	add    $0x10602,%eax
	unsigned short _v;

	__asm__ ("movw %%fs:%1,%0":"=q" (_v):"m" (*addr));
   21a03:	8b 44 24 14          	mov    0x14(%esp),%eax
   21a07:	64 66 8b 00          	mov    %fs:(%eax),%ax
   21a0b:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	return _v;
   21a10:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
}
   21a15:	83 c4 10             	add    $0x10,%esp
   21a18:	c3                   	ret    

00021a19 <get_fs_long>:
//// 读取fs段中指定地址处的长字(4字节).
// 参数:addr - 指定的内存地址.
// %0 - (返回的长字_v);%1 - (内存地址addr)
// 返回:返回内存fs:[addr]处的长字.
static inline unsigned long get_fs_long(const unsigned long *addr)
{
   21a19:	83 ec 10             	sub    $0x10,%esp
   21a1c:	e8 d1 52 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   21a21:	05 df 05 01 00       	add    $0x105df,%eax
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   21a26:	8b 44 24 14          	mov    0x14(%esp),%eax
   21a2a:	64 8b 00             	mov    %fs:(%eax),%eax
   21a2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
   21a31:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   21a35:	83 c4 10             	add    $0x10,%esp
   21a38:	c3                   	ret    

00021a39 <put_fs_word>:

//// 将一字存放在fs段中指定内存地址处.
// 参数:val - 字值;addr - 内存地址.
// %0 - 寄存器(字值val);%1 - (内存地址addr).
static inline void put_fs_word(short val,short * addr)
{
   21a39:	83 ec 04             	sub    $0x4,%esp
   21a3c:	e8 b1 52 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   21a41:	05 bf 05 01 00       	add    $0x105bf,%eax
   21a46:	8b 44 24 08          	mov    0x8(%esp),%eax
   21a4a:	66 89 04 24          	mov    %ax,(%esp)
__asm__ ("movw %0,%%fs:%1"::"q" (val),"m" (*addr));
   21a4e:	0f b7 04 24          	movzwl (%esp),%eax
   21a52:	8b 54 24 0c          	mov    0xc(%esp),%edx
   21a56:	64 66 89 02          	mov    %ax,%fs:(%edx)
}
   21a5a:	90                   	nop
   21a5b:	83 c4 04             	add    $0x4,%esp
   21a5e:	c3                   	ret    

00021a5f <put_fs_long>:

//// 将一长字存放在fs段中指定内存地址处.
// 参数:val - 长字值;addr - 内存地址.
// %0 - 寄存器(长字值val);%1 - (内存地址addr).
static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
   21a5f:	e8 8e 52 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   21a64:	05 9c 05 01 00       	add    $0x1059c,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   21a69:	8b 44 24 04          	mov    0x4(%esp),%eax
   21a6d:	8b 54 24 08          	mov    0x8(%esp),%edx
   21a71:	64 89 02             	mov    %eax,%fs:(%edx)
}
   21a74:	90                   	nop
   21a75:	c3                   	ret    

00021a76 <do_emu>:
// 该函数首先检测仿真的I387结构状态字寄存器中是否有未屏蔽的异常标志置位。若有则对状态字中忙标志B进行设置。然后把指令指针
// 保存起来，并取出代码指针EIP处的2字节浮点指令代码code。接着分析代码code，并根据其含义进行处理。针对不同代码类型值，Linus
// 使用了几个不同的switch程序块进行仿真处理。
// 参数是info结构指针。
static void do_emu(struct info * info)
{
   21a76:	56                   	push   %esi
   21a77:	53                   	push   %ebx
   21a78:	83 ec 24             	sub    $0x24,%esp
   21a7b:	e8 7a 52 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   21a80:	81 c3 80 05 01 00    	add    $0x10580,%ebx
	char * address;

// 该函数首先检测仿真的I387结构状态字寄存器中是否有未屏蔽的异常标志置位。若有就设置状态字中忙标志B（位15），否则复位B标
// 志。然后我们把指令指针保存起来。再看看执行本函数的代码是不是用户代码。如是不是，即调用者的代码段选择符不等于0x0f，则
// 说明内核中有代码使用了浮点指令。于是在显示出浮点指令处的CS、EIP值和信息“内核中需要数学仿真”后停机。
	if (I387.cwd & I387.swd & 0x3f)
   21a86:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21a8c:	8b 00                	mov    (%eax),%eax
   21a8e:	8b 90 18 04 00 00    	mov    0x418(%eax),%edx
   21a94:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21a9a:	8b 00                	mov    (%eax),%eax
   21a9c:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
   21aa2:	21 d0                	and    %edx,%eax
   21aa4:	83 e0 3f             	and    $0x3f,%eax
   21aa7:	85 c0                	test   %eax,%eax
   21aa9:	74 21                	je     21acc <do_emu+0x56>
		I387.swd |= 0x8000;             // 设置忙标志B。
   21aab:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21ab1:	8b 00                	mov    (%eax),%eax
   21ab3:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   21ab9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21abf:	8b 00                	mov    (%eax),%eax
   21ac1:	80 ce 80             	or     $0x80,%dh
   21ac4:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
   21aca:	eb 22                	jmp    21aee <do_emu+0x78>
	else
		I387.swd &= 0x7fff;             // 清忙标志B。
   21acc:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21ad2:	8b 00                	mov    (%eax),%eax
   21ad4:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   21ada:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21ae0:	8b 00                	mov    (%eax),%eax
   21ae2:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
   21ae8:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
	ORIG_EIP = EIP;                         // 保存浮点指令指针。
   21aee:	8b 44 24 30          	mov    0x30(%esp),%eax
   21af2:	8b 50 38             	mov    0x38(%eax),%edx
   21af5:	8b 44 24 30          	mov    0x30(%esp),%eax
   21af9:	89 50 04             	mov    %edx,0x4(%eax)
/* 0x0007 means user code space */
	if (CS != 0x000F) {                     // 不是用户代码则停机。
   21afc:	8b 44 24 30          	mov    0x30(%esp),%eax
   21b00:	83 c0 3c             	add    $0x3c,%eax
   21b03:	0f b7 00             	movzwl (%eax),%eax
   21b06:	66 83 f8 0f          	cmp    $0xf,%ax
   21b0a:	74 3a                	je     21b46 <do_emu+0xd0>
		printk("math_emulate: %04x:%08x\n\r",CS,EIP);
   21b0c:	8b 44 24 30          	mov    0x30(%esp),%eax
   21b10:	8b 50 38             	mov    0x38(%eax),%edx
   21b13:	8b 44 24 30          	mov    0x30(%esp),%eax
   21b17:	83 c0 3c             	add    $0x3c,%eax
   21b1a:	0f b7 00             	movzwl (%eax),%eax
   21b1d:	0f b7 c0             	movzwl %ax,%eax
   21b20:	83 ec 04             	sub    $0x4,%esp
   21b23:	52                   	push   %edx
   21b24:	50                   	push   %eax
   21b25:	8d 83 98 67 ff ff    	lea    -0x9868(%ebx),%eax
   21b2b:	50                   	push   %eax
   21b2c:	e8 01 78 fe ff       	call   9332 <printk>
   21b31:	83 c4 10             	add    $0x10,%esp
		panic("Math emulation needed in kernel");
   21b34:	83 ec 0c             	sub    $0xc,%esp
   21b37:	8d 83 b4 67 ff ff    	lea    -0x984c(%ebx),%eax
   21b3d:	50                   	push   %eax
   21b3e:	e8 9b 77 fe ff       	call   92de <panic>
   21b43:	83 c4 10             	add    $0x10,%esp
// 然后我们取出代码指针EIP处的2字节浮点指令代码code。由于Inter CPU存储数据时是“小头”（Little endian）在前的，此时取出
// 的代码正好与指令第1、第2字节顺序颠倒。因此我们需要交换一下code中两个字节的顺序。然后再屏蔽掉第1个代码字节中的ESC位（二
// 进制11011）。接着把浮点指令指针EIP保存到TSS段i387结构中的fip字段中，而CS保存到fcs字段中，同时把略微处理过的浮点指令
// 代码code放到fcs字段的高16位中。保存这些值是为了在出现仿真的处理器异常时程序可以像使用真实的协处理器一样进行处理。最后
// 让EIP指向随后的浮点指令或操作数。
	code = get_fs_word((unsigned short *) EIP);     // 取2字节的浮点指令或操作数。
   21b46:	8b 44 24 30          	mov    0x30(%esp),%eax
   21b4a:	8b 40 38             	mov    0x38(%eax),%eax
   21b4d:	83 ec 0c             	sub    $0xc,%esp
   21b50:	50                   	push   %eax
   21b51:	e8 a0 fe ff ff       	call   219f6 <get_fs_word>
   21b56:	83 c4 10             	add    $0x10,%esp
   21b59:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
	bswapw(code);                                   // 交换高低字节。
   21b5e:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   21b63:	86 c4                	xchg   %al,%ah
   21b65:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
	code &= 0x7ff;                                  // 屏蔽代码中的ESC码。
   21b6a:	66 81 64 24 1e ff 07 	andw   $0x7ff,0x1e(%esp)
	I387.fip = EIP;                                 // 保存指令指针。
   21b71:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21b77:	8b 00                	mov    (%eax),%eax
   21b79:	8b 54 24 30          	mov    0x30(%esp),%edx
   21b7d:	8b 52 38             	mov    0x38(%edx),%edx
   21b80:	89 90 24 04 00 00    	mov    %edx,0x424(%eax)
	*(unsigned short *) &I387.fcs = CS;             // 保存代码段选择符。
   21b86:	8b 44 24 30          	mov    0x30(%esp),%eax
   21b8a:	8d 48 3c             	lea    0x3c(%eax),%ecx
   21b8d:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21b93:	8b 00                	mov    (%eax),%eax
   21b95:	8d 90 28 04 00 00    	lea    0x428(%eax),%edx
   21b9b:	0f b7 01             	movzwl (%ecx),%eax
   21b9e:	66 89 02             	mov    %ax,(%edx)
	*(1+(unsigned short *) &I387.fcs) = code;       // 保存代码。
   21ba1:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21ba7:	8b 00                	mov    (%eax),%eax
   21ba9:	05 28 04 00 00       	add    $0x428,%eax
   21bae:	8d 50 02             	lea    0x2(%eax),%edx
   21bb1:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   21bb6:	66 89 02             	mov    %ax,(%edx)
	EIP += 2;                                       // 指令指针指向下一个字节。
   21bb9:	8b 44 24 30          	mov    0x30(%esp),%eax
   21bbd:	8b 40 38             	mov    0x38(%eax),%eax
   21bc0:	8d 50 02             	lea    0x2(%eax),%edx
   21bc3:	8b 44 24 30          	mov    0x30(%esp),%eax
   21bc7:	89 50 38             	mov    %edx,0x38(%eax)
        switch (code) {
   21bca:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   21bcf:	3d eb 01 00 00       	cmp    $0x1eb,%eax
   21bd4:	0f 84 a8 02 00 00    	je     21e82 <do_emu+0x40c>
   21bda:	3d eb 01 00 00       	cmp    $0x1eb,%eax
   21bdf:	0f 8f 97 00 00 00    	jg     21c7c <do_emu+0x206>
   21be5:	3d e3 01 00 00       	cmp    $0x1e3,%eax
   21bea:	7f 48                	jg     21c34 <do_emu+0x1be>
   21bec:	3d e2 01 00 00       	cmp    $0x1e2,%eax
   21bf1:	0f 8d 8c 01 00 00    	jge    21d83 <do_emu+0x30d>
   21bf7:	3d d7 01 00 00       	cmp    $0x1d7,%eax
   21bfc:	7f 1b                	jg     21c19 <do_emu+0x1a3>
   21bfe:	3d d1 01 00 00       	cmp    $0x1d1,%eax
   21c03:	0f 8d 2b 01 00 00    	jge    21d34 <do_emu+0x2be>
   21c09:	3d d0 01 00 00       	cmp    $0x1d0,%eax
   21c0e:	0f 84 2f 1c 00 00    	je     23843 <.L127+0xed>
   21c14:	e9 67 04 00 00       	jmp    22080 <do_emu+0x60a>
   21c19:	3d e0 01 00 00       	cmp    $0x1e0,%eax
   21c1e:	0f 84 21 01 00 00    	je     21d45 <do_emu+0x2cf>
   21c24:	3d e1 01 00 00       	cmp    $0x1e1,%eax
   21c29:	0f 84 35 01 00 00    	je     21d64 <do_emu+0x2ee>
   21c2f:	e9 4c 04 00 00       	jmp    22080 <do_emu+0x60a>
   21c34:	3d e7 01 00 00       	cmp    $0x1e7,%eax
   21c39:	7f 26                	jg     21c61 <do_emu+0x1eb>
   21c3b:	3d e6 01 00 00       	cmp    $0x1e6,%eax
   21c40:	0f 8d 8f 01 00 00    	jge    21dd5 <do_emu+0x35f>
   21c46:	3d e4 01 00 00       	cmp    $0x1e4,%eax
   21c4b:	0f 84 43 01 00 00    	je     21d94 <do_emu+0x31e>
   21c51:	3d e5 01 00 00       	cmp    $0x1e5,%eax
   21c56:	0f 84 56 01 00 00    	je     21db2 <do_emu+0x33c>
   21c5c:	e9 1f 04 00 00       	jmp    22080 <do_emu+0x60a>
   21c61:	3d e9 01 00 00       	cmp    $0x1e9,%eax
   21c66:	0f 84 ae 01 00 00    	je     21e1a <do_emu+0x3a4>
   21c6c:	3d e9 01 00 00       	cmp    $0x1e9,%eax
   21c71:	0f 8f d7 01 00 00    	jg     21e4e <do_emu+0x3d8>
   21c77:	e9 6a 01 00 00       	jmp    21de6 <do_emu+0x370>
   21c7c:	3d e9 02 00 00       	cmp    $0x2e9,%eax
   21c81:	0f 84 0a 03 00 00    	je     21f91 <do_emu+0x51b>
   21c87:	3d e9 02 00 00       	cmp    $0x2e9,%eax
   21c8c:	7f 48                	jg     21cd6 <do_emu+0x260>
   21c8e:	3d ee 01 00 00       	cmp    $0x1ee,%eax
   21c93:	0f 84 85 02 00 00    	je     21f1e <do_emu+0x4a8>
   21c99:	3d ee 01 00 00       	cmp    $0x1ee,%eax
   21c9e:	7f 1b                	jg     21cbb <do_emu+0x245>
   21ca0:	3d ec 01 00 00       	cmp    $0x1ec,%eax
   21ca5:	0f 84 0b 02 00 00    	je     21eb6 <do_emu+0x440>
   21cab:	3d ed 01 00 00       	cmp    $0x1ed,%eax
   21cb0:	0f 84 34 02 00 00    	je     21eea <do_emu+0x474>
   21cb6:	e9 c5 03 00 00       	jmp    22080 <do_emu+0x60a>
   21cbb:	3d ef 01 00 00       	cmp    $0x1ef,%eax
   21cc0:	0f 84 8c 02 00 00    	je     21f52 <do_emu+0x4dc>
   21cc6:	3d ff 01 00 00       	cmp    $0x1ff,%eax
   21ccb:	0f 8f af 03 00 00    	jg     22080 <do_emu+0x60a>
   21cd1:	e9 8d 02 00 00       	jmp    21f63 <do_emu+0x4ed>
   21cd6:	3d e3 03 00 00       	cmp    $0x3e3,%eax
   21cdb:	0f 84 0f 03 00 00    	je     21ff0 <do_emu+0x57a>
   21ce1:	3d e3 03 00 00       	cmp    $0x3e3,%eax
   21ce6:	7f 26                	jg     21d0e <do_emu+0x298>
   21ce8:	3d d0 03 00 00       	cmp    $0x3d0,%eax
   21ced:	0f 8c 8d 03 00 00    	jl     22080 <do_emu+0x60a>
   21cf3:	3d d1 03 00 00       	cmp    $0x3d1,%eax
   21cf8:	0f 8e 48 1b 00 00    	jle    23846 <.L127+0xf0>
   21cfe:	3d e2 03 00 00       	cmp    $0x3e2,%eax
   21d03:	0f 84 c0 02 00 00    	je     21fc9 <do_emu+0x553>
   21d09:	e9 72 03 00 00       	jmp    22080 <do_emu+0x60a>
   21d0e:	3d d9 06 00 00       	cmp    $0x6d9,%eax
   21d13:	0f 84 12 03 00 00    	je     2202b <do_emu+0x5b5>
   21d19:	3d e0 07 00 00       	cmp    $0x7e0,%eax
   21d1e:	0f 84 3f 03 00 00    	je     22063 <do_emu+0x5ed>
   21d24:	3d e4 03 00 00       	cmp    $0x3e4,%eax
   21d29:	0f 84 1a 1b 00 00    	je     23849 <.L127+0xf3>
   21d2f:	e9 4c 03 00 00       	jmp    22080 <do_emu+0x60a>
		case 0x1d0: /* fnop */          // 空操作指令FNOP
			return;
		case 0x1d1: case 0x1d2: case 0x1d3:     // 无效指令代码。必信号，退出。
		case 0x1d4: case 0x1d5: case 0x1d6: case 0x1d7:
			math_abort(info,1<<(SIGILL-1));
   21d34:	83 ec 08             	sub    $0x8,%esp
   21d37:	6a 08                	push   $0x8
   21d39:	ff 74 24 3c          	pushl  0x3c(%esp)
   21d3d:	e8 8b 1b 00 00       	call   238cd <__math_abort>
   21d42:	83 c4 10             	add    $0x10,%esp
		case 0x1e0:                     // FCHS - 改变ST符号位。即ST = -ST。
			ST(0).exponent ^= 0x8000;
   21d45:	83 ec 0c             	sub    $0xc,%esp
   21d48:	6a 00                	push   $0x0
   21d4a:	e8 2f 1d 00 00       	call   23a7e <__st>
   21d4f:	83 c4 10             	add    $0x10,%esp
   21d52:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   21d56:	66 81 f2 00 80       	xor    $0x8000,%dx
   21d5b:	66 89 50 08          	mov    %dx,0x8(%eax)
			return;
   21d5f:	e9 e6 1a 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1e1:                     // FABS - 取绝对值。即ST = |ST|。
			ST(0).exponent &= 0x7fff;
   21d64:	83 ec 0c             	sub    $0xc,%esp
   21d67:	6a 00                	push   $0x0
   21d69:	e8 10 1d 00 00       	call   23a7e <__st>
   21d6e:	83 c4 10             	add    $0x10,%esp
   21d71:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   21d75:	66 81 e2 ff 7f       	and    $0x7fff,%dx
   21d7a:	66 89 50 08          	mov    %dx,0x8(%eax)
			return;
   21d7e:	e9 c7 1a 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1e2: case 0x1e3:         // 无效指令代码。发信号，退出。
			math_abort(info,1<<(SIGILL-1));
   21d83:	83 ec 08             	sub    $0x8,%esp
   21d86:	6a 08                	push   $0x8
   21d88:	ff 74 24 3c          	pushl  0x3c(%esp)
   21d8c:	e8 3c 1b 00 00       	call   238cd <__math_abort>
   21d91:	83 c4 10             	add    $0x10,%esp
		case 0x1e4:                     // FTST - 测试TS，同时设置状态字中Cn。
			ftst(PST(0));
   21d94:	83 ec 0c             	sub    $0xc,%esp
   21d97:	6a 00                	push   $0x0
   21d99:	e8 e0 1c 00 00       	call   23a7e <__st>
   21d9e:	83 c4 10             	add    $0x10,%esp
   21da1:	83 ec 0c             	sub    $0xc,%esp
   21da4:	50                   	push   %eax
   21da5:	e8 12 33 00 00       	call   250bc <ftst>
   21daa:	83 c4 10             	add    $0x10,%esp
			return;
   21dad:	e9 98 1a 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1e5:                     // FXAM - 检查TS值，同时修改状态字中Cn。
			printk("fxam not implemented\n\r");     // 未实现。发信号退出。
   21db2:	83 ec 0c             	sub    $0xc,%esp
   21db5:	8d 83 d4 67 ff ff    	lea    -0x982c(%ebx),%eax
   21dbb:	50                   	push   %eax
   21dbc:	e8 71 75 fe ff       	call   9332 <printk>
   21dc1:	83 c4 10             	add    $0x10,%esp
			math_abort(info,1<<(SIGILL-1));
   21dc4:	83 ec 08             	sub    $0x8,%esp
   21dc7:	6a 08                	push   $0x8
   21dc9:	ff 74 24 3c          	pushl  0x3c(%esp)
   21dcd:	e8 fb 1a 00 00       	call   238cd <__math_abort>
   21dd2:	83 c4 10             	add    $0x10,%esp
		case 0x1e6: case 0x1e7:         // 无效指令代码。发信号，退出。
			math_abort(info,1<<(SIGILL-1));
   21dd5:	83 ec 08             	sub    $0x8,%esp
   21dd8:	6a 08                	push   $0x8
   21dda:	ff 74 24 3c          	pushl  0x3c(%esp)
   21dde:	e8 ea 1a 00 00       	call   238cd <__math_abort>
   21de3:	83 c4 10             	add    $0x10,%esp
		case 0x1e8:                     // FLD1 - 加载常数1.0到累加器ST。
			fpush();
   21de6:	e8 a8 1b 00 00       	call   23993 <fpush>
			ST(0) = CONST1;
   21deb:	83 ec 0c             	sub    $0xc,%esp
   21dee:	6a 00                	push   $0x0
   21df0:	e8 89 1c 00 00       	call   23a7e <__st>
   21df5:	83 c4 10             	add    $0x10,%esp
   21df8:	66 c7 00 00 00       	movw   $0x0,(%eax)
   21dfd:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
   21e03:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
   21e09:	66 c7 40 06 00 80    	movw   $0x8000,0x6(%eax)
   21e0f:	66 c7 40 08 ff 3f    	movw   $0x3fff,0x8(%eax)
			return;
   21e15:	e9 30 1a 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1e9:                     // FLDL2T - 加载常数Log2(10)到累加器ST。
			fpush();
   21e1a:	e8 74 1b 00 00       	call   23993 <fpush>
			ST(0) = CONSTL2T;
   21e1f:	83 ec 0c             	sub    $0xc,%esp
   21e22:	6a 00                	push   $0x0
   21e24:	e8 55 1c 00 00       	call   23a7e <__st>
   21e29:	83 c4 10             	add    $0x10,%esp
   21e2c:	66 c7 00 fe 8a       	movw   $0x8afe,(%eax)
   21e31:	66 c7 40 02 1b cd    	movw   $0xcd1b,0x2(%eax)
   21e37:	66 c7 40 04 4b 78    	movw   $0x784b,0x4(%eax)
   21e3d:	66 c7 40 06 9a d4    	movw   $0xd49a,0x6(%eax)
   21e43:	66 c7 40 08 00 40    	movw   $0x4000,0x8(%eax)
			return;
   21e49:	e9 fc 19 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1ea:                     // FLDL2E - 加载常数Log2(e)到累加器ST。
			fpush();
   21e4e:	e8 40 1b 00 00       	call   23993 <fpush>
			ST(0) = CONSTL2E;
   21e53:	83 ec 0c             	sub    $0xc,%esp
   21e56:	6a 00                	push   $0x0
   21e58:	e8 21 1c 00 00       	call   23a7e <__st>
   21e5d:	83 c4 10             	add    $0x10,%esp
   21e60:	66 c7 00 bc f0       	movw   $0xf0bc,(%eax)
   21e65:	66 c7 40 02 17 5c    	movw   $0x5c17,0x2(%eax)
   21e6b:	66 c7 40 04 29 3b    	movw   $0x3b29,0x4(%eax)
   21e71:	66 c7 40 06 aa b8    	movw   $0xb8aa,0x6(%eax)
   21e77:	66 c7 40 08 ff 3f    	movw   $0x3fff,0x8(%eax)
			return;
   21e7d:	e9 c8 19 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1eb:                     // FLDPI - 加载常数Pi到累加器ST。
			fpush();
   21e82:	e8 0c 1b 00 00       	call   23993 <fpush>
			ST(0) = CONSTPI;
   21e87:	83 ec 0c             	sub    $0xc,%esp
   21e8a:	6a 00                	push   $0x0
   21e8c:	e8 ed 1b 00 00       	call   23a7e <__st>
   21e91:	83 c4 10             	add    $0x10,%esp
   21e94:	66 c7 00 35 c2       	movw   $0xc235,(%eax)
   21e99:	66 c7 40 02 68 21    	movw   $0x2168,0x2(%eax)
   21e9f:	66 c7 40 04 a2 da    	movw   $0xdaa2,0x4(%eax)
   21ea5:	66 c7 40 06 0f c9    	movw   $0xc90f,0x6(%eax)
   21eab:	66 c7 40 08 00 40    	movw   $0x4000,0x8(%eax)
			return;
   21eb1:	e9 94 19 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1ec:                     // FLDLG2 - 加载常数Log10(2)到累加器ST。
			fpush();
   21eb6:	e8 d8 1a 00 00       	call   23993 <fpush>
			ST(0) = CONSTLG2;
   21ebb:	83 ec 0c             	sub    $0xc,%esp
   21ebe:	6a 00                	push   $0x0
   21ec0:	e8 b9 1b 00 00       	call   23a7e <__st>
   21ec5:	83 c4 10             	add    $0x10,%esp
   21ec8:	66 c7 00 99 f7       	movw   $0xf799,(%eax)
   21ecd:	66 c7 40 02 cf fb    	movw   $0xfbcf,0x2(%eax)
   21ed3:	66 c7 40 04 84 9a    	movw   $0x9a84,0x4(%eax)
   21ed9:	66 c7 40 06 20 9a    	movw   $0x9a20,0x6(%eax)
   21edf:	66 c7 40 08 fd 3f    	movw   $0x3ffd,0x8(%eax)
			return;
   21ee5:	e9 60 19 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1ed:                     // FLDLN2 - 加载常数Loge(2)到累加器ST。
			fpush();
   21eea:	e8 a4 1a 00 00       	call   23993 <fpush>
			ST(0) = CONSTLN2;
   21eef:	83 ec 0c             	sub    $0xc,%esp
   21ef2:	6a 00                	push   $0x0
   21ef4:	e8 85 1b 00 00       	call   23a7e <__st>
   21ef9:	83 c4 10             	add    $0x10,%esp
   21efc:	66 c7 00 ac 79       	movw   $0x79ac,(%eax)
   21f01:	66 c7 40 02 cf d1    	movw   $0xd1cf,0x2(%eax)
   21f07:	66 c7 40 04 f7 17    	movw   $0x17f7,0x4(%eax)
   21f0d:	66 c7 40 06 72 b1    	movw   $0xb172,0x6(%eax)
   21f13:	66 c7 40 08 fe 3f    	movw   $0x3ffe,0x8(%eax)
			return;
   21f19:	e9 2c 19 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1ee:                     // FLDZ - 加载常数0.0到累加器ST。
			fpush();
   21f1e:	e8 70 1a 00 00       	call   23993 <fpush>
			ST(0) = CONSTZ;
   21f23:	83 ec 0c             	sub    $0xc,%esp
   21f26:	6a 00                	push   $0x0
   21f28:	e8 51 1b 00 00       	call   23a7e <__st>
   21f2d:	83 c4 10             	add    $0x10,%esp
   21f30:	66 c7 00 00 00       	movw   $0x0,(%eax)
   21f35:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
   21f3b:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
   21f41:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
   21f47:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
			return;
   21f4d:	e9 f8 18 00 00       	jmp    2384a <.L127+0xf4>
		case 0x1ef:                     // 无效和未实现仿真指令代码。发信号，退出。
			math_abort(info,1<<(SIGILL-1));
   21f52:	83 ec 08             	sub    $0x8,%esp
   21f55:	6a 08                	push   $0x8
   21f57:	ff 74 24 3c          	pushl  0x3c(%esp)
   21f5b:	e8 6d 19 00 00       	call   238cd <__math_abort>
   21f60:	83 c4 10             	add    $0x10,%esp
		case 0x1f0: case 0x1f1: case 0x1f2: case 0x1f3:
		case 0x1f4: case 0x1f5: case 0x1f6: case 0x1f7:
		case 0x1f8: case 0x1f9: case 0x1fa: case 0x1fb:
		case 0x1fc: case 0x1fd: case 0x1fe: case 0x1ff:
			printk("%04x fxxx not implemented\n\r",code + 0xc800);
   21f63:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   21f68:	05 00 c8 00 00       	add    $0xc800,%eax
   21f6d:	83 ec 08             	sub    $0x8,%esp
   21f70:	50                   	push   %eax
   21f71:	8d 83 eb 67 ff ff    	lea    -0x9815(%ebx),%eax
   21f77:	50                   	push   %eax
   21f78:	e8 b5 73 fe ff       	call   9332 <printk>
   21f7d:	83 c4 10             	add    $0x10,%esp
			math_abort(info,1<<(SIGILL-1));
   21f80:	83 ec 08             	sub    $0x8,%esp
   21f83:	6a 08                	push   $0x8
   21f85:	ff 74 24 3c          	pushl  0x3c(%esp)
   21f89:	e8 3f 19 00 00       	call   238cd <__math_abort>
   21f8e:	83 c4 10             	add    $0x10,%esp
		case 0x2e9:                     // FUCOMPP - 无次序比较。
			fucom(PST(1),PST(0));
   21f91:	83 ec 0c             	sub    $0xc,%esp
   21f94:	6a 00                	push   $0x0
   21f96:	e8 e3 1a 00 00       	call   23a7e <__st>
   21f9b:	83 c4 10             	add    $0x10,%esp
   21f9e:	89 c6                	mov    %eax,%esi
   21fa0:	83 ec 0c             	sub    $0xc,%esp
   21fa3:	6a 01                	push   $0x1
   21fa5:	e8 d4 1a 00 00       	call   23a7e <__st>
   21faa:	83 c4 10             	add    $0x10,%esp
   21fad:	83 ec 08             	sub    $0x8,%esp
   21fb0:	56                   	push   %esi
   21fb1:	50                   	push   %eax
   21fb2:	e8 28 32 00 00       	call   251df <fucom>
   21fb7:	83 c4 10             	add    $0x10,%esp
			fpop(); fpop();
   21fba:	e8 49 19 00 00       	call   23908 <fpop>
   21fbf:	e8 44 19 00 00       	call   23908 <fpop>
			return;
   21fc4:	e9 81 18 00 00       	jmp    2384a <.L127+0xf4>
		case 0x3d0: case 0x3d1:         // FNOP - 对387。！！应该是0x3e0，0x3e1。
			return;
		case 0x3e2:                     // FCLEX - 清状态字中异常标志。
			I387.swd &= 0x7f00;
   21fc9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21fcf:	8b 00                	mov    (%eax),%eax
   21fd1:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   21fd7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21fdd:	8b 00                	mov    (%eax),%eax
   21fdf:	81 e2 00 7f 00 00    	and    $0x7f00,%edx
   21fe5:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
			return;
   21feb:	e9 5a 18 00 00       	jmp    2384a <.L127+0xf4>
		case 0x3e3:                     // FINIT - 初始化协处理器。
			I387.cwd = 0x037f;
   21ff0:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   21ff6:	8b 00                	mov    (%eax),%eax
   21ff8:	c7 80 18 04 00 00 7f 	movl   $0x37f,0x418(%eax)
   21fff:	03 00 00 
			I387.swd = 0x0000;
   22002:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   22008:	8b 00                	mov    (%eax),%eax
   2200a:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
   22011:	00 00 00 
			I387.twd = 0x0000;
   22014:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   2201a:	8b 00                	mov    (%eax),%eax
   2201c:	c7 80 20 04 00 00 00 	movl   $0x0,0x420(%eax)
   22023:	00 00 00 
			return;
   22026:	e9 1f 18 00 00       	jmp    2384a <.L127+0xf4>
		case 0x3e4:                     // FNOP - 对80387。
			return;
		case 0x6d9:                     // FCOMPP - ST(i)与ST比较，出栈操作两次。
			fcom(PST(1),PST(0));
   2202b:	83 ec 0c             	sub    $0xc,%esp
   2202e:	6a 00                	push   $0x0
   22030:	e8 49 1a 00 00       	call   23a7e <__st>
   22035:	83 c4 10             	add    $0x10,%esp
   22038:	89 c6                	mov    %eax,%esi
   2203a:	83 ec 0c             	sub    $0xc,%esp
   2203d:	6a 01                	push   $0x1
   2203f:	e8 3a 1a 00 00       	call   23a7e <__st>
   22044:	83 c4 10             	add    $0x10,%esp
   22047:	83 ec 08             	sub    $0x8,%esp
   2204a:	56                   	push   %esi
   2204b:	50                   	push   %eax
   2204c:	e8 28 31 00 00       	call   25179 <fcom>
   22051:	83 c4 10             	add    $0x10,%esp
			fpop(); fpop();
   22054:	e8 af 18 00 00       	call   23908 <fpop>
   22059:	e8 aa 18 00 00       	call   23908 <fpop>
			return;
   2205e:	e9 e7 17 00 00       	jmp    2384a <.L127+0xf4>
		case 0x7e0:                     // FSTSW AX - 保存当前状态字到AX寄存器中。
			*(short *) &EAX = I387.swd;
   22063:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   22069:	8b 00                	mov    (%eax),%eax
   2206b:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   22071:	8b 44 24 30          	mov    0x30(%esp),%eax
   22075:	83 c0 18             	add    $0x18,%eax
   22078:	66 89 10             	mov    %dx,(%eax)
			return;
   2207b:	e9 ca 17 00 00       	jmp    2384a <.L127+0xf4>
	}
// 下面开始处理第2字节最后3位是REG的指令。即11011,XXXXXXXX，REG形式的代码。
	switch (code >> 3) {
   22080:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22085:	66 c1 e8 03          	shr    $0x3,%ax
   22089:	0f b7 c0             	movzwl %ax,%eax
   2208c:	83 e8 18             	sub    $0x18,%eax
   2208f:	3d e3 00 00 00       	cmp    $0xe3,%eax
   22094:	0f 87 cc 0d 00 00    	ja     22e66 <.L44>
   2209a:	c1 e0 02             	shl    $0x2,%eax
   2209d:	8b 84 18 74 68 ff ff 	mov    -0x978c(%eax,%ebx,1),%eax
   220a4:	01 d8                	add    %ebx,%eax
   220a6:	ff e0                	jmp    *%eax

000220a8 <.L45>:
		case 0x18:                      // FADD ST, ST(i)。
			fadd(PST(0),PST(code & 7),&tmp);
   220a8:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   220ad:	83 e0 07             	and    $0x7,%eax
   220b0:	83 ec 0c             	sub    $0xc,%esp
   220b3:	50                   	push   %eax
   220b4:	e8 c5 19 00 00       	call   23a7e <__st>
   220b9:	83 c4 10             	add    $0x10,%esp
   220bc:	89 c6                	mov    %eax,%esi
   220be:	83 ec 0c             	sub    $0xc,%esp
   220c1:	6a 00                	push   $0x0
   220c3:	e8 b6 19 00 00       	call   23a7e <__st>
   220c8:	83 c4 10             	add    $0x10,%esp
   220cb:	89 c2                	mov    %eax,%edx
   220cd:	83 ec 04             	sub    $0x4,%esp
   220d0:	8d 44 24 10          	lea    0x10(%esp),%eax
   220d4:	50                   	push   %eax
   220d5:	56                   	push   %esi
   220d6:	52                   	push   %edx
   220d7:	e8 11 28 00 00       	call   248ed <fadd>
   220dc:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   220df:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   220e3:	83 ec 0c             	sub    $0xc,%esp
   220e6:	6a 00                	push   $0x0
   220e8:	e8 91 19 00 00       	call   23a7e <__st>
   220ed:	83 c4 10             	add    $0x10,%esp
   220f0:	89 c1                	mov    %eax,%ecx
   220f2:	8b 03                	mov    (%ebx),%eax
   220f4:	8b 53 04             	mov    0x4(%ebx),%edx
   220f7:	89 01                	mov    %eax,(%ecx)
   220f9:	89 51 04             	mov    %edx,0x4(%ecx)
   220fc:	83 ec 0c             	sub    $0xc,%esp
   220ff:	6a 00                	push   $0x0
   22101:	e8 78 19 00 00       	call   23a7e <__st>
   22106:	83 c4 10             	add    $0x10,%esp
   22109:	89 c2                	mov    %eax,%edx
   2210b:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22110:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   22114:	e9 31 17 00 00       	jmp    2384a <.L127+0xf4>

00022119 <.L47>:
		case 0x19:                      // FMUL ST, ST(i)。
			fmul(PST(0),PST(code & 7),&tmp);
   22119:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2211e:	83 e0 07             	and    $0x7,%eax
   22121:	83 ec 0c             	sub    $0xc,%esp
   22124:	50                   	push   %eax
   22125:	e8 54 19 00 00       	call   23a7e <__st>
   2212a:	83 c4 10             	add    $0x10,%esp
   2212d:	89 c6                	mov    %eax,%esi
   2212f:	83 ec 0c             	sub    $0xc,%esp
   22132:	6a 00                	push   $0x0
   22134:	e8 45 19 00 00       	call   23a7e <__st>
   22139:	83 c4 10             	add    $0x10,%esp
   2213c:	89 c2                	mov    %eax,%edx
   2213e:	83 ec 04             	sub    $0x4,%esp
   22141:	8d 44 24 10          	lea    0x10(%esp),%eax
   22145:	50                   	push   %eax
   22146:	56                   	push   %esi
   22147:	52                   	push   %edx
   22148:	e8 88 29 00 00       	call   24ad5 <fmul>
   2214d:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   22150:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22154:	83 ec 0c             	sub    $0xc,%esp
   22157:	6a 00                	push   $0x0
   22159:	e8 20 19 00 00       	call   23a7e <__st>
   2215e:	83 c4 10             	add    $0x10,%esp
   22161:	89 c1                	mov    %eax,%ecx
   22163:	8b 03                	mov    (%ebx),%eax
   22165:	8b 53 04             	mov    0x4(%ebx),%edx
   22168:	89 01                	mov    %eax,(%ecx)
   2216a:	89 51 04             	mov    %edx,0x4(%ecx)
   2216d:	83 ec 0c             	sub    $0xc,%esp
   22170:	6a 00                	push   $0x0
   22172:	e8 07 19 00 00       	call   23a7e <__st>
   22177:	83 c4 10             	add    $0x10,%esp
   2217a:	89 c2                	mov    %eax,%edx
   2217c:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22181:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   22185:	e9 c0 16 00 00       	jmp    2384a <.L127+0xf4>

0002218a <.L48>:
		case 0x1a:                      // FCOM ST(i)。
			fcom(PST(code & 7),&tmp);
   2218a:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2218f:	83 e0 07             	and    $0x7,%eax
   22192:	83 ec 0c             	sub    $0xc,%esp
   22195:	50                   	push   %eax
   22196:	e8 e3 18 00 00       	call   23a7e <__st>
   2219b:	83 c4 10             	add    $0x10,%esp
   2219e:	89 c2                	mov    %eax,%edx
   221a0:	83 ec 08             	sub    $0x8,%esp
   221a3:	8d 44 24 14          	lea    0x14(%esp),%eax
   221a7:	50                   	push   %eax
   221a8:	52                   	push   %edx
   221a9:	e8 cb 2f 00 00       	call   25179 <fcom>
   221ae:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   221b1:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   221b5:	83 ec 0c             	sub    $0xc,%esp
   221b8:	6a 00                	push   $0x0
   221ba:	e8 bf 18 00 00       	call   23a7e <__st>
   221bf:	83 c4 10             	add    $0x10,%esp
   221c2:	89 c1                	mov    %eax,%ecx
   221c4:	8b 03                	mov    (%ebx),%eax
   221c6:	8b 53 04             	mov    0x4(%ebx),%edx
   221c9:	89 01                	mov    %eax,(%ecx)
   221cb:	89 51 04             	mov    %edx,0x4(%ecx)
   221ce:	83 ec 0c             	sub    $0xc,%esp
   221d1:	6a 00                	push   $0x0
   221d3:	e8 a6 18 00 00       	call   23a7e <__st>
   221d8:	83 c4 10             	add    $0x10,%esp
   221db:	89 c2                	mov    %eax,%edx
   221dd:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   221e2:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   221e6:	e9 5f 16 00 00       	jmp    2384a <.L127+0xf4>

000221eb <.L49>:
		case 0x1b:                      // FCOMP ST(i)。
			fcom(PST(code & 7),&tmp);
   221eb:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   221f0:	83 e0 07             	and    $0x7,%eax
   221f3:	83 ec 0c             	sub    $0xc,%esp
   221f6:	50                   	push   %eax
   221f7:	e8 82 18 00 00       	call   23a7e <__st>
   221fc:	83 c4 10             	add    $0x10,%esp
   221ff:	89 c2                	mov    %eax,%edx
   22201:	83 ec 08             	sub    $0x8,%esp
   22204:	8d 44 24 14          	lea    0x14(%esp),%eax
   22208:	50                   	push   %eax
   22209:	52                   	push   %edx
   2220a:	e8 6a 2f 00 00       	call   25179 <fcom>
   2220f:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   22212:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22216:	83 ec 0c             	sub    $0xc,%esp
   22219:	6a 00                	push   $0x0
   2221b:	e8 5e 18 00 00       	call   23a7e <__st>
   22220:	83 c4 10             	add    $0x10,%esp
   22223:	89 c1                	mov    %eax,%ecx
   22225:	8b 03                	mov    (%ebx),%eax
   22227:	8b 53 04             	mov    0x4(%ebx),%edx
   2222a:	89 01                	mov    %eax,(%ecx)
   2222c:	89 51 04             	mov    %edx,0x4(%ecx)
   2222f:	83 ec 0c             	sub    $0xc,%esp
   22232:	6a 00                	push   $0x0
   22234:	e8 45 18 00 00       	call   23a7e <__st>
   22239:	83 c4 10             	add    $0x10,%esp
   2223c:	89 c2                	mov    %eax,%edx
   2223e:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22243:	66 89 42 08          	mov    %ax,0x8(%edx)
			fpop();
   22247:	e8 bc 16 00 00       	call   23908 <fpop>
			return;
   2224c:	e9 f9 15 00 00       	jmp    2384a <.L127+0xf4>

00022251 <.L50>:
		case 0x1c:                      // FSUB ST, ST(i)。
			real_to_real(&ST(code & 7),&tmp);
   22251:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22256:	83 e0 07             	and    $0x7,%eax
   22259:	83 ec 0c             	sub    $0xc,%esp
   2225c:	50                   	push   %eax
   2225d:	e8 1c 18 00 00       	call   23a7e <__st>
   22262:	83 c4 10             	add    $0x10,%esp
   22265:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
   22269:	8b 50 04             	mov    0x4(%eax),%edx
   2226c:	8b 00                	mov    (%eax),%eax
   2226e:	89 01                	mov    %eax,(%ecx)
   22270:	89 51 04             	mov    %edx,0x4(%ecx)
   22273:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22278:	83 e0 07             	and    $0x7,%eax
   2227b:	83 ec 0c             	sub    $0xc,%esp
   2227e:	50                   	push   %eax
   2227f:	e8 fa 17 00 00       	call   23a7e <__st>
   22284:	83 c4 10             	add    $0x10,%esp
   22287:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2228b:	66 89 44 24 14       	mov    %ax,0x14(%esp)
			tmp.exponent ^= 0x8000;
   22290:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22295:	66 35 00 80          	xor    $0x8000,%ax
   22299:	66 89 44 24 14       	mov    %ax,0x14(%esp)
			fadd(PST(0),&tmp,&tmp);
   2229e:	83 ec 0c             	sub    $0xc,%esp
   222a1:	6a 00                	push   $0x0
   222a3:	e8 d6 17 00 00       	call   23a7e <__st>
   222a8:	83 c4 10             	add    $0x10,%esp
   222ab:	89 c2                	mov    %eax,%edx
   222ad:	83 ec 04             	sub    $0x4,%esp
   222b0:	8d 44 24 10          	lea    0x10(%esp),%eax
   222b4:	50                   	push   %eax
   222b5:	8d 44 24 14          	lea    0x14(%esp),%eax
   222b9:	50                   	push   %eax
   222ba:	52                   	push   %edx
   222bb:	e8 2d 26 00 00       	call   248ed <fadd>
   222c0:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   222c3:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   222c7:	83 ec 0c             	sub    $0xc,%esp
   222ca:	6a 00                	push   $0x0
   222cc:	e8 ad 17 00 00       	call   23a7e <__st>
   222d1:	83 c4 10             	add    $0x10,%esp
   222d4:	89 c1                	mov    %eax,%ecx
   222d6:	8b 03                	mov    (%ebx),%eax
   222d8:	8b 53 04             	mov    0x4(%ebx),%edx
   222db:	89 01                	mov    %eax,(%ecx)
   222dd:	89 51 04             	mov    %edx,0x4(%ecx)
   222e0:	83 ec 0c             	sub    $0xc,%esp
   222e3:	6a 00                	push   $0x0
   222e5:	e8 94 17 00 00       	call   23a7e <__st>
   222ea:	83 c4 10             	add    $0x10,%esp
   222ed:	89 c2                	mov    %eax,%edx
   222ef:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   222f4:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   222f8:	e9 4d 15 00 00       	jmp    2384a <.L127+0xf4>

000222fd <.L51>:
		case 0x1d:                      // FSUBR ST, ST(i)。
			ST(0).exponent ^= 0x8000;
   222fd:	83 ec 0c             	sub    $0xc,%esp
   22300:	6a 00                	push   $0x0
   22302:	e8 77 17 00 00       	call   23a7e <__st>
   22307:	83 c4 10             	add    $0x10,%esp
   2230a:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   2230e:	66 81 f2 00 80       	xor    $0x8000,%dx
   22313:	66 89 50 08          	mov    %dx,0x8(%eax)
			fadd(PST(0),PST(code & 7),&tmp);
   22317:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2231c:	83 e0 07             	and    $0x7,%eax
   2231f:	83 ec 0c             	sub    $0xc,%esp
   22322:	50                   	push   %eax
   22323:	e8 56 17 00 00       	call   23a7e <__st>
   22328:	83 c4 10             	add    $0x10,%esp
   2232b:	89 c6                	mov    %eax,%esi
   2232d:	83 ec 0c             	sub    $0xc,%esp
   22330:	6a 00                	push   $0x0
   22332:	e8 47 17 00 00       	call   23a7e <__st>
   22337:	83 c4 10             	add    $0x10,%esp
   2233a:	89 c2                	mov    %eax,%edx
   2233c:	83 ec 04             	sub    $0x4,%esp
   2233f:	8d 44 24 10          	lea    0x10(%esp),%eax
   22343:	50                   	push   %eax
   22344:	56                   	push   %esi
   22345:	52                   	push   %edx
   22346:	e8 a2 25 00 00       	call   248ed <fadd>
   2234b:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   2234e:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22352:	83 ec 0c             	sub    $0xc,%esp
   22355:	6a 00                	push   $0x0
   22357:	e8 22 17 00 00       	call   23a7e <__st>
   2235c:	83 c4 10             	add    $0x10,%esp
   2235f:	89 c1                	mov    %eax,%ecx
   22361:	8b 03                	mov    (%ebx),%eax
   22363:	8b 53 04             	mov    0x4(%ebx),%edx
   22366:	89 01                	mov    %eax,(%ecx)
   22368:	89 51 04             	mov    %edx,0x4(%ecx)
   2236b:	83 ec 0c             	sub    $0xc,%esp
   2236e:	6a 00                	push   $0x0
   22370:	e8 09 17 00 00       	call   23a7e <__st>
   22375:	83 c4 10             	add    $0x10,%esp
   22378:	89 c2                	mov    %eax,%edx
   2237a:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   2237f:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   22383:	e9 c2 14 00 00       	jmp    2384a <.L127+0xf4>

00022388 <.L52>:
		case 0x1e:                      // FDIV ST, ST(i)。
			fdiv(PST(0),PST(code & 7),&tmp);
   22388:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2238d:	83 e0 07             	and    $0x7,%eax
   22390:	83 ec 0c             	sub    $0xc,%esp
   22393:	50                   	push   %eax
   22394:	e8 e5 16 00 00       	call   23a7e <__st>
   22399:	83 c4 10             	add    $0x10,%esp
   2239c:	89 c6                	mov    %eax,%esi
   2239e:	83 ec 0c             	sub    $0xc,%esp
   223a1:	6a 00                	push   $0x0
   223a3:	e8 d6 16 00 00       	call   23a7e <__st>
   223a8:	83 c4 10             	add    $0x10,%esp
   223ab:	89 c2                	mov    %eax,%edx
   223ad:	83 ec 04             	sub    $0x4,%esp
   223b0:	8d 44 24 10          	lea    0x10(%esp),%eax
   223b4:	50                   	push   %eax
   223b5:	56                   	push   %esi
   223b6:	52                   	push   %edx
   223b7:	e8 e8 29 00 00       	call   24da4 <fdiv>
   223bc:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   223bf:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   223c3:	83 ec 0c             	sub    $0xc,%esp
   223c6:	6a 00                	push   $0x0
   223c8:	e8 b1 16 00 00       	call   23a7e <__st>
   223cd:	83 c4 10             	add    $0x10,%esp
   223d0:	89 c1                	mov    %eax,%ecx
   223d2:	8b 03                	mov    (%ebx),%eax
   223d4:	8b 53 04             	mov    0x4(%ebx),%edx
   223d7:	89 01                	mov    %eax,(%ecx)
   223d9:	89 51 04             	mov    %edx,0x4(%ecx)
   223dc:	83 ec 0c             	sub    $0xc,%esp
   223df:	6a 00                	push   $0x0
   223e1:	e8 98 16 00 00       	call   23a7e <__st>
   223e6:	83 c4 10             	add    $0x10,%esp
   223e9:	89 c2                	mov    %eax,%edx
   223eb:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   223f0:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   223f4:	e9 51 14 00 00       	jmp    2384a <.L127+0xf4>

000223f9 <.L53>:
		case 0x1f:                      // FDIVR ST, ST(i)。
			fdiv(PST(code & 7),PST(0),&tmp);
   223f9:	83 ec 0c             	sub    $0xc,%esp
   223fc:	6a 00                	push   $0x0
   223fe:	e8 7b 16 00 00       	call   23a7e <__st>
   22403:	83 c4 10             	add    $0x10,%esp
   22406:	89 c6                	mov    %eax,%esi
   22408:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2240d:	83 e0 07             	and    $0x7,%eax
   22410:	83 ec 0c             	sub    $0xc,%esp
   22413:	50                   	push   %eax
   22414:	e8 65 16 00 00       	call   23a7e <__st>
   22419:	83 c4 10             	add    $0x10,%esp
   2241c:	89 c2                	mov    %eax,%edx
   2241e:	83 ec 04             	sub    $0x4,%esp
   22421:	8d 44 24 10          	lea    0x10(%esp),%eax
   22425:	50                   	push   %eax
   22426:	56                   	push   %esi
   22427:	52                   	push   %edx
   22428:	e8 77 29 00 00       	call   24da4 <fdiv>
   2242d:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   22430:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22434:	83 ec 0c             	sub    $0xc,%esp
   22437:	6a 00                	push   $0x0
   22439:	e8 40 16 00 00       	call   23a7e <__st>
   2243e:	83 c4 10             	add    $0x10,%esp
   22441:	89 c1                	mov    %eax,%ecx
   22443:	8b 03                	mov    (%ebx),%eax
   22445:	8b 53 04             	mov    0x4(%ebx),%edx
   22448:	89 01                	mov    %eax,(%ecx)
   2244a:	89 51 04             	mov    %edx,0x4(%ecx)
   2244d:	83 ec 0c             	sub    $0xc,%esp
   22450:	6a 00                	push   $0x0
   22452:	e8 27 16 00 00       	call   23a7e <__st>
   22457:	83 c4 10             	add    $0x10,%esp
   2245a:	89 c2                	mov    %eax,%edx
   2245c:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22461:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   22465:	e9 e0 13 00 00       	jmp    2384a <.L127+0xf4>

0002246a <.L54>:
		case 0x38:                      // FLD ST(i)。
			fpush();
   2246a:	e8 24 15 00 00       	call   23993 <fpush>
			ST(0) = ST((code & 7)+1);
   2246f:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22474:	83 e0 07             	and    $0x7,%eax
   22477:	83 c0 01             	add    $0x1,%eax
   2247a:	83 ec 0c             	sub    $0xc,%esp
   2247d:	50                   	push   %eax
   2247e:	e8 fb 15 00 00       	call   23a7e <__st>
   22483:	83 c4 10             	add    $0x10,%esp
   22486:	89 c3                	mov    %eax,%ebx
   22488:	83 ec 0c             	sub    $0xc,%esp
   2248b:	6a 00                	push   $0x0
   2248d:	e8 ec 15 00 00       	call   23a7e <__st>
   22492:	83 c4 10             	add    $0x10,%esp
   22495:	8b 13                	mov    (%ebx),%edx
   22497:	89 10                	mov    %edx,(%eax)
   22499:	8b 53 04             	mov    0x4(%ebx),%edx
   2249c:	89 50 04             	mov    %edx,0x4(%eax)
   2249f:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
   224a3:	66 89 50 08          	mov    %dx,0x8(%eax)
			return;
   224a7:	e9 9e 13 00 00       	jmp    2384a <.L127+0xf4>

000224ac <.L55>:
		case 0x39:                      // FXCH ST(i)。
			fxchg(&ST(0),&ST(code & 7));
   224ac:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   224b1:	83 e0 07             	and    $0x7,%eax
   224b4:	83 ec 0c             	sub    $0xc,%esp
   224b7:	50                   	push   %eax
   224b8:	e8 c1 15 00 00       	call   23a7e <__st>
   224bd:	83 c4 10             	add    $0x10,%esp
   224c0:	89 c3                	mov    %eax,%ebx
   224c2:	83 ec 0c             	sub    $0xc,%esp
   224c5:	6a 00                	push   $0x0
   224c7:	e8 b2 15 00 00       	call   23a7e <__st>
   224cc:	83 c4 10             	add    $0x10,%esp
   224cf:	83 ec 08             	sub    $0x8,%esp
   224d2:	53                   	push   %ebx
   224d3:	50                   	push   %eax
   224d4:	e8 45 15 00 00       	call   23a1e <fxchg>
   224d9:	83 c4 10             	add    $0x10,%esp
			return;
   224dc:	e9 69 13 00 00       	jmp    2384a <.L127+0xf4>

000224e1 <.L56>:
		case 0x3b:                      // FSTP ST(i)。
			ST(code & 7) = ST(0);
   224e1:	83 ec 0c             	sub    $0xc,%esp
   224e4:	6a 00                	push   $0x0
   224e6:	e8 93 15 00 00       	call   23a7e <__st>
   224eb:	83 c4 10             	add    $0x10,%esp
   224ee:	89 c3                	mov    %eax,%ebx
   224f0:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   224f5:	83 e0 07             	and    $0x7,%eax
   224f8:	83 ec 0c             	sub    $0xc,%esp
   224fb:	50                   	push   %eax
   224fc:	e8 7d 15 00 00       	call   23a7e <__st>
   22501:	83 c4 10             	add    $0x10,%esp
   22504:	8b 13                	mov    (%ebx),%edx
   22506:	89 10                	mov    %edx,(%eax)
   22508:	8b 53 04             	mov    0x4(%ebx),%edx
   2250b:	89 50 04             	mov    %edx,0x4(%eax)
   2250e:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
   22512:	66 89 50 08          	mov    %dx,0x8(%eax)
			fpop();
   22516:	e8 ed 13 00 00       	call   23908 <fpop>
			return;
   2251b:	e9 2a 13 00 00       	jmp    2384a <.L127+0xf4>

00022520 <.L57>:
		case 0x98:                      // FADD ST(i)， ST。
			fadd(PST(0),PST(code & 7),&tmp);
   22520:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22525:	83 e0 07             	and    $0x7,%eax
   22528:	83 ec 0c             	sub    $0xc,%esp
   2252b:	50                   	push   %eax
   2252c:	e8 4d 15 00 00       	call   23a7e <__st>
   22531:	83 c4 10             	add    $0x10,%esp
   22534:	89 c6                	mov    %eax,%esi
   22536:	83 ec 0c             	sub    $0xc,%esp
   22539:	6a 00                	push   $0x0
   2253b:	e8 3e 15 00 00       	call   23a7e <__st>
   22540:	83 c4 10             	add    $0x10,%esp
   22543:	89 c2                	mov    %eax,%edx
   22545:	83 ec 04             	sub    $0x4,%esp
   22548:	8d 44 24 10          	lea    0x10(%esp),%eax
   2254c:	50                   	push   %eax
   2254d:	56                   	push   %esi
   2254e:	52                   	push   %edx
   2254f:	e8 99 23 00 00       	call   248ed <fadd>
   22554:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22557:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   2255b:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22560:	83 e0 07             	and    $0x7,%eax
   22563:	83 ec 0c             	sub    $0xc,%esp
   22566:	50                   	push   %eax
   22567:	e8 12 15 00 00       	call   23a7e <__st>
   2256c:	83 c4 10             	add    $0x10,%esp
   2256f:	89 c1                	mov    %eax,%ecx
   22571:	8b 03                	mov    (%ebx),%eax
   22573:	8b 53 04             	mov    0x4(%ebx),%edx
   22576:	89 01                	mov    %eax,(%ecx)
   22578:	89 51 04             	mov    %edx,0x4(%ecx)
   2257b:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22580:	83 e0 07             	and    $0x7,%eax
   22583:	83 ec 0c             	sub    $0xc,%esp
   22586:	50                   	push   %eax
   22587:	e8 f2 14 00 00       	call   23a7e <__st>
   2258c:	83 c4 10             	add    $0x10,%esp
   2258f:	89 c2                	mov    %eax,%edx
   22591:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22596:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   2259a:	e9 ab 12 00 00       	jmp    2384a <.L127+0xf4>

0002259f <.L58>:
		case 0x99:                      // FMUL ST(i)， ST。
			fmul(PST(0),PST(code & 7),&tmp);
   2259f:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   225a4:	83 e0 07             	and    $0x7,%eax
   225a7:	83 ec 0c             	sub    $0xc,%esp
   225aa:	50                   	push   %eax
   225ab:	e8 ce 14 00 00       	call   23a7e <__st>
   225b0:	83 c4 10             	add    $0x10,%esp
   225b3:	89 c6                	mov    %eax,%esi
   225b5:	83 ec 0c             	sub    $0xc,%esp
   225b8:	6a 00                	push   $0x0
   225ba:	e8 bf 14 00 00       	call   23a7e <__st>
   225bf:	83 c4 10             	add    $0x10,%esp
   225c2:	89 c2                	mov    %eax,%edx
   225c4:	83 ec 04             	sub    $0x4,%esp
   225c7:	8d 44 24 10          	lea    0x10(%esp),%eax
   225cb:	50                   	push   %eax
   225cc:	56                   	push   %esi
   225cd:	52                   	push   %edx
   225ce:	e8 02 25 00 00       	call   24ad5 <fmul>
   225d3:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   225d6:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   225da:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   225df:	83 e0 07             	and    $0x7,%eax
   225e2:	83 ec 0c             	sub    $0xc,%esp
   225e5:	50                   	push   %eax
   225e6:	e8 93 14 00 00       	call   23a7e <__st>
   225eb:	83 c4 10             	add    $0x10,%esp
   225ee:	89 c1                	mov    %eax,%ecx
   225f0:	8b 03                	mov    (%ebx),%eax
   225f2:	8b 53 04             	mov    0x4(%ebx),%edx
   225f5:	89 01                	mov    %eax,(%ecx)
   225f7:	89 51 04             	mov    %edx,0x4(%ecx)
   225fa:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   225ff:	83 e0 07             	and    $0x7,%eax
   22602:	83 ec 0c             	sub    $0xc,%esp
   22605:	50                   	push   %eax
   22606:	e8 73 14 00 00       	call   23a7e <__st>
   2260b:	83 c4 10             	add    $0x10,%esp
   2260e:	89 c2                	mov    %eax,%edx
   22610:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22615:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   22619:	e9 2c 12 00 00       	jmp    2384a <.L127+0xf4>

0002261e <.L59>:
		case 0x9a:                      // FCOM ST(i)。
			fcom(PST(code & 7),PST(0));
   2261e:	83 ec 0c             	sub    $0xc,%esp
   22621:	6a 00                	push   $0x0
   22623:	e8 56 14 00 00       	call   23a7e <__st>
   22628:	83 c4 10             	add    $0x10,%esp
   2262b:	89 c6                	mov    %eax,%esi
   2262d:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22632:	83 e0 07             	and    $0x7,%eax
   22635:	83 ec 0c             	sub    $0xc,%esp
   22638:	50                   	push   %eax
   22639:	e8 40 14 00 00       	call   23a7e <__st>
   2263e:	83 c4 10             	add    $0x10,%esp
   22641:	83 ec 08             	sub    $0x8,%esp
   22644:	56                   	push   %esi
   22645:	50                   	push   %eax
   22646:	e8 2e 2b 00 00       	call   25179 <fcom>
   2264b:	83 c4 10             	add    $0x10,%esp
			return;
   2264e:	e9 f7 11 00 00       	jmp    2384a <.L127+0xf4>

00022653 <.L60>:
		case 0x9b:                      // FCOMP ST(i)。
			fcom(PST(code & 7),PST(0));
   22653:	83 ec 0c             	sub    $0xc,%esp
   22656:	6a 00                	push   $0x0
   22658:	e8 21 14 00 00       	call   23a7e <__st>
   2265d:	83 c4 10             	add    $0x10,%esp
   22660:	89 c6                	mov    %eax,%esi
   22662:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22667:	83 e0 07             	and    $0x7,%eax
   2266a:	83 ec 0c             	sub    $0xc,%esp
   2266d:	50                   	push   %eax
   2266e:	e8 0b 14 00 00       	call   23a7e <__st>
   22673:	83 c4 10             	add    $0x10,%esp
   22676:	83 ec 08             	sub    $0x8,%esp
   22679:	56                   	push   %esi
   2267a:	50                   	push   %eax
   2267b:	e8 f9 2a 00 00       	call   25179 <fcom>
   22680:	83 c4 10             	add    $0x10,%esp
			fpop();
   22683:	e8 80 12 00 00       	call   23908 <fpop>
			return;			
   22688:	e9 bd 11 00 00       	jmp    2384a <.L127+0xf4>

0002268d <.L61>:
		case 0x9c:                      // FSUBR ST(i), ST。
			ST(code & 7).exponent ^= 0x8000;
   2268d:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22692:	83 e0 07             	and    $0x7,%eax
   22695:	83 ec 0c             	sub    $0xc,%esp
   22698:	50                   	push   %eax
   22699:	e8 e0 13 00 00       	call   23a7e <__st>
   2269e:	83 c4 10             	add    $0x10,%esp
   226a1:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   226a5:	66 81 f2 00 80       	xor    $0x8000,%dx
   226aa:	66 89 50 08          	mov    %dx,0x8(%eax)
			fadd(PST(0),PST(code & 7),&tmp);
   226ae:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   226b3:	83 e0 07             	and    $0x7,%eax
   226b6:	83 ec 0c             	sub    $0xc,%esp
   226b9:	50                   	push   %eax
   226ba:	e8 bf 13 00 00       	call   23a7e <__st>
   226bf:	83 c4 10             	add    $0x10,%esp
   226c2:	89 c6                	mov    %eax,%esi
   226c4:	83 ec 0c             	sub    $0xc,%esp
   226c7:	6a 00                	push   $0x0
   226c9:	e8 b0 13 00 00       	call   23a7e <__st>
   226ce:	83 c4 10             	add    $0x10,%esp
   226d1:	89 c2                	mov    %eax,%edx
   226d3:	83 ec 04             	sub    $0x4,%esp
   226d6:	8d 44 24 10          	lea    0x10(%esp),%eax
   226da:	50                   	push   %eax
   226db:	56                   	push   %esi
   226dc:	52                   	push   %edx
   226dd:	e8 0b 22 00 00       	call   248ed <fadd>
   226e2:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   226e5:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   226e9:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   226ee:	83 e0 07             	and    $0x7,%eax
   226f1:	83 ec 0c             	sub    $0xc,%esp
   226f4:	50                   	push   %eax
   226f5:	e8 84 13 00 00       	call   23a7e <__st>
   226fa:	83 c4 10             	add    $0x10,%esp
   226fd:	89 c1                	mov    %eax,%ecx
   226ff:	8b 03                	mov    (%ebx),%eax
   22701:	8b 53 04             	mov    0x4(%ebx),%edx
   22704:	89 01                	mov    %eax,(%ecx)
   22706:	89 51 04             	mov    %edx,0x4(%ecx)
   22709:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2270e:	83 e0 07             	and    $0x7,%eax
   22711:	83 ec 0c             	sub    $0xc,%esp
   22714:	50                   	push   %eax
   22715:	e8 64 13 00 00       	call   23a7e <__st>
   2271a:	83 c4 10             	add    $0x10,%esp
   2271d:	89 c2                	mov    %eax,%edx
   2271f:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22724:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   22728:	e9 1d 11 00 00       	jmp    2384a <.L127+0xf4>

0002272d <.L62>:
		case 0x9d:                      // FSUB ST(i), ST。
			real_to_real(&ST(0),&tmp);
   2272d:	83 ec 0c             	sub    $0xc,%esp
   22730:	6a 00                	push   $0x0
   22732:	e8 47 13 00 00       	call   23a7e <__st>
   22737:	83 c4 10             	add    $0x10,%esp
   2273a:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
   2273e:	8b 50 04             	mov    0x4(%eax),%edx
   22741:	8b 00                	mov    (%eax),%eax
   22743:	89 01                	mov    %eax,(%ecx)
   22745:	89 51 04             	mov    %edx,0x4(%ecx)
   22748:	83 ec 0c             	sub    $0xc,%esp
   2274b:	6a 00                	push   $0x0
   2274d:	e8 2c 13 00 00       	call   23a7e <__st>
   22752:	83 c4 10             	add    $0x10,%esp
   22755:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   22759:	66 89 44 24 14       	mov    %ax,0x14(%esp)
			tmp.exponent ^= 0x8000;
   2275e:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22763:	66 35 00 80          	xor    $0x8000,%ax
   22767:	66 89 44 24 14       	mov    %ax,0x14(%esp)
			fadd(PST(code & 7),&tmp,&tmp);
   2276c:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22771:	83 e0 07             	and    $0x7,%eax
   22774:	83 ec 0c             	sub    $0xc,%esp
   22777:	50                   	push   %eax
   22778:	e8 01 13 00 00       	call   23a7e <__st>
   2277d:	83 c4 10             	add    $0x10,%esp
   22780:	89 c2                	mov    %eax,%edx
   22782:	83 ec 04             	sub    $0x4,%esp
   22785:	8d 44 24 10          	lea    0x10(%esp),%eax
   22789:	50                   	push   %eax
   2278a:	8d 44 24 14          	lea    0x14(%esp),%eax
   2278e:	50                   	push   %eax
   2278f:	52                   	push   %edx
   22790:	e8 58 21 00 00       	call   248ed <fadd>
   22795:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22798:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   2279c:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   227a1:	83 e0 07             	and    $0x7,%eax
   227a4:	83 ec 0c             	sub    $0xc,%esp
   227a7:	50                   	push   %eax
   227a8:	e8 d1 12 00 00       	call   23a7e <__st>
   227ad:	83 c4 10             	add    $0x10,%esp
   227b0:	89 c1                	mov    %eax,%ecx
   227b2:	8b 03                	mov    (%ebx),%eax
   227b4:	8b 53 04             	mov    0x4(%ebx),%edx
   227b7:	89 01                	mov    %eax,(%ecx)
   227b9:	89 51 04             	mov    %edx,0x4(%ecx)
   227bc:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   227c1:	83 e0 07             	and    $0x7,%eax
   227c4:	83 ec 0c             	sub    $0xc,%esp
   227c7:	50                   	push   %eax
   227c8:	e8 b1 12 00 00       	call   23a7e <__st>
   227cd:	83 c4 10             	add    $0x10,%esp
   227d0:	89 c2                	mov    %eax,%edx
   227d2:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   227d7:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   227db:	e9 6a 10 00 00       	jmp    2384a <.L127+0xf4>

000227e0 <.L63>:
		case 0x9e:                      // FDIVR ST(i), ST。
			fdiv(PST(0),PST(code & 7),&tmp);
   227e0:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   227e5:	83 e0 07             	and    $0x7,%eax
   227e8:	83 ec 0c             	sub    $0xc,%esp
   227eb:	50                   	push   %eax
   227ec:	e8 8d 12 00 00       	call   23a7e <__st>
   227f1:	83 c4 10             	add    $0x10,%esp
   227f4:	89 c6                	mov    %eax,%esi
   227f6:	83 ec 0c             	sub    $0xc,%esp
   227f9:	6a 00                	push   $0x0
   227fb:	e8 7e 12 00 00       	call   23a7e <__st>
   22800:	83 c4 10             	add    $0x10,%esp
   22803:	89 c2                	mov    %eax,%edx
   22805:	83 ec 04             	sub    $0x4,%esp
   22808:	8d 44 24 10          	lea    0x10(%esp),%eax
   2280c:	50                   	push   %eax
   2280d:	56                   	push   %esi
   2280e:	52                   	push   %edx
   2280f:	e8 90 25 00 00       	call   24da4 <fdiv>
   22814:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22817:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   2281b:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22820:	83 e0 07             	and    $0x7,%eax
   22823:	83 ec 0c             	sub    $0xc,%esp
   22826:	50                   	push   %eax
   22827:	e8 52 12 00 00       	call   23a7e <__st>
   2282c:	83 c4 10             	add    $0x10,%esp
   2282f:	89 c1                	mov    %eax,%ecx
   22831:	8b 03                	mov    (%ebx),%eax
   22833:	8b 53 04             	mov    0x4(%ebx),%edx
   22836:	89 01                	mov    %eax,(%ecx)
   22838:	89 51 04             	mov    %edx,0x4(%ecx)
   2283b:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22840:	83 e0 07             	and    $0x7,%eax
   22843:	83 ec 0c             	sub    $0xc,%esp
   22846:	50                   	push   %eax
   22847:	e8 32 12 00 00       	call   23a7e <__st>
   2284c:	83 c4 10             	add    $0x10,%esp
   2284f:	89 c2                	mov    %eax,%edx
   22851:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22856:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   2285a:	e9 eb 0f 00 00       	jmp    2384a <.L127+0xf4>

0002285f <.L64>:
		case 0x9f:                      // FDIV ST(i), ST。
			fdiv(PST(code & 7),PST(0),&tmp);
   2285f:	83 ec 0c             	sub    $0xc,%esp
   22862:	6a 00                	push   $0x0
   22864:	e8 15 12 00 00       	call   23a7e <__st>
   22869:	83 c4 10             	add    $0x10,%esp
   2286c:	89 c6                	mov    %eax,%esi
   2286e:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22873:	83 e0 07             	and    $0x7,%eax
   22876:	83 ec 0c             	sub    $0xc,%esp
   22879:	50                   	push   %eax
   2287a:	e8 ff 11 00 00       	call   23a7e <__st>
   2287f:	83 c4 10             	add    $0x10,%esp
   22882:	89 c2                	mov    %eax,%edx
   22884:	83 ec 04             	sub    $0x4,%esp
   22887:	8d 44 24 10          	lea    0x10(%esp),%eax
   2288b:	50                   	push   %eax
   2288c:	56                   	push   %esi
   2288d:	52                   	push   %edx
   2288e:	e8 11 25 00 00       	call   24da4 <fdiv>
   22893:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22896:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   2289a:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2289f:	83 e0 07             	and    $0x7,%eax
   228a2:	83 ec 0c             	sub    $0xc,%esp
   228a5:	50                   	push   %eax
   228a6:	e8 d3 11 00 00       	call   23a7e <__st>
   228ab:	83 c4 10             	add    $0x10,%esp
   228ae:	89 c1                	mov    %eax,%ecx
   228b0:	8b 03                	mov    (%ebx),%eax
   228b2:	8b 53 04             	mov    0x4(%ebx),%edx
   228b5:	89 01                	mov    %eax,(%ecx)
   228b7:	89 51 04             	mov    %edx,0x4(%ecx)
   228ba:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   228bf:	83 e0 07             	and    $0x7,%eax
   228c2:	83 ec 0c             	sub    $0xc,%esp
   228c5:	50                   	push   %eax
   228c6:	e8 b3 11 00 00       	call   23a7e <__st>
   228cb:	83 c4 10             	add    $0x10,%esp
   228ce:	89 c2                	mov    %eax,%edx
   228d0:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   228d5:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   228d9:	e9 6c 0f 00 00       	jmp    2384a <.L127+0xf4>

000228de <.L65>:
		case 0xb8:                      // FFREE ST(i), ST。未实现。
			printk("ffree not implemented\n\r");
   228de:	83 ec 0c             	sub    $0xc,%esp
   228e1:	8d 83 07 68 ff ff    	lea    -0x97f9(%ebx),%eax
   228e7:	50                   	push   %eax
   228e8:	e8 45 6a fe ff       	call   9332 <printk>
   228ed:	83 c4 10             	add    $0x10,%esp
			math_abort(info,1<<(SIGILL-1));
   228f0:	83 ec 08             	sub    $0x8,%esp
   228f3:	6a 08                	push   $0x8
   228f5:	ff 74 24 3c          	pushl  0x3c(%esp)
   228f9:	e8 cf 0f 00 00       	call   238cd <__math_abort>
   228fe:	83 c4 10             	add    $0x10,%esp

00022901 <.L66>:
		case 0xb9:                      // FXCH ST(i)。
			fxchg(&ST(0),&ST(code & 7));
   22901:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22906:	83 e0 07             	and    $0x7,%eax
   22909:	83 ec 0c             	sub    $0xc,%esp
   2290c:	50                   	push   %eax
   2290d:	e8 6c 11 00 00       	call   23a7e <__st>
   22912:	83 c4 10             	add    $0x10,%esp
   22915:	89 c3                	mov    %eax,%ebx
   22917:	83 ec 0c             	sub    $0xc,%esp
   2291a:	6a 00                	push   $0x0
   2291c:	e8 5d 11 00 00       	call   23a7e <__st>
   22921:	83 c4 10             	add    $0x10,%esp
   22924:	83 ec 08             	sub    $0x8,%esp
   22927:	53                   	push   %ebx
   22928:	50                   	push   %eax
   22929:	e8 f0 10 00 00       	call   23a1e <fxchg>
   2292e:	83 c4 10             	add    $0x10,%esp
			return;
   22931:	e9 14 0f 00 00       	jmp    2384a <.L127+0xf4>

00022936 <.L67>:
		case 0xba:                      // FST ST(i)。
			ST(code & 7) = ST(0);
   22936:	83 ec 0c             	sub    $0xc,%esp
   22939:	6a 00                	push   $0x0
   2293b:	e8 3e 11 00 00       	call   23a7e <__st>
   22940:	83 c4 10             	add    $0x10,%esp
   22943:	89 c3                	mov    %eax,%ebx
   22945:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2294a:	83 e0 07             	and    $0x7,%eax
   2294d:	83 ec 0c             	sub    $0xc,%esp
   22950:	50                   	push   %eax
   22951:	e8 28 11 00 00       	call   23a7e <__st>
   22956:	83 c4 10             	add    $0x10,%esp
   22959:	8b 13                	mov    (%ebx),%edx
   2295b:	89 10                	mov    %edx,(%eax)
   2295d:	8b 53 04             	mov    0x4(%ebx),%edx
   22960:	89 50 04             	mov    %edx,0x4(%eax)
   22963:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
   22967:	66 89 50 08          	mov    %dx,0x8(%eax)
			return;
   2296b:	e9 da 0e 00 00       	jmp    2384a <.L127+0xf4>

00022970 <.L68>:
		case 0xbb:                      // FSTP ST(i)。
			ST(code & 7) = ST(0);
   22970:	83 ec 0c             	sub    $0xc,%esp
   22973:	6a 00                	push   $0x0
   22975:	e8 04 11 00 00       	call   23a7e <__st>
   2297a:	83 c4 10             	add    $0x10,%esp
   2297d:	89 c3                	mov    %eax,%ebx
   2297f:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22984:	83 e0 07             	and    $0x7,%eax
   22987:	83 ec 0c             	sub    $0xc,%esp
   2298a:	50                   	push   %eax
   2298b:	e8 ee 10 00 00       	call   23a7e <__st>
   22990:	83 c4 10             	add    $0x10,%esp
   22993:	8b 13                	mov    (%ebx),%edx
   22995:	89 10                	mov    %edx,(%eax)
   22997:	8b 53 04             	mov    0x4(%ebx),%edx
   2299a:	89 50 04             	mov    %edx,0x4(%eax)
   2299d:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
   229a1:	66 89 50 08          	mov    %dx,0x8(%eax)
			fpop();
   229a5:	e8 5e 0f 00 00       	call   23908 <fpop>
			return;
   229aa:	e9 9b 0e 00 00       	jmp    2384a <.L127+0xf4>

000229af <.L69>:
		case 0xbc:                      // FUCOM ST(i)。
			fucom(PST(code & 7),PST(0));
   229af:	83 ec 0c             	sub    $0xc,%esp
   229b2:	6a 00                	push   $0x0
   229b4:	e8 c5 10 00 00       	call   23a7e <__st>
   229b9:	83 c4 10             	add    $0x10,%esp
   229bc:	89 c6                	mov    %eax,%esi
   229be:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   229c3:	83 e0 07             	and    $0x7,%eax
   229c6:	83 ec 0c             	sub    $0xc,%esp
   229c9:	50                   	push   %eax
   229ca:	e8 af 10 00 00       	call   23a7e <__st>
   229cf:	83 c4 10             	add    $0x10,%esp
   229d2:	83 ec 08             	sub    $0x8,%esp
   229d5:	56                   	push   %esi
   229d6:	50                   	push   %eax
   229d7:	e8 03 28 00 00       	call   251df <fucom>
   229dc:	83 c4 10             	add    $0x10,%esp
			return;
   229df:	e9 66 0e 00 00       	jmp    2384a <.L127+0xf4>

000229e4 <.L70>:
		case 0xbd:                      // FUCOMP ST(i)。
			fucom(PST(code & 7),PST(0));
   229e4:	83 ec 0c             	sub    $0xc,%esp
   229e7:	6a 00                	push   $0x0
   229e9:	e8 90 10 00 00       	call   23a7e <__st>
   229ee:	83 c4 10             	add    $0x10,%esp
   229f1:	89 c6                	mov    %eax,%esi
   229f3:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   229f8:	83 e0 07             	and    $0x7,%eax
   229fb:	83 ec 0c             	sub    $0xc,%esp
   229fe:	50                   	push   %eax
   229ff:	e8 7a 10 00 00       	call   23a7e <__st>
   22a04:	83 c4 10             	add    $0x10,%esp
   22a07:	83 ec 08             	sub    $0x8,%esp
   22a0a:	56                   	push   %esi
   22a0b:	50                   	push   %eax
   22a0c:	e8 ce 27 00 00       	call   251df <fucom>
   22a11:	83 c4 10             	add    $0x10,%esp
			fpop();
   22a14:	e8 ef 0e 00 00       	call   23908 <fpop>
			return;
   22a19:	e9 2c 0e 00 00       	jmp    2384a <.L127+0xf4>

00022a1e <.L71>:
		case 0xd8:                      // FADDP ST(i), ST。
			fadd(PST(code & 7),PST(0),&tmp);
   22a1e:	83 ec 0c             	sub    $0xc,%esp
   22a21:	6a 00                	push   $0x0
   22a23:	e8 56 10 00 00       	call   23a7e <__st>
   22a28:	83 c4 10             	add    $0x10,%esp
   22a2b:	89 c6                	mov    %eax,%esi
   22a2d:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22a32:	83 e0 07             	and    $0x7,%eax
   22a35:	83 ec 0c             	sub    $0xc,%esp
   22a38:	50                   	push   %eax
   22a39:	e8 40 10 00 00       	call   23a7e <__st>
   22a3e:	83 c4 10             	add    $0x10,%esp
   22a41:	89 c2                	mov    %eax,%edx
   22a43:	83 ec 04             	sub    $0x4,%esp
   22a46:	8d 44 24 10          	lea    0x10(%esp),%eax
   22a4a:	50                   	push   %eax
   22a4b:	56                   	push   %esi
   22a4c:	52                   	push   %edx
   22a4d:	e8 9b 1e 00 00       	call   248ed <fadd>
   22a52:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22a55:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22a59:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22a5e:	83 e0 07             	and    $0x7,%eax
   22a61:	83 ec 0c             	sub    $0xc,%esp
   22a64:	50                   	push   %eax
   22a65:	e8 14 10 00 00       	call   23a7e <__st>
   22a6a:	83 c4 10             	add    $0x10,%esp
   22a6d:	89 c1                	mov    %eax,%ecx
   22a6f:	8b 03                	mov    (%ebx),%eax
   22a71:	8b 53 04             	mov    0x4(%ebx),%edx
   22a74:	89 01                	mov    %eax,(%ecx)
   22a76:	89 51 04             	mov    %edx,0x4(%ecx)
   22a79:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22a7e:	83 e0 07             	and    $0x7,%eax
   22a81:	83 ec 0c             	sub    $0xc,%esp
   22a84:	50                   	push   %eax
   22a85:	e8 f4 0f 00 00       	call   23a7e <__st>
   22a8a:	83 c4 10             	add    $0x10,%esp
   22a8d:	89 c2                	mov    %eax,%edx
   22a8f:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22a94:	66 89 42 08          	mov    %ax,0x8(%edx)
			fpop();
   22a98:	e8 6b 0e 00 00       	call   23908 <fpop>
			return;
   22a9d:	e9 a8 0d 00 00       	jmp    2384a <.L127+0xf4>

00022aa2 <.L72>:
		case 0xd9:                      // FMULP ST(i), ST。
			fmul(PST(code & 7),PST(0),&tmp);
   22aa2:	83 ec 0c             	sub    $0xc,%esp
   22aa5:	6a 00                	push   $0x0
   22aa7:	e8 d2 0f 00 00       	call   23a7e <__st>
   22aac:	83 c4 10             	add    $0x10,%esp
   22aaf:	89 c6                	mov    %eax,%esi
   22ab1:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22ab6:	83 e0 07             	and    $0x7,%eax
   22ab9:	83 ec 0c             	sub    $0xc,%esp
   22abc:	50                   	push   %eax
   22abd:	e8 bc 0f 00 00       	call   23a7e <__st>
   22ac2:	83 c4 10             	add    $0x10,%esp
   22ac5:	89 c2                	mov    %eax,%edx
   22ac7:	83 ec 04             	sub    $0x4,%esp
   22aca:	8d 44 24 10          	lea    0x10(%esp),%eax
   22ace:	50                   	push   %eax
   22acf:	56                   	push   %esi
   22ad0:	52                   	push   %edx
   22ad1:	e8 ff 1f 00 00       	call   24ad5 <fmul>
   22ad6:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22ad9:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22add:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22ae2:	83 e0 07             	and    $0x7,%eax
   22ae5:	83 ec 0c             	sub    $0xc,%esp
   22ae8:	50                   	push   %eax
   22ae9:	e8 90 0f 00 00       	call   23a7e <__st>
   22aee:	83 c4 10             	add    $0x10,%esp
   22af1:	89 c1                	mov    %eax,%ecx
   22af3:	8b 03                	mov    (%ebx),%eax
   22af5:	8b 53 04             	mov    0x4(%ebx),%edx
   22af8:	89 01                	mov    %eax,(%ecx)
   22afa:	89 51 04             	mov    %edx,0x4(%ecx)
   22afd:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22b02:	83 e0 07             	and    $0x7,%eax
   22b05:	83 ec 0c             	sub    $0xc,%esp
   22b08:	50                   	push   %eax
   22b09:	e8 70 0f 00 00       	call   23a7e <__st>
   22b0e:	83 c4 10             	add    $0x10,%esp
   22b11:	89 c2                	mov    %eax,%edx
   22b13:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22b18:	66 89 42 08          	mov    %ax,0x8(%edx)
			fpop();
   22b1c:	e8 e7 0d 00 00       	call   23908 <fpop>
			return;
   22b21:	e9 24 0d 00 00       	jmp    2384a <.L127+0xf4>

00022b26 <.L73>:
		case 0xda:                      // FCOMP ST(i)。
			fcom(PST(code & 7),PST(0));
   22b26:	83 ec 0c             	sub    $0xc,%esp
   22b29:	6a 00                	push   $0x0
   22b2b:	e8 4e 0f 00 00       	call   23a7e <__st>
   22b30:	83 c4 10             	add    $0x10,%esp
   22b33:	89 c6                	mov    %eax,%esi
   22b35:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22b3a:	83 e0 07             	and    $0x7,%eax
   22b3d:	83 ec 0c             	sub    $0xc,%esp
   22b40:	50                   	push   %eax
   22b41:	e8 38 0f 00 00       	call   23a7e <__st>
   22b46:	83 c4 10             	add    $0x10,%esp
   22b49:	83 ec 08             	sub    $0x8,%esp
   22b4c:	56                   	push   %esi
   22b4d:	50                   	push   %eax
   22b4e:	e8 26 26 00 00       	call   25179 <fcom>
   22b53:	83 c4 10             	add    $0x10,%esp
			fpop();
   22b56:	e8 ad 0d 00 00       	call   23908 <fpop>
			return;
   22b5b:	e9 ea 0c 00 00       	jmp    2384a <.L127+0xf4>

00022b60 <.L74>:
		case 0xdc:                      // FSUBRP ST(i)。
			ST(code & 7).exponent ^= 0x8000;
   22b60:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22b65:	83 e0 07             	and    $0x7,%eax
   22b68:	83 ec 0c             	sub    $0xc,%esp
   22b6b:	50                   	push   %eax
   22b6c:	e8 0d 0f 00 00       	call   23a7e <__st>
   22b71:	83 c4 10             	add    $0x10,%esp
   22b74:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   22b78:	66 81 f2 00 80       	xor    $0x8000,%dx
   22b7d:	66 89 50 08          	mov    %dx,0x8(%eax)
			fadd(PST(0),PST(code & 7),&tmp);
   22b81:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22b86:	83 e0 07             	and    $0x7,%eax
   22b89:	83 ec 0c             	sub    $0xc,%esp
   22b8c:	50                   	push   %eax
   22b8d:	e8 ec 0e 00 00       	call   23a7e <__st>
   22b92:	83 c4 10             	add    $0x10,%esp
   22b95:	89 c6                	mov    %eax,%esi
   22b97:	83 ec 0c             	sub    $0xc,%esp
   22b9a:	6a 00                	push   $0x0
   22b9c:	e8 dd 0e 00 00       	call   23a7e <__st>
   22ba1:	83 c4 10             	add    $0x10,%esp
   22ba4:	89 c2                	mov    %eax,%edx
   22ba6:	83 ec 04             	sub    $0x4,%esp
   22ba9:	8d 44 24 10          	lea    0x10(%esp),%eax
   22bad:	50                   	push   %eax
   22bae:	56                   	push   %esi
   22baf:	52                   	push   %edx
   22bb0:	e8 38 1d 00 00       	call   248ed <fadd>
   22bb5:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22bb8:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22bbc:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22bc1:	83 e0 07             	and    $0x7,%eax
   22bc4:	83 ec 0c             	sub    $0xc,%esp
   22bc7:	50                   	push   %eax
   22bc8:	e8 b1 0e 00 00       	call   23a7e <__st>
   22bcd:	83 c4 10             	add    $0x10,%esp
   22bd0:	89 c1                	mov    %eax,%ecx
   22bd2:	8b 03                	mov    (%ebx),%eax
   22bd4:	8b 53 04             	mov    0x4(%ebx),%edx
   22bd7:	89 01                	mov    %eax,(%ecx)
   22bd9:	89 51 04             	mov    %edx,0x4(%ecx)
   22bdc:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22be1:	83 e0 07             	and    $0x7,%eax
   22be4:	83 ec 0c             	sub    $0xc,%esp
   22be7:	50                   	push   %eax
   22be8:	e8 91 0e 00 00       	call   23a7e <__st>
   22bed:	83 c4 10             	add    $0x10,%esp
   22bf0:	89 c2                	mov    %eax,%edx
   22bf2:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22bf7:	66 89 42 08          	mov    %ax,0x8(%edx)
			fpop();
   22bfb:	e8 08 0d 00 00       	call   23908 <fpop>
			return;
   22c00:	e9 45 0c 00 00       	jmp    2384a <.L127+0xf4>

00022c05 <.L75>:
		case 0xdd:                      // FSUBP ST(I), ST。
			real_to_real(&ST(0),&tmp);
   22c05:	83 ec 0c             	sub    $0xc,%esp
   22c08:	6a 00                	push   $0x0
   22c0a:	e8 6f 0e 00 00       	call   23a7e <__st>
   22c0f:	83 c4 10             	add    $0x10,%esp
   22c12:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
   22c16:	8b 50 04             	mov    0x4(%eax),%edx
   22c19:	8b 00                	mov    (%eax),%eax
   22c1b:	89 01                	mov    %eax,(%ecx)
   22c1d:	89 51 04             	mov    %edx,0x4(%ecx)
   22c20:	83 ec 0c             	sub    $0xc,%esp
   22c23:	6a 00                	push   $0x0
   22c25:	e8 54 0e 00 00       	call   23a7e <__st>
   22c2a:	83 c4 10             	add    $0x10,%esp
   22c2d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   22c31:	66 89 44 24 14       	mov    %ax,0x14(%esp)
			tmp.exponent ^= 0x8000;
   22c36:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22c3b:	66 35 00 80          	xor    $0x8000,%ax
   22c3f:	66 89 44 24 14       	mov    %ax,0x14(%esp)
			fadd(PST(code & 7),&tmp,&tmp);
   22c44:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22c49:	83 e0 07             	and    $0x7,%eax
   22c4c:	83 ec 0c             	sub    $0xc,%esp
   22c4f:	50                   	push   %eax
   22c50:	e8 29 0e 00 00       	call   23a7e <__st>
   22c55:	83 c4 10             	add    $0x10,%esp
   22c58:	89 c2                	mov    %eax,%edx
   22c5a:	83 ec 04             	sub    $0x4,%esp
   22c5d:	8d 44 24 10          	lea    0x10(%esp),%eax
   22c61:	50                   	push   %eax
   22c62:	8d 44 24 14          	lea    0x14(%esp),%eax
   22c66:	50                   	push   %eax
   22c67:	52                   	push   %edx
   22c68:	e8 80 1c 00 00       	call   248ed <fadd>
   22c6d:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22c70:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22c74:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22c79:	83 e0 07             	and    $0x7,%eax
   22c7c:	83 ec 0c             	sub    $0xc,%esp
   22c7f:	50                   	push   %eax
   22c80:	e8 f9 0d 00 00       	call   23a7e <__st>
   22c85:	83 c4 10             	add    $0x10,%esp
   22c88:	89 c1                	mov    %eax,%ecx
   22c8a:	8b 03                	mov    (%ebx),%eax
   22c8c:	8b 53 04             	mov    0x4(%ebx),%edx
   22c8f:	89 01                	mov    %eax,(%ecx)
   22c91:	89 51 04             	mov    %edx,0x4(%ecx)
   22c94:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22c99:	83 e0 07             	and    $0x7,%eax
   22c9c:	83 ec 0c             	sub    $0xc,%esp
   22c9f:	50                   	push   %eax
   22ca0:	e8 d9 0d 00 00       	call   23a7e <__st>
   22ca5:	83 c4 10             	add    $0x10,%esp
   22ca8:	89 c2                	mov    %eax,%edx
   22caa:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22caf:	66 89 42 08          	mov    %ax,0x8(%edx)
			fpop();
   22cb3:	e8 50 0c 00 00       	call   23908 <fpop>
			return;
   22cb8:	e9 8d 0b 00 00       	jmp    2384a <.L127+0xf4>

00022cbd <.L76>:
		case 0xde:                      // FDIVRP ST(i), ST。
			fdiv(PST(0),PST(code & 7),&tmp);
   22cbd:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22cc2:	83 e0 07             	and    $0x7,%eax
   22cc5:	83 ec 0c             	sub    $0xc,%esp
   22cc8:	50                   	push   %eax
   22cc9:	e8 b0 0d 00 00       	call   23a7e <__st>
   22cce:	83 c4 10             	add    $0x10,%esp
   22cd1:	89 c6                	mov    %eax,%esi
   22cd3:	83 ec 0c             	sub    $0xc,%esp
   22cd6:	6a 00                	push   $0x0
   22cd8:	e8 a1 0d 00 00       	call   23a7e <__st>
   22cdd:	83 c4 10             	add    $0x10,%esp
   22ce0:	89 c2                	mov    %eax,%edx
   22ce2:	83 ec 04             	sub    $0x4,%esp
   22ce5:	8d 44 24 10          	lea    0x10(%esp),%eax
   22ce9:	50                   	push   %eax
   22cea:	56                   	push   %esi
   22ceb:	52                   	push   %edx
   22cec:	e8 b3 20 00 00       	call   24da4 <fdiv>
   22cf1:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22cf4:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22cf8:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22cfd:	83 e0 07             	and    $0x7,%eax
   22d00:	83 ec 0c             	sub    $0xc,%esp
   22d03:	50                   	push   %eax
   22d04:	e8 75 0d 00 00       	call   23a7e <__st>
   22d09:	83 c4 10             	add    $0x10,%esp
   22d0c:	89 c1                	mov    %eax,%ecx
   22d0e:	8b 03                	mov    (%ebx),%eax
   22d10:	8b 53 04             	mov    0x4(%ebx),%edx
   22d13:	89 01                	mov    %eax,(%ecx)
   22d15:	89 51 04             	mov    %edx,0x4(%ecx)
   22d18:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22d1d:	83 e0 07             	and    $0x7,%eax
   22d20:	83 ec 0c             	sub    $0xc,%esp
   22d23:	50                   	push   %eax
   22d24:	e8 55 0d 00 00       	call   23a7e <__st>
   22d29:	83 c4 10             	add    $0x10,%esp
   22d2c:	89 c2                	mov    %eax,%edx
   22d2e:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22d33:	66 89 42 08          	mov    %ax,0x8(%edx)
			fpop();
   22d37:	e8 cc 0b 00 00       	call   23908 <fpop>
			return;
   22d3c:	e9 09 0b 00 00       	jmp    2384a <.L127+0xf4>

00022d41 <.L77>:
		case 0xdf:                      // FDIVP ST(i), ST。
			fdiv(PST(code & 7),PST(0),&tmp);
   22d41:	83 ec 0c             	sub    $0xc,%esp
   22d44:	6a 00                	push   $0x0
   22d46:	e8 33 0d 00 00       	call   23a7e <__st>
   22d4b:	83 c4 10             	add    $0x10,%esp
   22d4e:	89 c6                	mov    %eax,%esi
   22d50:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22d55:	83 e0 07             	and    $0x7,%eax
   22d58:	83 ec 0c             	sub    $0xc,%esp
   22d5b:	50                   	push   %eax
   22d5c:	e8 1d 0d 00 00       	call   23a7e <__st>
   22d61:	83 c4 10             	add    $0x10,%esp
   22d64:	89 c2                	mov    %eax,%edx
   22d66:	83 ec 04             	sub    $0x4,%esp
   22d69:	8d 44 24 10          	lea    0x10(%esp),%eax
   22d6d:	50                   	push   %eax
   22d6e:	56                   	push   %esi
   22d6f:	52                   	push   %edx
   22d70:	e8 2f 20 00 00       	call   24da4 <fdiv>
   22d75:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(code & 7));
   22d78:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   22d7c:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22d81:	83 e0 07             	and    $0x7,%eax
   22d84:	83 ec 0c             	sub    $0xc,%esp
   22d87:	50                   	push   %eax
   22d88:	e8 f1 0c 00 00       	call   23a7e <__st>
   22d8d:	83 c4 10             	add    $0x10,%esp
   22d90:	89 c1                	mov    %eax,%ecx
   22d92:	8b 03                	mov    (%ebx),%eax
   22d94:	8b 53 04             	mov    0x4(%ebx),%edx
   22d97:	89 01                	mov    %eax,(%ecx)
   22d99:	89 51 04             	mov    %edx,0x4(%ecx)
   22d9c:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22da1:	83 e0 07             	and    $0x7,%eax
   22da4:	83 ec 0c             	sub    $0xc,%esp
   22da7:	50                   	push   %eax
   22da8:	e8 d1 0c 00 00       	call   23a7e <__st>
   22dad:	83 c4 10             	add    $0x10,%esp
   22db0:	89 c2                	mov    %eax,%edx
   22db2:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   22db7:	66 89 42 08          	mov    %ax,0x8(%edx)
			fpop();
   22dbb:	e8 48 0b 00 00       	call   23908 <fpop>
			return;
   22dc0:	e9 85 0a 00 00       	jmp    2384a <.L127+0xf4>

00022dc5 <.L78>:
		case 0xf8:                      // FFREE ST(i)。未实现。
			printk("ffree not implemented\n\r");
   22dc5:	83 ec 0c             	sub    $0xc,%esp
   22dc8:	8d 83 07 68 ff ff    	lea    -0x97f9(%ebx),%eax
   22dce:	50                   	push   %eax
   22dcf:	e8 5e 65 fe ff       	call   9332 <printk>
   22dd4:	83 c4 10             	add    $0x10,%esp
			math_abort(info,1<<(SIGILL-1));
   22dd7:	83 ec 08             	sub    $0x8,%esp
   22dda:	6a 08                	push   $0x8
   22ddc:	ff 74 24 3c          	pushl  0x3c(%esp)
   22de0:	e8 e8 0a 00 00       	call   238cd <__math_abort>
   22de5:	83 c4 10             	add    $0x10,%esp
			fpop();
   22de8:	e8 1b 0b 00 00       	call   23908 <fpop>
			return;
   22ded:	e9 58 0a 00 00       	jmp    2384a <.L127+0xf4>

00022df2 <.L79>:
		case 0xf9:                      // FXCH ST(i)。
			fxchg(&ST(0),&ST(code & 7));
   22df2:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22df7:	83 e0 07             	and    $0x7,%eax
   22dfa:	83 ec 0c             	sub    $0xc,%esp
   22dfd:	50                   	push   %eax
   22dfe:	e8 7b 0c 00 00       	call   23a7e <__st>
   22e03:	83 c4 10             	add    $0x10,%esp
   22e06:	89 c3                	mov    %eax,%ebx
   22e08:	83 ec 0c             	sub    $0xc,%esp
   22e0b:	6a 00                	push   $0x0
   22e0d:	e8 6c 0c 00 00       	call   23a7e <__st>
   22e12:	83 c4 10             	add    $0x10,%esp
   22e15:	83 ec 08             	sub    $0x8,%esp
   22e18:	53                   	push   %ebx
   22e19:	50                   	push   %eax
   22e1a:	e8 ff 0b 00 00       	call   23a1e <fxchg>
   22e1f:	83 c4 10             	add    $0x10,%esp
			return;
   22e22:	e9 23 0a 00 00       	jmp    2384a <.L127+0xf4>

00022e27 <.L80>:
		case 0xfa:                      // FSTP ST(i)。
		case 0xfb:                      // FSTP ST(i)。
			ST(code & 7) = ST(0);
   22e27:	83 ec 0c             	sub    $0xc,%esp
   22e2a:	6a 00                	push   $0x0
   22e2c:	e8 4d 0c 00 00       	call   23a7e <__st>
   22e31:	83 c4 10             	add    $0x10,%esp
   22e34:	89 c3                	mov    %eax,%ebx
   22e36:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22e3b:	83 e0 07             	and    $0x7,%eax
   22e3e:	83 ec 0c             	sub    $0xc,%esp
   22e41:	50                   	push   %eax
   22e42:	e8 37 0c 00 00       	call   23a7e <__st>
   22e47:	83 c4 10             	add    $0x10,%esp
   22e4a:	8b 13                	mov    (%ebx),%edx
   22e4c:	89 10                	mov    %edx,(%eax)
   22e4e:	8b 53 04             	mov    0x4(%ebx),%edx
   22e51:	89 50 04             	mov    %edx,0x4(%eax)
   22e54:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
   22e58:	66 89 50 08          	mov    %dx,0x8(%eax)
			fpop();
   22e5c:	e8 a7 0a 00 00       	call   23908 <fpop>
			return;
   22e61:	e9 e4 09 00 00       	jmp    2384a <.L127+0xf4>

00022e66 <.L44>:
	}
// 处理第2个字节位7--6是MOD、位2--0是R/M的指令，即11011,XXX，MOD，XXX，R/M形式的代码。MOD在各子程序中处理，因此这里首先
// 让代码与上0xe7（0b11100111）屏蔽掉MOD。
	switch ((code>>3) & 0xe7) {
   22e66:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22e6b:	66 c1 e8 03          	shr    $0x3,%ax
   22e6f:	0f b7 c0             	movzwl %ax,%eax
   22e72:	25 e7 00 00 00       	and    $0xe7,%eax
   22e77:	83 e8 22             	sub    $0x22,%eax
   22e7a:	3d c5 00 00 00       	cmp    $0xc5,%eax
   22e7f:	0f 87 c7 05 00 00    	ja     2344c <.L81>
   22e85:	c1 e0 02             	shl    $0x2,%eax
   22e88:	8b 84 18 04 6c ff ff 	mov    -0x93fc(%eax,%ebx,1),%eax
   22e8f:	01 d8                	add    %ebx,%eax
   22e91:	ff e0                	jmp    *%eax

00022e93 <.L82>:
		case 0x22:
//			put_short_real(PST(0),info,code);
                    panic("kernel/math/math_emulate.c->do_emu(),394");
   22e93:	83 ec 0c             	sub    $0xc,%esp
   22e96:	8d 83 20 68 ff ff    	lea    -0x97e0(%ebx),%eax
   22e9c:	50                   	push   %eax
   22e9d:	e8 3c 64 fe ff       	call   92de <panic>
   22ea2:	83 c4 10             	add    $0x10,%esp
			return;
   22ea5:	e9 a0 09 00 00       	jmp    2384a <.L127+0xf4>

00022eaa <.L84>:
		case 0x23:                      // FSTP - 保存单精度实数（短实数）。
			put_short_real(PST(0),info,code);
   22eaa:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   22eaf:	83 ec 0c             	sub    $0xc,%esp
   22eb2:	6a 00                	push   $0x0
   22eb4:	e8 c5 0b 00 00       	call   23a7e <__st>
   22eb9:	83 c4 10             	add    $0x10,%esp
   22ebc:	83 ec 04             	sub    $0x4,%esp
   22ebf:	56                   	push   %esi
   22ec0:	ff 74 24 38          	pushl  0x38(%esp)
   22ec4:	50                   	push   %eax
   22ec5:	e8 6c 14 00 00       	call   24336 <put_short_real>
   22eca:	83 c4 10             	add    $0x10,%esp
			fpop();
   22ecd:	e8 36 0a 00 00       	call   23908 <fpop>
			return;
   22ed2:	e9 73 09 00 00       	jmp    2384a <.L127+0xf4>

00022ed7 <.L85>:
		case 0x24:                      // FLDENV - 加载协处理器状态和控制寄存器等。
			address = ea(info,code);
   22ed7:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22edc:	83 ec 08             	sub    $0x8,%esp
   22edf:	50                   	push   %eax
   22ee0:	ff 74 24 3c          	pushl  0x3c(%esp)
   22ee4:	e8 8d 0d 00 00       	call   23c76 <ea>
   22ee9:	83 c4 10             	add    $0x10,%esp
   22eec:	89 44 24 18          	mov    %eax,0x18(%esp)
			for (code = 0 ; code < 7 ; code++) {
   22ef0:	66 c7 44 24 1e 00 00 	movw   $0x0,0x1e(%esp)
   22ef7:	eb 3f                	jmp    22f38 <.L85+0x61>
				((long *) & I387)[code] =
				   get_fs_long((unsigned long *) address);
   22ef9:	83 ec 0c             	sub    $0xc,%esp
   22efc:	ff 74 24 24          	pushl  0x24(%esp)
   22f00:	e8 14 eb ff ff       	call   21a19 <get_fs_long>
   22f05:	83 c4 10             	add    $0x10,%esp
   22f08:	89 c1                	mov    %eax,%ecx
				((long *) & I387)[code] =
   22f0a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   22f10:	8b 00                	mov    (%eax),%eax
   22f12:	8d 90 18 04 00 00    	lea    0x418(%eax),%edx
   22f18:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22f1d:	c1 e0 02             	shl    $0x2,%eax
   22f20:	01 d0                	add    %edx,%eax
				   get_fs_long((unsigned long *) address);
   22f22:	89 ca                	mov    %ecx,%edx
				((long *) & I387)[code] =
   22f24:	89 10                	mov    %edx,(%eax)
				address += 4;
   22f26:	83 44 24 18 04       	addl   $0x4,0x18(%esp)
			for (code = 0 ; code < 7 ; code++) {
   22f2b:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22f30:	83 c0 01             	add    $0x1,%eax
   22f33:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
   22f38:	66 83 7c 24 1e 06    	cmpw   $0x6,0x1e(%esp)
   22f3e:	76 b9                	jbe    22ef9 <.L85+0x22>
			}
			return;
   22f40:	e9 05 09 00 00       	jmp    2384a <.L127+0xf4>

00022f45 <.L86>:
		case 0x25:                      // FLDCW - 加载控制字。
			address = ea(info,code);
   22f45:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22f4a:	83 ec 08             	sub    $0x8,%esp
   22f4d:	50                   	push   %eax
   22f4e:	ff 74 24 3c          	pushl  0x3c(%esp)
   22f52:	e8 1f 0d 00 00       	call   23c76 <ea>
   22f57:	83 c4 10             	add    $0x10,%esp
   22f5a:	89 44 24 18          	mov    %eax,0x18(%esp)
			*(unsigned short *) &I387.cwd =
   22f5e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   22f64:	8b 00                	mov    (%eax),%eax
   22f66:	8d 98 18 04 00 00    	lea    0x418(%eax),%ebx
				get_fs_word((unsigned short *) address);
   22f6c:	83 ec 0c             	sub    $0xc,%esp
   22f6f:	ff 74 24 24          	pushl  0x24(%esp)
   22f73:	e8 7e ea ff ff       	call   219f6 <get_fs_word>
   22f78:	83 c4 10             	add    $0x10,%esp
			*(unsigned short *) &I387.cwd =
   22f7b:	66 89 03             	mov    %ax,(%ebx)
			return;
   22f7e:	e9 c7 08 00 00       	jmp    2384a <.L127+0xf4>

00022f83 <.L87>:
		case 0x26:                      // FSTENV - 储存协处理器状态和控制寄存器等。
			address = ea(info,code);
   22f83:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22f88:	83 ec 08             	sub    $0x8,%esp
   22f8b:	50                   	push   %eax
   22f8c:	ff 74 24 3c          	pushl  0x3c(%esp)
   22f90:	e8 e1 0c 00 00       	call   23c76 <ea>
   22f95:	83 c4 10             	add    $0x10,%esp
   22f98:	89 44 24 18          	mov    %eax,0x18(%esp)
			verify_area(address,28);
   22f9c:	83 ec 08             	sub    $0x8,%esp
   22f9f:	6a 1c                	push   $0x1c
   22fa1:	ff 74 24 24          	pushl  0x24(%esp)
   22fa5:	e8 51 59 fe ff       	call   88fb <verify_area>
   22faa:	83 c4 10             	add    $0x10,%esp
			for (code = 0 ; code < 7 ; code++) {
   22fad:	66 c7 44 24 1e 00 00 	movw   $0x0,0x1e(%esp)
   22fb4:	eb 3c                	jmp    22ff2 <.L87+0x6f>
				put_fs_long( ((long *) & I387)[code],
   22fb6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   22fbc:	8b 00                	mov    (%eax),%eax
   22fbe:	8d 90 18 04 00 00    	lea    0x418(%eax),%edx
   22fc4:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22fc9:	c1 e0 02             	shl    $0x2,%eax
   22fcc:	01 d0                	add    %edx,%eax
   22fce:	8b 00                	mov    (%eax),%eax
   22fd0:	83 ec 08             	sub    $0x8,%esp
   22fd3:	ff 74 24 20          	pushl  0x20(%esp)
   22fd7:	50                   	push   %eax
   22fd8:	e8 82 ea ff ff       	call   21a5f <put_fs_long>
   22fdd:	83 c4 10             	add    $0x10,%esp
					(unsigned long *) address);
				address += 4;
   22fe0:	83 44 24 18 04       	addl   $0x4,0x18(%esp)
			for (code = 0 ; code < 7 ; code++) {
   22fe5:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   22fea:	83 c0 01             	add    $0x1,%eax
   22fed:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
   22ff2:	66 83 7c 24 1e 06    	cmpw   $0x6,0x1e(%esp)
   22ff8:	76 bc                	jbe    22fb6 <.L87+0x33>
			}
			return;
   22ffa:	e9 4b 08 00 00       	jmp    2384a <.L127+0xf4>

00022fff <.L88>:
		case 0x27:                      // FSTCW - 存储控制字。
			address = ea(info,code);
   22fff:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   23004:	83 ec 08             	sub    $0x8,%esp
   23007:	50                   	push   %eax
   23008:	ff 74 24 3c          	pushl  0x3c(%esp)
   2300c:	e8 65 0c 00 00       	call   23c76 <ea>
   23011:	83 c4 10             	add    $0x10,%esp
   23014:	89 44 24 18          	mov    %eax,0x18(%esp)
			verify_area(address,2);
   23018:	83 ec 08             	sub    $0x8,%esp
   2301b:	6a 02                	push   $0x2
   2301d:	ff 74 24 24          	pushl  0x24(%esp)
   23021:	e8 d5 58 fe ff       	call   88fb <verify_area>
   23026:	83 c4 10             	add    $0x10,%esp
			put_fs_word(I387.cwd,(short *) address);
   23029:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   2302f:	8b 00                	mov    (%eax),%eax
   23031:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   23037:	98                   	cwtl   
   23038:	83 ec 08             	sub    $0x8,%esp
   2303b:	ff 74 24 20          	pushl  0x20(%esp)
   2303f:	50                   	push   %eax
   23040:	e8 f4 e9 ff ff       	call   21a39 <put_fs_word>
   23045:	83 c4 10             	add    $0x10,%esp
			return;
   23048:	e9 fd 07 00 00       	jmp    2384a <.L127+0xf4>

0002304d <.L89>:
		case 0x62:                      // FIST - 存储短整形数。
			put_long_int(PST(0),info,code);
   2304d:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   23052:	83 ec 0c             	sub    $0xc,%esp
   23055:	6a 00                	push   $0x0
   23057:	e8 22 0a 00 00       	call   23a7e <__st>
   2305c:	83 c4 10             	add    $0x10,%esp
   2305f:	83 ec 04             	sub    $0x4,%esp
   23062:	56                   	push   %esi
   23063:	ff 74 24 38          	pushl  0x38(%esp)
   23067:	50                   	push   %eax
   23068:	e8 dc 14 00 00       	call   24549 <put_long_int>
   2306d:	83 c4 10             	add    $0x10,%esp
			return;
   23070:	e9 d5 07 00 00       	jmp    2384a <.L127+0xf4>

00023075 <.L90>:
		case 0x63:                      // FISTP - 存储短整型数。
			put_long_int(PST(0),info,code);
   23075:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   2307a:	83 ec 0c             	sub    $0xc,%esp
   2307d:	6a 00                	push   $0x0
   2307f:	e8 fa 09 00 00       	call   23a7e <__st>
   23084:	83 c4 10             	add    $0x10,%esp
   23087:	83 ec 04             	sub    $0x4,%esp
   2308a:	56                   	push   %esi
   2308b:	ff 74 24 38          	pushl  0x38(%esp)
   2308f:	50                   	push   %eax
   23090:	e8 b4 14 00 00       	call   24549 <put_long_int>
   23095:	83 c4 10             	add    $0x10,%esp
			fpop();
   23098:	e8 6b 08 00 00       	call   23908 <fpop>
			return;
   2309d:	e9 a8 07 00 00       	jmp    2384a <.L127+0xf4>

000230a2 <.L91>:
		case 0x65:                      // FLD - 加载扩展（临时）实数。
			fpush();
   230a2:	e8 ec 08 00 00       	call   23993 <fpush>
			get_temp_real(&tmp,info,code);
   230a7:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   230ac:	83 ec 04             	sub    $0x4,%esp
   230af:	50                   	push   %eax
   230b0:	ff 74 24 38          	pushl  0x38(%esp)
   230b4:	8d 44 24 18          	lea    0x18(%esp),%eax
   230b8:	50                   	push   %eax
   230b9:	e8 ef 0e 00 00       	call   23fad <get_temp_real>
   230be:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   230c1:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   230c5:	83 ec 0c             	sub    $0xc,%esp
   230c8:	6a 00                	push   $0x0
   230ca:	e8 af 09 00 00       	call   23a7e <__st>
   230cf:	83 c4 10             	add    $0x10,%esp
   230d2:	89 c1                	mov    %eax,%ecx
   230d4:	8b 03                	mov    (%ebx),%eax
   230d6:	8b 53 04             	mov    0x4(%ebx),%edx
   230d9:	89 01                	mov    %eax,(%ecx)
   230db:	89 51 04             	mov    %edx,0x4(%ecx)
   230de:	83 ec 0c             	sub    $0xc,%esp
   230e1:	6a 00                	push   $0x0
   230e3:	e8 96 09 00 00       	call   23a7e <__st>
   230e8:	83 c4 10             	add    $0x10,%esp
   230eb:	89 c2                	mov    %eax,%edx
   230ed:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   230f2:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   230f6:	e9 4f 07 00 00       	jmp    2384a <.L127+0xf4>

000230fb <.L92>:
		case 0x67:                      // FSTP - 储存扩展实数。
			put_temp_real(PST(0),info,code);
   230fb:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   23100:	83 ec 0c             	sub    $0xc,%esp
   23103:	6a 00                	push   $0x0
   23105:	e8 74 09 00 00       	call   23a7e <__st>
   2310a:	83 c4 10             	add    $0x10,%esp
   2310d:	83 ec 04             	sub    $0x4,%esp
   23110:	56                   	push   %esi
   23111:	ff 74 24 38          	pushl  0x38(%esp)
   23115:	50                   	push   %eax
   23116:	e8 13 13 00 00       	call   2442e <put_temp_real>
   2311b:	83 c4 10             	add    $0x10,%esp
			fpop();
   2311e:	e8 e5 07 00 00       	call   23908 <fpop>
			return;
   23123:	e9 22 07 00 00       	jmp    2384a <.L127+0xf4>

00023128 <.L93>:
		case 0xa2:                      // FST - 储存双精度实数。
			put_long_real(PST(0),info,code);
   23128:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   2312d:	83 ec 0c             	sub    $0xc,%esp
   23130:	6a 00                	push   $0x0
   23132:	e8 47 09 00 00       	call   23a7e <__st>
   23137:	83 c4 10             	add    $0x10,%esp
   2313a:	83 ec 04             	sub    $0x4,%esp
   2313d:	56                   	push   %esi
   2313e:	ff 74 24 38          	pushl  0x38(%esp)
   23142:	50                   	push   %eax
   23143:	e8 5e 12 00 00       	call   243a6 <put_long_real>
   23148:	83 c4 10             	add    $0x10,%esp
			return;
   2314b:	e9 fa 06 00 00       	jmp    2384a <.L127+0xf4>

00023150 <.L94>:
		case 0xa3:                      // FSTP - 存储双精度实数。
			put_long_real(PST(0),info,code);
   23150:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   23155:	83 ec 0c             	sub    $0xc,%esp
   23158:	6a 00                	push   $0x0
   2315a:	e8 1f 09 00 00       	call   23a7e <__st>
   2315f:	83 c4 10             	add    $0x10,%esp
   23162:	83 ec 04             	sub    $0x4,%esp
   23165:	56                   	push   %esi
   23166:	ff 74 24 38          	pushl  0x38(%esp)
   2316a:	50                   	push   %eax
   2316b:	e8 36 12 00 00       	call   243a6 <put_long_real>
   23170:	83 c4 10             	add    $0x10,%esp
			fpop();
   23173:	e8 90 07 00 00       	call   23908 <fpop>
			return;
   23178:	e9 cd 06 00 00       	jmp    2384a <.L127+0xf4>

0002317d <.L95>:
		case 0xa4:                      // FRSTOR - 恢复所有108字节的寄存器内容。
			address = ea(info,code);
   2317d:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   23182:	83 ec 08             	sub    $0x8,%esp
   23185:	50                   	push   %eax
   23186:	ff 74 24 3c          	pushl  0x3c(%esp)
   2318a:	e8 e7 0a 00 00       	call   23c76 <ea>
   2318f:	83 c4 10             	add    $0x10,%esp
   23192:	89 44 24 18          	mov    %eax,0x18(%esp)
			for (code = 0 ; code < 27 ; code++) {
   23196:	66 c7 44 24 1e 00 00 	movw   $0x0,0x1e(%esp)
   2319d:	eb 3f                	jmp    231de <.L95+0x61>
				((long *) & I387)[code] =
				   get_fs_long((unsigned long *) address);
   2319f:	83 ec 0c             	sub    $0xc,%esp
   231a2:	ff 74 24 24          	pushl  0x24(%esp)
   231a6:	e8 6e e8 ff ff       	call   21a19 <get_fs_long>
   231ab:	83 c4 10             	add    $0x10,%esp
   231ae:	89 c1                	mov    %eax,%ecx
				((long *) & I387)[code] =
   231b0:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   231b6:	8b 00                	mov    (%eax),%eax
   231b8:	8d 90 18 04 00 00    	lea    0x418(%eax),%edx
   231be:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   231c3:	c1 e0 02             	shl    $0x2,%eax
   231c6:	01 d0                	add    %edx,%eax
				   get_fs_long((unsigned long *) address);
   231c8:	89 ca                	mov    %ecx,%edx
				((long *) & I387)[code] =
   231ca:	89 10                	mov    %edx,(%eax)
				address += 4;
   231cc:	83 44 24 18 04       	addl   $0x4,0x18(%esp)
			for (code = 0 ; code < 27 ; code++) {
   231d1:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   231d6:	83 c0 01             	add    $0x1,%eax
   231d9:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
   231de:	66 83 7c 24 1e 1a    	cmpw   $0x1a,0x1e(%esp)
   231e4:	76 b9                	jbe    2319f <.L95+0x22>
			}
			return;
   231e6:	e9 5f 06 00 00       	jmp    2384a <.L127+0xf4>

000231eb <.L96>:
		case 0xa6:                      // FSAVE - 保存所有108字节寄存器内容。
			address = ea(info,code);
   231eb:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   231f0:	83 ec 08             	sub    $0x8,%esp
   231f3:	50                   	push   %eax
   231f4:	ff 74 24 3c          	pushl  0x3c(%esp)
   231f8:	e8 79 0a 00 00       	call   23c76 <ea>
   231fd:	83 c4 10             	add    $0x10,%esp
   23200:	89 44 24 18          	mov    %eax,0x18(%esp)
			verify_area(address,108);
   23204:	83 ec 08             	sub    $0x8,%esp
   23207:	6a 6c                	push   $0x6c
   23209:	ff 74 24 24          	pushl  0x24(%esp)
   2320d:	e8 e9 56 fe ff       	call   88fb <verify_area>
   23212:	83 c4 10             	add    $0x10,%esp
			for (code = 0 ; code < 27 ; code++) {
   23215:	66 c7 44 24 1e 00 00 	movw   $0x0,0x1e(%esp)
   2321c:	eb 3c                	jmp    2325a <.L96+0x6f>
				put_fs_long( ((long *) & I387)[code],
   2321e:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23224:	8b 00                	mov    (%eax),%eax
   23226:	8d 90 18 04 00 00    	lea    0x418(%eax),%edx
   2322c:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   23231:	c1 e0 02             	shl    $0x2,%eax
   23234:	01 d0                	add    %edx,%eax
   23236:	8b 00                	mov    (%eax),%eax
   23238:	83 ec 08             	sub    $0x8,%esp
   2323b:	ff 74 24 20          	pushl  0x20(%esp)
   2323f:	50                   	push   %eax
   23240:	e8 1a e8 ff ff       	call   21a5f <put_fs_long>
   23245:	83 c4 10             	add    $0x10,%esp
					(unsigned long *) address);
				address += 4;
   23248:	83 44 24 18 04       	addl   $0x4,0x18(%esp)
			for (code = 0 ; code < 27 ; code++) {
   2324d:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   23252:	83 c0 01             	add    $0x1,%eax
   23255:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
   2325a:	66 83 7c 24 1e 1a    	cmpw   $0x1a,0x1e(%esp)
   23260:	76 bc                	jbe    2321e <.L96+0x33>
			}
			I387.cwd = 0x037f;
   23262:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23268:	8b 00                	mov    (%eax),%eax
   2326a:	c7 80 18 04 00 00 7f 	movl   $0x37f,0x418(%eax)
   23271:	03 00 00 
			I387.swd = 0x0000;
   23274:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   2327a:	8b 00                	mov    (%eax),%eax
   2327c:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
   23283:	00 00 00 
			I387.twd = 0x0000;
   23286:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   2328c:	8b 00                	mov    (%eax),%eax
   2328e:	c7 80 20 04 00 00 00 	movl   $0x0,0x420(%eax)
   23295:	00 00 00 
			return;
   23298:	e9 ad 05 00 00       	jmp    2384a <.L127+0xf4>

0002329d <.L97>:
		case 0xa7:                      // FSTSW - 保存状态状态字。
			address = ea(info,code);
   2329d:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   232a2:	83 ec 08             	sub    $0x8,%esp
   232a5:	50                   	push   %eax
   232a6:	ff 74 24 3c          	pushl  0x3c(%esp)
   232aa:	e8 c7 09 00 00       	call   23c76 <ea>
   232af:	83 c4 10             	add    $0x10,%esp
   232b2:	89 44 24 18          	mov    %eax,0x18(%esp)
			verify_area(address,2);
   232b6:	83 ec 08             	sub    $0x8,%esp
   232b9:	6a 02                	push   $0x2
   232bb:	ff 74 24 24          	pushl  0x24(%esp)
   232bf:	e8 37 56 fe ff       	call   88fb <verify_area>
   232c4:	83 c4 10             	add    $0x10,%esp
			put_fs_word(I387.swd,(short *) address);
   232c7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   232cd:	8b 00                	mov    (%eax),%eax
   232cf:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
   232d5:	98                   	cwtl   
   232d6:	83 ec 08             	sub    $0x8,%esp
   232d9:	ff 74 24 20          	pushl  0x20(%esp)
   232dd:	50                   	push   %eax
   232de:	e8 56 e7 ff ff       	call   21a39 <put_fs_word>
   232e3:	83 c4 10             	add    $0x10,%esp
			return;
   232e6:	e9 5f 05 00 00       	jmp    2384a <.L127+0xf4>

000232eb <.L98>:
		case 0xe2:                      // FIST - 保存短整型数。
			put_short_int(PST(0),info,code);
   232eb:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   232f0:	83 ec 0c             	sub    $0xc,%esp
   232f3:	6a 00                	push   $0x0
   232f5:	e8 84 07 00 00       	call   23a7e <__st>
   232fa:	83 c4 10             	add    $0x10,%esp
   232fd:	83 ec 04             	sub    $0x4,%esp
   23300:	56                   	push   %esi
   23301:	ff 74 24 38          	pushl  0x38(%esp)
   23305:	50                   	push   %eax
   23306:	e8 b9 11 00 00       	call   244c4 <put_short_int>
   2330b:	83 c4 10             	add    $0x10,%esp
			return;
   2330e:	e9 37 05 00 00       	jmp    2384a <.L127+0xf4>

00023313 <.L99>:
		case 0xe3:                      // FISTP - 保存短整型数。
			put_short_int(PST(0),info,code);
   23313:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   23318:	83 ec 0c             	sub    $0xc,%esp
   2331b:	6a 00                	push   $0x0
   2331d:	e8 5c 07 00 00       	call   23a7e <__st>
   23322:	83 c4 10             	add    $0x10,%esp
   23325:	83 ec 04             	sub    $0x4,%esp
   23328:	56                   	push   %esi
   23329:	ff 74 24 38          	pushl  0x38(%esp)
   2332d:	50                   	push   %eax
   2332e:	e8 91 11 00 00       	call   244c4 <put_short_int>
   23333:	83 c4 10             	add    $0x10,%esp
			fpop();
   23336:	e8 cd 05 00 00       	call   23908 <fpop>
			return;
   2333b:	e9 0a 05 00 00       	jmp    2384a <.L127+0xf4>

00023340 <.L100>:
		case 0xe4:                      // FBLD - 加载BCD类型数。
			fpush();
   23340:	e8 4e 06 00 00       	call   23993 <fpush>
			get_BCD(&tmp,info,code);
   23345:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   2334a:	83 ec 04             	sub    $0x4,%esp
   2334d:	50                   	push   %eax
   2334e:	ff 74 24 38          	pushl  0x38(%esp)
   23352:	8d 44 24 18          	lea    0x18(%esp),%eax
   23356:	50                   	push   %eax
   23357:	e8 94 0e 00 00       	call   241f0 <get_BCD>
   2335c:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   2335f:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   23363:	83 ec 0c             	sub    $0xc,%esp
   23366:	6a 00                	push   $0x0
   23368:	e8 11 07 00 00       	call   23a7e <__st>
   2336d:	83 c4 10             	add    $0x10,%esp
   23370:	89 c1                	mov    %eax,%ecx
   23372:	8b 03                	mov    (%ebx),%eax
   23374:	8b 53 04             	mov    0x4(%ebx),%edx
   23377:	89 01                	mov    %eax,(%ecx)
   23379:	89 51 04             	mov    %edx,0x4(%ecx)
   2337c:	83 ec 0c             	sub    $0xc,%esp
   2337f:	6a 00                	push   $0x0
   23381:	e8 f8 06 00 00       	call   23a7e <__st>
   23386:	83 c4 10             	add    $0x10,%esp
   23389:	89 c2                	mov    %eax,%edx
   2338b:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   23390:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   23394:	e9 b1 04 00 00       	jmp    2384a <.L127+0xf4>

00023399 <.L101>:
		case 0xe5:                      // FILD - 加载长整型数。
			fpush();
   23399:	e8 f5 05 00 00       	call   23993 <fpush>
			get_longlong_int(&tmp,info,code);
   2339e:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   233a3:	83 ec 04             	sub    $0x4,%esp
   233a6:	50                   	push   %eax
   233a7:	ff 74 24 38          	pushl  0x38(%esp)
   233ab:	8d 44 24 18          	lea    0x18(%esp),%eax
   233af:	50                   	push   %eax
   233b0:	e8 93 0d 00 00       	call   24148 <get_longlong_int>
   233b5:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   233b8:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   233bc:	83 ec 0c             	sub    $0xc,%esp
   233bf:	6a 00                	push   $0x0
   233c1:	e8 b8 06 00 00       	call   23a7e <__st>
   233c6:	83 c4 10             	add    $0x10,%esp
   233c9:	89 c1                	mov    %eax,%ecx
   233cb:	8b 03                	mov    (%ebx),%eax
   233cd:	8b 53 04             	mov    0x4(%ebx),%edx
   233d0:	89 01                	mov    %eax,(%ecx)
   233d2:	89 51 04             	mov    %edx,0x4(%ecx)
   233d5:	83 ec 0c             	sub    $0xc,%esp
   233d8:	6a 00                	push   $0x0
   233da:	e8 9f 06 00 00       	call   23a7e <__st>
   233df:	83 c4 10             	add    $0x10,%esp
   233e2:	89 c2                	mov    %eax,%edx
   233e4:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   233e9:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   233ed:	e9 58 04 00 00       	jmp    2384a <.L127+0xf4>

000233f2 <.L102>:
		case 0xe6:                      // FBSTP - 保存BCD类型数。
			put_BCD(PST(0),info,code);
   233f2:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   233f7:	83 ec 0c             	sub    $0xc,%esp
   233fa:	6a 00                	push   $0x0
   233fc:	e8 7d 06 00 00       	call   23a7e <__st>
   23401:	83 c4 10             	add    $0x10,%esp
   23404:	83 ec 04             	sub    $0x4,%esp
   23407:	56                   	push   %esi
   23408:	ff 74 24 38          	pushl  0x38(%esp)
   2340c:	50                   	push   %eax
   2340d:	e8 67 12 00 00       	call   24679 <put_BCD>
   23412:	83 c4 10             	add    $0x10,%esp
			fpop();
   23415:	e8 ee 04 00 00       	call   23908 <fpop>
			return;
   2341a:	e9 2b 04 00 00       	jmp    2384a <.L127+0xf4>

0002341f <.L103>:
		case 0xe7:                      // BISTP - 保存长整型数。
			put_longlong_int(PST(0),info,code);
   2341f:	0f b7 74 24 1e       	movzwl 0x1e(%esp),%esi
   23424:	83 ec 0c             	sub    $0xc,%esp
   23427:	6a 00                	push   $0x0
   23429:	e8 50 06 00 00       	call   23a7e <__st>
   2342e:	83 c4 10             	add    $0x10,%esp
   23431:	83 ec 04             	sub    $0x4,%esp
   23434:	56                   	push   %esi
   23435:	ff 74 24 38          	pushl  0x38(%esp)
   23439:	50                   	push   %eax
   2343a:	e8 8e 11 00 00       	call   245cd <put_longlong_int>
   2343f:	83 c4 10             	add    $0x10,%esp
			fpop();
   23442:	e8 c1 04 00 00       	call   23908 <fpop>
			return;
   23447:	e9 fe 03 00 00       	jmp    2384a <.L127+0xf4>

0002344c <.L81>:
	}
// 下面处理第2类浮点指令。首先根据指令代码的位10--9的MF值取指定类型的数，然后根据OPA和OPB的组合值进行分别处理。即处理11011，
// MF，000,XXX，R/M形式的指令代码。
	switch (code >> 9) {
   2344c:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   23451:	66 c1 e8 09          	shr    $0x9,%ax
   23455:	0f b7 c0             	movzwl %ax,%eax
   23458:	83 f8 01             	cmp    $0x1,%eax
   2345b:	74 33                	je     23490 <.L81+0x44>
   2345d:	83 f8 01             	cmp    $0x1,%eax
   23460:	7f 06                	jg     23468 <.L81+0x1c>
   23462:	85 c0                	test   %eax,%eax
   23464:	74 0e                	je     23474 <.L81+0x28>
   23466:	eb 7a                	jmp    234e2 <.L81+0x96>
   23468:	83 f8 02             	cmp    $0x2,%eax
   2346b:	74 3f                	je     234ac <.L81+0x60>
   2346d:	83 f8 04             	cmp    $0x4,%eax
   23470:	74 56                	je     234c8 <.L81+0x7c>
   23472:	eb 6e                	jmp    234e2 <.L81+0x96>
		case 0:                 // MF = 00，短实数（32位整数）。
			get_short_real(&tmp,info,code);
   23474:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   23479:	83 ec 04             	sub    $0x4,%esp
   2347c:	50                   	push   %eax
   2347d:	ff 74 24 38          	pushl  0x38(%esp)
   23481:	8d 44 24 18          	lea    0x18(%esp),%eax
   23485:	50                   	push   %eax
   23486:	e8 4f 0a 00 00       	call   23eda <get_short_real>
   2348b:	83 c4 10             	add    $0x10,%esp
			break;
   2348e:	eb 52                	jmp    234e2 <.L81+0x96>
		case 1:                 // MF = 01，短整数（32位整数）。
			get_long_int(&tmp,info,code);
   23490:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   23495:	83 ec 04             	sub    $0x4,%esp
   23498:	50                   	push   %eax
   23499:	ff 74 24 38          	pushl  0x38(%esp)
   2349d:	8d 44 24 18          	lea    0x18(%esp),%eax
   234a1:	50                   	push   %eax
   234a2:	e8 18 0c 00 00       	call   240bf <get_long_int>
   234a7:	83 c4 10             	add    $0x10,%esp
			break;
   234aa:	eb 36                	jmp    234e2 <.L81+0x96>
		case 2:                 // MF = 10，长实数（64位实数）。
			get_long_real(&tmp,info,code);
   234ac:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   234b1:	83 ec 04             	sub    $0x4,%esp
   234b4:	50                   	push   %eax
   234b5:	ff 74 24 38          	pushl  0x38(%esp)
   234b9:	8d 44 24 18          	lea    0x18(%esp),%eax
   234bd:	50                   	push   %eax
   234be:	e8 75 0a 00 00       	call   23f38 <get_long_real>
   234c3:	83 c4 10             	add    $0x10,%esp
			break;
   234c6:	eb 1a                	jmp    234e2 <.L81+0x96>
		case 4:                 // MF = 11，长整数（64位整数）！应该是case 3。
			get_short_int(&tmp,info,code);
   234c8:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   234cd:	83 ec 04             	sub    $0x4,%esp
   234d0:	50                   	push   %eax
   234d1:	ff 74 24 38          	pushl  0x38(%esp)
   234d5:	8d 44 24 18          	lea    0x18(%esp),%eax
   234d9:	50                   	push   %eax
   234da:	e8 56 0b 00 00       	call   24035 <get_short_int>
   234df:	83 c4 10             	add    $0x10,%esp
	}
	switch ((code>>3) & 0x27) {
   234e2:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   234e7:	66 c1 e8 03          	shr    $0x3,%ax
   234eb:	0f b7 c0             	movzwl %ax,%eax
   234ee:	83 e0 27             	and    $0x27,%eax
   234f1:	83 f8 07             	cmp    $0x7,%eax
   234f4:	0f 87 bb 02 00 00    	ja     237b5 <.L127+0x5f>
   234fa:	c1 e0 02             	shl    $0x2,%eax
   234fd:	8b 84 18 1c 6f ff ff 	mov    -0x90e4(%eax,%ebx,1),%eax
   23504:	01 d8                	add    %ebx,%eax
   23506:	ff e0                	jmp    *%eax

00023508 <.L119>:
		case 0:                 // FADD。
			fadd(&tmp,PST(0),&tmp);
   23508:	83 ec 0c             	sub    $0xc,%esp
   2350b:	6a 00                	push   $0x0
   2350d:	e8 6c 05 00 00       	call   23a7e <__st>
   23512:	83 c4 10             	add    $0x10,%esp
   23515:	89 c2                	mov    %eax,%edx
   23517:	83 ec 04             	sub    $0x4,%esp
   2351a:	8d 44 24 10          	lea    0x10(%esp),%eax
   2351e:	50                   	push   %eax
   2351f:	52                   	push   %edx
   23520:	8d 44 24 18          	lea    0x18(%esp),%eax
   23524:	50                   	push   %eax
   23525:	e8 c3 13 00 00       	call   248ed <fadd>
   2352a:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   2352d:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   23531:	83 ec 0c             	sub    $0xc,%esp
   23534:	6a 00                	push   $0x0
   23536:	e8 43 05 00 00       	call   23a7e <__st>
   2353b:	83 c4 10             	add    $0x10,%esp
   2353e:	89 c1                	mov    %eax,%ecx
   23540:	8b 03                	mov    (%ebx),%eax
   23542:	8b 53 04             	mov    0x4(%ebx),%edx
   23545:	89 01                	mov    %eax,(%ecx)
   23547:	89 51 04             	mov    %edx,0x4(%ecx)
   2354a:	83 ec 0c             	sub    $0xc,%esp
   2354d:	6a 00                	push   $0x0
   2354f:	e8 2a 05 00 00       	call   23a7e <__st>
   23554:	83 c4 10             	add    $0x10,%esp
   23557:	89 c2                	mov    %eax,%edx
   23559:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   2355e:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   23562:	e9 e3 02 00 00       	jmp    2384a <.L127+0xf4>

00023567 <.L121>:
		case 1:                 // FMUL。
			fmul(&tmp,PST(0),&tmp);
   23567:	83 ec 0c             	sub    $0xc,%esp
   2356a:	6a 00                	push   $0x0
   2356c:	e8 0d 05 00 00       	call   23a7e <__st>
   23571:	83 c4 10             	add    $0x10,%esp
   23574:	89 c2                	mov    %eax,%edx
   23576:	83 ec 04             	sub    $0x4,%esp
   23579:	8d 44 24 10          	lea    0x10(%esp),%eax
   2357d:	50                   	push   %eax
   2357e:	52                   	push   %edx
   2357f:	8d 44 24 18          	lea    0x18(%esp),%eax
   23583:	50                   	push   %eax
   23584:	e8 4c 15 00 00       	call   24ad5 <fmul>
   23589:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   2358c:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   23590:	83 ec 0c             	sub    $0xc,%esp
   23593:	6a 00                	push   $0x0
   23595:	e8 e4 04 00 00       	call   23a7e <__st>
   2359a:	83 c4 10             	add    $0x10,%esp
   2359d:	89 c1                	mov    %eax,%ecx
   2359f:	8b 03                	mov    (%ebx),%eax
   235a1:	8b 53 04             	mov    0x4(%ebx),%edx
   235a4:	89 01                	mov    %eax,(%ecx)
   235a6:	89 51 04             	mov    %edx,0x4(%ecx)
   235a9:	83 ec 0c             	sub    $0xc,%esp
   235ac:	6a 00                	push   $0x0
   235ae:	e8 cb 04 00 00       	call   23a7e <__st>
   235b3:	83 c4 10             	add    $0x10,%esp
   235b6:	89 c2                	mov    %eax,%edx
   235b8:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   235bd:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   235c1:	e9 84 02 00 00       	jmp    2384a <.L127+0xf4>

000235c6 <.L122>:
		case 2:                 // FCOM。
			fcom(&tmp,PST(0));
   235c6:	83 ec 0c             	sub    $0xc,%esp
   235c9:	6a 00                	push   $0x0
   235cb:	e8 ae 04 00 00       	call   23a7e <__st>
   235d0:	83 c4 10             	add    $0x10,%esp
   235d3:	83 ec 08             	sub    $0x8,%esp
   235d6:	50                   	push   %eax
   235d7:	8d 44 24 18          	lea    0x18(%esp),%eax
   235db:	50                   	push   %eax
   235dc:	e8 98 1b 00 00       	call   25179 <fcom>
   235e1:	83 c4 10             	add    $0x10,%esp
			return;
   235e4:	e9 61 02 00 00       	jmp    2384a <.L127+0xf4>

000235e9 <.L123>:
		case 3:                 // FCOMP。
			fcom(&tmp,PST(0));
   235e9:	83 ec 0c             	sub    $0xc,%esp
   235ec:	6a 00                	push   $0x0
   235ee:	e8 8b 04 00 00       	call   23a7e <__st>
   235f3:	83 c4 10             	add    $0x10,%esp
   235f6:	83 ec 08             	sub    $0x8,%esp
   235f9:	50                   	push   %eax
   235fa:	8d 44 24 18          	lea    0x18(%esp),%eax
   235fe:	50                   	push   %eax
   235ff:	e8 75 1b 00 00       	call   25179 <fcom>
   23604:	83 c4 10             	add    $0x10,%esp
			fpop();
   23607:	e8 fc 02 00 00       	call   23908 <fpop>
			return;
   2360c:	e9 39 02 00 00       	jmp    2384a <.L127+0xf4>

00023611 <.L124>:
		case 4:                 // FSUB。
			tmp.exponent ^= 0x8000;
   23611:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   23616:	66 35 00 80          	xor    $0x8000,%ax
   2361a:	66 89 44 24 14       	mov    %ax,0x14(%esp)
			fadd(&tmp,PST(0),&tmp);
   2361f:	83 ec 0c             	sub    $0xc,%esp
   23622:	6a 00                	push   $0x0
   23624:	e8 55 04 00 00       	call   23a7e <__st>
   23629:	83 c4 10             	add    $0x10,%esp
   2362c:	89 c2                	mov    %eax,%edx
   2362e:	83 ec 04             	sub    $0x4,%esp
   23631:	8d 44 24 10          	lea    0x10(%esp),%eax
   23635:	50                   	push   %eax
   23636:	52                   	push   %edx
   23637:	8d 44 24 18          	lea    0x18(%esp),%eax
   2363b:	50                   	push   %eax
   2363c:	e8 ac 12 00 00       	call   248ed <fadd>
   23641:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   23644:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   23648:	83 ec 0c             	sub    $0xc,%esp
   2364b:	6a 00                	push   $0x0
   2364d:	e8 2c 04 00 00       	call   23a7e <__st>
   23652:	83 c4 10             	add    $0x10,%esp
   23655:	89 c1                	mov    %eax,%ecx
   23657:	8b 03                	mov    (%ebx),%eax
   23659:	8b 53 04             	mov    0x4(%ebx),%edx
   2365c:	89 01                	mov    %eax,(%ecx)
   2365e:	89 51 04             	mov    %edx,0x4(%ecx)
   23661:	83 ec 0c             	sub    $0xc,%esp
   23664:	6a 00                	push   $0x0
   23666:	e8 13 04 00 00       	call   23a7e <__st>
   2366b:	83 c4 10             	add    $0x10,%esp
   2366e:	89 c2                	mov    %eax,%edx
   23670:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   23675:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   23679:	e9 cc 01 00 00       	jmp    2384a <.L127+0xf4>

0002367e <.L125>:
		case 5:                 // FSUBR。
			ST(0).exponent ^= 0x8000;
   2367e:	83 ec 0c             	sub    $0xc,%esp
   23681:	6a 00                	push   $0x0
   23683:	e8 f6 03 00 00       	call   23a7e <__st>
   23688:	83 c4 10             	add    $0x10,%esp
   2368b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   2368f:	66 81 f2 00 80       	xor    $0x8000,%dx
   23694:	66 89 50 08          	mov    %dx,0x8(%eax)
			fadd(&tmp,PST(0),&tmp);
   23698:	83 ec 0c             	sub    $0xc,%esp
   2369b:	6a 00                	push   $0x0
   2369d:	e8 dc 03 00 00       	call   23a7e <__st>
   236a2:	83 c4 10             	add    $0x10,%esp
   236a5:	89 c2                	mov    %eax,%edx
   236a7:	83 ec 04             	sub    $0x4,%esp
   236aa:	8d 44 24 10          	lea    0x10(%esp),%eax
   236ae:	50                   	push   %eax
   236af:	52                   	push   %edx
   236b0:	8d 44 24 18          	lea    0x18(%esp),%eax
   236b4:	50                   	push   %eax
   236b5:	e8 33 12 00 00       	call   248ed <fadd>
   236ba:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   236bd:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   236c1:	83 ec 0c             	sub    $0xc,%esp
   236c4:	6a 00                	push   $0x0
   236c6:	e8 b3 03 00 00       	call   23a7e <__st>
   236cb:	83 c4 10             	add    $0x10,%esp
   236ce:	89 c1                	mov    %eax,%ecx
   236d0:	8b 03                	mov    (%ebx),%eax
   236d2:	8b 53 04             	mov    0x4(%ebx),%edx
   236d5:	89 01                	mov    %eax,(%ecx)
   236d7:	89 51 04             	mov    %edx,0x4(%ecx)
   236da:	83 ec 0c             	sub    $0xc,%esp
   236dd:	6a 00                	push   $0x0
   236df:	e8 9a 03 00 00       	call   23a7e <__st>
   236e4:	83 c4 10             	add    $0x10,%esp
   236e7:	89 c2                	mov    %eax,%edx
   236e9:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   236ee:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   236f2:	e9 53 01 00 00       	jmp    2384a <.L127+0xf4>

000236f7 <.L126>:
		case 6:                 // FDIV。
			fdiv(PST(0),&tmp,&tmp);
   236f7:	83 ec 0c             	sub    $0xc,%esp
   236fa:	6a 00                	push   $0x0
   236fc:	e8 7d 03 00 00       	call   23a7e <__st>
   23701:	83 c4 10             	add    $0x10,%esp
   23704:	89 c2                	mov    %eax,%edx
   23706:	83 ec 04             	sub    $0x4,%esp
   23709:	8d 44 24 10          	lea    0x10(%esp),%eax
   2370d:	50                   	push   %eax
   2370e:	8d 44 24 14          	lea    0x14(%esp),%eax
   23712:	50                   	push   %eax
   23713:	52                   	push   %edx
   23714:	e8 8b 16 00 00       	call   24da4 <fdiv>
   23719:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   2371c:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   23720:	83 ec 0c             	sub    $0xc,%esp
   23723:	6a 00                	push   $0x0
   23725:	e8 54 03 00 00       	call   23a7e <__st>
   2372a:	83 c4 10             	add    $0x10,%esp
   2372d:	89 c1                	mov    %eax,%ecx
   2372f:	8b 03                	mov    (%ebx),%eax
   23731:	8b 53 04             	mov    0x4(%ebx),%edx
   23734:	89 01                	mov    %eax,(%ecx)
   23736:	89 51 04             	mov    %edx,0x4(%ecx)
   23739:	83 ec 0c             	sub    $0xc,%esp
   2373c:	6a 00                	push   $0x0
   2373e:	e8 3b 03 00 00       	call   23a7e <__st>
   23743:	83 c4 10             	add    $0x10,%esp
   23746:	89 c2                	mov    %eax,%edx
   23748:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   2374d:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   23751:	e9 f4 00 00 00       	jmp    2384a <.L127+0xf4>

00023756 <.L127>:
		case 7:                 // FDIVR。
			fdiv(&tmp,PST(0),&tmp);
   23756:	83 ec 0c             	sub    $0xc,%esp
   23759:	6a 00                	push   $0x0
   2375b:	e8 1e 03 00 00       	call   23a7e <__st>
   23760:	83 c4 10             	add    $0x10,%esp
   23763:	89 c2                	mov    %eax,%edx
   23765:	83 ec 04             	sub    $0x4,%esp
   23768:	8d 44 24 10          	lea    0x10(%esp),%eax
   2376c:	50                   	push   %eax
   2376d:	52                   	push   %edx
   2376e:	8d 44 24 18          	lea    0x18(%esp),%eax
   23772:	50                   	push   %eax
   23773:	e8 2c 16 00 00       	call   24da4 <fdiv>
   23778:	83 c4 10             	add    $0x10,%esp
			real_to_real(&tmp,&ST(0));
   2377b:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   2377f:	83 ec 0c             	sub    $0xc,%esp
   23782:	6a 00                	push   $0x0
   23784:	e8 f5 02 00 00       	call   23a7e <__st>
   23789:	83 c4 10             	add    $0x10,%esp
   2378c:	89 c1                	mov    %eax,%ecx
   2378e:	8b 03                	mov    (%ebx),%eax
   23790:	8b 53 04             	mov    0x4(%ebx),%edx
   23793:	89 01                	mov    %eax,(%ecx)
   23795:	89 51 04             	mov    %edx,0x4(%ecx)
   23798:	83 ec 0c             	sub    $0xc,%esp
   2379b:	6a 00                	push   $0x0
   2379d:	e8 dc 02 00 00       	call   23a7e <__st>
   237a2:	83 c4 10             	add    $0x10,%esp
   237a5:	89 c2                	mov    %eax,%edx
   237a7:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   237ac:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   237b0:	e9 95 00 00 00       	jmp    2384a <.L127+0xf4>
	}
// 处理形如11011,XX,1,XX，000,R/M的指令代码。
	if ((code & 0x138) == 0x100) {
   237b5:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
   237ba:	25 38 01 00 00       	and    $0x138,%eax
   237bf:	3d 00 01 00 00       	cmp    $0x100,%eax
   237c4:	75 3c                	jne    23802 <.L127+0xac>
			fpush();
   237c6:	e8 c8 01 00 00       	call   23993 <fpush>
			real_to_real(&tmp,&ST(0));
   237cb:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
   237cf:	83 ec 0c             	sub    $0xc,%esp
   237d2:	6a 00                	push   $0x0
   237d4:	e8 a5 02 00 00       	call   23a7e <__st>
   237d9:	83 c4 10             	add    $0x10,%esp
   237dc:	89 c1                	mov    %eax,%ecx
   237de:	8b 03                	mov    (%ebx),%eax
   237e0:	8b 53 04             	mov    0x4(%ebx),%edx
   237e3:	89 01                	mov    %eax,(%ecx)
   237e5:	89 51 04             	mov    %edx,0x4(%ecx)
   237e8:	83 ec 0c             	sub    $0xc,%esp
   237eb:	6a 00                	push   $0x0
   237ed:	e8 8c 02 00 00       	call   23a7e <__st>
   237f2:	83 c4 10             	add    $0x10,%esp
   237f5:	89 c2                	mov    %eax,%edx
   237f7:	0f b7 44 24 14       	movzwl 0x14(%esp),%eax
   237fc:	66 89 42 08          	mov    %ax,0x8(%edx)
			return;
   23800:	eb 48                	jmp    2384a <.L127+0xf4>
	}
// 其余均为无效指令。
	printk("Unknown math-insns: %04x:%08x %04x\n\r",CS,EIP,code);
   23802:	0f b7 4c 24 1e       	movzwl 0x1e(%esp),%ecx
   23807:	8b 44 24 30          	mov    0x30(%esp),%eax
   2380b:	8b 50 38             	mov    0x38(%eax),%edx
   2380e:	8b 44 24 30          	mov    0x30(%esp),%eax
   23812:	83 c0 3c             	add    $0x3c,%eax
   23815:	0f b7 00             	movzwl (%eax),%eax
   23818:	0f b7 c0             	movzwl %ax,%eax
   2381b:	51                   	push   %ecx
   2381c:	52                   	push   %edx
   2381d:	50                   	push   %eax
   2381e:	8d 83 4c 68 ff ff    	lea    -0x97b4(%ebx),%eax
   23824:	50                   	push   %eax
   23825:	e8 08 5b fe ff       	call   9332 <printk>
   2382a:	83 c4 10             	add    $0x10,%esp
	math_abort(info,1<<(SIGFPE-1));
   2382d:	83 ec 08             	sub    $0x8,%esp
   23830:	68 80 00 00 00       	push   $0x80
   23835:	ff 74 24 3c          	pushl  0x3c(%esp)
   23839:	e8 8f 00 00 00       	call   238cd <__math_abort>
   2383e:	83 c4 10             	add    $0x10,%esp
   23841:	eb 07                	jmp    2384a <.L127+0xf4>
			return;
   23843:	90                   	nop
   23844:	eb 04                	jmp    2384a <.L127+0xf4>
			return;
   23846:	90                   	nop
   23847:	eb 01                	jmp    2384a <.L127+0xf4>
			return;
   23849:	90                   	nop
}
   2384a:	83 c4 24             	add    $0x24,%esp
   2384d:	5b                   	pop    %ebx
   2384e:	5e                   	pop    %esi
   2384f:	c3                   	ret    

00023850 <math_emulate>:
// CPU异常中断int 7调用的80387仿真接口函数。
// 若当前进程没有使用过协处理器，就设置使用协处理器标志used_math，然后初始化80387的控制字、状态字和特征字。最后使用中断
// int 7调用本函数的返回地址指针作为参数调用浮点指令仿真主函数do_emu()。
// 参数____false是_orig_eip。
void math_emulate(long ___false)
{
   23850:	83 ec 0c             	sub    $0xc,%esp
   23853:	e8 9a 34 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23858:	05 a8 e7 00 00       	add    $0xe7a8,%eax
	if (!current->used_math) {
   2385d:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23863:	8b 12                	mov    (%edx),%edx
   23865:	0f b7 92 28 03 00 00 	movzwl 0x328(%edx),%edx
   2386c:	66 85 d2             	test   %dx,%dx
   2386f:	75 47                	jne    238b8 <math_emulate+0x68>
		current->used_math = 1;
   23871:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23877:	8b 12                	mov    (%edx),%edx
   23879:	66 c7 82 28 03 00 00 	movw   $0x1,0x328(%edx)
   23880:	01 00 
		I387.cwd = 0x037f;
   23882:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23888:	8b 12                	mov    (%edx),%edx
   2388a:	c7 82 18 04 00 00 7f 	movl   $0x37f,0x418(%edx)
   23891:	03 00 00 
		I387.swd = 0x0000;
   23894:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   2389a:	8b 12                	mov    (%edx),%edx
   2389c:	c7 82 1c 04 00 00 00 	movl   $0x0,0x41c(%edx)
   238a3:	00 00 00 
		I387.twd = 0x0000;
   238a6:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   238ac:	8b 00                	mov    (%eax),%eax
   238ae:	c7 80 20 04 00 00 00 	movl   $0x0,0x420(%eax)
   238b5:	00 00 00 
	}
/* &___false points to info->___orig_eip, so subtract 1 to get info */
	do_emu((struct info *) ((&___false) - 1));
   238b8:	8d 44 24 0c          	lea    0xc(%esp),%eax
   238bc:	83 ec 0c             	sub    $0xc,%esp
   238bf:	50                   	push   %eax
   238c0:	e8 b1 e1 ff ff       	call   21a76 <do_emu>
   238c5:	83 c4 10             	add    $0x10,%esp
}
   238c8:	90                   	nop
   238c9:	83 c4 0c             	add    $0xc,%esp
   238cc:	c3                   	ret    

000238cd <__math_abort>:

// 终止仿真操作。
// 当处理到无效指令代码或者未实现的指令代码时，该函数首先恢复程序的原EIP，并发送指定信号给当前进程。最后将栈指针指向中断
// int 7处理过程调用本函数的返回地址，直接返回到中断处理过程中。
void __math_abort(struct info * info, unsigned int signal)
{
   238cd:	e8 20 34 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   238d2:	05 2e e7 00 00       	add    $0xe72e,%eax
	EIP = ORIG_EIP;
   238d7:	8b 54 24 04          	mov    0x4(%esp),%edx
   238db:	8b 4a 04             	mov    0x4(%edx),%ecx
   238de:	8b 54 24 04          	mov    0x4(%esp),%edx
   238e2:	89 4a 38             	mov    %ecx,0x38(%edx)
	current->signal |= signal;
   238e5:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   238eb:	8b 12                	mov    (%edx),%edx
   238ed:	8b 52 0c             	mov    0xc(%edx),%edx
   238f0:	0b 54 24 08          	or     0x8(%esp),%edx
   238f4:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   238fa:	8b 00                	mov    (%eax),%eax
   238fc:	89 50 0c             	mov    %edx,0xc(%eax)
	__asm__("movl %0,%%esp ; ret"::"g" ((long) info));
   238ff:	8b 44 24 04          	mov    0x4(%esp),%eax
   23903:	89 c4                	mov    %eax,%esp
   23905:	c3                   	ret    
}
   23906:	90                   	nop
   23907:	c3                   	ret    

00023908 <fpop>:

// 累加器栈弹出操作。
// 将状态字TOP字段值加1，并以7取模。
static void fpop(void)
{
   23908:	83 ec 10             	sub    $0x10,%esp
   2390b:	e8 e2 33 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23910:	05 f0 e6 00 00       	add    $0xe6f0,%eax
	unsigned long tmp;

	tmp = I387.swd & 0xffffc7ff;
   23915:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   2391b:	8b 12                	mov    (%edx),%edx
   2391d:	8b 92 1c 04 00 00    	mov    0x41c(%edx),%edx
   23923:	80 e6 c7             	and    $0xc7,%dh
   23926:	89 54 24 0c          	mov    %edx,0xc(%esp)
	I387.swd += 0x00000800;
   2392a:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23930:	8b 12                	mov    (%edx),%edx
   23932:	8b 8a 1c 04 00 00    	mov    0x41c(%edx),%ecx
   23938:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   2393e:	8b 12                	mov    (%edx),%edx
   23940:	81 c1 00 08 00 00    	add    $0x800,%ecx
   23946:	89 8a 1c 04 00 00    	mov    %ecx,0x41c(%edx)
	I387.swd &= 0x00003800;
   2394c:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23952:	8b 12                	mov    (%edx),%edx
   23954:	8b 8a 1c 04 00 00    	mov    0x41c(%edx),%ecx
   2395a:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23960:	8b 12                	mov    (%edx),%edx
   23962:	81 e1 00 38 00 00    	and    $0x3800,%ecx
   23968:	89 8a 1c 04 00 00    	mov    %ecx,0x41c(%edx)
	I387.swd |= tmp;
   2396e:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23974:	8b 12                	mov    (%edx),%edx
   23976:	8b 92 1c 04 00 00    	mov    0x41c(%edx),%edx
   2397c:	0b 54 24 0c          	or     0xc(%esp),%edx
   23980:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23986:	8b 00                	mov    (%eax),%eax
   23988:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
}
   2398e:	90                   	nop
   2398f:	83 c4 10             	add    $0x10,%esp
   23992:	c3                   	ret    

00023993 <fpush>:

// 累加器栈入栈操作。
// 将状态字TOP字段减1（即加7），并以7取模。
static void fpush(void)
{
   23993:	83 ec 10             	sub    $0x10,%esp
   23996:	e8 57 33 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   2399b:	05 65 e6 00 00       	add    $0xe665,%eax
	unsigned long tmp;

	tmp = I387.swd & 0xffffc7ff;
   239a0:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   239a6:	8b 12                	mov    (%edx),%edx
   239a8:	8b 92 1c 04 00 00    	mov    0x41c(%edx),%edx
   239ae:	80 e6 c7             	and    $0xc7,%dh
   239b1:	89 54 24 0c          	mov    %edx,0xc(%esp)
	I387.swd += 0x00003800;
   239b5:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   239bb:	8b 12                	mov    (%edx),%edx
   239bd:	8b 8a 1c 04 00 00    	mov    0x41c(%edx),%ecx
   239c3:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   239c9:	8b 12                	mov    (%edx),%edx
   239cb:	81 c1 00 38 00 00    	add    $0x3800,%ecx
   239d1:	89 8a 1c 04 00 00    	mov    %ecx,0x41c(%edx)
	I387.swd &= 0x00003800;
   239d7:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   239dd:	8b 12                	mov    (%edx),%edx
   239df:	8b 8a 1c 04 00 00    	mov    0x41c(%edx),%ecx
   239e5:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   239eb:	8b 12                	mov    (%edx),%edx
   239ed:	81 e1 00 38 00 00    	and    $0x3800,%ecx
   239f3:	89 8a 1c 04 00 00    	mov    %ecx,0x41c(%edx)
	I387.swd |= tmp;
   239f9:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   239ff:	8b 12                	mov    (%edx),%edx
   23a01:	8b 92 1c 04 00 00    	mov    0x41c(%edx),%edx
   23a07:	0b 54 24 0c          	or     0xc(%esp),%edx
   23a0b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23a11:	8b 00                	mov    (%eax),%eax
   23a13:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
}
   23a19:	90                   	nop
   23a1a:	83 c4 10             	add    $0x10,%esp
   23a1d:	c3                   	ret    

00023a1e <fxchg>:

// 交换两个累加器的值。
static void fxchg(temp_real_unaligned * a, temp_real_unaligned * b)
{
   23a1e:	83 ec 10             	sub    $0x10,%esp
   23a21:	e8 cc 32 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23a26:	05 da e5 00 00       	add    $0xe5da,%eax
	temp_real_unaligned c;

	c = *a;
   23a2b:	8b 44 24 14          	mov    0x14(%esp),%eax
   23a2f:	8b 10                	mov    (%eax),%edx
   23a31:	89 54 24 06          	mov    %edx,0x6(%esp)
   23a35:	8b 50 04             	mov    0x4(%eax),%edx
   23a38:	89 54 24 0a          	mov    %edx,0xa(%esp)
   23a3c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   23a40:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	*a = *b;
   23a45:	8b 44 24 14          	mov    0x14(%esp),%eax
   23a49:	8b 54 24 18          	mov    0x18(%esp),%edx
   23a4d:	8b 0a                	mov    (%edx),%ecx
   23a4f:	89 08                	mov    %ecx,(%eax)
   23a51:	8b 4a 04             	mov    0x4(%edx),%ecx
   23a54:	89 48 04             	mov    %ecx,0x4(%eax)
   23a57:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   23a5b:	66 89 50 08          	mov    %dx,0x8(%eax)
	*b = c;
   23a5f:	8b 44 24 18          	mov    0x18(%esp),%eax
   23a63:	8b 54 24 06          	mov    0x6(%esp),%edx
   23a67:	89 10                	mov    %edx,(%eax)
   23a69:	8b 54 24 0a          	mov    0xa(%esp),%edx
   23a6d:	89 50 04             	mov    %edx,0x4(%eax)
   23a70:	0f b7 54 24 0e       	movzwl 0xe(%esp),%edx
   23a75:	66 89 50 08          	mov    %dx,0x8(%eax)
}
   23a79:	90                   	nop
   23a7a:	83 c4 10             	add    $0x10,%esp
   23a7d:	c3                   	ret    

00023a7e <__st>:

// 取ST(i)的内存指针。
// 取状态字中TOP字段值。加上指定的物理数据寄存器号并取模，最后返回ST(i)对应的指针。
static temp_real_unaligned * __st(int i)
{
   23a7e:	e8 6f 32 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23a83:	05 7d e5 00 00       	add    $0xe57d,%eax
	i += I387.swd >> 11;            // 取状态字中TOP字段值。
   23a88:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   23a8e:	8b 12                	mov    (%edx),%edx
   23a90:	8b 92 1c 04 00 00    	mov    0x41c(%edx),%edx
   23a96:	c1 fa 0b             	sar    $0xb,%edx
   23a99:	01 54 24 04          	add    %edx,0x4(%esp)
	i &= 7;
   23a9d:	83 64 24 04 07       	andl   $0x7,0x4(%esp)
	return (temp_real_unaligned *) (i*10 + (char *)(I387.st_space));
   23aa2:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23aa8:	8b 00                	mov    (%eax),%eax
   23aaa:	8d 88 34 04 00 00    	lea    0x434(%eax),%ecx
   23ab0:	8b 54 24 04          	mov    0x4(%esp),%edx
   23ab4:	89 d0                	mov    %edx,%eax
   23ab6:	c1 e0 02             	shl    $0x2,%eax
   23ab9:	01 d0                	add    %edx,%eax
   23abb:	01 c0                	add    %eax,%eax
   23abd:	01 c8                	add    %ecx,%eax
   23abf:	c3                   	ret    

00023ac0 <math_error>:

// 协处理器错误中断int 16调用的处理函数。
// 当协处理器检测到自己发生错误时，就会通过ERROR引脚通知CPU。下面代码用于处理协处理器发出的出错信号。并跳转去执行math_error()
// 返回后将跳转到标号ret_from_sys_call处继续执行。
void math_error(void)
{
   23ac0:	e8 2d 32 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23ac5:	05 3b e5 00 00       	add    $0xe53b,%eax
	__asm__("fnclex");              // 让80387清除状态字中所有异常标志位和忙位。
   23aca:	db e2                	fnclex 
	if (last_task_used_math)        // 若使用了协处理器，则设置协处理器出错信号。
   23acc:	c7 c2 8c 3b 03 00    	mov    $0x33b8c,%edx
   23ad2:	8b 12                	mov    (%edx),%edx
   23ad4:	85 d2                	test   %edx,%edx
   23ad6:	74 19                	je     23af1 <math_error+0x31>
		last_task_used_math->signal |= 1<<(SIGFPE-1);
   23ad8:	c7 c2 8c 3b 03 00    	mov    $0x33b8c,%edx
   23ade:	8b 12                	mov    (%edx),%edx
   23ae0:	8b 52 0c             	mov    0xc(%edx),%edx
   23ae3:	c7 c0 8c 3b 03 00    	mov    $0x33b8c,%eax
   23ae9:	8b 00                	mov    (%eax),%eax
   23aeb:	80 ca 80             	or     $0x80,%dl
   23aee:	89 50 0c             	mov    %edx,0xc(%eax)
}
   23af1:	90                   	nop
   23af2:	c3                   	ret    

00023af3 <get_fs_byte>:
{
   23af3:	53                   	push   %ebx
   23af4:	e8 f9 31 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23af9:	05 07 e5 00 00       	add    $0xe507,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   23afe:	8b 44 24 08          	mov    0x8(%esp),%eax
   23b02:	64 8a 00             	mov    %fs:(%eax),%al
   23b05:	89 c3                	mov    %eax,%ebx
	return _v;
   23b07:	89 d8                	mov    %ebx,%eax
}
   23b09:	5b                   	pop    %ebx
   23b0a:	c3                   	ret    

00023b0b <get_fs_long>:
{
   23b0b:	83 ec 10             	sub    $0x10,%esp
   23b0e:	e8 df 31 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23b13:	05 ed e4 00 00       	add    $0xe4ed,%eax
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   23b18:	8b 44 24 14          	mov    0x14(%esp),%eax
   23b1c:	64 8b 00             	mov    %fs:(%eax),%eax
   23b1f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
   23b23:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   23b27:	83 c4 10             	add    $0x10,%esp
   23b2a:	c3                   	ret    

00023b2b <sib>:
// 取info结构中指定位置处寄存器内容。
#define REG(x) (*(long *)(__regoffset[(x)]+(char *) info))

// 求2字节寻址模式中第2操作数指示字节SIB（Scale, Index, Base）的值。
static char * sib(struct info * info, int mod)
{
   23b2b:	53                   	push   %ebx
   23b2c:	83 ec 10             	sub    $0x10,%esp
   23b2f:	e8 c6 31 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   23b34:	81 c3 cc e4 00 00    	add    $0xe4cc,%ebx
	unsigned char ss,index,base;
	long offset = 0;
   23b3a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   23b41:	00 

// 首先从用户代码段中取得SIB字节，然后取出各个字段位值。
	base = get_fs_byte((char *) EIP);
   23b42:	8b 44 24 18          	mov    0x18(%esp),%eax
   23b46:	8b 40 38             	mov    0x38(%eax),%eax
   23b49:	50                   	push   %eax
   23b4a:	e8 a4 ff ff ff       	call   23af3 <get_fs_byte>
   23b4f:	83 c4 04             	add    $0x4,%esp
   23b52:	88 44 24 0b          	mov    %al,0xb(%esp)
	EIP++;
   23b56:	8b 44 24 18          	mov    0x18(%esp),%eax
   23b5a:	8b 40 38             	mov    0x38(%eax),%eax
   23b5d:	8d 50 01             	lea    0x1(%eax),%edx
   23b60:	8b 44 24 18          	mov    0x18(%esp),%eax
   23b64:	89 50 38             	mov    %edx,0x38(%eax)
	ss = base >> 6;                 // 比例因子大小ss。
   23b67:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   23b6c:	c0 e8 06             	shr    $0x6,%al
   23b6f:	88 44 24 0a          	mov    %al,0xa(%esp)
	index = (base >> 3) & 7;        // 索引值索引代号index。
   23b73:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   23b78:	c0 e8 03             	shr    $0x3,%al
   23b7b:	83 e0 07             	and    $0x7,%eax
   23b7e:	88 44 24 09          	mov    %al,0x9(%esp)
	base &= 7;                      // 基地址代号base。
   23b82:	80 64 24 0b 07       	andb   $0x7,0xb(%esp)
// 如果索引代号为0b100，表示无索引偏移值。否则索引偏移值offset=对应寄存器内容×比例因子。
	if (index == 4)
   23b87:	80 7c 24 09 04       	cmpb   $0x4,0x9(%esp)
   23b8c:	75 0a                	jne    23b98 <sib+0x6d>
		offset = 0;
   23b8e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   23b95:	00 
   23b96:	eb 1a                	jmp    23bb2 <sib+0x87>
	else
		offset = REG(index);
   23b98:	0f b6 44 24 09       	movzbl 0x9(%esp),%eax
   23b9d:	8b 84 83 00 16 00 00 	mov    0x1600(%ebx,%eax,4),%eax
   23ba4:	89 c2                	mov    %eax,%edx
   23ba6:	8b 44 24 18          	mov    0x18(%esp),%eax
   23baa:	01 d0                	add    %edx,%eax
   23bac:	8b 00                	mov    (%eax),%eax
   23bae:	89 44 24 0c          	mov    %eax,0xc(%esp)
	offset <<= ss;
   23bb2:	0f b6 44 24 0a       	movzbl 0xa(%esp),%eax
   23bb7:	89 c1                	mov    %eax,%ecx
   23bb9:	d3 64 24 0c          	shll   %cl,0xc(%esp)
// 如果上一MODRM字节中的MOD不为零，或者Base不等于0b101，则表示有偏移值在base指定的寄存器中。因此偏移offset需要再加上base
// 对应寄存器中的内容。
	if (mod || base != 5)
   23bbd:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   23bc2:	75 07                	jne    23bcb <sib+0xa0>
   23bc4:	80 7c 24 0b 05       	cmpb   $0x5,0xb(%esp)
   23bc9:	74 1a                	je     23be5 <sib+0xba>
		offset += REG(base);
   23bcb:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   23bd0:	8b 84 83 00 16 00 00 	mov    0x1600(%ebx,%eax,4),%eax
   23bd7:	89 c2                	mov    %eax,%edx
   23bd9:	8b 44 24 18          	mov    0x18(%esp),%eax
   23bdd:	01 d0                	add    %edx,%eax
   23bdf:	8b 00                	mov    (%eax),%eax
   23be1:	01 44 24 0c          	add    %eax,0xc(%esp)
// 如果MOD=1，则表示偏移值为1字节。否则，若MOD=2，或者base=0b101，则偏移值为4字节。
	if (mod == 1) {
   23be5:	83 7c 24 1c 01       	cmpl   $0x1,0x1c(%esp)
   23bea:	75 2a                	jne    23c16 <sib+0xeb>
		offset += (signed char) get_fs_byte((char *) EIP);
   23bec:	8b 44 24 18          	mov    0x18(%esp),%eax
   23bf0:	8b 40 38             	mov    0x38(%eax),%eax
   23bf3:	50                   	push   %eax
   23bf4:	e8 fa fe ff ff       	call   23af3 <get_fs_byte>
   23bf9:	83 c4 04             	add    $0x4,%esp
   23bfc:	0f be c0             	movsbl %al,%eax
   23bff:	01 44 24 0c          	add    %eax,0xc(%esp)
		EIP++;
   23c03:	8b 44 24 18          	mov    0x18(%esp),%eax
   23c07:	8b 40 38             	mov    0x38(%eax),%eax
   23c0a:	8d 50 01             	lea    0x1(%eax),%edx
   23c0d:	8b 44 24 18          	mov    0x18(%esp),%eax
   23c11:	89 50 38             	mov    %edx,0x38(%eax)
   23c14:	eb 33                	jmp    23c49 <sib+0x11e>
	} else if (mod == 2 || base == 5) {
   23c16:	83 7c 24 1c 02       	cmpl   $0x2,0x1c(%esp)
   23c1b:	74 07                	je     23c24 <sib+0xf9>
   23c1d:	80 7c 24 0b 05       	cmpb   $0x5,0xb(%esp)
   23c22:	75 25                	jne    23c49 <sib+0x11e>
		offset += (signed) get_fs_long((unsigned long *) EIP);
   23c24:	8b 44 24 18          	mov    0x18(%esp),%eax
   23c28:	8b 40 38             	mov    0x38(%eax),%eax
   23c2b:	50                   	push   %eax
   23c2c:	e8 da fe ff ff       	call   23b0b <get_fs_long>
   23c31:	83 c4 04             	add    $0x4,%esp
   23c34:	01 44 24 0c          	add    %eax,0xc(%esp)
		EIP += 4;
   23c38:	8b 44 24 18          	mov    0x18(%esp),%eax
   23c3c:	8b 40 38             	mov    0x38(%eax),%eax
   23c3f:	8d 50 04             	lea    0x4(%eax),%edx
   23c42:	8b 44 24 18          	mov    0x18(%esp),%eax
   23c46:	89 50 38             	mov    %edx,0x38(%eax)
	}
// 最后保存并返回偏移值。
	I387.foo = offset;
   23c49:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23c4f:	8b 00                	mov    (%eax),%eax
   23c51:	8b 54 24 0c          	mov    0xc(%esp),%edx
   23c55:	89 90 2c 04 00 00    	mov    %edx,0x42c(%eax)
	I387.fos = 0x17;
   23c5b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23c61:	8b 00                	mov    (%eax),%eax
   23c63:	c7 80 30 04 00 00 17 	movl   $0x17,0x430(%eax)
   23c6a:	00 00 00 
	return (char *) offset;
   23c6d:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   23c71:	83 c4 10             	add    $0x10,%esp
   23c74:	5b                   	pop    %ebx
   23c75:	c3                   	ret    

00023c76 <ea>:

// 根据指令中寻址模式字节计算有效地址值。
char * ea(struct info * info, unsigned short code)
{
   23c76:	53                   	push   %ebx
   23c77:	83 ec 28             	sub    $0x28,%esp
   23c7a:	e8 7b 30 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   23c7f:	81 c3 81 e3 00 00    	add    $0xe381,%ebx
   23c85:	8b 44 24 34          	mov    0x34(%esp),%eax
   23c89:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	unsigned char mod,rm;
	long * tmp = &EAX;
   23c8e:	8b 44 24 30          	mov    0x30(%esp),%eax
   23c92:	83 c0 18             	add    $0x18,%eax
   23c95:	89 44 24 18          	mov    %eax,0x18(%esp)
	int offset = 0;
   23c99:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   23ca0:	00 

// 首先取代码中的MOD字段和R/M字段值。如果MOD=0b11，表示是单字节指令，没有偏移字段。如果R/M字段=0b100，并且MOD不为0b11，
// 表示是2字节地址模式寻址，因此调用sib()求出偏移值并返回即可。
	mod = (code >> 6) & 3;          // MOD字段。
   23ca1:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   23ca6:	66 c1 e8 06          	shr    $0x6,%ax
   23caa:	83 e0 03             	and    $0x3,%eax
   23cad:	88 44 24 17          	mov    %al,0x17(%esp)
	rm = code & 7;                  // R/M字段。
   23cb1:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   23cb6:	83 e0 07             	and    $0x7,%eax
   23cb9:	88 44 24 16          	mov    %al,0x16(%esp)
	if (rm == 4 && mod != 3)
   23cbd:	80 7c 24 16 04       	cmpb   $0x4,0x16(%esp)
   23cc2:	75 1e                	jne    23ce2 <ea+0x6c>
   23cc4:	80 7c 24 17 03       	cmpb   $0x3,0x17(%esp)
   23cc9:	74 17                	je     23ce2 <ea+0x6c>
		return sib(info,mod);
   23ccb:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
   23cd0:	50                   	push   %eax
   23cd1:	ff 74 24 34          	pushl  0x34(%esp)
   23cd5:	e8 51 fe ff ff       	call   23b2b <sib>
   23cda:	83 c4 08             	add    $0x8,%esp
   23cdd:	e9 37 01 00 00       	jmp    23e19 <ea+0x1a3>
// 如果R/M字段为0b101，并且MOD为0，表示是单字节地址模式编码且后随32字节偏移值。于是取出用户代码中4字节偏移值，保存并返回
// 之。
	if (rm == 5 && !mod) {
   23ce2:	80 7c 24 16 05       	cmpb   $0x5,0x16(%esp)
   23ce7:	75 59                	jne    23d42 <ea+0xcc>
   23ce9:	80 7c 24 17 00       	cmpb   $0x0,0x17(%esp)
   23cee:	75 52                	jne    23d42 <ea+0xcc>
		offset = get_fs_long((unsigned long *) EIP);
   23cf0:	8b 44 24 30          	mov    0x30(%esp),%eax
   23cf4:	8b 40 38             	mov    0x38(%eax),%eax
   23cf7:	50                   	push   %eax
   23cf8:	e8 0e fe ff ff       	call   23b0b <get_fs_long>
   23cfd:	83 c4 04             	add    $0x4,%esp
   23d00:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		EIP += 4;
   23d04:	8b 44 24 30          	mov    0x30(%esp),%eax
   23d08:	8b 40 38             	mov    0x38(%eax),%eax
   23d0b:	8d 50 04             	lea    0x4(%eax),%edx
   23d0e:	8b 44 24 30          	mov    0x30(%esp),%eax
   23d12:	89 50 38             	mov    %edx,0x38(%eax)
		I387.foo = offset;
   23d15:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23d1b:	8b 00                	mov    (%eax),%eax
   23d1d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   23d21:	89 90 2c 04 00 00    	mov    %edx,0x42c(%eax)
		I387.fos = 0x17;
   23d27:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23d2d:	8b 00                	mov    (%eax),%eax
   23d2f:	c7 80 30 04 00 00 17 	movl   $0x17,0x430(%eax)
   23d36:	00 00 00 
		return (char *) offset;
   23d39:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   23d3d:	e9 d7 00 00 00       	jmp    23e19 <ea+0x1a3>
	}
// 对于其余情况，则根据MOD进行处理。首先取出R/M代码对应寄存器内容的值作为指针tmp。对于MOD=0，无偏移值。对于MOD=1，代码后
// 随1字节偏移值。对于MOD=2，代码后有4字节偏移值。最后保存并返回有效地址值。
	tmp = & REG(rm);
   23d42:	0f b6 44 24 16       	movzbl 0x16(%esp),%eax
   23d47:	8b 84 83 00 16 00 00 	mov    0x1600(%ebx,%eax,4),%eax
   23d4e:	89 c2                	mov    %eax,%edx
   23d50:	8b 44 24 30          	mov    0x30(%esp),%eax
   23d54:	01 d0                	add    %edx,%eax
   23d56:	89 44 24 18          	mov    %eax,0x18(%esp)
	switch (mod) {
   23d5a:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
   23d5f:	83 f8 01             	cmp    $0x1,%eax
   23d62:	74 21                	je     23d85 <ea+0x10f>
   23d64:	83 f8 01             	cmp    $0x1,%eax
   23d67:	7f 06                	jg     23d6f <ea+0xf9>
   23d69:	85 c0                	test   %eax,%eax
   23d6b:	74 0e                	je     23d7b <ea+0x105>
   23d6d:	eb 78                	jmp    23de7 <ea+0x171>
   23d6f:	83 f8 02             	cmp    $0x2,%eax
   23d72:	74 3b                	je     23daf <ea+0x139>
   23d74:	83 f8 03             	cmp    $0x3,%eax
   23d77:	74 5d                	je     23dd6 <ea+0x160>
   23d79:	eb 6c                	jmp    23de7 <ea+0x171>
		case 0: offset = 0; break;
   23d7b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   23d82:	00 
   23d83:	eb 62                	jmp    23de7 <ea+0x171>
		case 1:
			offset = (signed char) get_fs_byte((char *) EIP);
   23d85:	8b 44 24 30          	mov    0x30(%esp),%eax
   23d89:	8b 40 38             	mov    0x38(%eax),%eax
   23d8c:	50                   	push   %eax
   23d8d:	e8 61 fd ff ff       	call   23af3 <get_fs_byte>
   23d92:	83 c4 04             	add    $0x4,%esp
   23d95:	0f be c0             	movsbl %al,%eax
   23d98:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			EIP++;
   23d9c:	8b 44 24 30          	mov    0x30(%esp),%eax
   23da0:	8b 40 38             	mov    0x38(%eax),%eax
   23da3:	8d 50 01             	lea    0x1(%eax),%edx
   23da6:	8b 44 24 30          	mov    0x30(%esp),%eax
   23daa:	89 50 38             	mov    %edx,0x38(%eax)
			break;
   23dad:	eb 38                	jmp    23de7 <ea+0x171>
		case 2:
			offset = (signed) get_fs_long((unsigned long *) EIP);
   23daf:	8b 44 24 30          	mov    0x30(%esp),%eax
   23db3:	8b 40 38             	mov    0x38(%eax),%eax
   23db6:	50                   	push   %eax
   23db7:	e8 4f fd ff ff       	call   23b0b <get_fs_long>
   23dbc:	83 c4 04             	add    $0x4,%esp
   23dbf:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			EIP += 4;
   23dc3:	8b 44 24 30          	mov    0x30(%esp),%eax
   23dc7:	8b 40 38             	mov    0x38(%eax),%eax
   23dca:	8d 50 04             	lea    0x4(%eax),%edx
   23dcd:	8b 44 24 30          	mov    0x30(%esp),%eax
   23dd1:	89 50 38             	mov    %edx,0x38(%eax)
			break;
   23dd4:	eb 11                	jmp    23de7 <ea+0x171>
		case 3:
			math_abort(info,1<<(SIGILL-1));
   23dd6:	83 ec 08             	sub    $0x8,%esp
   23dd9:	6a 08                	push   $0x8
   23ddb:	ff 74 24 3c          	pushl  0x3c(%esp)
   23ddf:	e8 e9 fa ff ff       	call   238cd <__math_abort>
   23de4:	83 c4 10             	add    $0x10,%esp
	}
	I387.foo = offset;
   23de7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23ded:	8b 00                	mov    (%eax),%eax
   23def:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   23df3:	89 90 2c 04 00 00    	mov    %edx,0x42c(%eax)
	I387.fos = 0x17;
   23df9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   23dff:	8b 00                	mov    (%eax),%eax
   23e01:	c7 80 30 04 00 00 17 	movl   $0x17,0x430(%eax)
   23e08:	00 00 00 
	return offset + (char *) *tmp;
   23e0b:	8b 44 24 18          	mov    0x18(%esp),%eax
   23e0f:	8b 00                	mov    (%eax),%eax
   23e11:	89 c2                	mov    %eax,%edx
   23e13:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   23e17:	01 d0                	add    %edx,%eax
}
   23e19:	83 c4 28             	add    $0x28,%esp
   23e1c:	5b                   	pop    %ebx
   23e1d:	c3                   	ret    

00023e1e <get_fs_byte>:
{
   23e1e:	53                   	push   %ebx
   23e1f:	e8 ce 2e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23e24:	05 dc e1 00 00       	add    $0xe1dc,%eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   23e29:	8b 44 24 08          	mov    0x8(%esp),%eax
   23e2d:	64 8a 00             	mov    %fs:(%eax),%al
   23e30:	89 c3                	mov    %eax,%ebx
	return _v;
   23e32:	89 d8                	mov    %ebx,%eax
}
   23e34:	5b                   	pop    %ebx
   23e35:	c3                   	ret    

00023e36 <get_fs_word>:
{
   23e36:	83 ec 10             	sub    $0x10,%esp
   23e39:	e8 b4 2e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23e3e:	05 c2 e1 00 00       	add    $0xe1c2,%eax
	__asm__ ("movw %%fs:%1,%0":"=q" (_v):"m" (*addr));
   23e43:	8b 44 24 14          	mov    0x14(%esp),%eax
   23e47:	64 66 8b 00          	mov    %fs:(%eax),%ax
   23e4b:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	return _v;
   23e50:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
}
   23e55:	83 c4 10             	add    $0x10,%esp
   23e58:	c3                   	ret    

00023e59 <get_fs_long>:
{
   23e59:	83 ec 10             	sub    $0x10,%esp
   23e5c:	e8 91 2e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23e61:	05 9f e1 00 00       	add    $0xe19f,%eax
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   23e66:	8b 44 24 14          	mov    0x14(%esp),%eax
   23e6a:	64 8b 00             	mov    %fs:(%eax),%eax
   23e6d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
   23e71:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   23e75:	83 c4 10             	add    $0x10,%esp
   23e78:	c3                   	ret    

00023e79 <put_fs_byte>:
{
   23e79:	83 ec 04             	sub    $0x4,%esp
   23e7c:	e8 71 2e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23e81:	05 7f e1 00 00       	add    $0xe17f,%eax
   23e86:	8b 44 24 08          	mov    0x8(%esp),%eax
   23e8a:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   23e8d:	0f b6 04 24          	movzbl (%esp),%eax
   23e91:	8b 54 24 0c          	mov    0xc(%esp),%edx
   23e95:	64 88 02             	mov    %al,%fs:(%edx)
}
   23e98:	90                   	nop
   23e99:	83 c4 04             	add    $0x4,%esp
   23e9c:	c3                   	ret    

00023e9d <put_fs_word>:
{
   23e9d:	83 ec 04             	sub    $0x4,%esp
   23ea0:	e8 4d 2e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23ea5:	05 5b e1 00 00       	add    $0xe15b,%eax
   23eaa:	8b 44 24 08          	mov    0x8(%esp),%eax
   23eae:	66 89 04 24          	mov    %ax,(%esp)
__asm__ ("movw %0,%%fs:%1"::"q" (val),"m" (*addr));
   23eb2:	0f b7 04 24          	movzwl (%esp),%eax
   23eb6:	8b 54 24 0c          	mov    0xc(%esp),%edx
   23eba:	64 66 89 02          	mov    %ax,%fs:(%edx)
}
   23ebe:	90                   	nop
   23ebf:	83 c4 04             	add    $0x4,%esp
   23ec2:	c3                   	ret    

00023ec3 <put_fs_long>:
{
   23ec3:	e8 2a 2e fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23ec8:	05 38 e1 00 00       	add    $0xe138,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   23ecd:	8b 44 24 04          	mov    0x4(%esp),%eax
   23ed1:	8b 54 24 08          	mov    0x8(%esp),%edx
   23ed5:	64 89 02             	mov    %eax,%fs:(%edx)
}
   23ed8:	90                   	nop
   23ed9:	c3                   	ret    

00023eda <get_short_real>:
// 根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得短实数所在有效地址（math/ea.c），然后从用户
// 数据区读取相应实数值。最后把用户短实数转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_short_real(temp_real * tmp,
	struct info * info, unsigned short code)
{
   23eda:	53                   	push   %ebx
   23edb:	83 ec 28             	sub    $0x28,%esp
   23ede:	e8 17 2e fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   23ee3:	81 c3 1d e1 00 00    	add    $0xe11d,%ebx
   23ee9:	8b 44 24 38          	mov    0x38(%esp),%eax
   23eed:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	short_real sr;

	addr = ea(info,code);                           // 计算有效地址。
   23ef2:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   23ef7:	83 ec 08             	sub    $0x8,%esp
   23efa:	50                   	push   %eax
   23efb:	ff 74 24 40          	pushl  0x40(%esp)
   23eff:	e8 72 fd ff ff       	call   23c76 <ea>
   23f04:	83 c4 10             	add    $0x10,%esp
   23f07:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	sr = get_fs_long((unsigned long *) addr);       // 取用户数据区中的值。
   23f0b:	83 ec 0c             	sub    $0xc,%esp
   23f0e:	ff 74 24 28          	pushl  0x28(%esp)
   23f12:	e8 42 ff ff ff       	call   23e59 <get_fs_long>
   23f17:	83 c4 10             	add    $0x10,%esp
   23f1a:	89 44 24 18          	mov    %eax,0x18(%esp)
	short_to_temp(&sr,tmp);                         // 转换成临时实数格式。
   23f1e:	83 ec 08             	sub    $0x8,%esp
   23f21:	ff 74 24 38          	pushl  0x38(%esp)
   23f25:	8d 44 24 24          	lea    0x24(%esp),%eax
   23f29:	50                   	push   %eax
   23f2a:	e8 d5 12 00 00       	call   25204 <short_to_temp>
   23f2f:	83 c4 10             	add    $0x10,%esp
}
   23f32:	90                   	nop
   23f33:	83 c4 28             	add    $0x28,%esp
   23f36:	5b                   	pop    %ebx
   23f37:	c3                   	ret    

00023f38 <get_long_real>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得长实数所在有效地址（math/ec.c），然后从
// 用户数据区读取相应实数值。最后把用户实数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_long_real(temp_real * tmp,
	struct info * info, unsigned short code)
{
   23f38:	53                   	push   %ebx
   23f39:	83 ec 28             	sub    $0x28,%esp
   23f3c:	e8 b9 2d fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   23f41:	81 c3 bf e0 00 00    	add    $0xe0bf,%ebx
   23f47:	8b 44 24 38          	mov    0x38(%esp),%eax
   23f4b:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	long_real lr;

	addr = ea(info,code);                           // 取指令中的有效地址。
   23f50:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   23f55:	83 ec 08             	sub    $0x8,%esp
   23f58:	50                   	push   %eax
   23f59:	ff 74 24 40          	pushl  0x40(%esp)
   23f5d:	e8 14 fd ff ff       	call   23c76 <ea>
   23f62:	83 c4 10             	add    $0x10,%esp
   23f65:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	lr.a = get_fs_long((unsigned long *) addr);     // 取长8字节实数。
   23f69:	83 ec 0c             	sub    $0xc,%esp
   23f6c:	ff 74 24 28          	pushl  0x28(%esp)
   23f70:	e8 e4 fe ff ff       	call   23e59 <get_fs_long>
   23f75:	83 c4 10             	add    $0x10,%esp
   23f78:	89 44 24 14          	mov    %eax,0x14(%esp)
	lr.b = get_fs_long(1 + (unsigned long *) addr); // 转换成临时实数格式。
   23f7c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   23f80:	83 c0 04             	add    $0x4,%eax
   23f83:	83 ec 0c             	sub    $0xc,%esp
   23f86:	50                   	push   %eax
   23f87:	e8 cd fe ff ff       	call   23e59 <get_fs_long>
   23f8c:	83 c4 10             	add    $0x10,%esp
   23f8f:	89 44 24 18          	mov    %eax,0x18(%esp)
	long_to_temp(&lr,tmp);
   23f93:	83 ec 08             	sub    $0x8,%esp
   23f96:	ff 74 24 38          	pushl  0x38(%esp)
   23f9a:	8d 44 24 20          	lea    0x20(%esp),%eax
   23f9e:	50                   	push   %eax
   23f9f:	e8 0d 13 00 00       	call   252b1 <long_to_temp>
   23fa4:	83 c4 10             	add    $0x10,%esp
}
   23fa7:	90                   	nop
   23fa8:	83 c4 28             	add    $0x28,%esp
   23fab:	5b                   	pop    %ebx
   23fac:	c3                   	ret    

00023fad <get_temp_real>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得临时实数所在有效地址（math/ea.c），然后
// 从用户数据区读取相应临时实数值。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_temp_real(temp_real * tmp,
	struct info * info, unsigned short code)
{
   23fad:	53                   	push   %ebx
   23fae:	83 ec 28             	sub    $0x28,%esp
   23fb1:	e8 3c 2d fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   23fb6:	05 4a e0 00 00       	add    $0xe04a,%eax
   23fbb:	8b 54 24 38          	mov    0x38(%esp),%edx
   23fbf:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
	char * addr;

	addr = ea(info,code);           // 取指令中的有效地址值。
   23fc4:	0f b7 54 24 0c       	movzwl 0xc(%esp),%edx
   23fc9:	83 ec 08             	sub    $0x8,%esp
   23fcc:	52                   	push   %edx
   23fcd:	ff 74 24 40          	pushl  0x40(%esp)
   23fd1:	89 c3                	mov    %eax,%ebx
   23fd3:	e8 9e fc ff ff       	call   23c76 <ea>
   23fd8:	83 c4 10             	add    $0x10,%esp
   23fdb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	tmp->a = get_fs_long((unsigned long *) addr);
   23fdf:	83 ec 0c             	sub    $0xc,%esp
   23fe2:	ff 74 24 28          	pushl  0x28(%esp)
   23fe6:	e8 6e fe ff ff       	call   23e59 <get_fs_long>
   23feb:	83 c4 10             	add    $0x10,%esp
   23fee:	89 c2                	mov    %eax,%edx
   23ff0:	8b 44 24 30          	mov    0x30(%esp),%eax
   23ff4:	89 10                	mov    %edx,(%eax)
	tmp->b = get_fs_long(1 + (unsigned long *) addr);
   23ff6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   23ffa:	83 c0 04             	add    $0x4,%eax
   23ffd:	83 ec 0c             	sub    $0xc,%esp
   24000:	50                   	push   %eax
   24001:	e8 53 fe ff ff       	call   23e59 <get_fs_long>
   24006:	83 c4 10             	add    $0x10,%esp
   24009:	89 c2                	mov    %eax,%edx
   2400b:	8b 44 24 30          	mov    0x30(%esp),%eax
   2400f:	89 50 04             	mov    %edx,0x4(%eax)
	tmp->exponent = get_fs_word(4 + (unsigned short *) addr);
   24012:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   24016:	83 c0 08             	add    $0x8,%eax
   24019:	83 ec 0c             	sub    $0xc,%esp
   2401c:	50                   	push   %eax
   2401d:	e8 14 fe ff ff       	call   23e36 <get_fs_word>
   24022:	83 c4 10             	add    $0x10,%esp
   24025:	89 c2                	mov    %eax,%edx
   24027:	8b 44 24 30          	mov    0x30(%esp),%eax
   2402b:	66 89 50 08          	mov    %dx,0x8(%eax)
}
   2402f:	90                   	nop
   24030:	83 c4 28             	add    $0x28,%esp
   24033:	5b                   	pop    %ebx
   24034:	c3                   	ret    

00024035 <get_short_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得短整数所在有效地址（math/ea.c）
// 然后从用户数据区读取相应整数值，并保存为临时整数格式。最后把临时整数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_short_int(temp_real * tmp,
	struct info * info, unsigned short code)
{
   24035:	53                   	push   %ebx
   24036:	83 ec 28             	sub    $0x28,%esp
   24039:	e8 bc 2c fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   2403e:	81 c3 c2 df 00 00    	add    $0xdfc2,%ebx
   24044:	8b 44 24 38          	mov    0x38(%esp),%eax
   24048:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取指令中的有效地址值。
   2404d:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   24052:	83 ec 08             	sub    $0x8,%esp
   24055:	50                   	push   %eax
   24056:	ff 74 24 40          	pushl  0x40(%esp)
   2405a:	e8 17 fc ff ff       	call   23c76 <ea>
   2405f:	83 c4 10             	add    $0x10,%esp
   24062:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	ti.a = (signed short) get_fs_word((unsigned short *) addr);
   24066:	83 ec 0c             	sub    $0xc,%esp
   24069:	ff 74 24 28          	pushl  0x28(%esp)
   2406d:	e8 c4 fd ff ff       	call   23e36 <get_fs_word>
   24072:	83 c4 10             	add    $0x10,%esp
   24075:	98                   	cwtl   
   24076:	89 44 24 10          	mov    %eax,0x10(%esp)
	ti.b = 0;
   2407a:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   24081:	00 
	if (ti.sign = (ti.a < 0))       // 若是负数，则设置临时整数符号位。
   24082:	8b 44 24 10          	mov    0x10(%esp),%eax
   24086:	c1 e8 1f             	shr    $0x1f,%eax
   24089:	0f b6 c0             	movzbl %al,%eax
   2408c:	66 89 44 24 18       	mov    %ax,0x18(%esp)
   24091:	0f b7 44 24 18       	movzwl 0x18(%esp),%eax
   24096:	66 85 c0             	test   %ax,%ax
   24099:	74 0a                	je     240a5 <get_short_int+0x70>
		ti.a = - ti.a;          // 临时整数“尾数”部分为无符号数。
   2409b:	8b 44 24 10          	mov    0x10(%esp),%eax
   2409f:	f7 d8                	neg    %eax
   240a1:	89 44 24 10          	mov    %eax,0x10(%esp)
	int_to_real(&ti,tmp);           // 把临时整数转换成临时实数格式。
   240a5:	83 ec 08             	sub    $0x8,%esp
   240a8:	ff 74 24 38          	pushl  0x38(%esp)
   240ac:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   240b0:	50                   	push   %eax
   240b1:	e8 fa 17 00 00       	call   258b0 <int_to_real>
   240b6:	83 c4 10             	add    $0x10,%esp
}
   240b9:	90                   	nop
   240ba:	83 c4 28             	add    $0x28,%esp
   240bd:	5b                   	pop    %ebx
   240be:	c3                   	ret    

000240bf <get_long_int>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得长整数所在有效地址（math/ea.c），然后从
// 用户数据区读取相应整数值，并保存为临时整数格式。最后把临时整数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_long_int(temp_real * tmp,
	struct info * info, unsigned short code)
{
   240bf:	53                   	push   %ebx
   240c0:	83 ec 28             	sub    $0x28,%esp
   240c3:	e8 32 2c fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   240c8:	81 c3 38 df 00 00    	add    $0xdf38,%ebx
   240ce:	8b 44 24 38          	mov    0x38(%esp),%eax
   240d2:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取指令中的有效地址值。
   240d7:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   240dc:	83 ec 08             	sub    $0x8,%esp
   240df:	50                   	push   %eax
   240e0:	ff 74 24 40          	pushl  0x40(%esp)
   240e4:	e8 8d fb ff ff       	call   23c76 <ea>
   240e9:	83 c4 10             	add    $0x10,%esp
   240ec:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	ti.a = get_fs_long((unsigned long *) addr);
   240f0:	83 ec 0c             	sub    $0xc,%esp
   240f3:	ff 74 24 28          	pushl  0x28(%esp)
   240f7:	e8 5d fd ff ff       	call   23e59 <get_fs_long>
   240fc:	83 c4 10             	add    $0x10,%esp
   240ff:	89 44 24 10          	mov    %eax,0x10(%esp)
	ti.b = 0;
   24103:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   2410a:	00 
	if (ti.sign = (ti.a < 0))       // 若是负数，则设置临时整数符号位。
   2410b:	8b 44 24 10          	mov    0x10(%esp),%eax
   2410f:	c1 e8 1f             	shr    $0x1f,%eax
   24112:	0f b6 c0             	movzbl %al,%eax
   24115:	66 89 44 24 18       	mov    %ax,0x18(%esp)
   2411a:	0f b7 44 24 18       	movzwl 0x18(%esp),%eax
   2411f:	66 85 c0             	test   %ax,%ax
   24122:	74 0a                	je     2412e <get_long_int+0x6f>
		ti.a = - ti.a;          // 临时整数“尾数”部分为无符号数。
   24124:	8b 44 24 10          	mov    0x10(%esp),%eax
   24128:	f7 d8                	neg    %eax
   2412a:	89 44 24 10          	mov    %eax,0x10(%esp)
	int_to_real(&ti,tmp);           // 把临时整数转换成临时实数格式。
   2412e:	83 ec 08             	sub    $0x8,%esp
   24131:	ff 74 24 38          	pushl  0x38(%esp)
   24135:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   24139:	50                   	push   %eax
   2413a:	e8 71 17 00 00       	call   258b0 <int_to_real>
   2413f:	83 c4 10             	add    $0x10,%esp
}
   24142:	90                   	nop
   24143:	83 c4 28             	add    $0x28,%esp
   24146:	5b                   	pop    %ebx
   24147:	c3                   	ret    

00024148 <get_longlong_int>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得64位长整数所有有效地址（math/ea.c），
// 然后从用户数据区读取相应整数值，并保存为临时整数格式。最后再把临时整数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_longlong_int(temp_real * tmp,
	struct info * info, unsigned short code)
{
   24148:	53                   	push   %ebx
   24149:	83 ec 28             	sub    $0x28,%esp
   2414c:	e8 a9 2b fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   24151:	81 c3 af de 00 00    	add    $0xdeaf,%ebx
   24157:	8b 44 24 38          	mov    0x38(%esp),%eax
   2415b:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	temp_int ti;

	addr = ea(info,code);                           // 取指令中的有效地址值。
   24160:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   24165:	83 ec 08             	sub    $0x8,%esp
   24168:	50                   	push   %eax
   24169:	ff 74 24 40          	pushl  0x40(%esp)
   2416d:	e8 04 fb ff ff       	call   23c76 <ea>
   24172:	83 c4 10             	add    $0x10,%esp
   24175:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	ti.a = get_fs_long((unsigned long *) addr);     // 取用户64位长整数。
   24179:	83 ec 0c             	sub    $0xc,%esp
   2417c:	ff 74 24 28          	pushl  0x28(%esp)
   24180:	e8 d4 fc ff ff       	call   23e59 <get_fs_long>
   24185:	83 c4 10             	add    $0x10,%esp
   24188:	89 44 24 10          	mov    %eax,0x10(%esp)
	ti.b = get_fs_long(1 + (unsigned long *) addr);
   2418c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   24190:	83 c0 04             	add    $0x4,%eax
   24193:	83 ec 0c             	sub    $0xc,%esp
   24196:	50                   	push   %eax
   24197:	e8 bd fc ff ff       	call   23e59 <get_fs_long>
   2419c:	83 c4 10             	add    $0x10,%esp
   2419f:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (ti.sign = (ti.b < 0))                       // 若是负数则设置临时整数符号位。
   241a3:	8b 44 24 14          	mov    0x14(%esp),%eax
   241a7:	c1 e8 1f             	shr    $0x1f,%eax
   241aa:	0f b6 c0             	movzbl %al,%eax
   241ad:	66 89 44 24 18       	mov    %ax,0x18(%esp)
   241b2:	0f b7 44 24 18       	movzwl 0x18(%esp),%eax
   241b7:	66 85 c0             	test   %ax,%ax
   241ba:	74 1a                	je     241d6 <get_longlong_int+0x8e>
		__asm__("notl %0 ; notl %1\n\t"         // 同时取反加1和进位调整。
			"addl $1,%0 ; adcl $0,%1"
			:"=r" (ti.a),"=r" (ti.b)
			:"0" (ti.a),"1" (ti.b));
   241bc:	8b 54 24 10          	mov    0x10(%esp),%edx
   241c0:	8b 44 24 14          	mov    0x14(%esp),%eax
		__asm__("notl %0 ; notl %1\n\t"         // 同时取反加1和进位调整。
   241c4:	f7 d2                	not    %edx
   241c6:	f7 d0                	not    %eax
   241c8:	83 c2 01             	add    $0x1,%edx
   241cb:	83 d0 00             	adc    $0x0,%eax
   241ce:	89 54 24 10          	mov    %edx,0x10(%esp)
   241d2:	89 44 24 14          	mov    %eax,0x14(%esp)
	int_to_real(&ti,tmp);                           // 把临时整数转换成临时实数格式。
   241d6:	83 ec 08             	sub    $0x8,%esp
   241d9:	ff 74 24 38          	pushl  0x38(%esp)
   241dd:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   241e1:	50                   	push   %eax
   241e2:	e8 c9 16 00 00       	call   258b0 <int_to_real>
   241e7:	83 c4 10             	add    $0x10,%esp
}
   241ea:	90                   	nop
   241eb:	83 c4 28             	add    $0x28,%esp
   241ee:	5b                   	pop    %ebx
   241ef:	c3                   	ret    

000241f0 <get_BCD>:
// 取用户内存中的BCD码数值并转换成临时实数格式。
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得BCD码所在有效地址（math/ea.c），
// 然后从用户数据区读取10字节相应BCD码值（其中1字节用于符号），同时转换成临时整数形式。最后把临时整数值转换成临时实数。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_BCD(temp_real * tmp, struct info * info, unsigned short code)
{
   241f0:	56                   	push   %esi
   241f1:	53                   	push   %ebx
   241f2:	83 ec 34             	sub    $0x34,%esp
   241f5:	e8 0c a1 fe ff       	call   e306 <__x86.get_pc_thunk.si>
   241fa:	81 c6 06 de 00 00    	add    $0xde06,%esi
   24200:	8b 44 24 48          	mov    0x48(%esp),%eax
   24204:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	unsigned char c;

// 取得BCD码数值所在内存有效地址。然后从最后1个BCD码字节（最高有效位）开始处理。
// 先取得BCD码数值的符号位，并设置临时整数的符号位。然后把9字节的BCD码值转换成临时整数格式，最后把临时整数值转换成临时
// 实数。
	addr = ea(info,code);                   // 取有效地址。
   24209:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   2420e:	83 ec 08             	sub    $0x8,%esp
   24211:	50                   	push   %eax
   24212:	ff 74 24 50          	pushl  0x50(%esp)
   24216:	89 f3                	mov    %esi,%ebx
   24218:	e8 59 fa ff ff       	call   23c76 <ea>
   2421d:	83 c4 10             	add    $0x10,%esp
   24220:	89 44 24 28          	mov    %eax,0x28(%esp)
	addr += 9;                              // 指向最后一个（第10个）字节。
   24224:	83 44 24 28 09       	addl   $0x9,0x28(%esp)
	i.sign = 0x80 & get_fs_byte(addr--);    // 取其中符号位。
   24229:	8b 44 24 28          	mov    0x28(%esp),%eax
   2422d:	8d 50 ff             	lea    -0x1(%eax),%edx
   24230:	89 54 24 28          	mov    %edx,0x28(%esp)
   24234:	83 ec 0c             	sub    $0xc,%esp
   24237:	50                   	push   %eax
   24238:	e8 e1 fb ff ff       	call   23e1e <get_fs_byte>
   2423d:	83 c4 10             	add    $0x10,%esp
   24240:	0f b6 c0             	movzbl %al,%eax
   24243:	66 25 80 00          	and    $0x80,%ax
   24247:	66 89 44 24 20       	mov    %ax,0x20(%esp)
	i.a = i.b = 0;
   2424c:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   24253:	00 
   24254:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   24258:	89 44 24 18          	mov    %eax,0x18(%esp)
	for (k = 0; k < 9; k++) {               // 转换成临时整数格式。
   2425c:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   24263:	00 
   24264:	e9 a5 00 00 00       	jmp    2430e <get_BCD+0x11e>
		c = get_fs_byte(addr--);
   24269:	8b 44 24 28          	mov    0x28(%esp),%eax
   2426d:	8d 50 ff             	lea    -0x1(%eax),%edx
   24270:	89 54 24 28          	mov    %edx,0x28(%esp)
   24274:	83 ec 0c             	sub    $0xc,%esp
   24277:	50                   	push   %eax
   24278:	e8 a1 fb ff ff       	call   23e1e <get_fs_byte>
   2427d:	83 c4 10             	add    $0x10,%esp
   24280:	88 44 24 27          	mov    %al,0x27(%esp)
		MUL10(i.a, i.b);
   24284:	8b 44 24 18          	mov    0x18(%esp),%eax
   24288:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   2428c:	01 c0                	add    %eax,%eax
   2428e:	11 d2                	adc    %edx,%edx
   24290:	89 c1                	mov    %eax,%ecx
   24292:	89 d3                	mov    %edx,%ebx
   24294:	01 c0                	add    %eax,%eax
   24296:	11 d2                	adc    %edx,%edx
   24298:	01 c0                	add    %eax,%eax
   2429a:	11 d2                	adc    %edx,%edx
   2429c:	01 c8                	add    %ecx,%eax
   2429e:	11 da                	adc    %ebx,%edx
   242a0:	89 44 24 18          	mov    %eax,0x18(%esp)
   242a4:	89 54 24 1c          	mov    %edx,0x1c(%esp)
		ADD64((c>>4), i.a, i.b);
   242a8:	8b 54 24 18          	mov    0x18(%esp),%edx
   242ac:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   242b0:	0f b6 4c 24 27       	movzbl 0x27(%esp),%ecx
   242b5:	c0 e9 04             	shr    $0x4,%cl
   242b8:	0f b6 c9             	movzbl %cl,%ecx
   242bb:	01 ca                	add    %ecx,%edx
   242bd:	83 d0 00             	adc    $0x0,%eax
   242c0:	89 54 24 18          	mov    %edx,0x18(%esp)
   242c4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		MUL10(i.a, i.b);
   242c8:	8b 44 24 18          	mov    0x18(%esp),%eax
   242cc:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   242d0:	01 c0                	add    %eax,%eax
   242d2:	11 d2                	adc    %edx,%edx
   242d4:	89 c1                	mov    %eax,%ecx
   242d6:	89 d3                	mov    %edx,%ebx
   242d8:	01 c0                	add    %eax,%eax
   242da:	11 d2                	adc    %edx,%edx
   242dc:	01 c0                	add    %eax,%eax
   242de:	11 d2                	adc    %edx,%edx
   242e0:	01 c8                	add    %ecx,%eax
   242e2:	11 da                	adc    %ebx,%edx
   242e4:	89 44 24 18          	mov    %eax,0x18(%esp)
   242e8:	89 54 24 1c          	mov    %edx,0x1c(%esp)
		ADD64((c&0xf), i.a, i.b);
   242ec:	8b 54 24 18          	mov    0x18(%esp),%edx
   242f0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   242f4:	0f b6 4c 24 27       	movzbl 0x27(%esp),%ecx
   242f9:	83 e1 0f             	and    $0xf,%ecx
   242fc:	01 ca                	add    %ecx,%edx
   242fe:	83 d0 00             	adc    $0x0,%eax
   24301:	89 54 24 18          	mov    %edx,0x18(%esp)
   24305:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	for (k = 0; k < 9; k++) {               // 转换成临时整数格式。
   24309:	83 44 24 2c 01       	addl   $0x1,0x2c(%esp)
   2430e:	83 7c 24 2c 08       	cmpl   $0x8,0x2c(%esp)
   24313:	0f 8e 50 ff ff ff    	jle    24269 <get_BCD+0x79>
	}
	int_to_real(&i,tmp);                    // 转换成临时实数格式。
   24319:	83 ec 08             	sub    $0x8,%esp
   2431c:	ff 74 24 48          	pushl  0x48(%esp)
   24320:	8d 44 24 24          	lea    0x24(%esp),%eax
   24324:	50                   	push   %eax
   24325:	89 f3                	mov    %esi,%ebx
   24327:	e8 84 15 00 00       	call   258b0 <int_to_real>
   2432c:	83 c4 10             	add    $0x10,%esp
}
   2432f:	90                   	nop
   24330:	83 c4 34             	add    $0x34,%esp
   24333:	5b                   	pop    %ebx
   24334:	5e                   	pop    %esi
   24335:	c3                   	ret    

00024336 <put_short_real>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时实
// 数格式的结果转换成短实数格式并存储到有效地址addr处。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_short_real(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   24336:	53                   	push   %ebx
   24337:	83 ec 28             	sub    $0x28,%esp
   2433a:	e8 bb 29 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   2433f:	81 c3 c1 dc 00 00    	add    $0xdcc1,%ebx
   24345:	8b 44 24 38          	mov    0x38(%esp),%eax
   24349:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	short_real sr;

	addr = ea(info,code);                           // 取有效地址。
   2434e:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   24353:	83 ec 08             	sub    $0x8,%esp
   24356:	50                   	push   %eax
   24357:	ff 74 24 40          	pushl  0x40(%esp)
   2435b:	e8 16 f9 ff ff       	call   23c76 <ea>
   24360:	83 c4 10             	add    $0x10,%esp
   24363:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	verify_area(addr,4);                            // 为保存结果验证或分配内存。
   24367:	83 ec 08             	sub    $0x8,%esp
   2436a:	6a 04                	push   $0x4
   2436c:	ff 74 24 28          	pushl  0x28(%esp)
   24370:	e8 86 45 fe ff       	call   88fb <verify_area>
   24375:	83 c4 10             	add    $0x10,%esp
	temp_to_short(tmp,&sr);                         // 结果转换成短实数格式。
   24378:	83 ec 08             	sub    $0x8,%esp
   2437b:	8d 44 24 20          	lea    0x20(%esp),%eax
   2437f:	50                   	push   %eax
   24380:	ff 74 24 3c          	pushl  0x3c(%esp)
   24384:	e8 f9 0f 00 00       	call   25382 <temp_to_short>
   24389:	83 c4 10             	add    $0x10,%esp
	put_fs_long(sr,(unsigned long *) addr);         // 存储数据到用户内存区。
   2438c:	8b 44 24 18          	mov    0x18(%esp),%eax
   24390:	83 ec 08             	sub    $0x8,%esp
   24393:	ff 74 24 24          	pushl  0x24(%esp)
   24397:	50                   	push   %eax
   24398:	e8 26 fb ff ff       	call   23ec3 <put_fs_long>
   2439d:	83 c4 10             	add    $0x10,%esp
}
   243a0:	90                   	nop
   243a1:	83 c4 28             	add    $0x28,%esp
   243a4:	5b                   	pop    %ebx
   243a5:	c3                   	ret    

000243a6 <put_long_real>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时
// 实数格式的结果转换成长实数格式，并存储到有效地址addr处。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_long_real(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   243a6:	53                   	push   %ebx
   243a7:	83 ec 28             	sub    $0x28,%esp
   243aa:	e8 4b 29 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   243af:	81 c3 51 dc 00 00    	add    $0xdc51,%ebx
   243b5:	8b 44 24 38          	mov    0x38(%esp),%eax
   243b9:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	long_real lr;

	addr = ea(info,code);                           // 取有效地址。
   243be:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   243c3:	83 ec 08             	sub    $0x8,%esp
   243c6:	50                   	push   %eax
   243c7:	ff 74 24 40          	pushl  0x40(%esp)
   243cb:	e8 a6 f8 ff ff       	call   23c76 <ea>
   243d0:	83 c4 10             	add    $0x10,%esp
   243d3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	verify_area(addr,8);                            // 为保存结果验证或分配内存。
   243d7:	83 ec 08             	sub    $0x8,%esp
   243da:	6a 08                	push   $0x8
   243dc:	ff 74 24 28          	pushl  0x28(%esp)
   243e0:	e8 16 45 fe ff       	call   88fb <verify_area>
   243e5:	83 c4 10             	add    $0x10,%esp
	temp_to_long(tmp,&lr);                          // 结果转换成长实数格式。
   243e8:	83 ec 08             	sub    $0x8,%esp
   243eb:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   243ef:	50                   	push   %eax
   243f0:	ff 74 24 3c          	pushl  0x3c(%esp)
   243f4:	e8 d0 10 00 00       	call   254c9 <temp_to_long>
   243f9:	83 c4 10             	add    $0x10,%esp
	put_fs_long(lr.a, (unsigned long *) addr);      // 存储数据到用户内存区。
   243fc:	8b 44 24 14          	mov    0x14(%esp),%eax
   24400:	83 ec 08             	sub    $0x8,%esp
   24403:	ff 74 24 24          	pushl  0x24(%esp)
   24407:	50                   	push   %eax
   24408:	e8 b6 fa ff ff       	call   23ec3 <put_fs_long>
   2440d:	83 c4 10             	add    $0x10,%esp
	put_fs_long(lr.b, 1 + (unsigned long *) addr);
   24410:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   24414:	83 c0 04             	add    $0x4,%eax
   24417:	8b 54 24 18          	mov    0x18(%esp),%edx
   2441b:	83 ec 08             	sub    $0x8,%esp
   2441e:	50                   	push   %eax
   2441f:	52                   	push   %edx
   24420:	e8 9e fa ff ff       	call   23ec3 <put_fs_long>
   24425:	83 c4 10             	add    $0x10,%esp
}
   24428:	90                   	nop
   24429:	83 c4 28             	add    $0x28,%esp
   2442c:	5b                   	pop    %ebx
   2442d:	c3                   	ret    

0002442e <put_temp_real>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临
// 时实数存储到有效地址addr处。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_temp_real(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   2442e:	53                   	push   %ebx
   2442f:	83 ec 28             	sub    $0x28,%esp
   24432:	e8 c3 28 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   24437:	81 c3 c9 db 00 00    	add    $0xdbc9,%ebx
   2443d:	8b 44 24 38          	mov    0x38(%esp),%eax
   24441:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;

	addr = ea(info,code);                           // 取有效地址。
   24446:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   2444b:	83 ec 08             	sub    $0x8,%esp
   2444e:	50                   	push   %eax
   2444f:	ff 74 24 40          	pushl  0x40(%esp)
   24453:	e8 1e f8 ff ff       	call   23c76 <ea>
   24458:	83 c4 10             	add    $0x10,%esp
   2445b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	verify_area(addr,10);                           // 为保存结果验证或分配内存。
   2445f:	83 ec 08             	sub    $0x8,%esp
   24462:	6a 0a                	push   $0xa
   24464:	ff 74 24 28          	pushl  0x28(%esp)
   24468:	e8 8e 44 fe ff       	call   88fb <verify_area>
   2446d:	83 c4 10             	add    $0x10,%esp
	put_fs_long(tmp->a, (unsigned long *) addr);    // 存储数据到用户内存区。
   24470:	8b 44 24 30          	mov    0x30(%esp),%eax
   24474:	8b 00                	mov    (%eax),%eax
   24476:	83 ec 08             	sub    $0x8,%esp
   24479:	ff 74 24 24          	pushl  0x24(%esp)
   2447d:	50                   	push   %eax
   2447e:	e8 40 fa ff ff       	call   23ec3 <put_fs_long>
   24483:	83 c4 10             	add    $0x10,%esp
	put_fs_long(tmp->b, 1 + (unsigned long *) addr);
   24486:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   2448a:	8d 50 04             	lea    0x4(%eax),%edx
   2448d:	8b 44 24 30          	mov    0x30(%esp),%eax
   24491:	8b 40 04             	mov    0x4(%eax),%eax
   24494:	83 ec 08             	sub    $0x8,%esp
   24497:	52                   	push   %edx
   24498:	50                   	push   %eax
   24499:	e8 25 fa ff ff       	call   23ec3 <put_fs_long>
   2449e:	83 c4 10             	add    $0x10,%esp
	put_fs_word(tmp->exponent, 4 + (short *) addr);
   244a1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   244a5:	8d 50 08             	lea    0x8(%eax),%edx
   244a8:	8b 44 24 30          	mov    0x30(%esp),%eax
   244ac:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   244b0:	98                   	cwtl   
   244b1:	83 ec 08             	sub    $0x8,%esp
   244b4:	52                   	push   %edx
   244b5:	50                   	push   %eax
   244b6:	e8 e2 f9 ff ff       	call   23e9d <put_fs_word>
   244bb:	83 c4 10             	add    $0x10,%esp
}
   244be:	90                   	nop
   244bf:	83 c4 28             	add    $0x28,%esp
   244c2:	5b                   	pop    %ebx
   244c3:	c3                   	ret    

000244c4 <put_short_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临
// 时实数格式的结果转换成临时整数格式。如果是负数则设置整数符号位。最后把整数保存到用户内存中。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_short_int(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   244c4:	53                   	push   %ebx
   244c5:	83 ec 28             	sub    $0x28,%esp
   244c8:	e8 2d 28 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   244cd:	81 c3 33 db 00 00    	add    $0xdb33,%ebx
   244d3:	8b 44 24 38          	mov    0x38(%esp),%eax
   244d7:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取有效地址。
   244dc:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   244e1:	83 ec 08             	sub    $0x8,%esp
   244e4:	50                   	push   %eax
   244e5:	ff 74 24 40          	pushl  0x40(%esp)
   244e9:	e8 88 f7 ff ff       	call   23c76 <ea>
   244ee:	83 c4 10             	add    $0x10,%esp
   244f1:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	real_to_int(tmp,&ti);           // 转换成临时整数格式。
   244f5:	83 ec 08             	sub    $0x8,%esp
   244f8:	8d 44 24 18          	lea    0x18(%esp),%eax
   244fc:	50                   	push   %eax
   244fd:	ff 74 24 3c          	pushl  0x3c(%esp)
   24501:	e8 81 11 00 00       	call   25687 <real_to_int>
   24506:	83 c4 10             	add    $0x10,%esp
	verify_area(addr,2);            // 验证或分配存储内存。
   24509:	83 ec 08             	sub    $0x8,%esp
   2450c:	6a 02                	push   $0x2
   2450e:	ff 74 24 28          	pushl  0x28(%esp)
   24512:	e8 e4 43 fe ff       	call   88fb <verify_area>
   24517:	83 c4 10             	add    $0x10,%esp
	if (ti.sign)                    // 若有符号位，则取负数值。
   2451a:	0f b7 44 24 18       	movzwl 0x18(%esp),%eax
   2451f:	66 85 c0             	test   %ax,%ax
   24522:	74 0a                	je     2452e <put_short_int+0x6a>
		ti.a = -ti.a;
   24524:	8b 44 24 10          	mov    0x10(%esp),%eax
   24528:	f7 d8                	neg    %eax
   2452a:	89 44 24 10          	mov    %eax,0x10(%esp)
	put_fs_word(ti.a,(short *) addr);       // 存储到用户数据区中。
   2452e:	8b 44 24 10          	mov    0x10(%esp),%eax
   24532:	98                   	cwtl   
   24533:	83 ec 08             	sub    $0x8,%esp
   24536:	ff 74 24 24          	pushl  0x24(%esp)
   2453a:	50                   	push   %eax
   2453b:	e8 5d f9 ff ff       	call   23e9d <put_fs_word>
   24540:	83 c4 10             	add    $0x10,%esp
}
   24543:	90                   	nop
   24544:	83 c4 28             	add    $0x28,%esp
   24547:	5b                   	pop    %ebx
   24548:	c3                   	ret    

00024549 <put_long_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时
// 实数格式的结果转换成临时整数格式。如果是负数则设置整数符号位。最后把整数保存到用户内存中。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_long_int(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   24549:	53                   	push   %ebx
   2454a:	83 ec 28             	sub    $0x28,%esp
   2454d:	e8 a8 27 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   24552:	81 c3 ae da 00 00    	add    $0xdaae,%ebx
   24558:	8b 44 24 38          	mov    0x38(%esp),%eax
   2455c:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	temp_int ti;

	addr = ea(info,code);                           // 取有效地址值。
   24561:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   24566:	83 ec 08             	sub    $0x8,%esp
   24569:	50                   	push   %eax
   2456a:	ff 74 24 40          	pushl  0x40(%esp)
   2456e:	e8 03 f7 ff ff       	call   23c76 <ea>
   24573:	83 c4 10             	add    $0x10,%esp
   24576:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	real_to_int(tmp,&ti);                           // 转换成临时整数格式。
   2457a:	83 ec 08             	sub    $0x8,%esp
   2457d:	8d 44 24 18          	lea    0x18(%esp),%eax
   24581:	50                   	push   %eax
   24582:	ff 74 24 3c          	pushl  0x3c(%esp)
   24586:	e8 fc 10 00 00       	call   25687 <real_to_int>
   2458b:	83 c4 10             	add    $0x10,%esp
	verify_area(addr,4);                            // 验证或分配存储内存。
   2458e:	83 ec 08             	sub    $0x8,%esp
   24591:	6a 04                	push   $0x4
   24593:	ff 74 24 28          	pushl  0x28(%esp)
   24597:	e8 5f 43 fe ff       	call   88fb <verify_area>
   2459c:	83 c4 10             	add    $0x10,%esp
	if (ti.sign)                                    // 若有符号位，则取负数值。
   2459f:	0f b7 44 24 18       	movzwl 0x18(%esp),%eax
   245a4:	66 85 c0             	test   %ax,%ax
   245a7:	74 0a                	je     245b3 <put_long_int+0x6a>
		ti.a = -ti.a;
   245a9:	8b 44 24 10          	mov    0x10(%esp),%eax
   245ad:	f7 d8                	neg    %eax
   245af:	89 44 24 10          	mov    %eax,0x10(%esp)
	put_fs_long(ti.a,(unsigned long *) addr);       // 存储到用户数据区中。
   245b3:	8b 44 24 10          	mov    0x10(%esp),%eax
   245b7:	83 ec 08             	sub    $0x8,%esp
   245ba:	ff 74 24 24          	pushl  0x24(%esp)
   245be:	50                   	push   %eax
   245bf:	e8 ff f8 ff ff       	call   23ec3 <put_fs_long>
   245c4:	83 c4 10             	add    $0x10,%esp
}
   245c7:	90                   	nop
   245c8:	83 c4 28             	add    $0x28,%esp
   245cb:	5b                   	pop    %ebx
   245cc:	c3                   	ret    

000245cd <put_longlong_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时
// 实数格式的结果转换成临时整数格式。如果是负数则设置整数符号位。最后把整数保存到用户内存中。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_longlong_int(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   245cd:	53                   	push   %ebx
   245ce:	83 ec 28             	sub    $0x28,%esp
   245d1:	e8 24 27 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   245d6:	81 c3 2a da 00 00    	add    $0xda2a,%ebx
   245dc:	8b 44 24 38          	mov    0x38(%esp),%eax
   245e0:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取有效地址。
   245e5:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   245ea:	83 ec 08             	sub    $0x8,%esp
   245ed:	50                   	push   %eax
   245ee:	ff 74 24 40          	pushl  0x40(%esp)
   245f2:	e8 7f f6 ff ff       	call   23c76 <ea>
   245f7:	83 c4 10             	add    $0x10,%esp
   245fa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	real_to_int(tmp,&ti);           // 转换成临时整数格式。
   245fe:	83 ec 08             	sub    $0x8,%esp
   24601:	8d 44 24 18          	lea    0x18(%esp),%eax
   24605:	50                   	push   %eax
   24606:	ff 74 24 3c          	pushl  0x3c(%esp)
   2460a:	e8 78 10 00 00       	call   25687 <real_to_int>
   2460f:	83 c4 10             	add    $0x10,%esp
	verify_area(addr,8);            // 验证存储区域。
   24612:	83 ec 08             	sub    $0x8,%esp
   24615:	6a 08                	push   $0x8
   24617:	ff 74 24 28          	pushl  0x28(%esp)
   2461b:	e8 db 42 fe ff       	call   88fb <verify_area>
   24620:	83 c4 10             	add    $0x10,%esp
	if (ti.sign)                    // 若是负数，则取反加1。
   24623:	0f b7 44 24 18       	movzwl 0x18(%esp),%eax
   24628:	66 85 c0             	test   %ax,%ax
   2462b:	74 1a                	je     24647 <put_longlong_int+0x7a>
		__asm__("notl %0 ; notl %1\n\t"
			"addl $1,%0 ; adcl $0,%1"
			:"=r" (ti.a),"=r" (ti.b)
			:"0" (ti.a),"1" (ti.b));
   2462d:	8b 54 24 10          	mov    0x10(%esp),%edx
   24631:	8b 44 24 14          	mov    0x14(%esp),%eax
		__asm__("notl %0 ; notl %1\n\t"
   24635:	f7 d2                	not    %edx
   24637:	f7 d0                	not    %eax
   24639:	83 c2 01             	add    $0x1,%edx
   2463c:	83 d0 00             	adc    $0x0,%eax
   2463f:	89 54 24 10          	mov    %edx,0x10(%esp)
   24643:	89 44 24 14          	mov    %eax,0x14(%esp)
	put_fs_long(ti.a,(unsigned long *) addr);       // 存储到用户数据区中。
   24647:	8b 44 24 10          	mov    0x10(%esp),%eax
   2464b:	83 ec 08             	sub    $0x8,%esp
   2464e:	ff 74 24 24          	pushl  0x24(%esp)
   24652:	50                   	push   %eax
   24653:	e8 6b f8 ff ff       	call   23ec3 <put_fs_long>
   24658:	83 c4 10             	add    $0x10,%esp
	put_fs_long(ti.b,1 + (unsigned long *) addr);
   2465b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   2465f:	83 c0 04             	add    $0x4,%eax
   24662:	8b 54 24 14          	mov    0x14(%esp),%edx
   24666:	83 ec 08             	sub    $0x8,%esp
   24669:	50                   	push   %eax
   2466a:	52                   	push   %edx
   2466b:	e8 53 f8 ff ff       	call   23ec3 <put_fs_long>
   24670:	83 c4 10             	add    $0x10,%esp
}
   24673:	90                   	nop
   24674:	83 c4 28             	add    $0x28,%esp
   24677:	5b                   	pop    %ebx
   24678:	c3                   	ret    

00024679 <put_BCD>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，并验证保
// 存10字节BCD码的用户空间。然后把临时实数格式的结果转换成BCD码格式的数据并保存到用户内存中。如果是负数则设置最高存储字
// 节的最高有效位。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_BCD(const temp_real * tmp,struct info * info, unsigned short code)
{
   24679:	53                   	push   %ebx
   2467a:	83 ec 38             	sub    $0x38,%esp
   2467d:	e8 78 26 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   24682:	81 c3 7e d9 00 00    	add    $0xd97e,%ebx
   24688:	8b 44 24 48          	mov    0x48(%esp),%eax
   2468c:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	int k,rem;
	char * addr;
	temp_int i;
	unsigned char c;

	addr = ea(info,code);                   // 取有效地址。
   24691:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   24696:	83 ec 08             	sub    $0x8,%esp
   24699:	50                   	push   %eax
   2469a:	ff 74 24 50          	pushl  0x50(%esp)
   2469e:	e8 d3 f5 ff ff       	call   23c76 <ea>
   246a3:	83 c4 10             	add    $0x10,%esp
   246a6:	89 44 24 28          	mov    %eax,0x28(%esp)
	verify_area(addr,10);                   // 验证存储空间容量。
   246aa:	83 ec 08             	sub    $0x8,%esp
   246ad:	6a 0a                	push   $0xa
   246af:	ff 74 24 34          	pushl  0x34(%esp)
   246b3:	e8 43 42 fe ff       	call   88fb <verify_area>
   246b8:	83 c4 10             	add    $0x10,%esp
	real_to_int(tmp,&i);                    // 转换成临时整数格式。
   246bb:	83 ec 08             	sub    $0x8,%esp
   246be:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   246c2:	50                   	push   %eax
   246c3:	ff 74 24 4c          	pushl  0x4c(%esp)
   246c7:	e8 bb 0f 00 00       	call   25687 <real_to_int>
   246cc:	83 c4 10             	add    $0x10,%esp
	if (i.sign)                             // 若是负数，则设置符号字节最高有效位。
   246cf:	0f b7 44 24 1c       	movzwl 0x1c(%esp),%eax
   246d4:	66 85 c0             	test   %ax,%ax
   246d7:	74 17                	je     246f0 <put_BCD+0x77>
		put_fs_byte(0x80, addr+9);
   246d9:	8b 44 24 28          	mov    0x28(%esp),%eax
   246dd:	83 c0 09             	add    $0x9,%eax
   246e0:	83 ec 08             	sub    $0x8,%esp
   246e3:	50                   	push   %eax
   246e4:	6a 80                	push   $0xffffff80
   246e6:	e8 8e f7 ff ff       	call   23e79 <put_fs_byte>
   246eb:	83 c4 10             	add    $0x10,%esp
   246ee:	eb 15                	jmp    24705 <put_BCD+0x8c>
	else                                    // 否则符号字节设置为0。
		put_fs_byte(0, addr+9);
   246f0:	8b 44 24 28          	mov    0x28(%esp),%eax
   246f4:	83 c0 09             	add    $0x9,%eax
   246f7:	83 ec 08             	sub    $0x8,%esp
   246fa:	50                   	push   %eax
   246fb:	6a 00                	push   $0x0
   246fd:	e8 77 f7 ff ff       	call   23e79 <put_fs_byte>
   24702:	83 c4 10             	add    $0x10,%esp
	for (k = 0; k < 9; k++) {               // 临时整数转换成BCD码并保存。
   24705:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   2470c:	00 
   2470d:	eb 7e                	jmp    2478d <put_BCD+0x114>
		DIV10(i.a,i.b,rem);
   2470f:	8b 44 24 18          	mov    0x18(%esp),%eax
   24713:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   24717:	ba 00 00 00 00       	mov    $0x0,%edx
   2471c:	b9 0a 00 00 00       	mov    $0xa,%ecx
   24721:	f7 f1                	div    %ecx
   24723:	93                   	xchg   %eax,%ebx
   24724:	f7 f1                	div    %ecx
   24726:	89 54 24 24          	mov    %edx,0x24(%esp)
   2472a:	89 44 24 14          	mov    %eax,0x14(%esp)
   2472e:	89 5c 24 18          	mov    %ebx,0x18(%esp)
		c = rem;
   24732:	8b 44 24 24          	mov    0x24(%esp),%eax
   24736:	88 44 24 23          	mov    %al,0x23(%esp)
		DIV10(i.a,i.b,rem);
   2473a:	8b 44 24 18          	mov    0x18(%esp),%eax
   2473e:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   24742:	ba 00 00 00 00       	mov    $0x0,%edx
   24747:	b9 0a 00 00 00       	mov    $0xa,%ecx
   2474c:	f7 f1                	div    %ecx
   2474e:	93                   	xchg   %eax,%ebx
   2474f:	f7 f1                	div    %ecx
   24751:	89 54 24 24          	mov    %edx,0x24(%esp)
   24755:	89 44 24 14          	mov    %eax,0x14(%esp)
   24759:	89 5c 24 18          	mov    %ebx,0x18(%esp)
		c += rem<<4;
   2475d:	8b 44 24 24          	mov    0x24(%esp),%eax
   24761:	c1 e0 04             	shl    $0x4,%eax
   24764:	00 44 24 23          	add    %al,0x23(%esp)
		put_fs_byte(c,addr++);
   24768:	8b 44 24 28          	mov    0x28(%esp),%eax
   2476c:	8d 50 01             	lea    0x1(%eax),%edx
   2476f:	89 54 24 28          	mov    %edx,0x28(%esp)
   24773:	0f b6 54 24 23       	movzbl 0x23(%esp),%edx
   24778:	0f be d2             	movsbl %dl,%edx
   2477b:	83 ec 08             	sub    $0x8,%esp
   2477e:	50                   	push   %eax
   2477f:	52                   	push   %edx
   24780:	e8 f4 f6 ff ff       	call   23e79 <put_fs_byte>
   24785:	83 c4 10             	add    $0x10,%esp
	for (k = 0; k < 9; k++) {               // 临时整数转换成BCD码并保存。
   24788:	83 44 24 2c 01       	addl   $0x1,0x2c(%esp)
   2478d:	83 7c 24 2c 08       	cmpl   $0x8,0x2c(%esp)
   24792:	0f 8e 77 ff ff ff    	jle    2470f <put_BCD+0x96>
	}
   24798:	90                   	nop
   24799:	83 c4 38             	add    $0x38,%esp
   2479c:	5b                   	pop    %ebx
   2479d:	c3                   	ret    

0002479e <signify>:
	:"0" (a->a),"1" (a->b))

// 尾数符号化。
// 即把临时实数变换成指数和整数表示形式，便于仿真运算。因此这里称其为仿真格式。
static void signify(temp_real * a)
{
   2479e:	e8 4f 25 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   247a3:	05 5d d8 00 00       	add    $0xd85d,%eax
// 把64位二进制尾数右移2位（因此指数需要加2）。因为指针字段exponent的最高位是符号位，所以若指数值小于零，说明该数是负数。
// 于是则把尾数用补码表示（取负）。然后把指数取正值。此时尾数中不仅包含移过2位的有效数，而且还包含数值的符号位。
// 30行上：%0 - a->a；%1 - a->b。汇编指令“shrdl $2, %1, %0”执行双精度（64位）右移，即把组合尾数<b,a>右移2位。由于
// 该移动操作不会改变%1（a->b）中的值，因此还需要单独对其右移2位。
	a->exponent += 2;
   247a8:	8b 44 24 04          	mov    0x4(%esp),%eax
   247ac:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   247b0:	83 c0 02             	add    $0x2,%eax
   247b3:	89 c2                	mov    %eax,%edx
   247b5:	8b 44 24 04          	mov    0x4(%esp),%eax
   247b9:	66 89 50 08          	mov    %dx,0x8(%eax)
	__asm__("shrdl $2,%1,%0 ; shrl $2,%1"   // 使用双精度指令把尾数右移2位。
		:"=r" (a->a),"=r" (a->b)
		:"0" (a->a),"1" (a->b));
   247bd:	8b 44 24 04          	mov    0x4(%esp),%eax
   247c1:	8b 10                	mov    (%eax),%edx
   247c3:	8b 44 24 04          	mov    0x4(%esp),%eax
   247c7:	8b 40 04             	mov    0x4(%eax),%eax
	__asm__("shrdl $2,%1,%0 ; shrl $2,%1"   // 使用双精度指令把尾数右移2位。
   247ca:	0f ac c2 02          	shrd   $0x2,%eax,%edx
   247ce:	c1 e8 02             	shr    $0x2,%eax
   247d1:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   247d5:	89 11                	mov    %edx,(%ecx)
   247d7:	8b 54 24 04          	mov    0x4(%esp),%edx
   247db:	89 42 04             	mov    %eax,0x4(%edx)
	if (a->exponent < 0)                    // 是负数，则尾数用补码表示（取负值）。
   247de:	8b 44 24 04          	mov    0x4(%esp),%eax
   247e2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   247e6:	66 85 c0             	test   %ax,%ax
   247e9:	79 24                	jns    2480f <signify+0x71>
		NEGINT(a);
   247eb:	8b 44 24 04          	mov    0x4(%esp),%eax
   247ef:	8b 10                	mov    (%eax),%edx
   247f1:	8b 44 24 04          	mov    0x4(%esp),%eax
   247f5:	8b 40 04             	mov    0x4(%eax),%eax
   247f8:	f7 d2                	not    %edx
   247fa:	f7 d0                	not    %eax
   247fc:	83 c2 01             	add    $0x1,%edx
   247ff:	83 d0 00             	adc    $0x0,%eax
   24802:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   24806:	89 11                	mov    %edx,(%ecx)
   24808:	8b 54 24 04          	mov    0x4(%esp),%edx
   2480c:	89 42 04             	mov    %eax,0x4(%edx)
	a->exponent &= 0x7fff;                  // 去掉符号位（若有）。
   2480f:	8b 44 24 04          	mov    0x4(%esp),%eax
   24813:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   24817:	66 25 ff 7f          	and    $0x7fff,%ax
   2481b:	89 c2                	mov    %eax,%edx
   2481d:	8b 44 24 04          	mov    0x4(%esp),%eax
   24821:	66 89 50 08          	mov    %dx,0x8(%eax)
}
   24825:	90                   	nop
   24826:	c3                   	ret    

00024827 <unsignify>:

// 尾数非符号化。
// 将仿真格式转换为临时实数格式。即把指数和整数表示的实数转换为临时实数格式。
static void unsignify(temp_real * a)
{
   24827:	e8 c6 24 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   2482c:	05 d4 d7 00 00       	add    $0xd7d4,%eax
// 对于值为0的数不用处理，直接返回。否则，我们先复位临时实数格式的符号位。然后判断尾数的高位long字段a->b是否带有符号位。
// 若有，则在exponent字段添加符号位，同时把尾数用无符号数形式表示（取补）。最后对尾数进行规格化处理，同时指数值作相应递
// 减。即执行左移操作，使得尾数最高有效位不为0（最后a->b值表现为负值）。
	if (!(a->a || a->b)) {                          // 若值为0就返回。
   24831:	8b 44 24 04          	mov    0x4(%esp),%eax
   24835:	8b 00                	mov    (%eax),%eax
   24837:	85 c0                	test   %eax,%eax
   24839:	75 16                	jne    24851 <unsignify+0x2a>
   2483b:	8b 44 24 04          	mov    0x4(%esp),%eax
   2483f:	8b 40 04             	mov    0x4(%eax),%eax
   24842:	85 c0                	test   %eax,%eax
   24844:	75 0b                	jne    24851 <unsignify+0x2a>
		a->exponent = 0;
   24846:	8b 44 24 04          	mov    0x4(%esp),%eax
   2484a:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		return;
   24850:	c3                   	ret    
	}
	a->exponent &= 0x7fff;                          // 去掉符号位（若有）。
   24851:	8b 44 24 04          	mov    0x4(%esp),%eax
   24855:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   24859:	66 25 ff 7f          	and    $0x7fff,%ax
   2485d:	89 c2                	mov    %eax,%edx
   2485f:	8b 44 24 04          	mov    0x4(%esp),%eax
   24863:	66 89 50 08          	mov    %dx,0x8(%eax)
	if (a->b < 0) {                                 // 去负数，则尾数取正值。
   24867:	8b 44 24 04          	mov    0x4(%esp),%eax
   2486b:	8b 40 04             	mov    0x4(%eax),%eax
   2486e:	85 c0                	test   %eax,%eax
   24870:	79 6f                	jns    248e1 <unsignify+0xba>
		NEGINT(a);
   24872:	8b 44 24 04          	mov    0x4(%esp),%eax
   24876:	8b 10                	mov    (%eax),%edx
   24878:	8b 44 24 04          	mov    0x4(%esp),%eax
   2487c:	8b 40 04             	mov    0x4(%eax),%eax
   2487f:	f7 d2                	not    %edx
   24881:	f7 d0                	not    %eax
   24883:	83 c2 01             	add    $0x1,%edx
   24886:	83 d0 00             	adc    $0x0,%eax
   24889:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   2488d:	89 11                	mov    %edx,(%ecx)
   2488f:	8b 54 24 04          	mov    0x4(%esp),%edx
   24893:	89 42 04             	mov    %eax,0x4(%edx)
		a->exponent |= 0x8000;                  // 临时实数添加置符号位。
   24896:	8b 44 24 04          	mov    0x4(%esp),%eax
   2489a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2489e:	66 0d 00 80          	or     $0x8000,%ax
   248a2:	89 c2                	mov    %eax,%edx
   248a4:	8b 44 24 04          	mov    0x4(%esp),%eax
   248a8:	66 89 50 08          	mov    %dx,0x8(%eax)
	}
	while (a->b >= 0) {                             // 对尾数进行规格化处理。
   248ac:	eb 33                	jmp    248e1 <unsignify+0xba>
		a->exponent--;
   248ae:	8b 44 24 04          	mov    0x4(%esp),%eax
   248b2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   248b6:	83 e8 01             	sub    $0x1,%eax
   248b9:	89 c2                	mov    %eax,%edx
   248bb:	8b 44 24 04          	mov    0x4(%esp),%eax
   248bf:	66 89 50 08          	mov    %dx,0x8(%eax)
		__asm__("addl %0,%0 ; adcl %1,%1"
			:"=r" (a->a),"=r" (a->b)
			:"0" (a->a),"1" (a->b));
   248c3:	8b 44 24 04          	mov    0x4(%esp),%eax
   248c7:	8b 10                	mov    (%eax),%edx
   248c9:	8b 44 24 04          	mov    0x4(%esp),%eax
   248cd:	8b 40 04             	mov    0x4(%eax),%eax
		__asm__("addl %0,%0 ; adcl %1,%1"
   248d0:	01 d2                	add    %edx,%edx
   248d2:	11 c0                	adc    %eax,%eax
   248d4:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   248d8:	89 11                	mov    %edx,(%ecx)
   248da:	8b 54 24 04          	mov    0x4(%esp),%edx
   248de:	89 42 04             	mov    %eax,0x4(%edx)
	while (a->b >= 0) {                             // 对尾数进行规格化处理。
   248e1:	8b 44 24 04          	mov    0x4(%esp),%eax
   248e5:	8b 40 04             	mov    0x4(%eax),%eax
   248e8:	85 c0                	test   %eax,%eax
   248ea:	79 c2                	jns    248ae <unsignify+0x87>
	}
}
   248ec:	c3                   	ret    

000248ed <fadd>:

// 仿真浮点加法指令运算。
// 临时实数参数src1 + src2 -> result。
void fadd(const temp_real * src1, const temp_real * src2, temp_real * result)
{
   248ed:	53                   	push   %ebx
   248ee:	83 ec 30             	sub    $0x30,%esp
   248f1:	e8 fc 23 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   248f6:	05 0a d7 00 00       	add    $0xd70a,%eax
	temp_real a,b;
	int x1,x2,shift;

// 首先取两个数的指数值x1、x2（去掉符号位）。然后让变量a等于基中最大值，shift为指数差值（即相差2的倍数值）。
	x1 = src1->exponent & 0x7fff;
   248fb:	8b 44 24 38          	mov    0x38(%esp),%eax
   248ff:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   24903:	98                   	cwtl   
   24904:	25 ff 7f 00 00       	and    $0x7fff,%eax
   24909:	89 44 24 28          	mov    %eax,0x28(%esp)
	x2 = src2->exponent & 0x7fff;
   2490d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   24911:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   24915:	98                   	cwtl   
   24916:	25 ff 7f 00 00       	and    $0x7fff,%eax
   2491b:	89 44 24 24          	mov    %eax,0x24(%esp)
	if (x1 > x2) {
   2491f:	8b 44 24 28          	mov    0x28(%esp),%eax
   24923:	3b 44 24 24          	cmp    0x24(%esp),%eax
   24927:	7e 3e                	jle    24967 <fadd+0x7a>
		a = *src1;
   24929:	8b 44 24 38          	mov    0x38(%esp),%eax
   2492d:	8b 10                	mov    (%eax),%edx
   2492f:	89 54 24 18          	mov    %edx,0x18(%esp)
   24933:	8b 50 04             	mov    0x4(%eax),%edx
   24936:	89 54 24 1c          	mov    %edx,0x1c(%esp)
   2493a:	8b 40 08             	mov    0x8(%eax),%eax
   2493d:	89 44 24 20          	mov    %eax,0x20(%esp)
		b = *src2;
   24941:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   24945:	8b 10                	mov    (%eax),%edx
   24947:	89 54 24 0c          	mov    %edx,0xc(%esp)
   2494b:	8b 50 04             	mov    0x4(%eax),%edx
   2494e:	89 54 24 10          	mov    %edx,0x10(%esp)
   24952:	8b 40 08             	mov    0x8(%eax),%eax
   24955:	89 44 24 14          	mov    %eax,0x14(%esp)
		shift = x1-x2;
   24959:	8b 44 24 28          	mov    0x28(%esp),%eax
   2495d:	2b 44 24 24          	sub    0x24(%esp),%eax
   24961:	89 44 24 2c          	mov    %eax,0x2c(%esp)
   24965:	eb 3c                	jmp    249a3 <fadd+0xb6>
	} else {
		a = *src2;
   24967:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   2496b:	8b 10                	mov    (%eax),%edx
   2496d:	89 54 24 18          	mov    %edx,0x18(%esp)
   24971:	8b 50 04             	mov    0x4(%eax),%edx
   24974:	89 54 24 1c          	mov    %edx,0x1c(%esp)
   24978:	8b 40 08             	mov    0x8(%eax),%eax
   2497b:	89 44 24 20          	mov    %eax,0x20(%esp)
		b = *src1;
   2497f:	8b 44 24 38          	mov    0x38(%esp),%eax
   24983:	8b 10                	mov    (%eax),%edx
   24985:	89 54 24 0c          	mov    %edx,0xc(%esp)
   24989:	8b 50 04             	mov    0x4(%eax),%edx
   2498c:	89 54 24 10          	mov    %edx,0x10(%esp)
   24990:	8b 40 08             	mov    0x8(%eax),%eax
   24993:	89 44 24 14          	mov    %eax,0x14(%esp)
		shift = x2-x1;
   24997:	8b 44 24 24          	mov    0x24(%esp),%eax
   2499b:	2b 44 24 28          	sub    0x28(%esp),%eax
   2499f:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	}
// 若两者相差太大，大于等于2的64次方，则我们可以忽略小的那个数，即b值。于是直接返回a值即可。否则，若相差大于等于2的32次
// 方，那么我们可以忽略小值b中的低32位值。于是我们把b的高long字段值b.b右移32位，即放到b.a中。然后把b的指数值相应地增加
// 32次方。即指数差值减去32。这样调整之后，相加的两个数的尾数基本上落在相同区域中。
	if (shift >= 64) {
   249a3:	83 7c 24 2c 3f       	cmpl   $0x3f,0x2c(%esp)
   249a8:	7e 1d                	jle    249c7 <fadd+0xda>
		*result = a;
   249aa:	8b 44 24 40          	mov    0x40(%esp),%eax
   249ae:	8b 54 24 18          	mov    0x18(%esp),%edx
   249b2:	89 10                	mov    %edx,(%eax)
   249b4:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   249b8:	89 50 04             	mov    %edx,0x4(%eax)
   249bb:	8b 54 24 20          	mov    0x20(%esp),%edx
   249bf:	89 50 08             	mov    %edx,0x8(%eax)
   249c2:	e9 90 00 00 00       	jmp    24a57 <fadd+0x16a>
		return;
	}
	if (shift >= 32) {
   249c7:	83 7c 24 2c 1f       	cmpl   $0x1f,0x2c(%esp)
   249cc:	7e 15                	jle    249e3 <fadd+0xf6>
		b.a = b.b;
   249ce:	8b 44 24 10          	mov    0x10(%esp),%eax
   249d2:	89 44 24 0c          	mov    %eax,0xc(%esp)
		b.b = 0;
   249d6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   249dd:	00 
		shift -= 32;
   249de:	83 6c 24 2c 20       	subl   $0x20,0x2c(%esp)
	}
// 接着再进行细致的调整，以将相加两者调整成相同。调整方法是把小值b的尾数右移shift各位。这样两者的指数相同，处于同一个数量级。
// 我们就要以对尾数进行相加运算了。相加之前我们需要先把它们转换成仿真运算格式。在加法运算后再变换回临时实数格式。
	__asm__("shrdl %4,%1,%0 ; shrl %4,%1"                   // 双精度（64位）右移。
		:"=r" (b.a),"=r" (b.b)
		:"0" (b.a),"1" (b.b),"c" ((char) shift));
   249e3:	8b 54 24 0c          	mov    0xc(%esp),%edx
   249e7:	8b 44 24 10          	mov    0x10(%esp),%eax
   249eb:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
	__asm__("shrdl %4,%1,%0 ; shrl %4,%1"                   // 双精度（64位）右移。
   249ef:	0f ad c2             	shrd   %cl,%eax,%edx
   249f2:	d3 e8                	shr    %cl,%eax
   249f4:	89 54 24 0c          	mov    %edx,0xc(%esp)
   249f8:	89 44 24 10          	mov    %eax,0x10(%esp)
	signify(&a);                                            // 变换格式。
   249fc:	8d 44 24 18          	lea    0x18(%esp),%eax
   24a00:	50                   	push   %eax
   24a01:	e8 98 fd ff ff       	call   2479e <signify>
   24a06:	83 c4 04             	add    $0x4,%esp
	signify(&b);
   24a09:	8d 44 24 0c          	lea    0xc(%esp),%eax
   24a0d:	50                   	push   %eax
   24a0e:	e8 8b fd ff ff       	call   2479e <signify>
   24a13:	83 c4 04             	add    $0x4,%esp
	__asm__("addl %4,%0 ; adcl %5,%1"                       // 执行加法运算。
		:"=r" (a.a),"=r" (a.b)
		:"0" (a.a),"1" (a.b),"g" (b.a),"g" (b.b));
   24a16:	8b 54 24 18          	mov    0x18(%esp),%edx
   24a1a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   24a1e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   24a22:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	__asm__("addl %4,%0 ; adcl %5,%1"                       // 执行加法运算。
   24a26:	01 ca                	add    %ecx,%edx
   24a28:	11 d8                	adc    %ebx,%eax
   24a2a:	89 54 24 18          	mov    %edx,0x18(%esp)
   24a2e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	unsignify(&a);                                          // 再变换回临时实数格式。
   24a32:	8d 44 24 18          	lea    0x18(%esp),%eax
   24a36:	50                   	push   %eax
   24a37:	e8 eb fd ff ff       	call   24827 <unsignify>
   24a3c:	83 c4 04             	add    $0x4,%esp
	*result = a;
   24a3f:	8b 44 24 40          	mov    0x40(%esp),%eax
   24a43:	8b 54 24 18          	mov    0x18(%esp),%edx
   24a47:	89 10                	mov    %edx,(%eax)
   24a49:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   24a4d:	89 50 04             	mov    %edx,0x4(%eax)
   24a50:	8b 54 24 20          	mov    0x20(%esp),%edx
   24a54:	89 50 08             	mov    %edx,0x8(%eax)
}
   24a57:	83 c4 30             	add    $0x30,%esp
   24a5a:	5b                   	pop    %ebx
   24a5b:	c3                   	ret    

00024a5c <shift>:

#include <linux/math_emu.h>

// 把c指针处的16字节值左移1位（乘2）。
static void shift(int * c)
{
   24a5c:	e8 91 22 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   24a61:	05 9f d5 00 00       	add    $0xd59f,%eax
	__asm__("movl (%0),%%eax ; addl %%eax,(%0)\n\t"
		"movl 4(%0),%%eax ; adcl %%eax,4(%0)\n\t"
		"movl 8(%0),%%eax ; adcl %%eax,8(%0)\n\t"
		"movl 12(%0),%%eax ; adcl %%eax,12(%0)"
		::"r" ((long) c):"ax");
   24a66:	8b 54 24 04          	mov    0x4(%esp),%edx
	__asm__("movl (%0),%%eax ; addl %%eax,(%0)\n\t"
   24a6a:	8b 02                	mov    (%edx),%eax
   24a6c:	01 02                	add    %eax,(%edx)
   24a6e:	8b 42 04             	mov    0x4(%edx),%eax
   24a71:	11 42 04             	adc    %eax,0x4(%edx)
   24a74:	8b 42 08             	mov    0x8(%edx),%eax
   24a77:	11 42 08             	adc    %eax,0x8(%edx)
   24a7a:	8b 42 0c             	mov    0xc(%edx),%eax
   24a7d:	11 42 0c             	adc    %eax,0xc(%edx)
}
   24a80:	90                   	nop
   24a81:	c3                   	ret    

00024a82 <mul64>:

// 2个临时实数相乘，结果放在c指针处（16字节）。
static void mul64(const temp_real * a, const temp_real * b, int * c)
{
   24a82:	57                   	push   %edi
   24a83:	56                   	push   %esi
   24a84:	53                   	push   %ebx
   24a85:	e8 68 22 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   24a8a:	05 76 d5 00 00       	add    $0xd576,%eax
		"movl 4(%0),%%eax\n\t"          // 取a->b的值到eax。
		"mull (%1)\n\t"                 // 与b->a的值相乘。
		"addl %%eax,4(%2)\n\t"          // 乘积的低位与c[1]相加放入c[1]。
		"adcl %%edx,8(%2)\n\t"          // 乘积的高位与c[2]相加再加进位，然后放入a[2]。
		"adcl $0,12(%2)"                // 把0与c[3]相加再加进位，然后放入c[3]。
		::"b" ((long) a),"c" ((long) b),"D" ((long) c)
   24a8f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   24a93:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   24a97:	8b 74 24 18          	mov    0x18(%esp),%esi
	__asm__("movl (%0),%%eax\n\t"           // 取a->a的值到eax。
   24a9b:	89 f7                	mov    %esi,%edi
   24a9d:	8b 03                	mov    (%ebx),%eax
   24a9f:	f7 21                	mull   (%ecx)
   24aa1:	89 07                	mov    %eax,(%edi)
   24aa3:	89 57 04             	mov    %edx,0x4(%edi)
   24aa6:	8b 43 04             	mov    0x4(%ebx),%eax
   24aa9:	f7 61 04             	mull   0x4(%ecx)
   24aac:	89 47 08             	mov    %eax,0x8(%edi)
   24aaf:	89 57 0c             	mov    %edx,0xc(%edi)
   24ab2:	8b 03                	mov    (%ebx),%eax
   24ab4:	f7 61 04             	mull   0x4(%ecx)
   24ab7:	01 47 04             	add    %eax,0x4(%edi)
   24aba:	11 57 08             	adc    %edx,0x8(%edi)
   24abd:	83 57 0c 00          	adcl   $0x0,0xc(%edi)
   24ac1:	8b 43 04             	mov    0x4(%ebx),%eax
   24ac4:	f7 21                	mull   (%ecx)
   24ac6:	01 47 04             	add    %eax,0x4(%edi)
   24ac9:	11 57 08             	adc    %edx,0x8(%edi)
   24acc:	83 57 0c 00          	adcl   $0x0,0xc(%edi)
		:"ax","dx");
}
   24ad0:	90                   	nop
   24ad1:	5b                   	pop    %ebx
   24ad2:	5e                   	pop    %esi
   24ad3:	5f                   	pop    %edi
   24ad4:	c3                   	ret    

00024ad5 <fmul>:

// 仿真浮点指令FMUL。
// 临时实数src1 * src2 -> result处。
void fmul(const temp_real * src1, const temp_real * src2, temp_real * result)
{
   24ad5:	83 ec 20             	sub    $0x20,%esp
   24ad8:	e8 15 22 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   24add:	05 23 d5 00 00       	add    $0xd523,%eax
	int i,sign;
	int tmp[4] = {0,0,0,0};
   24ae2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   24ae9:	00 
   24aea:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   24af1:	00 
   24af2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   24af9:	00 
   24afa:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   24b01:	00 

// 首先确定两数相乘的符号。符号值等于两者符号位异或值。然后计算乘后的指数值。相乘时指数值需要相加。但是由于指数使用偏置
// 格式保存，两个数的指数相加时偏置量也被加了两次，因此需要减掉一个偏置量值（临时实数的偏置量是16383）。
	sign = (src1->exponent ^ src2->exponent) & 0x8000;
   24b02:	8b 54 24 24          	mov    0x24(%esp),%edx
   24b06:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
   24b0a:	8b 54 24 28          	mov    0x28(%esp),%edx
   24b0e:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   24b12:	31 ca                	xor    %ecx,%edx
   24b14:	0f bf d2             	movswl %dx,%edx
   24b17:	81 e2 00 80 00 00    	and    $0x8000,%edx
   24b1d:	89 54 24 18          	mov    %edx,0x18(%esp)
	i = (src1->exponent & 0x7fff) + (src2->exponent & 0x7fff) - 16383 + 1;
   24b21:	8b 54 24 24          	mov    0x24(%esp),%edx
   24b25:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   24b29:	0f bf d2             	movswl %dx,%edx
   24b2c:	89 d1                	mov    %edx,%ecx
   24b2e:	81 e1 ff 7f 00 00    	and    $0x7fff,%ecx
   24b34:	8b 54 24 28          	mov    0x28(%esp),%edx
   24b38:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   24b3c:	0f bf d2             	movswl %dx,%edx
   24b3f:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
   24b45:	01 ca                	add    %ecx,%edx
   24b47:	81 ea fe 3f 00 00    	sub    $0x3ffe,%edx
   24b4d:	89 54 24 1c          	mov    %edx,0x1c(%esp)
// 如果结果指数变成了负值，表示两数相乘后产生下溢。于是直接返回带符号的零值。如果结果指数大于0x7fff，表示产生上溢，于是
// 设置状态字溢出异常标志位，并返回。
	if (i<0) {
   24b51:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   24b56:	79 2b                	jns    24b83 <fmul+0xae>
		result->exponent = sign;
   24b58:	8b 44 24 18          	mov    0x18(%esp),%eax
   24b5c:	89 c2                	mov    %eax,%edx
   24b5e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24b62:	66 89 50 08          	mov    %dx,0x8(%eax)
		result->a = result->b = 0;
   24b66:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24b6a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   24b71:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24b75:	8b 50 04             	mov    0x4(%eax),%edx
   24b78:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24b7c:	89 10                	mov    %edx,(%eax)
		return;
   24b7e:	e9 bc 00 00 00       	jmp    24c3f <fmul+0x16a>
	}
	if (i>0x7fff) {
   24b83:	81 7c 24 1c ff 7f 00 	cmpl   $0x7fff,0x1c(%esp)
   24b8a:	00 
   24b8b:	7e 24                	jle    24bb1 <fmul+0xdc>
		set_OE();       // 置位溢出标志位。
   24b8d:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   24b93:	8b 12                	mov    (%edx),%edx
   24b95:	8b 92 1c 04 00 00    	mov    0x41c(%edx),%edx
   24b9b:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24ba1:	8b 00                	mov    (%eax),%eax
   24ba3:	83 ca 08             	or     $0x8,%edx
   24ba6:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
		return;
   24bac:	e9 8e 00 00 00       	jmp    24c3f <fmul+0x16a>
	}
// 如果两数尾数相乘后结果不为0，则对结果尾数进行规格化处理。即左移结果尾数值，使得最高有效位为1。同时相应地调整指数值。如果
// 两数相乘后16字节的结尾数为0，则也设置指数值为0。最后把相乘结果保存在临时实数变量result中。
	mul64(src1,src2,tmp);
   24bb1:	8d 44 24 08          	lea    0x8(%esp),%eax
   24bb5:	50                   	push   %eax
   24bb6:	ff 74 24 2c          	pushl  0x2c(%esp)
   24bba:	ff 74 24 2c          	pushl  0x2c(%esp)
   24bbe:	e8 bf fe ff ff       	call   24a82 <mul64>
   24bc3:	83 c4 0c             	add    $0xc,%esp
	if (tmp[0] || tmp[1] || tmp[2] || tmp[3])
   24bc6:	8b 44 24 08          	mov    0x8(%esp),%eax
   24bca:	85 c0                	test   %eax,%eax
   24bcc:	75 2c                	jne    24bfa <fmul+0x125>
   24bce:	8b 44 24 0c          	mov    0xc(%esp),%eax
   24bd2:	85 c0                	test   %eax,%eax
   24bd4:	75 24                	jne    24bfa <fmul+0x125>
   24bd6:	8b 44 24 10          	mov    0x10(%esp),%eax
   24bda:	85 c0                	test   %eax,%eax
   24bdc:	75 1c                	jne    24bfa <fmul+0x125>
   24bde:	8b 44 24 14          	mov    0x14(%esp),%eax
   24be2:	85 c0                	test   %eax,%eax
   24be4:	74 25                	je     24c0b <fmul+0x136>
		while (i && tmp[3] >= 0) {
   24be6:	eb 12                	jmp    24bfa <fmul+0x125>
			i--;
   24be8:	83 6c 24 1c 01       	subl   $0x1,0x1c(%esp)
			shift(tmp);
   24bed:	8d 44 24 08          	lea    0x8(%esp),%eax
   24bf1:	50                   	push   %eax
   24bf2:	e8 65 fe ff ff       	call   24a5c <shift>
   24bf7:	83 c4 04             	add    $0x4,%esp
		while (i && tmp[3] >= 0) {
   24bfa:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   24bff:	74 14                	je     24c15 <fmul+0x140>
   24c01:	8b 44 24 14          	mov    0x14(%esp),%eax
   24c05:	85 c0                	test   %eax,%eax
   24c07:	79 df                	jns    24be8 <fmul+0x113>
	if (tmp[0] || tmp[1] || tmp[2] || tmp[3])
   24c09:	eb 0a                	jmp    24c15 <fmul+0x140>
		}
	else
		i = 0;
   24c0b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   24c12:	00 
   24c13:	eb 01                	jmp    24c16 <fmul+0x141>
	if (tmp[0] || tmp[1] || tmp[2] || tmp[3])
   24c15:	90                   	nop
	result->exponent = i | sign;
   24c16:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   24c1a:	89 c2                	mov    %eax,%edx
   24c1c:	8b 44 24 18          	mov    0x18(%esp),%eax
   24c20:	09 c2                	or     %eax,%edx
   24c22:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24c26:	66 89 50 08          	mov    %dx,0x8(%eax)
	result->a = tmp[2];
   24c2a:	8b 54 24 10          	mov    0x10(%esp),%edx
   24c2e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24c32:	89 10                	mov    %edx,(%eax)
	result->b = tmp[3];
   24c34:	8b 54 24 14          	mov    0x14(%esp),%edx
   24c38:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24c3c:	89 50 04             	mov    %edx,0x4(%eax)
}
   24c3f:	83 c4 20             	add    $0x20,%esp
   24c42:	c3                   	ret    

00024c43 <shift_left>:

#include <linux/math_emu.h>

// 将指针c指向的4字节中内容左移1位。
static void shift_left(int * c)
{
   24c43:	e8 aa 20 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   24c48:	05 b8 d3 00 00       	add    $0xd3b8,%eax
	__asm__ __volatile__("movl (%0),%%eax ; addl %%eax,(%0)\n\t"
		"movl 4(%0),%%eax ; adcl %%eax,4(%0)\n\t"
		"movl 8(%0),%%eax ; adcl %%eax,8(%0)\n\t"
		"movl 12(%0),%%eax ; adcl %%eax,12(%0)"
		::"r" ((long) c):"ax");
   24c4d:	8b 54 24 04          	mov    0x4(%esp),%edx
	__asm__ __volatile__("movl (%0),%%eax ; addl %%eax,(%0)\n\t"
   24c51:	8b 02                	mov    (%edx),%eax
   24c53:	01 02                	add    %eax,(%edx)
   24c55:	8b 42 04             	mov    0x4(%edx),%eax
   24c58:	11 42 04             	adc    %eax,0x4(%edx)
   24c5b:	8b 42 08             	mov    0x8(%edx),%eax
   24c5e:	11 42 08             	adc    %eax,0x8(%edx)
   24c61:	8b 42 0c             	mov    0xc(%edx),%eax
   24c64:	11 42 0c             	adc    %eax,0xc(%edx)
}
   24c67:	90                   	nop
   24c68:	c3                   	ret    

00024c69 <shift_right>:

// 将指针c指向的4字节中内容右移1位。
static void shift_right(int * c)
{
   24c69:	e8 84 20 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   24c6e:	05 92 d3 00 00       	add    $0xd392,%eax
	__asm__("shrl $1,12(%0) ; rcrl $1,8(%0) ; rcrl $1,4(%0) ; rcrl $1,(%0)"
		::"r" ((long) c));
   24c73:	8b 44 24 04          	mov    0x4(%esp),%eax
	__asm__("shrl $1,12(%0) ; rcrl $1,8(%0) ; rcrl $1,4(%0) ; rcrl $1,(%0)"
   24c77:	d1 68 0c             	shrl   0xc(%eax)
   24c7a:	d1 58 08             	rcrl   0x8(%eax)
   24c7d:	d1 58 04             	rcrl   0x4(%eax)
   24c80:	d1 18                	rcrl   (%eax)
}
   24c82:	90                   	nop
   24c83:	c3                   	ret    

00024c84 <try_sub>:

// 减法运算。
// 16字节减法运算，b-a ->a。最后根据是否有借位（CF=1）设置OK。若无借位（CF=0）则ok = 1。否则ok = 0。
static int try_sub(int * a, int * b)
{
   24c84:	83 ec 10             	sub    $0x10,%esp
   24c87:	e8 66 20 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   24c8c:	05 74 d3 00 00       	add    $0xd374,%eax

	__asm__ __volatile__("movl (%1),%%eax ; subl %%eax,(%2)\n\t"
		"movl 4(%1),%%eax ; sbbl %%eax,4(%2)\n\t"
		"movl 8(%1),%%eax ; sbbl %%eax,8(%2)\n\t"
		"movl 12(%1),%%eax ; sbbl %%eax,12(%2)\n\t"
		"setae %%al":"=a" (ok):"c" ((long) a),"d" ((long) b));
   24c91:	8b 44 24 14          	mov    0x14(%esp),%eax
   24c95:	8b 54 24 18          	mov    0x18(%esp),%edx
	__asm__ __volatile__("movl (%1),%%eax ; subl %%eax,(%2)\n\t"
   24c99:	89 c1                	mov    %eax,%ecx
   24c9b:	8b 01                	mov    (%ecx),%eax
   24c9d:	29 02                	sub    %eax,(%edx)
   24c9f:	8b 41 04             	mov    0x4(%ecx),%eax
   24ca2:	19 42 04             	sbb    %eax,0x4(%edx)
   24ca5:	8b 41 08             	mov    0x8(%ecx),%eax
   24ca8:	19 42 08             	sbb    %eax,0x8(%edx)
   24cab:	8b 41 0c             	mov    0xc(%ecx),%eax
   24cae:	19 42 0c             	sbb    %eax,0xc(%edx)
   24cb1:	0f 93 c0             	setae  %al
   24cb4:	88 44 24 0f          	mov    %al,0xf(%esp)
	return ok;
   24cb8:	0f be 44 24 0f       	movsbl 0xf(%esp),%eax
}
   24cbd:	83 c4 10             	add    $0x10,%esp
   24cc0:	c3                   	ret    

00024cc1 <div64>:

// 16字节除法。
// 参数a/b -> c。利用减法模拟多字节除法。
static void div64(int * a, int * b, int * c)
{
   24cc1:	83 ec 20             	sub    $0x20,%esp
   24cc4:	e8 29 20 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   24cc9:	05 37 d3 00 00       	add    $0xd337,%eax
	int tmp[4];     // 余数变量。
	int i;
	unsigned int mask = 0;  // 操作位。
   24cce:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   24cd5:	00 

	c += 4;
   24cd6:	83 44 24 2c 10       	addl   $0x10,0x2c(%esp)
// 16字节共64位。
	for (i = 0 ; i<64 ; i++) {
   24cdb:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   24ce2:	00 
   24ce3:	e9 ac 00 00 00       	jmp    24d94 <div64+0xd3>
		if (!(mask >>= 1)) {
   24ce8:	d1 6c 24 18          	shrl   0x18(%esp)
   24cec:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   24cf1:	75 0d                	jne    24d00 <div64+0x3f>
			c--;
   24cf3:	83 6c 24 2c 04       	subl   $0x4,0x2c(%esp)
			mask = 0x80000000;
   24cf8:	c7 44 24 18 00 00 00 	movl   $0x80000000,0x18(%esp)
   24cff:	80 
		}
// 把余数值tmp初始化为a值。
		tmp[0] = a[0]; tmp[1] = a[1];
   24d00:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d04:	8b 00                	mov    (%eax),%eax
   24d06:	89 44 24 08          	mov    %eax,0x8(%esp)
   24d0a:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d0e:	8b 40 04             	mov    0x4(%eax),%eax
   24d11:	89 44 24 0c          	mov    %eax,0xc(%esp)
		tmp[2] = a[2]; tmp[3] = a[3];
   24d15:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d19:	8b 40 08             	mov    0x8(%eax),%eax
   24d1c:	89 44 24 10          	mov    %eax,0x10(%esp)
   24d20:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d24:	8b 40 0c             	mov    0xc(%eax),%eax
   24d27:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (try_sub(b,tmp)) {           // 是否有借位。
   24d2b:	8d 44 24 08          	lea    0x8(%esp),%eax
   24d2f:	50                   	push   %eax
   24d30:	ff 74 24 2c          	pushl  0x2c(%esp)
   24d34:	e8 4b ff ff ff       	call   24c84 <try_sub>
   24d39:	83 c4 08             	add    $0x8,%esp
   24d3c:	85 c0                	test   %eax,%eax
   24d3e:	74 43                	je     24d83 <div64+0xc2>
			*c |= mask;             // 如果无借位，置当前操作位，把余数存入a，用于下次操作。
   24d40:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24d44:	8b 00                	mov    (%eax),%eax
   24d46:	0b 44 24 18          	or     0x18(%esp),%eax
   24d4a:	89 c2                	mov    %eax,%edx
   24d4c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24d50:	89 10                	mov    %edx,(%eax)
			a[0] = tmp[0]; a[1] = tmp[1];
   24d52:	8b 54 24 08          	mov    0x8(%esp),%edx
   24d56:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d5a:	89 10                	mov    %edx,(%eax)
   24d5c:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d60:	8d 50 04             	lea    0x4(%eax),%edx
   24d63:	8b 44 24 0c          	mov    0xc(%esp),%eax
   24d67:	89 02                	mov    %eax,(%edx)
			a[2] = tmp[2]; a[3] = tmp[3];
   24d69:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d6d:	8d 50 08             	lea    0x8(%eax),%edx
   24d70:	8b 44 24 10          	mov    0x10(%esp),%eax
   24d74:	89 02                	mov    %eax,(%edx)
   24d76:	8b 44 24 24          	mov    0x24(%esp),%eax
   24d7a:	8d 50 0c             	lea    0xc(%eax),%edx
   24d7d:	8b 44 24 14          	mov    0x14(%esp),%eax
   24d81:	89 02                	mov    %eax,(%edx)
		}
		shift_right(b);         // 右移一位，使b的值与值数处于同一级别。
   24d83:	ff 74 24 28          	pushl  0x28(%esp)
   24d87:	e8 dd fe ff ff       	call   24c69 <shift_right>
   24d8c:	83 c4 04             	add    $0x4,%esp
	for (i = 0 ; i<64 ; i++) {
   24d8f:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   24d94:	83 7c 24 1c 3f       	cmpl   $0x3f,0x1c(%esp)
   24d99:	0f 8e 49 ff ff ff    	jle    24ce8 <div64+0x27>
	}
}
   24d9f:	90                   	nop
   24da0:	83 c4 20             	add    $0x20,%esp
   24da3:	c3                   	ret    

00024da4 <fdiv>:

// 仿真浮点指令FDIV。
// 临时实数src1 / src2 -> result处。
void fdiv(const temp_real * src1, const temp_real * src2, temp_real * result)
{
   24da4:	53                   	push   %ebx
   24da5:	83 ec 40             	sub    $0x40,%esp
   24da8:	e8 4d 1f fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   24dad:	81 c3 53 d2 00 00    	add    $0xd253,%ebx
	int i,sign;
	int a[4],b[4],tmp[4] = {0,0,0,0};
   24db3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   24dba:	00 
   24dbb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   24dc2:	00 
   24dc3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   24dca:	00 
   24dcb:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   24dd2:	00 

// 首先确定两个数相除的符号。符号值等于两者符号位异或值。然后判断除数src2值是否为0，如果是，则置被零除异常。
	sign = (src1->exponent ^ src2->exponent) & 0x8000;
   24dd3:	8b 44 24 48          	mov    0x48(%esp),%eax
   24dd7:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   24ddb:	8b 44 24 4c          	mov    0x4c(%esp),%eax
   24ddf:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   24de3:	31 d0                	xor    %edx,%eax
   24de5:	98                   	cwtl   
   24de6:	25 00 80 00 00       	and    $0x8000,%eax
   24deb:	89 44 24 38          	mov    %eax,0x38(%esp)
	if (!(src2->a || src2->b)) {
   24def:	8b 44 24 4c          	mov    0x4c(%esp),%eax
   24df3:	8b 00                	mov    (%eax),%eax
   24df5:	85 c0                	test   %eax,%eax
   24df7:	75 2f                	jne    24e28 <fdiv+0x84>
   24df9:	8b 44 24 4c          	mov    0x4c(%esp),%eax
   24dfd:	8b 40 04             	mov    0x4(%eax),%eax
   24e00:	85 c0                	test   %eax,%eax
   24e02:	75 24                	jne    24e28 <fdiv+0x84>
		set_ZE();               // 置被零除异常。
   24e04:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24e0a:	8b 00                	mov    (%eax),%eax
   24e0c:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   24e12:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24e18:	8b 00                	mov    (%eax),%eax
   24e1a:	83 ca 04             	or     $0x4,%edx
   24e1d:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
		return;
   24e23:	e9 f0 01 00 00       	jmp    25018 <fdiv+0x274>
	}
// 然后计算除后的指数值。相除时指数值需要相减。但是由于指数使用偏置格式保存，两个数的指数相减时偏置量也被减去了，因此需
// 要加上偏置量值（临时实数的偏置量是16383）。
        i = (src1->exponent & 0x7fff) - (src2->exponent & 0x7fff) + 16383;
   24e28:	8b 44 24 48          	mov    0x48(%esp),%eax
   24e2c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   24e30:	98                   	cwtl   
   24e31:	25 ff 7f 00 00       	and    $0x7fff,%eax
   24e36:	89 c2                	mov    %eax,%edx
   24e38:	8b 44 24 4c          	mov    0x4c(%esp),%eax
   24e3c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   24e40:	98                   	cwtl   
   24e41:	25 ff 7f 00 00       	and    $0x7fff,%eax
   24e46:	29 c2                	sub    %eax,%edx
   24e48:	89 d0                	mov    %edx,%eax
   24e4a:	05 ff 3f 00 00       	add    $0x3fff,%eax
   24e4f:	89 44 24 3c          	mov    %eax,0x3c(%esp)
// 如果结果指数变成了负值，表示两数相除后产生下溢。于是直接返回带符号的零值。
	if (i<0) {
   24e53:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
   24e58:	79 4a                	jns    24ea4 <fdiv+0x100>
		set_UE();
   24e5a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24e60:	8b 00                	mov    (%eax),%eax
   24e62:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   24e68:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24e6e:	8b 00                	mov    (%eax),%eax
   24e70:	83 ca 10             	or     $0x10,%edx
   24e73:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
		result->exponent = sign;        // 设置符号位。
   24e79:	8b 44 24 38          	mov    0x38(%esp),%eax
   24e7d:	89 c2                	mov    %eax,%edx
   24e7f:	8b 44 24 50          	mov    0x50(%esp),%eax
   24e83:	66 89 50 08          	mov    %dx,0x8(%eax)
		result->a = result->b = 0;      // 设置返回值为0。
   24e87:	8b 44 24 50          	mov    0x50(%esp),%eax
   24e8b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   24e92:	8b 44 24 50          	mov    0x50(%esp),%eax
   24e96:	8b 50 04             	mov    0x4(%eax),%edx
   24e99:	8b 44 24 50          	mov    0x50(%esp),%eax
   24e9d:	89 10                	mov    %edx,(%eax)
		return;
   24e9f:	e9 74 01 00 00       	jmp    25018 <fdiv+0x274>
	}
// 把临时实数src1、src2有效数放入整型数组a和b。
	a[0] = a[1] = 0;
   24ea4:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   24eab:	00 
   24eac:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   24eb0:	89 44 24 28          	mov    %eax,0x28(%esp)
	a[2] = src1->a;
   24eb4:	8b 44 24 48          	mov    0x48(%esp),%eax
   24eb8:	8b 00                	mov    (%eax),%eax
   24eba:	89 44 24 30          	mov    %eax,0x30(%esp)
	a[3] = src1->b;
   24ebe:	8b 44 24 48          	mov    0x48(%esp),%eax
   24ec2:	8b 40 04             	mov    0x4(%eax),%eax
   24ec5:	89 44 24 34          	mov    %eax,0x34(%esp)
	b[0] = b[1] = 0;
   24ec9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   24ed0:	00 
   24ed1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   24ed5:	89 44 24 18          	mov    %eax,0x18(%esp)
	b[2] = src2->a;
   24ed9:	8b 44 24 4c          	mov    0x4c(%esp),%eax
   24edd:	8b 00                	mov    (%eax),%eax
   24edf:	89 44 24 20          	mov    %eax,0x20(%esp)
	b[3] = src2->b;
   24ee3:	8b 44 24 4c          	mov    0x4c(%esp),%eax
   24ee7:	8b 40 04             	mov    0x4(%eax),%eax
   24eea:	89 44 24 24          	mov    %eax,0x24(%esp)
// 如果b[3]大于等于0，则进行规格化处理，即对b进行左移调整b[3]为负数。
	while (b[3] >= 0) {
   24eee:	eb 12                	jmp    24f02 <fdiv+0x15e>
		i++;
   24ef0:	83 44 24 3c 01       	addl   $0x1,0x3c(%esp)
		shift_left(b);
   24ef5:	8d 44 24 18          	lea    0x18(%esp),%eax
   24ef9:	50                   	push   %eax
   24efa:	e8 44 fd ff ff       	call   24c43 <shift_left>
   24eff:	83 c4 04             	add    $0x4,%esp
	while (b[3] >= 0) {
   24f02:	8b 44 24 24          	mov    0x24(%esp),%eax
   24f06:	85 c0                	test   %eax,%eax
   24f08:	79 e6                	jns    24ef0 <fdiv+0x14c>
	}
// 进行64位除法操作。
	div64(a,b,tmp);
   24f0a:	8d 44 24 08          	lea    0x8(%esp),%eax
   24f0e:	50                   	push   %eax
   24f0f:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   24f13:	50                   	push   %eax
   24f14:	8d 44 24 30          	lea    0x30(%esp),%eax
   24f18:	50                   	push   %eax
   24f19:	e8 a3 fd ff ff       	call   24cc1 <div64>
   24f1e:	83 c4 0c             	add    $0xc,%esp
// 如果除结果tmp[0]、tmp[1]、tmp[2]和tmp[3]都为0的话，说明结果为0,则设置指数i为0。否则进行规格化处理。
	if (tmp[0] || tmp[1] || tmp[2] || tmp[3]) {
   24f21:	8b 44 24 08          	mov    0x8(%esp),%eax
   24f25:	85 c0                	test   %eax,%eax
   24f27:	75 2c                	jne    24f55 <fdiv+0x1b1>
   24f29:	8b 44 24 0c          	mov    0xc(%esp),%eax
   24f2d:	85 c0                	test   %eax,%eax
   24f2f:	75 24                	jne    24f55 <fdiv+0x1b1>
   24f31:	8b 44 24 10          	mov    0x10(%esp),%eax
   24f35:	85 c0                	test   %eax,%eax
   24f37:	75 1c                	jne    24f55 <fdiv+0x1b1>
   24f39:	8b 44 24 14          	mov    0x14(%esp),%eax
   24f3d:	85 c0                	test   %eax,%eax
   24f3f:	74 4c                	je     24f8d <fdiv+0x1e9>
		while (i && tmp[3] >= 0) {      // 进行规格化处理。
   24f41:	eb 12                	jmp    24f55 <fdiv+0x1b1>
			i--;
   24f43:	83 6c 24 3c 01       	subl   $0x1,0x3c(%esp)
			shift_left(tmp);
   24f48:	8d 44 24 08          	lea    0x8(%esp),%eax
   24f4c:	50                   	push   %eax
   24f4d:	e8 f1 fc ff ff       	call   24c43 <shift_left>
   24f52:	83 c4 04             	add    $0x4,%esp
		while (i && tmp[3] >= 0) {      // 进行规格化处理。
   24f55:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
   24f5a:	74 08                	je     24f64 <fdiv+0x1c0>
   24f5c:	8b 44 24 14          	mov    0x14(%esp),%eax
   24f60:	85 c0                	test   %eax,%eax
   24f62:	79 df                	jns    24f43 <fdiv+0x19f>
		}
		if (tmp[3] >= 0)                // 如果tmp[3]大于等于0，设置状态字非格式化异常标志位。
   24f64:	8b 44 24 14          	mov    0x14(%esp),%eax
   24f68:	85 c0                	test   %eax,%eax
   24f6a:	78 29                	js     24f95 <fdiv+0x1f1>
			set_DE();
   24f6c:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24f72:	8b 00                	mov    (%eax),%eax
   24f74:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   24f7a:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24f80:	8b 00                	mov    (%eax),%eax
   24f82:	83 ca 02             	or     $0x2,%edx
   24f85:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
		if (tmp[3] >= 0)                // 如果tmp[3]大于等于0，设置状态字非格式化异常标志位。
   24f8b:	eb 08                	jmp    24f95 <fdiv+0x1f1>
	} else
		i = 0;          // 设置结果指数为0。
   24f8d:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
   24f94:	00 
// 如果结果指数大于0x7fff，表示产生上溢，于是设置状态字溢出异常标志位，并返回。
	if (i>0x7fff) {
   24f95:	81 7c 24 3c ff 7f 00 	cmpl   $0x7fff,0x3c(%esp)
   24f9c:	00 
   24f9d:	7e 21                	jle    24fc0 <fdiv+0x21c>
		set_OE();
   24f9f:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24fa5:	8b 00                	mov    (%eax),%eax
   24fa7:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   24fad:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24fb3:	8b 00                	mov    (%eax),%eax
   24fb5:	83 ca 08             	or     $0x8,%edx
   24fb8:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
		return;
   24fbe:	eb 58                	jmp    25018 <fdiv+0x274>
	}
// 如果tmp[0]或tmp[1]不为0，则设置状态字精度异常标志位
	if (tmp[0] || tmp[1])
   24fc0:	8b 44 24 08          	mov    0x8(%esp),%eax
   24fc4:	85 c0                	test   %eax,%eax
   24fc6:	75 08                	jne    24fd0 <fdiv+0x22c>
   24fc8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   24fcc:	85 c0                	test   %eax,%eax
   24fce:	74 1f                	je     24fef <fdiv+0x24b>
		set_PE();
   24fd0:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24fd6:	8b 00                	mov    (%eax),%eax
   24fd8:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   24fde:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   24fe4:	8b 00                	mov    (%eax),%eax
   24fe6:	83 ca 20             	or     $0x20,%edx
   24fe9:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
	result->exponent = i | sign;            // 设置返回临时实数的符号位和指数值。
   24fef:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   24ff3:	89 c2                	mov    %eax,%edx
   24ff5:	8b 44 24 38          	mov    0x38(%esp),%eax
   24ff9:	09 c2                	or     %eax,%edx
   24ffb:	8b 44 24 50          	mov    0x50(%esp),%eax
   24fff:	66 89 50 08          	mov    %dx,0x8(%eax)
	result->a = tmp[2];                     // 设置返回临时实数的有效值。
   25003:	8b 54 24 10          	mov    0x10(%esp),%edx
   25007:	8b 44 24 50          	mov    0x50(%esp),%eax
   2500b:	89 10                	mov    %edx,(%eax)
	result->b = tmp[3];
   2500d:	8b 54 24 14          	mov    0x14(%esp),%edx
   25011:	8b 44 24 50          	mov    0x50(%esp),%eax
   25015:	89 50 04             	mov    %edx,0x4(%eax)
}
   25018:	83 c4 40             	add    $0x40,%esp
   2501b:	5b                   	pop    %ebx
   2501c:	c3                   	ret    

0002501d <normalize>:
#define clear_Cx() (I387.swd &= ~0x4500)

// 对临时实数a进行规格化处理。即表示成指数、有效数形式。
// 例如：102.345表示成1.02345 X 10^2。0.0001234表示成1.234 X 10^-1。当然，函数中是二进制表示。
static void normalize(temp_real * a)
{
   2501d:	83 ec 10             	sub    $0x10,%esp
   25020:	e8 cd 1c fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   25025:	05 db cf 00 00       	add    $0xcfdb,%eax
	int i = a->exponent & 0x7fff;           // 取指数值（略去符号位）。
   2502a:	8b 44 24 14          	mov    0x14(%esp),%eax
   2502e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   25032:	98                   	cwtl   
   25033:	25 ff 7f 00 00       	and    $0x7fff,%eax
   25038:	89 44 24 0c          	mov    %eax,0xc(%esp)
	int sign = a->exponent & 0x8000;        // 取符号位。
   2503c:	8b 44 24 14          	mov    0x14(%esp),%eax
   25040:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   25044:	98                   	cwtl   
   25045:	25 00 80 00 00       	and    $0x8000,%eax
   2504a:	89 44 24 08          	mov    %eax,0x8(%esp)

// 如果临时实数a的64位有效数（尾数）为0，那么说明a等于0。于是清a的指数，返回。
	if (!(a->a || a->b)) {
   2504e:	8b 44 24 14          	mov    0x14(%esp),%eax
   25052:	8b 00                	mov    (%eax),%eax
   25054:	85 c0                	test   %eax,%eax
   25056:	75 3a                	jne    25092 <normalize+0x75>
   25058:	8b 44 24 14          	mov    0x14(%esp),%eax
   2505c:	8b 40 04             	mov    0x4(%eax),%eax
   2505f:	85 c0                	test   %eax,%eax
   25061:	75 2f                	jne    25092 <normalize+0x75>
		a->exponent = 0;
   25063:	8b 44 24 14          	mov    0x14(%esp),%eax
   25067:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		return;
   2506d:	eb 49                	jmp    250b8 <normalize+0x9b>
	}
// 如果a的尾数最左端有0值位，那么将尾数左移，同时调整指数值（递减）。直到尾数的b字段最高有效位MSB是1位置（此时b表现为负值）
// 最后再添加符号位。
	while (i && a->b >= 0) {
		i--;
   2506f:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
		__asm__("addl %0,%0 ; adcl %1,%1"
			:"=r" (a->a),"=r" (a->b)
			:"0" (a->a),"1" (a->b));
   25074:	8b 44 24 14          	mov    0x14(%esp),%eax
   25078:	8b 10                	mov    (%eax),%edx
   2507a:	8b 44 24 14          	mov    0x14(%esp),%eax
   2507e:	8b 40 04             	mov    0x4(%eax),%eax
		__asm__("addl %0,%0 ; adcl %1,%1"
   25081:	01 d2                	add    %edx,%edx
   25083:	11 c0                	adc    %eax,%eax
   25085:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   25089:	89 11                	mov    %edx,(%ecx)
   2508b:	8b 54 24 14          	mov    0x14(%esp),%edx
   2508f:	89 42 04             	mov    %eax,0x4(%edx)
	while (i && a->b >= 0) {
   25092:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   25097:	74 0b                	je     250a4 <normalize+0x87>
   25099:	8b 44 24 14          	mov    0x14(%esp),%eax
   2509d:	8b 40 04             	mov    0x4(%eax),%eax
   250a0:	85 c0                	test   %eax,%eax
   250a2:	79 cb                	jns    2506f <normalize+0x52>
	}
	a->exponent = i | sign;
   250a4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   250a8:	89 c2                	mov    %eax,%edx
   250aa:	8b 44 24 08          	mov    0x8(%esp),%eax
   250ae:	09 c2                	or     %eax,%edx
   250b0:	8b 44 24 14          	mov    0x14(%esp),%eax
   250b4:	66 89 50 08          	mov    %dx,0x8(%eax)
}
   250b8:	83 c4 10             	add    $0x10,%esp
   250bb:	c3                   	ret    

000250bc <ftst>:

// 仿真浮点指令FTST。
// 即栈定累加器ST(0)与0比较，并根据比较结果设置条件位。若ST > 0.0，则C3，C2，C0分别为000；若ST < 0.0，则条件位为001；若
// ST == 0.0，则条件位是100；若不可比较，则条件位为111。
void ftst(const temp_real * a)
{
   250bc:	53                   	push   %ebx
   250bd:	83 ec 10             	sub    $0x10,%esp
   250c0:	e8 35 1c fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   250c5:	81 c3 3b cf 00 00    	add    $0xcf3b,%ebx
	temp_real b;

// 首先清状态字中条件标志位，并对比较值b（ST）进行规格化处理。若b不等于零并且设置了符号位（是负数），则设置条件位C0。否则设置
// 条件位C3。
	clear_Cx();
   250cb:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   250d1:	8b 00                	mov    (%eax),%eax
   250d3:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   250d9:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   250df:	8b 00                	mov    (%eax),%eax
   250e1:	80 e6 ba             	and    $0xba,%dh
   250e4:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
	b = *a;
   250ea:	8b 44 24 18          	mov    0x18(%esp),%eax
   250ee:	8b 10                	mov    (%eax),%edx
   250f0:	89 54 24 04          	mov    %edx,0x4(%esp)
   250f4:	8b 50 04             	mov    0x4(%eax),%edx
   250f7:	89 54 24 08          	mov    %edx,0x8(%esp)
   250fb:	8b 40 08             	mov    0x8(%eax),%eax
   250fe:	89 44 24 0c          	mov    %eax,0xc(%esp)
	normalize(&b);
   25102:	8d 44 24 04          	lea    0x4(%esp),%eax
   25106:	50                   	push   %eax
   25107:	e8 11 ff ff ff       	call   2501d <normalize>
   2510c:	83 c4 04             	add    $0x4,%esp
	if (b.a || b.b || b.exponent) {
   2510f:	8b 44 24 04          	mov    0x4(%esp),%eax
   25113:	85 c0                	test   %eax,%eax
   25115:	75 12                	jne    25129 <ftst+0x6d>
   25117:	8b 44 24 08          	mov    0x8(%esp),%eax
   2511b:	85 c0                	test   %eax,%eax
   2511d:	75 0a                	jne    25129 <ftst+0x6d>
   2511f:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   25124:	66 85 c0             	test   %ax,%ax
   25127:	74 2b                	je     25154 <ftst+0x98>
		if (b.exponent < 0)
   25129:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   2512e:	66 85 c0             	test   %ax,%ax
   25131:	79 40                	jns    25173 <ftst+0xb7>
			set_C0();
   25133:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   25139:	8b 00                	mov    (%eax),%eax
   2513b:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   25141:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   25147:	8b 00                	mov    (%eax),%eax
   25149:	80 ce 01             	or     $0x1,%dh
   2514c:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
		if (b.exponent < 0)
   25152:	eb 1f                	jmp    25173 <ftst+0xb7>
	} else
		set_C3();
   25154:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   2515a:	8b 00                	mov    (%eax),%eax
   2515c:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   25162:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   25168:	8b 00                	mov    (%eax),%eax
   2516a:	80 ce 40             	or     $0x40,%dh
   2516d:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
}
   25173:	90                   	nop
   25174:	83 c4 10             	add    $0x10,%esp
   25177:	5b                   	pop    %ebx
   25178:	c3                   	ret    

00025179 <fcom>:

// 仿真浮点指令FCOM。
// 比较两个参数src1、src2。并根据比较结果设置条件位。若src1 > src2，则C3，C2，C0分别为000；若src1 < src2，则条件位为
// 001；若两者相等，则条件位是100。
void fcom(const temp_real * src1, const temp_real * src2)
{
   25179:	53                   	push   %ebx
   2517a:	83 ec 18             	sub    $0x18,%esp
   2517d:	e8 74 1b fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   25182:	81 c2 7e ce 00 00    	add    $0xce7e,%edx
	temp_real a;

	a = *src1;
   25188:	8b 44 24 20          	mov    0x20(%esp),%eax
   2518c:	8b 08                	mov    (%eax),%ecx
   2518e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
   25192:	8b 48 04             	mov    0x4(%eax),%ecx
   25195:	89 4c 24 08          	mov    %ecx,0x8(%esp)
   25199:	8b 40 08             	mov    0x8(%eax),%eax
   2519c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	a.exponent ^= 0x8000;           // 符号位取反。
   251a0:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   251a5:	66 35 00 80          	xor    $0x8000,%ax
   251a9:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	fadd(&a,src2,&a);               // 两者相加（即相减）。
   251ae:	83 ec 04             	sub    $0x4,%esp
   251b1:	8d 44 24 08          	lea    0x8(%esp),%eax
   251b5:	50                   	push   %eax
   251b6:	ff 74 24 2c          	pushl  0x2c(%esp)
   251ba:	8d 44 24 10          	lea    0x10(%esp),%eax
   251be:	50                   	push   %eax
   251bf:	89 d3                	mov    %edx,%ebx
   251c1:	e8 27 f7 ff ff       	call   248ed <fadd>
   251c6:	83 c4 10             	add    $0x10,%esp
	ftst(&a);                       // 测试结果并设置条件位。
   251c9:	83 ec 0c             	sub    $0xc,%esp
   251cc:	8d 44 24 10          	lea    0x10(%esp),%eax
   251d0:	50                   	push   %eax
   251d1:	e8 e6 fe ff ff       	call   250bc <ftst>
   251d6:	83 c4 10             	add    $0x10,%esp
}
   251d9:	90                   	nop
   251da:	83 c4 18             	add    $0x18,%esp
   251dd:	5b                   	pop    %ebx
   251de:	c3                   	ret    

000251df <fucom>:

// 仿真浮点指令FUCOM（无次序比较）。
// 用于操作数之一是NaN的比较。
void fucom(const temp_real * src1, const temp_real * src2)
{
   251df:	83 ec 0c             	sub    $0xc,%esp
   251e2:	e8 0b 1b fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   251e7:	05 19 ce 00 00       	add    $0xce19,%eax
	fcom(src1,src2);
   251ec:	83 ec 08             	sub    $0x8,%esp
   251ef:	ff 74 24 1c          	pushl  0x1c(%esp)
   251f3:	ff 74 24 1c          	pushl  0x1c(%esp)
   251f7:	e8 7d ff ff ff       	call   25179 <fcom>
   251fc:	83 c4 10             	add    $0x10,%esp
}
   251ff:	90                   	nop
   25200:	83 c4 0c             	add    $0xc,%esp
   25203:	c3                   	ret    

00025204 <short_to_temp>:
 */

// 短实数转换成临时实数格式。
// 短实数长度是32位，基有效数（尾数）长度是23位，指数是8位，还有1个符号位。
void short_to_temp(const short_real * a, temp_real * b)
{
   25204:	e8 e9 1a fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   25209:	05 f7 cd 00 00       	add    $0xcdf7,%eax
// 首先处理被转换的短实数是0的情况。若为0,则设置对应临时实数b的有效数为0。然后根据短实数符号位设置临时实数的符号位，即exponent
// 的最高有效位。
	if (!(*a & 0x7fffffff)) {
   2520e:	8b 44 24 04          	mov    0x4(%esp),%eax
   25212:	8b 00                	mov    (%eax),%eax
   25214:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   25219:	85 c0                	test   %eax,%eax
   2521b:	75 38                	jne    25255 <short_to_temp+0x51>
		b->a = b->b = 0;                // 置临时实数的有效数 = 0。
   2521d:	8b 44 24 08          	mov    0x8(%esp),%eax
   25221:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   25228:	8b 44 24 08          	mov    0x8(%esp),%eax
   2522c:	8b 50 04             	mov    0x4(%eax),%edx
   2522f:	8b 44 24 08          	mov    0x8(%esp),%eax
   25233:	89 10                	mov    %edx,(%eax)
		if (*a)
   25235:	8b 44 24 04          	mov    0x4(%esp),%eax
   25239:	8b 00                	mov    (%eax),%eax
   2523b:	85 c0                	test   %eax,%eax
   2523d:	74 0b                	je     2524a <short_to_temp+0x46>
			b->exponent = 0x8000;   // 设置符号位。
   2523f:	8b 44 24 08          	mov    0x8(%esp),%eax
   25243:	66 c7 40 08 00 80    	movw   $0x8000,0x8(%eax)
		else
			b->exponent = 0;
		return;
   25249:	c3                   	ret    
			b->exponent = 0;
   2524a:	8b 44 24 08          	mov    0x8(%esp),%eax
   2524e:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		return;
   25254:	c3                   	ret    
	}
// 对于一般短实数，先确定对应临时实数的指数值。这里需要用到整型数偏置表示方法的概念。短实数指数的偏置量是127，而临时实数指数的偏置
// 量是16383。因此在取出短实数中指数值后需要变更其中的偏置量为16383。此时就形成了临时实数格式的指数值exponent。另外，如果短实数
// 是负数，则需要设置临时实数的符号位（位79）。下一步设置尾数值。方法是把短实数左移8位，让23位尾数最高有效位处于临时实数的位62处。
// 而临时实数尾数位63处需要恒置一个1，即需要或上0x80000000。最后清掉临时实数低32位有效数。
	b->exponent = ((*a>>23) & 0xff)-127+16383;      // 取出短实数指数位，更换偏置量。
   25255:	8b 44 24 04          	mov    0x4(%esp),%eax
   25259:	8b 00                	mov    (%eax),%eax
   2525b:	c1 f8 17             	sar    $0x17,%eax
   2525e:	0f b6 c0             	movzbl %al,%eax
   25261:	66 05 80 3f          	add    $0x3f80,%ax
   25265:	89 c2                	mov    %eax,%edx
   25267:	8b 44 24 08          	mov    0x8(%esp),%eax
   2526b:	66 89 50 08          	mov    %dx,0x8(%eax)
	if (*a<0)
   2526f:	8b 44 24 04          	mov    0x4(%esp),%eax
   25273:	8b 00                	mov    (%eax),%eax
   25275:	85 c0                	test   %eax,%eax
   25277:	79 16                	jns    2528f <short_to_temp+0x8b>
		b->exponent |= 0x8000;                  // 若为负数则设置符号位。
   25279:	8b 44 24 08          	mov    0x8(%esp),%eax
   2527d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   25281:	66 0d 00 80          	or     $0x8000,%ax
   25285:	89 c2                	mov    %eax,%edx
   25287:	8b 44 24 08          	mov    0x8(%esp),%eax
   2528b:	66 89 50 08          	mov    %dx,0x8(%eax)
	b->b = (*a<<8) | 0x80000000;                    // 放置尾数，添加固定1值。
   2528f:	8b 44 24 04          	mov    0x4(%esp),%eax
   25293:	8b 00                	mov    (%eax),%eax
   25295:	c1 e0 08             	shl    $0x8,%eax
   25298:	0d 00 00 00 80       	or     $0x80000000,%eax
   2529d:	89 c2                	mov    %eax,%edx
   2529f:	8b 44 24 08          	mov    0x8(%esp),%eax
   252a3:	89 50 04             	mov    %edx,0x4(%eax)
	b->a = 0;
   252a6:	8b 44 24 08          	mov    0x8(%esp),%eax
   252aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   252b0:	c3                   	ret    

000252b1 <long_to_temp>:

// 长实数转换成临时实数格式。
// 方法与short_to_temp()安全一样。不过长实数指数偏置量是1034。
void long_to_temp(const long_real * a, temp_real * b)
{
   252b1:	e8 3c 1a fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   252b6:	05 4a cd 00 00       	add    $0xcd4a,%eax
	if (!a->a && !(a->b & 0x7fffffff)) {
   252bb:	8b 44 24 04          	mov    0x4(%esp),%eax
   252bf:	8b 00                	mov    (%eax),%eax
   252c1:	85 c0                	test   %eax,%eax
   252c3:	75 49                	jne    2530e <long_to_temp+0x5d>
   252c5:	8b 44 24 04          	mov    0x4(%esp),%eax
   252c9:	8b 40 04             	mov    0x4(%eax),%eax
   252cc:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   252d1:	85 c0                	test   %eax,%eax
   252d3:	75 39                	jne    2530e <long_to_temp+0x5d>
		b->a = b->b = 0;                // 置临时实数的有效数 = 0。
   252d5:	8b 44 24 08          	mov    0x8(%esp),%eax
   252d9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   252e0:	8b 44 24 08          	mov    0x8(%esp),%eax
   252e4:	8b 50 04             	mov    0x4(%eax),%edx
   252e7:	8b 44 24 08          	mov    0x8(%esp),%eax
   252eb:	89 10                	mov    %edx,(%eax)
		if (a->b)
   252ed:	8b 44 24 04          	mov    0x4(%esp),%eax
   252f1:	8b 40 04             	mov    0x4(%eax),%eax
   252f4:	85 c0                	test   %eax,%eax
   252f6:	74 0b                	je     25303 <long_to_temp+0x52>
			b->exponent = 0x8000;   // 设置符号位。
   252f8:	8b 44 24 08          	mov    0x8(%esp),%eax
   252fc:	66 c7 40 08 00 80    	movw   $0x8000,0x8(%eax)
		else
			b->exponent = 0;
		return;
   25302:	c3                   	ret    
			b->exponent = 0;
   25303:	8b 44 24 08          	mov    0x8(%esp),%eax
   25307:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		return;
   2530d:	c3                   	ret    
	}
	b->exponent = ((a->b >> 20) & 0x7ff)-1023+16383;        // 取长实数指数，更换偏置量。
   2530e:	8b 44 24 04          	mov    0x4(%esp),%eax
   25312:	8b 40 04             	mov    0x4(%eax),%eax
   25315:	c1 f8 14             	sar    $0x14,%eax
   25318:	66 25 ff 07          	and    $0x7ff,%ax
   2531c:	66 05 00 3c          	add    $0x3c00,%ax
   25320:	89 c2                	mov    %eax,%edx
   25322:	8b 44 24 08          	mov    0x8(%esp),%eax
   25326:	66 89 50 08          	mov    %dx,0x8(%eax)
	if (a->b<0)
   2532a:	8b 44 24 04          	mov    0x4(%esp),%eax
   2532e:	8b 40 04             	mov    0x4(%eax),%eax
   25331:	85 c0                	test   %eax,%eax
   25333:	79 16                	jns    2534b <long_to_temp+0x9a>
		b->exponent |= 0x8000;          // 若为负数则设置符号位。
   25335:	8b 44 24 08          	mov    0x8(%esp),%eax
   25339:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2533d:	66 0d 00 80          	or     $0x8000,%ax
   25341:	89 c2                	mov    %eax,%edx
   25343:	8b 44 24 08          	mov    0x8(%esp),%eax
   25347:	66 89 50 08          	mov    %dx,0x8(%eax)
	b->b = 0x80000000 | (a->b<<11) | (((unsigned long)a->a)>>21);
   2534b:	8b 44 24 04          	mov    0x4(%esp),%eax
   2534f:	8b 40 04             	mov    0x4(%eax),%eax
   25352:	c1 e0 0b             	shl    $0xb,%eax
   25355:	89 c2                	mov    %eax,%edx
   25357:	8b 44 24 04          	mov    0x4(%esp),%eax
   2535b:	8b 00                	mov    (%eax),%eax
   2535d:	c1 e8 15             	shr    $0x15,%eax
   25360:	09 d0                	or     %edx,%eax
   25362:	0d 00 00 00 80       	or     $0x80000000,%eax
   25367:	89 c2                	mov    %eax,%edx
   25369:	8b 44 24 08          	mov    0x8(%esp),%eax
   2536d:	89 50 04             	mov    %edx,0x4(%eax)
	b->a = a->a<<11;                        // 放置尾数，添1。
   25370:	8b 44 24 04          	mov    0x4(%esp),%eax
   25374:	8b 00                	mov    (%eax),%eax
   25376:	c1 e0 0b             	shl    $0xb,%eax
   25379:	89 c2                	mov    %eax,%edx
   2537b:	8b 44 24 08          	mov    0x8(%esp),%eax
   2537f:	89 10                	mov    %edx,(%eax)
}
   25381:	c3                   	ret    

00025382 <temp_to_short>:

// 临时实数转换成短实数格式。
// 过程与short_to_temp()相反，但需要处理精度和舍入问题。
void temp_to_short(const temp_real * a, short_real * b)
{
   25382:	e8 6b 19 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   25387:	05 79 cc 00 00       	add    $0xcc79,%eax
// 如果指数部分为0，则根据有无符号位设置短实数为-0或0。
	if (!(a->exponent & 0x7fff)) {
   2538c:	8b 54 24 04          	mov    0x4(%esp),%edx
   25390:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   25394:	0f bf d2             	movswl %dx,%edx
   25397:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
   2539d:	85 d2                	test   %edx,%edx
   2539f:	75 20                	jne    253c1 <temp_to_short+0x3f>
		*b = (a->exponent)?0x80000000:0;
   253a1:	8b 44 24 04          	mov    0x4(%esp),%eax
   253a5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   253a9:	66 85 c0             	test   %ax,%ax
   253ac:	74 07                	je     253b5 <temp_to_short+0x33>
   253ae:	ba 00 00 00 80       	mov    $0x80000000,%edx
   253b3:	eb 05                	jmp    253ba <temp_to_short+0x38>
   253b5:	ba 00 00 00 00       	mov    $0x0,%edx
   253ba:	8b 44 24 08          	mov    0x8(%esp),%eax
   253be:	89 10                	mov    %edx,(%eax)
		return;
   253c0:	c3                   	ret    
	}
// 先处理指数部分。即更换临时实数指数偏置量（16383）为短实数的偏置量127。
	*b = ((((long) a->exponent)-16383+127) << 23) & 0x7f800000;
   253c1:	8b 54 24 04          	mov    0x4(%esp),%edx
   253c5:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   253c9:	0f bf d2             	movswl %dx,%edx
   253cc:	81 ea 80 3f 00 00    	sub    $0x3f80,%edx
   253d2:	c1 e2 17             	shl    $0x17,%edx
   253d5:	89 d1                	mov    %edx,%ecx
   253d7:	81 e1 00 00 80 7f    	and    $0x7f800000,%ecx
   253dd:	8b 54 24 08          	mov    0x8(%esp),%edx
   253e1:	89 0a                	mov    %ecx,(%edx)
	if (a->exponent < 0)                    // 若是负数则设置符号位。
   253e3:	8b 54 24 04          	mov    0x4(%esp),%edx
   253e7:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   253eb:	66 85 d2             	test   %dx,%dx
   253ee:	79 14                	jns    25404 <temp_to_short+0x82>
		*b |= 0x80000000;
   253f0:	8b 54 24 08          	mov    0x8(%esp),%edx
   253f4:	8b 12                	mov    (%edx),%edx
   253f6:	81 ca 00 00 00 80    	or     $0x80000000,%edx
   253fc:	89 d1                	mov    %edx,%ecx
   253fe:	8b 54 24 08          	mov    0x8(%esp),%edx
   25402:	89 0a                	mov    %ecx,(%edx)
	*b |= (a->b >> 8) & 0x007fffff;         // 取临时实数有效数高23位。
   25404:	8b 54 24 08          	mov    0x8(%esp),%edx
   25408:	8b 0a                	mov    (%edx),%ecx
   2540a:	8b 54 24 04          	mov    0x4(%esp),%edx
   2540e:	8b 52 04             	mov    0x4(%edx),%edx
   25411:	c1 fa 08             	sar    $0x8,%edx
   25414:	81 e2 ff ff 7f 00    	and    $0x7fffff,%edx
   2541a:	09 d1                	or     %edx,%ecx
   2541c:	8b 54 24 08          	mov    0x8(%esp),%edx
   25420:	89 0a                	mov    %ecx,(%edx)
// 根据控制字中的舍入设置执行舍入操作。
	switch (ROUNDING) {
   25422:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   25428:	8b 00                	mov    (%eax),%eax
   2542a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   25430:	c1 f8 0a             	sar    $0xa,%eax
   25433:	83 e0 03             	and    $0x3,%eax
   25436:	83 f8 01             	cmp    $0x1,%eax
   25439:	74 2f                	je     2546a <temp_to_short+0xe8>
   2543b:	83 f8 02             	cmp    $0x2,%eax
   2543e:	74 56                	je     25496 <temp_to_short+0x114>
   25440:	85 c0                	test   %eax,%eax
   25442:	0f 85 80 00 00 00    	jne    254c8 <temp_to_short+0x146>
		case ROUND_NEAREST:
			if ((a->b & 0xff) > 0x80)
   25448:	8b 44 24 04          	mov    0x4(%esp),%eax
   2544c:	8b 40 04             	mov    0x4(%eax),%eax
   2544f:	0f b6 c0             	movzbl %al,%eax
   25452:	3d 80 00 00 00       	cmp    $0x80,%eax
   25457:	7e 6a                	jle    254c3 <temp_to_short+0x141>
				++*b;
   25459:	8b 44 24 08          	mov    0x8(%esp),%eax
   2545d:	8b 00                	mov    (%eax),%eax
   2545f:	8d 50 01             	lea    0x1(%eax),%edx
   25462:	8b 44 24 08          	mov    0x8(%esp),%eax
   25466:	89 10                	mov    %edx,(%eax)
			break;
   25468:	eb 59                	jmp    254c3 <temp_to_short+0x141>
		case ROUND_DOWN:
			if ((a->exponent & 0x8000) && (a->b & 0xff))
   2546a:	8b 44 24 04          	mov    0x4(%esp),%eax
   2546e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   25472:	66 85 c0             	test   %ax,%ax
   25475:	79 4e                	jns    254c5 <temp_to_short+0x143>
   25477:	8b 44 24 04          	mov    0x4(%esp),%eax
   2547b:	8b 40 04             	mov    0x4(%eax),%eax
   2547e:	0f b6 c0             	movzbl %al,%eax
   25481:	85 c0                	test   %eax,%eax
   25483:	74 40                	je     254c5 <temp_to_short+0x143>
				++*b;
   25485:	8b 44 24 08          	mov    0x8(%esp),%eax
   25489:	8b 00                	mov    (%eax),%eax
   2548b:	8d 50 01             	lea    0x1(%eax),%edx
   2548e:	8b 44 24 08          	mov    0x8(%esp),%eax
   25492:	89 10                	mov    %edx,(%eax)
			break;
   25494:	eb 2f                	jmp    254c5 <temp_to_short+0x143>
		case ROUND_UP:
			if (!(a->exponent & 0x8000) && (a->b & 0xff))
   25496:	8b 44 24 04          	mov    0x4(%esp),%eax
   2549a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2549e:	66 85 c0             	test   %ax,%ax
   254a1:	78 24                	js     254c7 <temp_to_short+0x145>
   254a3:	8b 44 24 04          	mov    0x4(%esp),%eax
   254a7:	8b 40 04             	mov    0x4(%eax),%eax
   254aa:	0f b6 c0             	movzbl %al,%eax
   254ad:	85 c0                	test   %eax,%eax
   254af:	74 16                	je     254c7 <temp_to_short+0x145>
				++*b;
   254b1:	8b 44 24 08          	mov    0x8(%esp),%eax
   254b5:	8b 00                	mov    (%eax),%eax
   254b7:	8d 50 01             	lea    0x1(%eax),%edx
   254ba:	8b 44 24 08          	mov    0x8(%esp),%eax
   254be:	89 10                	mov    %edx,(%eax)
			break;
   254c0:	90                   	nop
   254c1:	eb 04                	jmp    254c7 <temp_to_short+0x145>
			break;
   254c3:	90                   	nop
   254c4:	c3                   	ret    
			break;
   254c5:	90                   	nop
   254c6:	c3                   	ret    
			break;
   254c7:	90                   	nop
	}
}
   254c8:	c3                   	ret    

000254c9 <temp_to_long>:

// 临时实数转换成长实数。
void temp_to_long(const temp_real * a, long_real * b)
{
   254c9:	e8 24 18 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   254ce:	05 32 cb 00 00       	add    $0xcb32,%eax
// 如果指数部分为0，则根据有无符号位设置长实数为-0或0。
	if (!(a->exponent & 0x7fff)) {
   254d3:	8b 54 24 04          	mov    0x4(%esp),%edx
   254d7:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   254db:	0f bf d2             	movswl %dx,%edx
   254de:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
   254e4:	85 d2                	test   %edx,%edx
   254e6:	75 2b                	jne    25513 <temp_to_long+0x4a>
		b->a = 0;
   254e8:	8b 44 24 08          	mov    0x8(%esp),%eax
   254ec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		b->b = (a->exponent)?0x80000000:0;
   254f2:	8b 44 24 04          	mov    0x4(%esp),%eax
   254f6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   254fa:	66 85 c0             	test   %ax,%ax
   254fd:	74 07                	je     25506 <temp_to_long+0x3d>
   254ff:	ba 00 00 00 80       	mov    $0x80000000,%edx
   25504:	eb 05                	jmp    2550b <temp_to_long+0x42>
   25506:	ba 00 00 00 00       	mov    $0x0,%edx
   2550b:	8b 44 24 08          	mov    0x8(%esp),%eax
   2550f:	89 50 04             	mov    %edx,0x4(%eax)
		return;
   25512:	c3                   	ret    
	}
// 先处理指数部分。即更换临时实数指数偏置量（16383）为长实数的偏置量1023.
	b->b = (((0x7fff & (long) a->exponent)-16383+1023) << 20) & 0x7ff00000;
   25513:	8b 54 24 04          	mov    0x4(%esp),%edx
   25517:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   2551b:	0f bf d2             	movswl %dx,%edx
   2551e:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
   25524:	81 ea 00 3c 00 00    	sub    $0x3c00,%edx
   2552a:	c1 e2 14             	shl    $0x14,%edx
   2552d:	89 d1                	mov    %edx,%ecx
   2552f:	81 e1 00 00 f0 7f    	and    $0x7ff00000,%ecx
   25535:	8b 54 24 08          	mov    0x8(%esp),%edx
   25539:	89 4a 04             	mov    %ecx,0x4(%edx)
	if (a->exponent < 0)            // 若是负数则设置符号位。
   2553c:	8b 54 24 04          	mov    0x4(%esp),%edx
   25540:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   25544:	66 85 d2             	test   %dx,%dx
   25547:	79 16                	jns    2555f <temp_to_long+0x96>
		b->b |= 0x80000000;
   25549:	8b 54 24 08          	mov    0x8(%esp),%edx
   2554d:	8b 52 04             	mov    0x4(%edx),%edx
   25550:	81 ca 00 00 00 80    	or     $0x80000000,%edx
   25556:	89 d1                	mov    %edx,%ecx
   25558:	8b 54 24 08          	mov    0x8(%esp),%edx
   2555c:	89 4a 04             	mov    %ecx,0x4(%edx)
	b->b |= (a->b >> 11) & 0x000fffff;      // 取临时实数有效数高20位。
   2555f:	8b 54 24 08          	mov    0x8(%esp),%edx
   25563:	8b 4a 04             	mov    0x4(%edx),%ecx
   25566:	8b 54 24 04          	mov    0x4(%esp),%edx
   2556a:	8b 52 04             	mov    0x4(%edx),%edx
   2556d:	c1 fa 0b             	sar    $0xb,%edx
   25570:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
   25576:	09 d1                	or     %edx,%ecx
   25578:	8b 54 24 08          	mov    0x8(%esp),%edx
   2557c:	89 4a 04             	mov    %ecx,0x4(%edx)
	b->a = a->b << 21;
   2557f:	8b 54 24 04          	mov    0x4(%esp),%edx
   25583:	8b 52 04             	mov    0x4(%edx),%edx
   25586:	89 d1                	mov    %edx,%ecx
   25588:	c1 e1 15             	shl    $0x15,%ecx
   2558b:	8b 54 24 08          	mov    0x8(%esp),%edx
   2558f:	89 0a                	mov    %ecx,(%edx)
	b->a |= (a->a >> 11) & 0x001fffff;
   25591:	8b 54 24 08          	mov    0x8(%esp),%edx
   25595:	8b 0a                	mov    (%edx),%ecx
   25597:	8b 54 24 04          	mov    0x4(%esp),%edx
   2559b:	8b 12                	mov    (%edx),%edx
   2559d:	c1 ea 0b             	shr    $0xb,%edx
   255a0:	09 d1                	or     %edx,%ecx
   255a2:	8b 54 24 08          	mov    0x8(%esp),%edx
   255a6:	89 0a                	mov    %ecx,(%edx)
// 根据控制字中的舍入设置执行舍入操作。
	switch (ROUNDING) {
   255a8:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   255ae:	8b 00                	mov    (%eax),%eax
   255b0:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   255b6:	c1 f8 0a             	sar    $0xa,%eax
   255b9:	83 e0 03             	and    $0x3,%eax
   255bc:	83 f8 01             	cmp    $0x1,%eax
   255bf:	74 45                	je     25606 <temp_to_long+0x13d>
   255c1:	83 f8 02             	cmp    $0x2,%eax
   255c4:	74 7d                	je     25643 <temp_to_long+0x17a>
   255c6:	85 c0                	test   %eax,%eax
   255c8:	0f 85 b8 00 00 00    	jne    25686 <temp_to_long+0x1bd>
		case ROUND_NEAREST:
			if ((a->a & 0x7ff) > 0x400)
   255ce:	8b 44 24 04          	mov    0x4(%esp),%eax
   255d2:	8b 00                	mov    (%eax),%eax
   255d4:	25 ff 07 00 00       	and    $0x7ff,%eax
   255d9:	3d 00 04 00 00       	cmp    $0x400,%eax
   255de:	0f 8e 9d 00 00 00    	jle    25681 <temp_to_long+0x1b8>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
   255e4:	8b 44 24 08          	mov    0x8(%esp),%eax
   255e8:	8b 10                	mov    (%eax),%edx
   255ea:	8b 44 24 08          	mov    0x8(%esp),%eax
   255ee:	8b 40 04             	mov    0x4(%eax),%eax
				__asm__("addl $1,%0 ; adcl $0,%1"
   255f1:	83 c2 01             	add    $0x1,%edx
   255f4:	83 d0 00             	adc    $0x0,%eax
   255f7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   255fb:	89 11                	mov    %edx,(%ecx)
   255fd:	8b 54 24 08          	mov    0x8(%esp),%edx
   25601:	89 42 04             	mov    %eax,0x4(%edx)
			break;
   25604:	eb 7b                	jmp    25681 <temp_to_long+0x1b8>
		case ROUND_DOWN:
			if ((a->exponent & 0x8000) && (a->b & 0xff))
   25606:	8b 44 24 04          	mov    0x4(%esp),%eax
   2560a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2560e:	66 85 c0             	test   %ax,%ax
   25611:	79 70                	jns    25683 <temp_to_long+0x1ba>
   25613:	8b 44 24 04          	mov    0x4(%esp),%eax
   25617:	8b 40 04             	mov    0x4(%eax),%eax
   2561a:	0f b6 c0             	movzbl %al,%eax
   2561d:	85 c0                	test   %eax,%eax
   2561f:	74 62                	je     25683 <temp_to_long+0x1ba>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
   25621:	8b 44 24 08          	mov    0x8(%esp),%eax
   25625:	8b 10                	mov    (%eax),%edx
   25627:	8b 44 24 08          	mov    0x8(%esp),%eax
   2562b:	8b 40 04             	mov    0x4(%eax),%eax
				__asm__("addl $1,%0 ; adcl $0,%1"
   2562e:	83 c2 01             	add    $0x1,%edx
   25631:	83 d0 00             	adc    $0x0,%eax
   25634:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   25638:	89 11                	mov    %edx,(%ecx)
   2563a:	8b 54 24 08          	mov    0x8(%esp),%edx
   2563e:	89 42 04             	mov    %eax,0x4(%edx)
			break;
   25641:	eb 40                	jmp    25683 <temp_to_long+0x1ba>
		case ROUND_UP:
			if (!(a->exponent & 0x8000) && (a->b & 0xff))
   25643:	8b 44 24 04          	mov    0x4(%esp),%eax
   25647:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2564b:	66 85 c0             	test   %ax,%ax
   2564e:	78 35                	js     25685 <temp_to_long+0x1bc>
   25650:	8b 44 24 04          	mov    0x4(%esp),%eax
   25654:	8b 40 04             	mov    0x4(%eax),%eax
   25657:	0f b6 c0             	movzbl %al,%eax
   2565a:	85 c0                	test   %eax,%eax
   2565c:	74 27                	je     25685 <temp_to_long+0x1bc>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
   2565e:	8b 44 24 08          	mov    0x8(%esp),%eax
   25662:	8b 10                	mov    (%eax),%edx
   25664:	8b 44 24 08          	mov    0x8(%esp),%eax
   25668:	8b 40 04             	mov    0x4(%eax),%eax
				__asm__("addl $1,%0 ; adcl $0,%1"
   2566b:	83 c2 01             	add    $0x1,%edx
   2566e:	83 d0 00             	adc    $0x0,%eax
   25671:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   25675:	89 11                	mov    %edx,(%ecx)
   25677:	8b 54 24 08          	mov    0x8(%esp),%edx
   2567b:	89 42 04             	mov    %eax,0x4(%edx)
			break;
   2567e:	90                   	nop
   2567f:	eb 04                	jmp    25685 <temp_to_long+0x1bc>
			break;
   25681:	90                   	nop
   25682:	c3                   	ret    
			break;
   25683:	90                   	nop
   25684:	c3                   	ret    
			break;
   25685:	90                   	nop
	}
}
   25686:	c3                   	ret    

00025687 <real_to_int>:

// 临时实数转换成临时整数格式。
// 临时整数也用10字节表示。其中低8字节是无符号整数值，高2字节表示指数值和符号位。如果高2字节最高有效位为1，则表示是负数；
// 若位0，表示是正数。
void real_to_int(const temp_real * a, temp_int * b)
{
   25687:	56                   	push   %esi
   25688:	53                   	push   %ebx
   25689:	83 ec 10             	sub    $0x10,%esp
   2568c:	e8 61 16 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   25691:	05 6f c9 00 00       	add    $0xc96f,%eax
// 整数值最大值是2的63次方，加上临时实数偏置值16383,表示一个整数值转换为临时实数，临时实数指数最大值，减去临时实数指数，
// 得到指数差值（相当于与最大整数值的差值）。
	int shift =  16383 + 63 - (a->exponent & 0x7fff);
   25696:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   2569a:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   2569e:	0f bf d2             	movswl %dx,%edx
   256a1:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
   256a7:	b9 3e 40 00 00       	mov    $0x403e,%ecx
   256ac:	29 d1                	sub    %edx,%ecx
   256ae:	89 ca                	mov    %ecx,%edx
   256b0:	89 54 24 0c          	mov    %edx,0xc(%esp)
	unsigned long underflow;

	b->a = b->b = underflow = 0;    // 初始化临时整数值为0。
   256b4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   256bb:	00 
   256bc:	8b 54 24 20          	mov    0x20(%esp),%edx
   256c0:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
   256c7:	8b 54 24 20          	mov    0x20(%esp),%edx
   256cb:	8b 4a 04             	mov    0x4(%edx),%ecx
   256ce:	8b 54 24 20          	mov    0x20(%esp),%edx
   256d2:	89 0a                	mov    %ecx,(%edx)
	b->sign = (a->exponent < 0);    // 置临时整数符号与临时实数符号一致。
   256d4:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   256d8:	0f b7 52 08          	movzwl 0x8(%edx),%edx
   256dc:	66 c1 ea 0f          	shr    $0xf,%dx
   256e0:	0f b6 ca             	movzbl %dl,%ecx
   256e3:	8b 54 24 20          	mov    0x20(%esp),%edx
   256e7:	66 89 4a 08          	mov    %cx,0x8(%edx)
	if (shift < 0) {                // 如果指数差值小于0，说明这个临时实数不能放入临时整数中，
   256eb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   256f0:	79 24                	jns    25716 <real_to_int+0x8f>
		set_OE();               // 置状态字溢出位。
   256f2:	c7 c2 80 32 03 00    	mov    $0x33280,%edx
   256f8:	8b 12                	mov    (%edx),%edx
   256fa:	8b 92 1c 04 00 00    	mov    0x41c(%edx),%edx
   25700:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   25706:	8b 00                	mov    (%eax),%eax
   25708:	83 ca 08             	or     $0x8,%edx
   2570b:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
		return;
   25711:	e9 94 01 00 00       	jmp    258aa <real_to_int+0x223>
	}
// 如果两值差值小于2的32次方，直接把实数值放入整数值。
	if (shift < 32) {
   25716:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
   2571b:	7f 1c                	jg     25739 <real_to_int+0xb2>
		b->b = a->b; b->a = a->a;
   2571d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   25721:	8b 4a 04             	mov    0x4(%edx),%ecx
   25724:	8b 54 24 20          	mov    0x20(%esp),%edx
   25728:	89 4a 04             	mov    %ecx,0x4(%edx)
   2572b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   2572f:	8b 0a                	mov    (%edx),%ecx
   25731:	8b 54 24 20          	mov    0x20(%esp),%edx
   25735:	89 0a                	mov    %ecx,(%edx)
   25737:	eb 40                	jmp    25779 <real_to_int+0xf2>
// 如果两值差值介于2的32次方与64次方之间，把实数高位a->b放入整数低位b->a，然后把实数低位放入下溢出变量underflow，指数差值
// shift-32。
	} else if (shift < 64) {
   25739:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
   2573e:	7f 1e                	jg     2575e <real_to_int+0xd7>
		b->a = a->b; underflow = a->a;
   25740:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   25744:	8b 4a 04             	mov    0x4(%edx),%ecx
   25747:	8b 54 24 20          	mov    0x20(%esp),%edx
   2574b:	89 0a                	mov    %ecx,(%edx)
   2574d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   25751:	8b 12                	mov    (%edx),%edx
   25753:	89 54 24 08          	mov    %edx,0x8(%esp)
		shift -= 32;
   25757:	83 6c 24 0c 20       	subl   $0x20,0xc(%esp)
   2575c:	eb 1b                	jmp    25779 <real_to_int+0xf2>
// 如果两值差值介于2的64次方与96次方之间，把实数高位a->b放入下溢出变量underflow，指数差值shift-64。
	} else if (shift < 96) {
   2575e:	83 7c 24 0c 5f       	cmpl   $0x5f,0xc(%esp)
   25763:	0f 8f 3a 01 00 00    	jg     258a3 <real_to_int+0x21c>
		underflow = a->b;
   25769:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   2576d:	8b 52 04             	mov    0x4(%edx),%edx
   25770:	89 54 24 08          	mov    %edx,0x8(%esp)
		shift -= 64;
   25774:	83 6c 24 0c 40       	subl   $0x40,0xc(%esp)
	} else
		return;
// 接着再进行细致的调整，调整方法是把临时整数b的向下溢出变量underflow右移shift位。
	__asm__("shrdl %2,%1,%0"
		:"=r" (underflow),"=r" (b->a)
		:"c" ((char) shift),"0" (underflow),"1" (b->a));
   25779:	8b 54 24 0c          	mov    0xc(%esp),%edx
   2577d:	89 d6                	mov    %edx,%esi
	__asm__("shrdl %2,%1,%0"
   2577f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
		:"c" ((char) shift),"0" (underflow),"1" (b->a));
   25783:	8b 54 24 20          	mov    0x20(%esp),%edx
   25787:	8b 12                	mov    (%edx),%edx
	__asm__("shrdl %2,%1,%0"
   25789:	89 cb                	mov    %ecx,%ebx
   2578b:	89 f1                	mov    %esi,%ecx
   2578d:	0f ad d3             	shrd   %cl,%edx,%ebx
   25790:	89 5c 24 08          	mov    %ebx,0x8(%esp)
   25794:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   25798:	89 11                	mov    %edx,(%ecx)
// 然后把临时整数b的尾数b->a右移shift位。
	__asm__("shrdl %2,%1,%0"
		:"=r" (b->a),"=r" (b->b)
		:"c" ((char) shift),"0" (b->a),"1" (b->b));
   2579a:	8b 54 24 0c          	mov    0xc(%esp),%edx
   2579e:	89 d6                	mov    %edx,%esi
   257a0:	8b 54 24 20          	mov    0x20(%esp),%edx
   257a4:	8b 0a                	mov    (%edx),%ecx
   257a6:	8b 54 24 20          	mov    0x20(%esp),%edx
   257aa:	8b 52 04             	mov    0x4(%edx),%edx
	__asm__("shrdl %2,%1,%0"
   257ad:	89 cb                	mov    %ecx,%ebx
   257af:	89 f1                	mov    %esi,%ecx
   257b1:	0f ad d3             	shrd   %cl,%edx,%ebx
   257b4:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   257b8:	89 19                	mov    %ebx,(%ecx)
   257ba:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   257be:	89 51 04             	mov    %edx,0x4(%ecx)
// 最后把临时整数b的尾数b->b右移shift位。
	__asm__("shrl %1,%0"
		:"=r" (b->b)
		:"c" ((char) shift),"0" (b->b));
   257c1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   257c5:	89 d1                	mov    %edx,%ecx
   257c7:	8b 54 24 20          	mov    0x20(%esp),%edx
   257cb:	8b 52 04             	mov    0x4(%edx),%edx
	__asm__("shrl %1,%0"
   257ce:	d3 ea                	shr    %cl,%edx
   257d0:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   257d4:	89 51 04             	mov    %edx,0x4(%ecx)
// 根据控制字中的舍入设置执行舍入操作。
	switch (ROUNDING) {
   257d7:	c7 c0 80 32 03 00    	mov    $0x33280,%eax
   257dd:	8b 00                	mov    (%eax),%eax
   257df:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   257e5:	c1 f8 0a             	sar    $0xa,%eax
   257e8:	83 e0 03             	and    $0x3,%eax
   257eb:	83 f8 01             	cmp    $0x1,%eax
   257ee:	74 7b                	je     2586b <real_to_int+0x1e4>
   257f0:	83 f8 02             	cmp    $0x2,%eax
   257f3:	74 3f                	je     25834 <real_to_int+0x1ad>
   257f5:	85 c0                	test   %eax,%eax
   257f7:	0f 85 ad 00 00 00    	jne    258aa <real_to_int+0x223>
		case ROUND_NEAREST:
			__asm__("addl %4,%5 ; adcl $0,%0 ; adcl $0,%1"
				:"=r" (b->a),"=r" (b->b)
				:"0" (b->a),"1" (b->b)
   257fd:	8b 44 24 20          	mov    0x20(%esp),%eax
   25801:	8b 10                	mov    (%eax),%edx
   25803:	8b 44 24 20          	mov    0x20(%esp),%eax
   25807:	8b 58 04             	mov    0x4(%eax),%ebx
				,"r" (0x7fffffff + (b->a & 1))
   2580a:	8b 44 24 20          	mov    0x20(%esp),%eax
   2580e:	8b 00                	mov    (%eax),%eax
   25810:	83 e0 01             	and    $0x1,%eax
   25813:	8d 88 ff ff ff 7f    	lea    0x7fffffff(%eax),%ecx
			__asm__("addl %4,%5 ; adcl $0,%0 ; adcl $0,%1"
   25819:	89 d8                	mov    %ebx,%eax
   2581b:	01 4c 24 08          	add    %ecx,0x8(%esp)
   2581f:	83 d2 00             	adc    $0x0,%edx
   25822:	83 d0 00             	adc    $0x0,%eax
   25825:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   25829:	89 11                	mov    %edx,(%ecx)
   2582b:	8b 54 24 20          	mov    0x20(%esp),%edx
   2582f:	89 42 04             	mov    %eax,0x4(%edx)
				,"m" (*&underflow));
			break;
   25832:	eb 76                	jmp    258aa <real_to_int+0x223>
		case ROUND_UP:
			if (!b->sign && underflow)
   25834:	8b 44 24 20          	mov    0x20(%esp),%eax
   25838:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2583c:	66 85 c0             	test   %ax,%ax
   2583f:	75 65                	jne    258a6 <real_to_int+0x21f>
   25841:	8b 44 24 08          	mov    0x8(%esp),%eax
   25845:	85 c0                	test   %eax,%eax
   25847:	74 5d                	je     258a6 <real_to_int+0x21f>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
   25849:	8b 44 24 20          	mov    0x20(%esp),%eax
   2584d:	8b 10                	mov    (%eax),%edx
   2584f:	8b 44 24 20          	mov    0x20(%esp),%eax
   25853:	8b 40 04             	mov    0x4(%eax),%eax
				__asm__("addl $1,%0 ; adcl $0,%1"
   25856:	83 c2 01             	add    $0x1,%edx
   25859:	83 d0 00             	adc    $0x0,%eax
   2585c:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   25860:	89 11                	mov    %edx,(%ecx)
   25862:	8b 54 24 20          	mov    0x20(%esp),%edx
   25866:	89 42 04             	mov    %eax,0x4(%edx)
			break;
   25869:	eb 3b                	jmp    258a6 <real_to_int+0x21f>
		case ROUND_DOWN:
			if (b->sign && underflow)
   2586b:	8b 44 24 20          	mov    0x20(%esp),%eax
   2586f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   25873:	66 85 c0             	test   %ax,%ax
   25876:	74 31                	je     258a9 <real_to_int+0x222>
   25878:	8b 44 24 08          	mov    0x8(%esp),%eax
   2587c:	85 c0                	test   %eax,%eax
   2587e:	74 29                	je     258a9 <real_to_int+0x222>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
   25880:	8b 44 24 20          	mov    0x20(%esp),%eax
   25884:	8b 10                	mov    (%eax),%edx
   25886:	8b 44 24 20          	mov    0x20(%esp),%eax
   2588a:	8b 40 04             	mov    0x4(%eax),%eax
				__asm__("addl $1,%0 ; adcl $0,%1"
   2588d:	83 c2 01             	add    $0x1,%edx
   25890:	83 d0 00             	adc    $0x0,%eax
   25893:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   25897:	89 11                	mov    %edx,(%ecx)
   25899:	8b 54 24 20          	mov    0x20(%esp),%edx
   2589d:	89 42 04             	mov    %eax,0x4(%edx)
			break;
   258a0:	90                   	nop
   258a1:	eb 06                	jmp    258a9 <real_to_int+0x222>
		return;
   258a3:	90                   	nop
   258a4:	eb 04                	jmp    258aa <real_to_int+0x223>
			break;
   258a6:	90                   	nop
   258a7:	eb 01                	jmp    258aa <real_to_int+0x223>
			break;
   258a9:	90                   	nop
	}
}
   258aa:	83 c4 10             	add    $0x10,%esp
   258ad:	5b                   	pop    %ebx
   258ae:	5e                   	pop    %esi
   258af:	c3                   	ret    

000258b0 <int_to_real>:

// 临时整数转换成临时实数格式。
void int_to_real(const temp_int * a, temp_real * b)
{
   258b0:	e8 3d 14 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   258b5:	05 4b c7 00 00       	add    $0xc74b,%eax
// 由于原值是整数，所以转换成临时实数时指数除了需要加上偏置量16383外，还要加上63。表示
	b->a = a->a;
   258ba:	8b 44 24 04          	mov    0x4(%esp),%eax
   258be:	8b 10                	mov    (%eax),%edx
   258c0:	8b 44 24 08          	mov    0x8(%esp),%eax
   258c4:	89 10                	mov    %edx,(%eax)
	b->b = a->b;
   258c6:	8b 44 24 04          	mov    0x4(%esp),%eax
   258ca:	8b 50 04             	mov    0x4(%eax),%edx
   258cd:	8b 44 24 08          	mov    0x8(%esp),%eax
   258d1:	89 50 04             	mov    %edx,0x4(%eax)
	if (b->a || b->b)
   258d4:	8b 44 24 08          	mov    0x8(%esp),%eax
   258d8:	8b 00                	mov    (%eax),%eax
   258da:	85 c0                	test   %eax,%eax
   258dc:	75 0b                	jne    258e9 <int_to_real+0x39>
   258de:	8b 44 24 08          	mov    0x8(%esp),%eax
   258e2:	8b 40 04             	mov    0x4(%eax),%eax
   258e5:	85 c0                	test   %eax,%eax
   258e7:	74 23                	je     2590c <int_to_real+0x5c>
		b->exponent = 16383 + 63 + (a->sign? 0x8000:0);
   258e9:	8b 44 24 04          	mov    0x4(%esp),%eax
   258ed:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   258f1:	66 85 c0             	test   %ax,%ax
   258f4:	74 07                	je     258fd <int_to_real+0x4d>
   258f6:	ba 3e c0 ff ff       	mov    $0xffffc03e,%edx
   258fb:	eb 05                	jmp    25902 <int_to_real+0x52>
   258fd:	ba 3e 40 00 00       	mov    $0x403e,%edx
   25902:	8b 44 24 08          	mov    0x8(%esp),%eax
   25906:	66 89 50 08          	mov    %dx,0x8(%eax)
	else {
		b->exponent = 0;
		return;
	}
// 对格式转换后的临时实数进行规格化处理，即让有效数最高有效位不是0。
	while (b->b >= 0) {
   2590a:	eb 3e                	jmp    2594a <int_to_real+0x9a>
		b->exponent = 0;
   2590c:	8b 44 24 08          	mov    0x8(%esp),%eax
   25910:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		return;
   25916:	c3                   	ret    
		b->exponent--;
   25917:	8b 44 24 08          	mov    0x8(%esp),%eax
   2591b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   2591f:	83 e8 01             	sub    $0x1,%eax
   25922:	89 c2                	mov    %eax,%edx
   25924:	8b 44 24 08          	mov    0x8(%esp),%eax
   25928:	66 89 50 08          	mov    %dx,0x8(%eax)
		__asm__("addl %0,%0 ; adcl %1,%1"
			:"=r" (b->a),"=r" (b->b)
			:"0" (b->a),"1" (b->b));
   2592c:	8b 44 24 08          	mov    0x8(%esp),%eax
   25930:	8b 10                	mov    (%eax),%edx
   25932:	8b 44 24 08          	mov    0x8(%esp),%eax
   25936:	8b 40 04             	mov    0x4(%eax),%eax
		__asm__("addl %0,%0 ; adcl %1,%1"
   25939:	01 d2                	add    %edx,%edx
   2593b:	11 c0                	adc    %eax,%eax
   2593d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   25941:	89 11                	mov    %edx,(%ecx)
   25943:	8b 54 24 08          	mov    0x8(%esp),%edx
   25947:	89 42 04             	mov    %eax,0x4(%edx)
	while (b->b >= 0) {
   2594a:	8b 44 24 08          	mov    0x8(%esp),%eax
   2594e:	8b 40 04             	mov    0x4(%eax),%eax
   25951:	85 c0                	test   %eax,%eax
   25953:	79 c2                	jns    25917 <int_to_real+0x67>
	}
}
   25955:	c3                   	ret    

00025956 <_exit>:
// 直接调用系统中断int 0x80,功能号__NR_exit.
// 参数:exit_code - 退出码.
// 函数名前的关键字volatile用于告诉编译器gcc该函数不会返回.这样可让gcc产生更好的代码,更重要的是使用这个关键字可以避免产生某些(未初始化变量的)
// 假警告信息.等同于gcc的函数属性说明:void do_exit(int error_code) __attribute__((noreturn));
void _exit(int exit_code)
{
   25956:	53                   	push   %ebx
   25957:	e8 96 13 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   2595c:	05 a4 c6 00 00       	add    $0xc6a4,%eax
	__asm__ __volatile__ ("int $0x80"::"a" (__NR_exit), "b" (exit_code));
   25961:	b8 01 00 00 00       	mov    $0x1,%eax
   25966:	8b 54 24 08          	mov    0x8(%esp),%edx
   2596a:	89 d3                	mov    %edx,%ebx
   2596c:	cd 80                	int    $0x80
}
   2596e:	90                   	nop
   2596f:	5b                   	pop    %ebx
   25970:	c3                   	ret    

00025971 <open>:
// 打开文件函数
// 打开并有可能创建一个文件.
// 参数:filname - 文件名;flag - 文件打开标志;...
// 返回:文件描述符,若出错则置出错码,并返回-1.
int open(const char * filename, int flag, ...)
{
   25971:	56                   	push   %esi
   25972:	53                   	push   %ebx
   25973:	83 ec 10             	sub    $0x10,%esp
   25976:	e8 8b 89 fe ff       	call   e306 <__x86.get_pc_thunk.si>
   2597b:	81 c6 85 c6 00 00    	add    $0xc685,%esi

	// 利用va_start()宏函数,取得flag后面参数的指针,然后调用系统中断int 0x80,功能open进行.
	// 文件打开操作.
	// %0 - eax(返回的描述符或出错码); %1 - eax(系统中断调用功能号__NR_open);
	// %2 - ebx(文件名filename); %3 - ecx(打开文件标志flag); %4 - edx(后随参数文件属性mode).
	va_start(arg, flag);
   25981:	8d 44 24 20          	lea    0x20(%esp),%eax
   25985:	83 c0 04             	add    $0x4,%eax
   25988:	89 44 24 0c          	mov    %eax,0xc(%esp)
	__asm__(
   2598c:	8b 4c 24 20          	mov    0x20(%esp),%ecx
		"int $0x80"
		:"=a" (res)
		:"0" (__NR_open), "b" (filename), "c" (flag),
		"d" (va_arg(arg, int)));
   25990:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)
   25995:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25999:	83 e8 04             	sub    $0x4,%eax
   2599c:	8b 10                	mov    (%eax),%edx
	__asm__(
   2599e:	b8 05 00 00 00       	mov    $0x5,%eax
   259a3:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
   259a7:	cd 80                	int    $0x80
   259a9:	89 c3                	mov    %eax,%ebx
	// 系统中断调用返回值大于或等于0,表示是一个文件描述符,则直接返回之.
	if (res >= 0)
   259ab:	85 db                	test   %ebx,%ebx
   259ad:	78 04                	js     259b3 <open+0x42>
		return res;
   259af:	89 d8                	mov    %ebx,%eax
   259b1:	eb 11                	jmp    259c4 <open+0x53>
	// 否则说明返回值小于0,则代表一个出错码.设置该出错码并返回-1.
	errno = -res;
   259b3:	89 da                	mov    %ebx,%edx
   259b5:	f7 da                	neg    %edx
   259b7:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
   259bd:	89 10                	mov    %edx,(%eax)
	return -1;
   259bf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   259c4:	83 c4 10             	add    $0x10,%esp
   259c7:	5b                   	pop    %ebx
   259c8:	5e                   	pop    %esi
   259c9:	c3                   	ret    

000259ca <close>:
#define __LIBRARY__
#include <unistd.h>	                                // Linux标准头文件.定义了各种符号常数和类型,并声明了各种函数.

// 关闭文件函数
// 下面该调用宏函数对应:int close(int fd).直接调用了系统中断int 0x80,参数是__NR_close.其中fd是文件描述符.
_syscall1(int, close, int, fd)
   259ca:	53                   	push   %ebx
   259cb:	83 ec 10             	sub    $0x10,%esp
   259ce:	e8 23 13 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   259d3:	81 c2 2d c6 00 00    	add    $0xc62d,%edx
   259d9:	b8 06 00 00 00       	mov    $0x6,%eax
   259de:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   259e2:	89 cb                	mov    %ecx,%ebx
   259e4:	cd 80                	int    $0x80
   259e6:	89 44 24 0c          	mov    %eax,0xc(%esp)
   259ea:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   259ef:	78 06                	js     259f7 <close+0x2d>
   259f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   259f5:	eb 15                	jmp    25a0c <close+0x42>
   259f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   259fb:	f7 d8                	neg    %eax
   259fd:	89 c1                	mov    %eax,%ecx
   259ff:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
   25a05:	89 08                	mov    %ecx,(%eax)
   25a07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   25a0c:	83 c4 10             	add    $0x10,%esp
   25a0f:	5b                   	pop    %ebx
   25a10:	c3                   	ret    

00025a11 <write>:

// 写文件系统调用函函数.
// 该宏结构对应于函数:int write(int fd, const char * buf, off_t count)
// 参数:fd - 文件描述符;buf - 写缓冲指针; count - 写字节数.
// 返回:成功时返回写入的字节数(0表示写入0字节);出错时将返回-1,并且设置了出错号.
_syscall3(int, write, int, fd, const char *, buf, off_t, count)
   25a11:	56                   	push   %esi
   25a12:	53                   	push   %ebx
   25a13:	83 ec 10             	sub    $0x10,%esp
   25a16:	e8 eb 88 fe ff       	call   e306 <__x86.get_pc_thunk.si>
   25a1b:	81 c6 e5 c5 00 00    	add    $0xc5e5,%esi
   25a21:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   25a25:	b8 04 00 00 00       	mov    $0x4,%eax
   25a2a:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
   25a2e:	8b 54 24 24          	mov    0x24(%esp),%edx
   25a32:	cd 80                	int    $0x80
   25a34:	89 44 24 0c          	mov    %eax,0xc(%esp)
   25a38:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   25a3d:	78 06                	js     25a45 <write+0x34>
   25a3f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25a43:	eb 15                	jmp    25a5a <write+0x49>
   25a45:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25a49:	f7 d8                	neg    %eax
   25a4b:	89 c2                	mov    %eax,%edx
   25a4d:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
   25a53:	89 10                	mov    %edx,(%eax)
   25a55:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   25a5a:	83 c4 10             	add    $0x10,%esp
   25a5d:	5b                   	pop    %ebx
   25a5e:	5e                   	pop    %esi
   25a5f:	c3                   	ret    

00025a60 <dup>:
			                                    // 如定义了__LIBRARY__,则还含系统调用号和内嵌汇编_syscall0()等.

// 复制文件描述符函数.
// 下面该调用宏函数对应:int dup(int fd).直接调用了系统中断int 0x80,参数是__NR_dup.
// 其中fd是文件描述符.
_syscall1(int, dup, int, fd)
   25a60:	53                   	push   %ebx
   25a61:	83 ec 10             	sub    $0x10,%esp
   25a64:	e8 8d 12 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   25a69:	81 c2 97 c5 00 00    	add    $0xc597,%edx
   25a6f:	b8 29 00 00 00       	mov    $0x29,%eax
   25a74:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   25a78:	89 cb                	mov    %ecx,%ebx
   25a7a:	cd 80                	int    $0x80
   25a7c:	89 44 24 0c          	mov    %eax,0xc(%esp)
   25a80:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   25a85:	78 06                	js     25a8d <dup+0x2d>
   25a87:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25a8b:	eb 15                	jmp    25aa2 <dup+0x42>
   25a8d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25a91:	f7 d8                	neg    %eax
   25a93:	89 c1                	mov    %eax,%ecx
   25a95:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
   25a9b:	89 08                	mov    %ecx,(%eax)
   25a9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   25aa2:	83 c4 10             	add    $0x10,%esp
   25aa5:	5b                   	pop    %ebx
   25aa6:	c3                   	ret    

00025aa7 <setsid>:
#include <unistd.h>

// 创建一个会话并设置进程组号。
// 下面系统调用宏对应于函数：pid_t setsid()。
// 返回：调用进程的会话标识符（session ID）。
_syscall0(pid_t, setsid)
   25aa7:	83 ec 10             	sub    $0x10,%esp
   25aaa:	e8 47 12 fe ff       	call   6cf6 <__x86.get_pc_thunk.dx>
   25aaf:	81 c2 51 c5 00 00    	add    $0xc551,%edx
   25ab5:	b8 42 00 00 00       	mov    $0x42,%eax
   25aba:	cd 80                	int    $0x80
   25abc:	89 44 24 0c          	mov    %eax,0xc(%esp)
   25ac0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   25ac5:	78 06                	js     25acd <setsid+0x26>
   25ac7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25acb:	eb 15                	jmp    25ae2 <setsid+0x3b>
   25acd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25ad1:	f7 d8                	neg    %eax
   25ad3:	89 c1                	mov    %eax,%ecx
   25ad5:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
   25adb:	89 08                	mov    %ecx,(%eax)
   25add:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   25ae2:	83 c4 10             	add    $0x10,%esp
   25ae5:	c3                   	ret    

00025ae6 <execve>:

// 加载并执行子进程(其他程序)函数.
// 下面该调用宏函数对应:int execve(const char * file,char ** argv, char ** envp).
// 参数:file - 被执行程序文件名;argv - 命令行参数指针数组;envp - 环境变量指针数组.
// 直接调用了系统中断int 0x80,参数是__NR_execve.参见include/unistd.h和fs/exec.c程序.
_syscall3(int, execve, const char *, file, char **, argv, char **, envp)
   25ae6:	56                   	push   %esi
   25ae7:	53                   	push   %ebx
   25ae8:	83 ec 10             	sub    $0x10,%esp
   25aeb:	e8 16 88 fe ff       	call   e306 <__x86.get_pc_thunk.si>
   25af0:	81 c6 10 c5 00 00    	add    $0xc510,%esi
   25af6:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
   25afa:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   25afe:	8b 54 24 24          	mov    0x24(%esp),%edx
   25b02:	b8 0b 00 00 00       	mov    $0xb,%eax
   25b07:	cd 80                	int    $0x80
   25b09:	89 44 24 0c          	mov    %eax,0xc(%esp)
   25b0d:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   25b12:	78 06                	js     25b1a <execve+0x34>
   25b14:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25b18:	eb 15                	jmp    25b2f <execve+0x49>
   25b1a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25b1e:	f7 d8                	neg    %eax
   25b20:	89 c2                	mov    %eax,%edx
   25b22:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
   25b28:	89 10                	mov    %edx,(%eax)
   25b2a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   25b2f:	83 c4 10             	add    $0x10,%esp
   25b32:	5b                   	pop    %ebx
   25b33:	5e                   	pop    %esi
   25b34:	c3                   	ret    

00025b35 <waitpid>:

// 等待进程终止系统调用函数.
// 该下面宏结构对应于函数:pid_t waitpid(pid_t pid,int * wait_stat,int options)
//
// 参数:pid - 等待被终止进程的进程id,或者是用于指定特殊情况的其他特定数值;wait_stat - 用于存放状态信息;options - WNOHANG或WUNTRACED或是0.
_syscall3(pid_t, waitpid, pid_t, pid, int *, wait_stat, int, options)
   25b35:	56                   	push   %esi
   25b36:	53                   	push   %ebx
   25b37:	83 ec 10             	sub    $0x10,%esp
   25b3a:	e8 c7 87 fe ff       	call   e306 <__x86.get_pc_thunk.si>
   25b3f:	81 c6 c1 c4 00 00    	add    $0xc4c1,%esi
   25b45:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   25b49:	b8 07 00 00 00       	mov    $0x7,%eax
   25b4e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
   25b52:	8b 54 24 24          	mov    0x24(%esp),%edx
   25b56:	cd 80                	int    $0x80
   25b58:	89 44 24 0c          	mov    %eax,0xc(%esp)
   25b5c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   25b61:	78 06                	js     25b69 <waitpid+0x34>
   25b63:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25b67:	eb 15                	jmp    25b7e <waitpid+0x49>
   25b69:	8b 44 24 0c          	mov    0xc(%esp),%eax
   25b6d:	f7 d8                	neg    %eax
   25b6f:	89 c2                	mov    %eax,%edx
   25b71:	c7 c0 a4 a8 04 00    	mov    $0x4a8a4,%eax
   25b77:	89 10                	mov    %edx,(%eax)
   25b79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   25b7e:	83 c4 10             	add    $0x10,%esp
   25b81:	5b                   	pop    %ebx
   25b82:	5e                   	pop    %esi
   25b83:	c3                   	ret    

00025b84 <wait>:

// wait()系统调用.直接调用waitpid()函数.
pid_t wait(int * wait_stat)
{
   25b84:	e8 69 11 fe ff       	call   6cf2 <__x86.get_pc_thunk.ax>
   25b89:	05 77 c4 00 00       	add    $0xc477,%eax
	return waitpid(-1, wait_stat, 0);
   25b8e:	6a 00                	push   $0x0
   25b90:	ff 74 24 08          	pushl  0x8(%esp)
   25b94:	6a ff                	push   $0xffffffff
   25b96:	e8 9a ff ff ff       	call   25b35 <waitpid>
   25b9b:	83 c4 0c             	add    $0xc,%esp
}
   25b9e:	c3                   	ret    

00025b9f <Log>:

static unsigned short cur_log_level = LOG_INFO_TYPE;

// linux0.12 kernel log function
void Log(unsigned short log_level, const char *fmt, ...)
{
   25b9f:	53                   	push   %ebx
   25ba0:	83 ec 28             	sub    $0x28,%esp
   25ba3:	e8 52 11 fe ff       	call   6cfa <__x86.get_pc_thunk.bx>
   25ba8:	81 c3 58 c4 00 00    	add    $0xc458,%ebx
   25bae:	8b 44 24 30          	mov    0x30(%esp),%eax
   25bb2:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
    if (log_level >= cur_log_level) {
   25bb7:	0f b7 83 60 27 01 00 	movzwl 0x12760(%ebx),%eax
   25bbe:	66 39 44 24 0c       	cmp    %ax,0xc(%esp)
   25bc3:	72 38                	jb     25bfd <Log+0x5e>
        va_list args;                           // va_list实际上是一个字符指针类型.

        // 运行参数处理开始函数.然后使用格式串fmt将参数列表args输出到buf中.返回值i等于输出字符串的长度.再运行参数处理结束函数.最后调用控制台显示
        // 函数并返回显示字符数.
        va_start(args, fmt);
   25bc5:	8d 44 24 34          	lea    0x34(%esp),%eax
   25bc9:	83 c0 04             	add    $0x4,%eax
   25bcc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        vsprintf(log_buf, fmt, args);
   25bd0:	8b 44 24 34          	mov    0x34(%esp),%eax
   25bd4:	83 ec 04             	sub    $0x4,%esp
   25bd7:	ff 74 24 20          	pushl  0x20(%esp)
   25bdb:	50                   	push   %eax
   25bdc:	8d 83 60 23 01 00    	lea    0x12360(%ebx),%eax
   25be2:	50                   	push   %eax
   25be3:	e8 ad 3a fe ff       	call   9695 <vsprintf>
   25be8:	83 c4 10             	add    $0x10,%esp
        va_end(args);
        console_print(log_buf);                 // chr_drv/console.c
   25beb:	83 ec 0c             	sub    $0xc,%esp
   25bee:	8d 83 60 23 01 00    	lea    0x12360(%ebx),%eax
   25bf4:	50                   	push   %eax
   25bf5:	e8 3c a5 ff ff       	call   20136 <console_print>
   25bfa:	83 c4 10             	add    $0x10,%esp
    }
}
   25bfd:	90                   	nop
   25bfe:	83 c4 28             	add    $0x28,%esp
   25c01:	5b                   	pop    %ebx
   25c02:	c3                   	ret    
